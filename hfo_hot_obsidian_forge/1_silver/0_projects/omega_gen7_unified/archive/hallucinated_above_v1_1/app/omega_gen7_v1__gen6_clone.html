<!-- Medallion: Bronze | Mutation: 0% | HIVE: V -->
<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!-- OMEGA GEN6 v19 (v18 clone; dual tripwires: static-screen + knuckle; shared primitive p2/tripwire_cross) -->
<!-- OMEGA V39: UI POLISH & PROGRESSIVE DISCLOSURE (KIOSK MODE) -->
<!-- Goal: Implement Essentials/Developer toggle for progressive disclosure.
     Simplify default Golden Layout for a clean Kiosk experience. -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN6 | v23.10</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-dark-theme.css" />

    <!-- Babylon.js Dependencies -->
    <script src="./lib/js/babylon.js"></script>
    <script src="./lib/js/babylon.loaders.min.js"></script>

    <!-- OpenFeature SDK -->
    <script src="./lib/js/web-sdk.min.js"></script>

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        html.kiosk #status-bar {
            display: none;
        }

        html.kiosk #layout-container {
            height: 100%;
        }

        /* GoldenLayout chrome suppression for hero/kiosk */
        html.kiosk .lm_header,
        html.kiosk .lm_tabs,
        html.kiosk .lm_controls,
        html.kiosk .lm_splitter {
            display: none !important;
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 2000;
            /* V32: Elevate above GL components */
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        /* ðŸ“œ SECURED SCROLLING PANEL */
        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        html.hero #video-feed {
            object-fit: cover;
            filter: none;
        }

        /* v23.10: kiosk keeps lil-gui visible in the sidebar */

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            /* Above Pixi Juice (10) */
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        /* ï¿½ BABYLON/PIXI OVERLAY CONTAINERS */
        .visual-substrate {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ï¿½ðŸ’Ž M3 INTEGRATION */
        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }

        /* ðŸ“– TUTORIAL OVERLAY [V30] */
        .tutorial-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--md-sys-color-primary);
            border-radius: var(--m3-radius);
            padding: 16px;
            z-index: 100;
            pointer-events: none;
            display: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .tutorial-step-active {
            animation: tutorial-pulse 2s infinite;
        }

        @keyframes tutorial-pulse {
            0% {
                border-color: var(--md-sys-color-primary);
            }

            50% {
                border-color: #fff;
            }

            100% {
                border-color: var(--md-sys-color-primary);
            }
        }

        .tutorial-step {
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
        }

        /* ðŸŽ¥ GEN5: CLIP REPLAY OVERLAY */
        #hfo-clip-replay {
            position: absolute;
            right: 12px;
            bottom: 44px;
            width: 320px;
            max-width: 45vw;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--m3-radius);
            padding: 8px;
            z-index: 2001;
            display: none;
        }

        #hfo-clip-replay video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
        }

        .tutorial-highlight {
            color: var(--md-sys-color-primary);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA GEN6 V23.10 - PHOENIX PYREBLADE (HISTORICAL FLAMBERGE, THICK AMBER CORE)]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./lib/js/golden-layout.esm.js",
            "lil-gui": "./lib/js/lil-gui.esm.js",
            "@mediapipe/tasks-vision": "./lib/js/vision_bundle.js",
            "zod": "./lib/js/zod.esm.js",
            "planck": "./lib/js/planck.esm.js"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';

        // --- ðŸš© OPENFEATURE CONFIGURATION (V24.2 Evolution) ---
        const urlParams = new URLSearchParams(window.location.search);

        const getParamBool = (key, defaultValue) => {
            try {
                if (!urlParams.has(key)) return Boolean(defaultValue);
                const raw = String(urlParams.get(key) || '').toLowerCase();
                if (raw === '0' || raw === 'false' || raw === 'off' || raw === 'no') return false;
                if (raw === '1' || raw === 'true' || raw === 'on' || raw === 'yes') return true;
                return Boolean(defaultValue);
            } catch {
                return Boolean(defaultValue);
            }
        };

        // v23.6: kiosk + hero are ON by default; escape hatches: ?kiosk=0 and/or ?hero=0
        const kioskMode = getParamBool('kiosk', true);
        const heroMode = getParamBool('hero', true);
        try {
            document.documentElement.classList.toggle('kiosk', kioskMode);
            document.documentElement.classList.toggle('hero', heroMode);
        } catch { }

        const featureConfig = {
            'phoenix-core': true,
            'engine-babylon': true,
            'engine-pixi': false,
            'engine-canvas': false,
            'physics-planck': true,
            'ui-golden-layout': true,
            'ui-excalidraw': true,
            // v23.9: keep Navigator tuning available in kiosk/hero
            'ui-lil-gui': true,
            // v23.9: enable lil-gui microkernel by default
            'ui-microkernel': true,
            // --- GEN6 v23: sword visual (Babylon) ---
            // Kept separate from p2-sword-meter to allow contract-only tests to disable the meter.
            'p2-sword-vfx': true,
            // --- GEN6 v23.1: sword meter enabled by default (manual testing artifact) ---
            'p2-sword-meter': true,
            // --- GEN6 v23.2: sword debug HUD (manual camera tuning; safe overlay) ---
            'p2-sword-debug-hud': false,
            // --- GEN6 v23.2: sword marker uses live knuckle trip-lane (17â†’5) when landmarks present ---
            // Falls back to cursor-centered deterministic marker when landmarks absent (keeps tests stable).
            'p2-sword-marker-live-landmarks': true,
            'p3-injector': true,
            'p3-legacy-click': true,
            // --- GEN6 v17.4: Tracer venom (debug tagging; default off) ---
            'p3-tracer-bullet-venom': false,
            // --- GEN6 v22.1: Tracer venom battery (pipeline stage breadcrumbs; default off) ---
            'p3-tracer-venom-battery': false,
            'p3-tracer-venom-battery-verbose': false,
            // --- GEN6 v17.4: P2 palm-cone READY gate (anti-midas; default off) ---
            'p2-ready-gate-palm-cone': false,
            // --- GEN6 v14: Tripwireâ†’Dino wiring ---
            // Disable legacy IDLEâ†’READY trigger by default; use tripwire down-cross instead.
            'p3-dino-ready-edge': false,
            // --- GEN6 v22: Knuckle-first tripwire primitives (static zones are future work) ---
            // Legacy key kept as alias for static; default off.
            'p3-tripwire-injector': false,
            // Static screen tripwire injection is gated behind flags (later: multiple zones/modifiers).
            'p3-tripwire-injector-static': false,
            // Default to knuckle tripwire injection (Space) for Dino Runner wiring.
            'p3-tripwire-injector-knuckle': true,
            // --- GEN6 v22: P2 tripwire sources ---
            // Keep static available but off by default; knuckle is on by default.
            'p2-tripwire-static': false,
            'p2-tripwire-knuckle': true,

            // --- GEN6 v19: UI (dev sidecar) ---
            'ui-knuckle-tripwire-panel': true,
            // --- GEN6 v15: Tripwire Planck contact metadata ---
            'p2-tripwire-planck-contact': true,
            // --- GEN6 v17: Tripwire lookahead (predictive pre-arm; default off) ---
            'p2-tripwire-lookahead': false,
            'p3-tripwire-lookahead': false,
            'p3-adapter-standard': false,
            'data-fabric': true,

            // --- GEN5 v11.1: multi-app (opt-in; default off) ---
            'ui-multiapp': false,

            // --- GEN5 v11.2: multiview (single-camera shared substrate; default off) ---
            'ui-multiview': false,

            // --- GEN5 v11.3: touch games (same-origin iframes; default off) ---
            'ui-games': false,
            // --- GEN5 v12: intent injection panel (default off) ---
            'ui-intent': false,
            'p3-target-active-app': false,
            'p5-defend-strict-v11_1': false
        };

        const HFOFeatureProvider = {
            metadata: { name: 'HFODefaultProvider' },
            resolveBooleanEvaluation(flagKey, defaultValue) {
                // Priority: URL Param > Config Map > Default
                let val = featureConfig[flagKey] ?? defaultValue;
                if (urlParams.has(`flag-${flagKey}`)) {
                    val = urlParams.get(`flag-${flagKey}`) === 'true';
                }
                return { value: val };
            }
        };

        // ðŸ›¡ï¸ [HFO] Initialize OpenFeature (Local UMD Bridge)
        const OF_ROOT = window.OpenFeature || {};
        const api = OF_ROOT.OpenFeature || OF_ROOT.default || OF_ROOT;

        if (typeof api.setProvider === 'function') {
            api.setProvider(HFOFeatureProvider);
            console.log("ðŸš€ [HFO] OpenFeature Hardened (Offline Ready)");
        } else {
            console.warn("âš ï¸ [HFO] OpenFeature API not found in expected UMD location.");
        }

        const featureClient = typeof api.getClient === 'function' ? api.getClient() : {
            getBooleanValue: (key, def) => {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has(`flag-${key}`)) return urlParams.get(`flag-${key}`) === 'true';
                return featureConfig[key] ?? def;
            }
        };

        const isFlagEnabled = (key) => featureClient.getBooleanValue(key, false);

        const getFlagNumber = (key, defaultValue) => {
            try {
                const raw = urlParams.get(`flag-${key}`);
                if (raw === null || raw === undefined) return Number(defaultValue);
                const n = Number(raw);
                return Number.isFinite(n) ? n : Number(defaultValue);
            } catch {
                return Number(defaultValue);
            }
        };

        // --- MEDALLION LIFECYCLE: Resource Zero-Trust [V24.5] ---
        class LifecycleManager {
            constructor() {
                this.disposables = new Set();
                this.engines = new Map(); // Track singleton engines
            }
            register(id, obj) {
                if (obj && typeof obj.dispose === 'function') {
                    this.disposables.add(obj);
                    if (id) this.engines.set(id, obj);
                }
                return obj;
            }
            unregister(obj) {
                this.disposables.delete(obj);
            }
            dispose(id) {
                if (id) {
                    const obj = this.engines.get(id);
                    if (obj) {
                        try { obj.dispose(); } catch (e) { console.error(`[LIFECYCLE] Error disposing ${id}:`, e); }
                        this.disposables.delete(obj);
                        this.engines.delete(id);
                        console.log(`[LIFECYCLE] Disposed engine: ${id}`);
                    }
                }
            }
            disposeAll() {
                this.disposables.forEach(obj => {
                    try {
                        obj.dispose();
                    } catch (e) {
                        console.error("[LIFECYCLE] Purge Error:", e);
                    }
                });
                this.disposables.clear();
                this.engines.clear();
                console.log("[LIFECYCLE] All resources purged.");
            }
        }
        window.hfoLifecycle = new LifecycleManager();

        // --- TELEMETRY: Deterministic Replay Substrate [V24.5] ---
        class TelemetryRecorder {
            constructor() {
                this.buffer = [];
                this.isRecording = false;
                this.maxEntries = 10000;
            }
            start() {
                this.buffer = [];
                this.isRecording = true;
                console.log("âºï¸ [TELEMETRY] Recording started.");
            }
            stop() {
                this.isRecording = false;
                console.log("â¹ï¸ [TELEMETRY] Recording stopped. Entries:", this.buffer.length);
            }
            record(phase, data) {
                if (!this.isRecording || window.hfoPlayer.isPlaying) return;
                this.buffer.push({
                    timestamp: performance.now(),
                    phase: phase,
                    data: JSON.parse(JSON.stringify(data)) // Deep clone
                });
                if (this.buffer.length > this.maxEntries) this.buffer.shift();
            }
            exportJSONL() {
                const content = this.buffer.map(e => JSON.stringify(e)).join('\n');
                const blob = new Blob([content], { type: 'application/x-jsonlines' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hfo_telemetry_${new Date().toISOString()}.jsonl`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        window.hfoTelemetry = new TelemetryRecorder();

        // --- TELEMETRY PLAYER: Golden Master Replay [V24.6] ---
        class TelemetryPlayer {
            constructor() {
                this.sequence = [];
                this.index = 0;
                this.isPlaying = false;
                this.loop = false;
            }
            async load(file) {
                const text = await file.text();
                this.sequence = text.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
                this.index = 0;
                console.log("ðŸŽžï¸ [TELEMETRY] Sequence loaded. Entries:", this.sequence.length);
            }
            start() {
                if (this.sequence.length === 0) return console.warn("P6: No sequence loaded.");
                this.index = 0;
                this.isPlaying = true;
                systemState.parameters.p0Active = true; // Force loop
                console.log("â–¶ï¸ [TELEMETRY] Playback started.");
            }
            stop() {
                this.isPlaying = false;
                console.log("â¹ï¸ [TELEMETRY] Playback stopped.");
            }
            pause() {
                this.isPlaying = false;
                console.log("â¸ï¸ [TELEMETRY] Playback paused.");
            }
            getNextFrame() {
                if (!this.isPlaying || this.sequence.length === 0) return null;
                const frame = this.sequence[this.index];
                this.index++;
                if (this.index >= this.sequence.length) {
                    if (this.loop) this.index = 0;
                    else this.stop();
                }
                return frame;
            }
        }
        window.hfoPlayer = new TelemetryPlayer();

        // --- REPLAY LOADER: JSONL TEXT INJECTION (Golden Master Harness) ---
        window.hfoLoadReplayFromText = (text) => {
            try {
                const seq = text
                    .split('\n')
                    .filter(l => l.trim())
                    .map(l => JSON.parse(l));
                window.hfoPlayer.sequence = seq;
                window.hfoPlayer.index = 0;
                window.hfoPlayer.isPlaying = false;
                console.log("ðŸ§ª [TELEMETRY] Replay loaded from text. Entries:", seq.length);
                return seq.length;
            } catch (e) {
                console.error("[TELEMETRY] Failed to load replay from text:", e);
                return 0;
            }
        };

        // --- VIDEO CLIP HARNESS: Record live video/canvas to WEBM ---
        window.hfoClipRecorder = (() => {
            let recorder = null;
            let chunks = [];

            const getStream = () => {
                if (systemState?.p0?.video && systemState.p0.video.srcObject) {
                    return systemState.p0.video.srcObject;
                }
                if (systemState?.p0?.canvas?.captureStream) {
                    return systemState.p0.canvas.captureStream(30);
                }
                return null;
            };

            const start = () => {
                const stream = getStream();
                if (!stream) {
                    console.warn("[CLIP] No stream available (video or canvas). Ignite first.");
                    return false;
                }
                chunks = [];
                recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hfo_clip_${new Date().toISOString()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
                recorder.start();
                console.log("ðŸŽ¥ [CLIP] Recording started.");
                return true;
            };

            const stop = () => {
                if (recorder && recorder.state !== 'inactive') {
                    recorder.stop();
                    console.log("ðŸŽ¥ [CLIP] Recording stopped.");
                    return true;
                }
                return false;
            };

            return { start, stop };
        })();

        // --- GEN5: CLIP REPLAY HARNESS ---
        window.hfoClipPlayer = (() => {
            let container = null;
            let video = null;

            const ensure = () => {
                if (container && video) return;
                container = document.getElementById('hfo-clip-replay');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'hfo-clip-replay';
                    container.innerHTML = `
                        <div class="m3-label" style="margin-bottom:6px;">GEN5 CLIP REPLAY</div>
                        <video controls></video>
                    `;
                    document.body.appendChild(container);
                }
                video = container.querySelector('video');
            };

            const open = () => {
                ensure();
                const inp = document.createElement('input');
                inp.type = 'file';
                inp.accept = 'video/webm,video/mp4';
                inp.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (file) loadFile(file);
                };
                inp.click();
            };

            const loadFile = (file) => {
                ensure();
                const url = URL.createObjectURL(file);
                video.src = url;
                container.style.display = 'block';
                video.play().catch(() => { });
                console.log("ðŸŽžï¸ [CLIP] Replay loaded:", file.name);
            };

            const hide = () => {
                if (container) container.style.display = 'none';
            };

            return { open, loadFile, hide };
        })();

        // --- GEN5: MOCK RESULTS REPLAY (JSONL) ---
        window.hfoMockPlayer = (() => {
            let sequence = [];
            let index = 0;
            let isPlaying = false;

            const loadFromText = (text) => {
                try {
                    sequence = text
                        .split('\n')
                        .filter(l => l.trim())
                        .map(l => JSON.parse(l));
                    index = 0;
                    isPlaying = false;
                    console.log("ðŸ§ª [MOCK] Loaded JSONL entries:", sequence.length);
                    return sequence.length;
                } catch (e) {
                    console.error("[MOCK] Failed to parse JSONL:", e);
                    sequence = [];
                    index = 0;
                    isPlaying = false;
                    return 0;
                }
            };

            const open = () => {
                const inp = document.createElement('input');
                inp.type = 'file';
                inp.accept = '.jsonl';
                inp.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    file.text().then(loadFromText);
                };
                inp.click();
            };

            const start = () => {
                if (!sequence.length) return false;
                index = 0;
                isPlaying = true;
                systemState.parameters.p0Active = true;
                return true;
            };

            const stop = () => {
                isPlaying = false;
            };

            const nextResults = () => {
                if (!isPlaying || index >= sequence.length) {
                    isPlaying = false;
                    return null;
                }
                const frame = sequence[index++];
                return frame?.results || null;
            };

            return { loadFromText, open, start, stop, nextResults, get isPlaying() { return isPlaying; } };
        })();

        // --- GEN5: MOCK RESULTS REPLAY (MediaPipe JSONL) ---
        window.hfoLoadMockResultsFromText = (text) => {
            try {
                const lines = text.split('\n').filter(l => l.trim());
                let fps = 30;
                const frames = [];
                for (const line of lines) {
                    const obj = JSON.parse(line);
                    if (obj.type === 'meta' && obj.fps) fps = obj.fps;
                    if (obj.type === 'frame' && obj.results) frames.push(obj);
                }
                window.__hfoMockFrames = frames;
                window.__hfoMockFps = fps;
                console.log("ðŸ§ª [MOCK] Loaded frames:", frames.length, "fps:", fps);
                return { frames: frames.length, fps };
            } catch (e) {
                console.error("[MOCK] Failed to load mock results:", e);
                return { frames: 0, fps: 0 };
            }
        };

        window.hfoMockResultsPlayer = (() => {
            let timer = null;
            let index = 0;

            const start = () => {
                const frames = window.__hfoMockFrames || [];
                const fps = window.__hfoMockFps || 30;
                if (!frames.length) {
                    console.warn("[MOCK] No frames loaded.");
                    return false;
                }
                index = 0;
                const interval = Math.max(1, Math.floor(1000 / fps));
                timer = setInterval(() => {
                    const frame = frames[index];
                    if (!frame) {
                        stop();
                        return;
                    }
                    window.hfoMockResults = frame.results;
                    index += 1;
                }, interval);
                console.log("â–¶ï¸ [MOCK] Playback started.");
                return true;
            };

            const stop = () => {
                if (timer) {
                    clearInterval(timer);
                    timer = null;
                }
                window.hfoMockResults = null;
                console.log("â¹ï¸ [MOCK] Playback stopped.");
            };

            return { start, stop };
        })();

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            ui: z.object({
                showTutorial: z.boolean().default(true)
            }).optional(),
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                minPresenceConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            palm: z.object({
                enterThreshold: z.number().min(0).max(1),
                exitThreshold: z.number().min(0).max(1)
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(1),
                hysteresisLow: z.number().min(0).max(1),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1), // Added for V16
                tensionMs: z.number().min(0)
            }),
            coasting: z.object({
                timeoutMs: z.number().min(0),
                confidenceThreshold: z.number().min(0).max(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(), // V20.6: User Requested Feature Flag
                directProjectionOffset: z.number().min(0), // V20.6: Tuning for LI/Direct stability
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']), // V20.4: HFO Trigram Bagua
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                oneEuroRodMinCutoff: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                fireScale: z.number().min(0.1).default(1.0),
                fireIntensity: z.number().min(0.1).default(1.0),
                palmRodMultiplier: z.number().min(0.5).max(10), // V18: Palm-width based scaling
                showLaserBeam: z.boolean(),
                predictiveLookahead: z.number().min(0)
            }),
            anatomy: z.object({
                palmWidthCm: z.number().min(3).max(15),
                rodExtensionMultiplier: z.number().min(0.1).max(10)
            }),
            visuals: z.object({
                engine: z.literal('BABYLON'),
                variant: z.string()
            }).optional(),
            canvasCursors: z.object({
                radiusBase: z.number().default(40).optional(),
                gageHeight: z.number().default(80).optional(),
                readinessGaugeHeight: z.number().default(80).optional(),
                gageOffset: z.number().default(20).optional()
            }).optional()
        });

        // ðŸ—ï¸ PORT 1: FUSION CONTRACTS
        const FusionSchema = z.object({
            screenX: z.number(),
            screenY: z.number(),
            normX: z.number(),
            normY: z.number(),
            uiNormX: z.number().optional(), // V28.5: UPE Parity Hardening
            uiNormY: z.number().optional(), // V28.5: UPE Parity Hardening
            normZ: z.number(), // V24.21: Depth Parity
            rawX: z.number(), // V18: Required for laser origin
            rawY: z.number(), // V18: Required for laser origin
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(),
            confidence: z.number(),
            isPalmFacing: z.boolean(),
            normalZ: z.number(),
            palmConeAngle: z.number(), // V20.3: Anatomical Stability Factor
            palmNormal: z.object({
                x: z.number(),
                y: z.number(),
                z: z.number()
            }),
            readinessScore: z.number().min(0).max(1),
            skeletonAlpha: z.number().default(1.0), // V24.22: Fading on tracking loss
            handIndex: z.number(),
            pointerId: z.number(), // V24.4: Stable ABI ID
            curls: z.object({
                index: z.number(),
                middle: z.number(),
                ring: z.number(),
                pinky: z.number()
            }),
            landmarks: z.array(z.object({ x: z.number(), y: z.number(), z: z.number() })).optional(), // V24.17: Skeletal Fabric
            timestamp: z.number().optional()
        });

        const LandmarkSchema = z.object({ x: z.number(), y: z.number(), z: z.number() });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        // P1 Universal Fabric Envelope (CloudEvents-inspired, but local-only for v10.1)
        // Non-breaking: existing consumers keep using systemState.dataFabric.
        const FabricEnvelopeSchema = z.object({
            specversion: z.string(),
            id: z.string(),
            type: z.string(),
            source: z.string(),
            subject: z.string().optional(),
            time: z.string(),
            datacontenttype: z.string().optional(),
            monotonicMs: z.number().optional(),
            dt: z.number().optional(),
            data: DataFabricSchema
        });

        // --- P1: v11.1 Multi-App Contracts (SSOT) ---
        // Invariant: schemas live only here (P1 authority).
        window.Contracts = window.Contracts || (() => {
            const TargetPolicySchema = z.enum(['ACTIVE_APP_ONLY', 'ACTIVE_APP_OR_FALLBACK', 'GLOBAL']);

            // NOTE: This is an additive contract used by P7 AppHost; runtime fields are passthrough.
            const AppManifestSchema = z.object({
                appId: z.string().min(1),
                title: z.string().min(1),
                kind: z.enum(['iframe', 'overlay']).default('iframe'),
                entrypoint: z.string().optional(),
                tags: z.array(z.string()).optional(),
                targetPolicy: TargetPolicySchema.optional()
            }).passthrough();

            const IntentManifestSchema = z.object({
                id: z.string().min(1),
                type: z.string().min(1),
                ts: z.string().min(1),
                data: z.any(),
                subject: z.string().optional(),
                source: z.string().optional()
            }).passthrough();

            return Object.freeze({ TargetPolicySchema, AppManifestSchema, IntentManifestSchema });
        })();

        const CoordinateSchema = FusionSchema;

        // --- PRODUCTION STATE ---
        const systemState = {
            parameters: {
                ui: { showTutorial: true },
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                p3: {
                    // Adapter selection can be forced via URL flag: ?flag-p3-adapter-standard=true
                    adapter: isFlagEnabled('p3-adapter-standard') ? 'standard' : 'auto',
                    // Click synthesis is controlled by the existing legacy flag (can be disabled via URL)
                    enableClickSynthesis: isFlagEnabled('p3-legacy-click'),
                    tapMoveThresholdPx: 6,
                    // v17.3: Predictive tripwire pre-arm controls (Port7 knob).
                    tripwireInjector: {
                        lookaheadEnabled: false
                    },
                    // GEN6 v16: Deadman (fail-closed) for P3 tripwire injector.
                    // If a COMMIT pointer is perfectly still for long enough, cancel injection eligibility.
                    deadman: {
                        enabled: true,
                        timeoutMs: 60_000,
                        // uiNorm units (0..1). 0 means exact equality only.
                        epsilonUiNorm: 0,
                        // If true, movement beyond epsilon clears the deadman tripped state.
                        rearmOnMove: true
                    }
                },
                // --- GEN6 v11: P2 Gesture Language (experimental) ---
                // Hooks into the FSM via P1 DataFabric cursors (fsmState/readiness/landmarks) and can emit Port3 payloads.
                // Default is telemetry-only; enable payload dispatch by setting `emitP3` or using the feature flag.
                p2: {
                    gestureLanguage: {
                        enabled: false,
                        emitP3: false,
                        emitTelemetry: true,
                        minReadiness: 0.2
                    },
                    // --- GEN6 v22: Knuckle Tripwire Defaults (distance-based hysteresis, uiNorm units) ---
                    // Goal: easy trigger by crossing fingertip past the knuckle bar.
                    knuckleTripwire: {
                        // Distance in uiNorm space. 0.004 ~= ~3px at 720p.
                        on: 0.004,
                        off: 0.002,
                        // v22: extend bar endpoints by a fraction of barLen on each side.
                        // This is a critical primitive: a hand-anchored "trip-plane" can be extended into a sword/tool.
                        // Example: 0.5 => 0.5*barLen extension on both ends (0.5 + 1.0 + 0.5).
                        // Asymmetric tuning creates a "sword" (extend one side more than the other).
                        // v23: asymmetric default "blade" posture (pinkyâ†’index; extend toward thumb/index side)
                        // A corresponds to the index-knuckle endpoint (landmark 5), B corresponds to pinky-knuckle (landmark 17).
                        barExtensionFracA: 1.25,
                        barExtensionFracB: 0.25,
                        minReadiness: 0.2
                    },

                    // --- GEN6 v23: P2 Sword Meter (leaky bucket + hysteresis lock) ---
                    swordMeter: {
                        enabled: false,
                        fillMs: 800,
                        drainMs: 800,
                        minConfidence: 0.64,
                        lockAt01: 1.0,
                        unlockAt01: 0.0,
                        // Visual scaling: the base extension exists even when inactive; meter scales it up.
                        baseScale01: 0.2,
                        // v23.3: sword marker extension multipliers (relative to knuckle span).
                        // A extends beyond index knuckle (outward blade), B extends beyond pinky knuckle (handle/back).
                        knuckleSpanMultiplierA: 8.0,
                        knuckleSpanMultiplierB: 0.25,
                    },

                    // v23.10: PHOENIX PYREBLADE VFX tuning (historical flamberge, thick core + thermal flames)
                    pyrebladeVfx: {
                        enabled: true,
                        bladeDarkness: 0.02,
                        bladeAmber: 0.8,
                        bladeOpacity: 0.22,
                        glowIntensity: 1.20,
                        glowAlpha: 0.26,
                        flameIntensity: 1.45,
                        flameSpeed: 0.55,
                        tipIntensity: 1.10,
                        emberIntensity: 0.95,
                        tipWhiteness: 0.55,
                        // v23.10: flamberge wave controls (historical look; default is static/very slow)
                        waveAmp: 0.034,
                        waveCycles: 3.2,
                        waveSpeedHz: 0.0,
                        waveTaperIn: 0.10,
                        waveTaperOut: 0.10,
                    },
                    // v17.3: Tripwire thread controls (Port7 knob).
                    tripwireThread: {
                        enabled: true,
                        emitTelemetry: true,
                        cooldownMs: 250,
                        emitDownOnly: true,
                        commitOnly: true,
                        lookaheadEnabled: false,
                        lookaheadWindowMs: 0,
                        band: {
                            centerUiNormY: 0.5,
                            thicknessUiNorm: 0.06,
                            spanUiNormXMin: 0.0,
                            spanUiNormXMax: 1.0
                        }
                    }
                },
                landmarks: {
                    minConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    minPresenceConfidence: 0.5,
                    numHands: 2,
                    showSkeleton: true,
                    skeletonFadeTimeMs: 400, // V26: Time to fade out
                    skeletonInactivityTimeoutMs: 1500 // V26: Time before pruning stale skeleton
                },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.70, exitThreshold: 0.55 },
                fsm: {
                    hysteresisHigh: 0.88,
                    hysteresisLow: 0.64,
                    chargeTimeMs: 200,
                    releaseTimeMs: 200,
                    coastDrainTimeMs: 1200, // Slower drain for Inertia [V16]
                    tensionMs: 100
                },
                readiness: {
                    fillMultiplier: 1.0,
                    drainMultiplier: 1.0,
                    coastDrainMultiplier: 1.25 // COAST drains faster by default
                },
                coasting: {
                    timeoutMs: 150,
                    confidenceThreshold: 0.4,
                    // Fail-closed COAST: treat impossible-still pointers as low-confidence.
                    deadman: {
                        enabled: true,
                        timeoutMs: 60_000,
                        // uiNorm units (0..1). 0 means exact equality only.
                        epsilonUiNorm: 0,
                        // If true, movement beyond epsilon clears the tripped state.
                        rearmOnMove: true
                    }
                },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true, // V20.6 Feature Flag (Default ON)
                    directProjectionOffset: 0.04, // V20.6 Custom Offset for Direct projection
                    cursorTheme: 'LI', // V20.5 stable evolution
                    oneEuroMinCutoff: 0.85,
                    oneEuroBeta: 0.02,
                    oneEuroRodMinCutoff: 0.8,
                    planckStiffness: 4.5,
                    planckDamping: 1.2,
                    palmRodMultiplier: 0.64,
                    showLaserBeam: true,
                    showTrailMesh: false, // V24.17: Off by default
                    showHFOClaw: false, // V24.18: Off by default
                    predictiveLookahead: 0.5,
                    fireScale: 2.0, // V24.11 Default
                    fireIntensity: 2.0 // V24.11 Default
                },
                anatomy: {
                    palmWidthCm: 8,
                    rodExtensionMultiplier: 0.125
                },
                excalidraw: {
                    opacity: 0.8,
                    enabled: true,
                    activeTool: 'freedraw',
                    zoomFactor: 1.2, // V37: Applied 20% Safety Margin to bring bottom UI into safe reach zone
                },
                apps: {
                    overlay: {
                        opacity: 1.0,
                        zoom: 1.0,
                        rememberPerApp: true
                    },
                    perApp: {}
                },
                visuals: {
                    engine: 'BABYLON',
                    variant: 'PHOENIX_CORE'
                },
                ports: {
                    p0_recognizer: 'MEDIAPIPE_HANDS',
                    p1_fusion: 'UNIVERSAL_PROJECTION_V28',
                    p2_fsm: 'SOVEREIGN_4_STATE',
                    p3_injector: 'HYDRA_ADAPTER_PULSE',
                },
                canvasCursors: {
                    radiusBase: 40,
                    gageHeight: 80,
                    readinessGaugeHeight: 80,
                    gageOffset: 20
                },
                p0Active: false,
                devMode: false,
                essentialsMode: true // v23.6: Kiosk-first by default (toggleable; ?kiosk=0)
            },
            fsm: {
                currentState: 'IDLE',
                lastState: 'IDLE',
                lastCommitTime: 0,
                commitExitStartTime: 0,
                primaryHandIndex: null,
                // GEN6 v4: Any-hand IDLEâ†’READY rising edge triggers a nematocyst payload (e.g., Dino jump).
                lastReadyTriggerTimes: [0, 0, 0, 0],
                readyTriggerCooldownMs: 350,
                nematocystTargetLock: null,
                lastTarget: null,
                activePointers: {} // V24.4: Tracks down status per pointerId
            },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [],
                readinessScores: [0, 0, 0, 0], // Per-hand leaky buckets
                fsmStates: ['IDLE', 'IDLE', 'IDLE', 'IDLE'], // Per-hand FSM states [V15]
                palmFacingStates: [false, false, false, false], // Hysteresis state
                lastPalmFacingTimes: [0, 0, 0, 0], // Tension/Coyote timers
                lastData: [null, null, null, null], // Per-hand coasting data
                lastTrackingTimes: [0, 0, 0, 0], // V26: Tracking heartbeats
                lastMovementTimes: [0, 0, 0, 0], // V26: Inactivity detection
                lastLandmarks: [null, null, null, null], // V26: Ghost landmarks for fading
                coastStartTimes: [0, 0, 0, 0], // Per-hand coast timers
                filters: [null, null, null, null], // OneEuroFilters
                rodFilters: [null, null, null, null], // V19.2: Stabilize rod length
                anchorFilters: [null, null, null, null], // V19.2: Stabilize anchor point
                directionFilters: [null, null, null, null], // V19.2: Stabilize rod direction
                physicsState: [null, null, null, null], // Mass-Spring state

                // ðŸŽ¯ V28.0 UNIVERSAL PROJECTION ENGINE (UPE)
                // Centralized parity logic for all coordinate substrates
                // V28.0 FIX: Internal drawing (Fire/Skeleton) MUST use buffer space.
                // Interaction (PointerEvents) MUST use viewport space.
                toBufferX: (nx) => nx * (systemState.p0.canvas?.width || 1280),
                toBufferY: (ny) => ny * (systemState.p0.canvas?.height || 720),
                toViewportX: (nx) => {
                    const b = systemState.ui.viewBounds || { width: 1280, offsetX: 0, containerRect: { left: 0 } };
                    // V33: Use cached containerRect for Option 1 performance stability
                    const left = b.containerRect?.left || 0;
                    return left + b.offsetX + (nx * b.width);
                },
                toViewportY: (ny) => {
                    const b = systemState.ui.viewBounds || { height: 720, offsetY: 0, containerRect: { top: 0 } };
                    const top = b.containerRect?.top || 0;
                    return top + b.offsetY + (ny * b.height);
                }
            },

            // --- GEN6 v23: P2 Runtime State (contract surface for RED tests) ---
            p2: {
                // swordMeter and sword are kept in sync for back-compat with early RED specs.
                swordMeter: {
                    active: false,
                    locked: false,
                    meter01: 0,
                    lockedBy: { handIndex: 0, pointerId: 0 },
                    lastCommitVariant: 'NONE',
                    extensionFracA: 1.25,
                    extensionFracB: 0.25
                },
                sword: null,
                commitVariantByHand: { hand0: 'NONE', hand1: 'NONE' }
            },
            ui: {
                gestures: null,
                palm: null,
                palmCtx: null,
                fsm: null,
                fsmCtx: null,
                juiceLayers: [],
                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0, containerRect: { left: 0, top: 0, width: 0, height: 0 } }
            },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
            ,
            // Optional: canonical envelope shaped by P1 (kept separate for back-compat)
            dataFabricEnvelope: null
        };

        // Initialize v23 sword pointers + inspectable markers (required by RED tests).
        try {
            systemState.p2.sword = systemState.p2.swordMeter;

            const centerX = 0.5;
            const centerY = 0.5;
            const baseLen = 0.12;
            const axis = { x: 1.0, y: 0.0 }; // pinkyâ†’index (rightwards)
            const baseEndpointB = { x: centerX - baseLen / 2, y: centerY };
            const baseEndpointA = { x: centerX + baseLen / 2, y: centerY };

            const extA = baseLen * 1.25 * 0.2;
            const extB = baseLen * 0.25 * 0.2;
            const endpointA = { x: baseEndpointA.x + axis.x * extA, y: baseEndpointA.y + axis.y * extA };
            const endpointB = { x: baseEndpointB.x - axis.x * extB, y: baseEndpointB.y - axis.y * extB };

            window.__hfoSwordTouch2dMarker = {
                weaponName: 'PHOENIX_PYREBLADE',
                active: false,
                locked: false,
                endpointPinkyUiNorm: baseEndpointB,
                endpointIndexUiNorm: baseEndpointA,
                endpointAUiNorm: endpointA,
                endpointBUiNorm: endpointB,
                axisUiNorm: axis,
                thicknessUiNorm: 0.01,
                baseEndpointAUiNorm: baseEndpointA,
                baseEndpointBUiNorm: baseEndpointB,
            };

            window.__hfoSwordBabylonMarker = { weaponName: 'PHOENIX_PYREBLADE', active: false, locked: false, meshName: 'HFO_SWORD_V23' };
            window.__hfoSwordMeshName = 'HFO_SWORD_V23';
        } catch (_) {
            // ignore
        }

        // --- P4: VISUAL JUICE (BabylonJS Substrate) ---
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // thumb
            [0, 5], [5, 6], [6, 7], [7, 8], // index
            [0, 9], [9, 10], [10, 11], [11, 12], // middle
            [0, 13], [13, 14], [14, 15], [15, 16], // ring
            [0, 17], [17, 18], [18, 19], [19, 20], // pinky
            [5, 9], [9, 13], [13, 17] // palm
        ];

        class BabylonJuiceSubstrate {
            constructor(container) {
                // V24.4: Hard Enforcement of Single-Engine Invariant
                window.hfoLifecycle.dispose('BABYLON_ENGINE');

                this.canvas = document.createElement('canvas');
                this.canvas.id = 'babylon-canvas';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '0';
                this.canvas.style.top = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.zIndex = '12';
                this.canvas.style.display = 'none';
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                this.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -10), this.scene);
                this.camera.setTarget(BABYLON.Vector3.Zero());
                // Defensive: ensure projection/view matrices resolve even during early frames.
                this.scene.activeCamera = this.camera;

                this.light = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 0, -5), this.scene);
                this.light.intensity = 0.8;
                this.light.diffuse = new BABYLON.Color3(1, 0.4, 0.1);

                this.emitterRoots = [];
                this.particleSystems = [];
                this.trails = []; // V24.16: Hybrid Geometric Core
                this.skeletons = []; // V24.17: Skeletal Data Fabric
                this.idleIndicators = []; // V38: Leaky Bucket Visualization
                this.lastPositions = [];
                this.swordVfx = null; // v23: HFO_SWORD_V23 visual bundle
                this.perfMultiplier = 1.0; // Math.max(0.2, Math.min(this.perfMultiplier, 1.5));

                this.engine.runRenderLoop(() => {
                    if (this.canvas && this.canvas.style.display !== 'none') {
                        this.scene.render();

                        // V24.15: 30FPS Mobile Optimization Target
                        const fps = this.engine.getFps();
                        if (fps > 0) {
                            const target = 30; // 30Hz Baseline for Midrange Mobile
                            const factor = fps / target;
                            this.perfMultiplier = this.perfMultiplier * 0.95 + factor * 0.05;
                            this.perfMultiplier = Math.max(0.2, Math.min(this.perfMultiplier, 1.5));
                        }
                    }
                });

                window.hfoLifecycle.register('BABYLON_ENGINE', this);
            }

            dispose() {
                if (this.engine) {
                    // v23+: Dispose sword VFX bundle (single, global visual).
                    try {
                        const vfx = this.swordVfx;
                        if (vfx) {
                            try { vfx.sheath?.stop?.(); } catch (_) { }
                            try { vfx.tip?.stop?.(); } catch (_) { }
                            try { vfx.embers?.stop?.(); } catch (_) { }
                            try { vfx.sheath?.dispose?.(); } catch (_) { }
                            try { vfx.tip?.dispose?.(); } catch (_) { }
                            try { vfx.embers?.dispose?.(); } catch (_) { }
                            try { vfx.tipEmitter?.dispose?.(); } catch (_) { }
                            try { vfx.core?.dispose?.(); } catch (_) { }
                            try { vfx.shell?.dispose?.(); } catch (_) { }
                            try { vfx.coreMat?.dispose?.(); } catch (_) { }
                            try { vfx.shellMat?.dispose?.(); } catch (_) { }
                            try { vfx.root?.dispose?.(); } catch (_) { }
                        }
                    } catch (_) {
                        // ignore
                    }
                    this.swordVfx = null;

                    // Loop through all hand-specific resources
                    this.emitterRoots.forEach((root, i) => {
                        this.particleSystems[i]?.forEach(s => s.dispose());
                        this.trails[i]?.dispose();
                        this.skeletons[i]?.root.dispose();
                        root?.dispose();
                    });

                    this.idleIndicators.forEach(ind => ind?.group?.dispose());

                    this.engine.dispose();
                    this.engine = null;
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                console.log("[BABYLON] Engine and all associated trails/emitters disposed via Lifecycle hook.");
            }

            update(cursors) {
                const width = this.engine.getRenderWidth();
                const height = this.engine.getRenderHeight();

                const activeIndices = new Set();

                cursors.forEach((c) => {
                    const i = c.handIndex;
                    activeIndices.add(i);

                    if (!this.emitterRoots[i]) this.createEffect(i);
                    const root = this.emitterRoots[i];
                    const systems = this.particleSystems[i];
                    const trail = this.trails[i];
                    const skeleton = this.skeletons[i];

                    const isActive = (c.fsmState !== 'IDLE');
                    const isCoast = (c.fsmState === 'COAST');
                    const showSkeleton = systemState.parameters.landmarks.showSkeleton;
                    const hasLandmarks = !!(c.landmarks && c.landmarks.length > 0);

                    // V24.18: Sovereign Skeleton Visibility (IDLE, READY, COMMIT)
                    // V24.22: Fading logic for Tracking Loss / COAST
                    if (skeleton) {
                        const shouldShowSkeleton = showSkeleton && hasLandmarks;
                        skeleton.root.setEnabled(shouldShowSkeleton);

                        if (shouldShowSkeleton) {
                            const fadeAlpha = c.skeletonAlpha !== undefined ? c.skeletonAlpha : 1.0;
                            // Apply fading to children
                            skeleton.root.getChildMeshes().forEach(m => {
                                m.visibility = fadeAlpha;
                            });

                            // Update 21 landmark spheres
                            c.landmarks.forEach((lm, lIndex) => {
                                // V24.18 Perspective Alignment:
                                // projectToWorld correctly handles the perspective shift for depth.
                                // V28.5 HARDENED: Use landmarks directly (already mirrored/scaled in Fabric)
                                const targetZ = lm.z * 1.5;
                                const lmPos = this.projectToWorld(lm.x, lm.y, width, height, targetZ);
                                skeleton.spheres[lIndex].position.copyFrom(lmPos);
                            });

                            // Update Index Claw (Link from Tip 8 to pointer root)
                            const showClaw = systemState.parameters.physics.showHFOClaw || false;
                            skeleton.claw.setEnabled(showClaw && isActive); // Only show claw if in an active pointing state

                            if (showClaw && isActive) {
                                const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height);
                                const tipPos = skeleton.spheres[8].position;
                                const clawPoints = [tipPos, targetPos];
                                skeleton.claw = BABYLON.MeshBuilder.CreateLines("claw" + i, { points: clawPoints, instance: skeleton.claw }, this.scene);

                                // Set Claw Color based on state
                                const isCommit = (c.fsmState === 'COMMIT');
                                skeleton.claw.color = isCommit ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0.4, 0);
                            }

                            // Update wire skeleton bones
                            HAND_CONNECTIONS.forEach((conn, bIndex) => {
                                const p1 = skeleton.spheres[conn[0]].position;
                                const p2 = skeleton.spheres[conn[1]].position;
                                const bonePoints = [p1, p2];
                                skeleton.bones[bIndex] = BABYLON.MeshBuilder.CreateLines("bone" + i + "_" + bIndex, { points: bonePoints, instance: skeleton.bones[bIndex] }, this.scene);
                            });
                        }
                    }

                    if (isActive) {
                        if (this.idleIndicators[i]) this.idleIndicators[i].group.setEnabled(false);
                        systems.forEach(s => { if (!s.isStarted()) s.start(); });

                        // V24.17: Toggleable TrailMesh (Off by default)
                        if (trail) {
                            trail.isVisible = systemState.parameters.physics.showTrailMesh || false;
                        }

                        // Pixel to World Projection for the pointer root
                        // V28.5: Use unified uiNorm coordinates to bypass Zod Scythe and parity drift
                        const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height, (c.normZ || 0) * 1.5);

                        let motionVector = BABYLON.Vector3.Zero();
                        if (this.lastPositions[i]) {
                            motionVector = targetPos.subtract(this.lastPositions[i]);
                        }
                        this.lastPositions[i] = targetPos.clone();
                        root.position.copyFrom(targetPos);

                        // V24.10: Plasma Needle Scion (Fire Lab V3 Aesthetics)
                        const scale = systemState.parameters.physics.fireScale || 1.0;
                        const intensity = systemState.parameters.physics.fireIntensity || 1.0;

                        if (c.fsmState === 'COMMIT') {
                            if (trail) {
                                trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1);
                                trail.material.alpha = 0.3;
                            }
                            systems.forEach(s => {
                                s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                this.tuneFireSystem(s, motionVector, scale, intensity, true);
                            });
                        } else {
                            // READY, COAST, etc.
                            const isCyan = (c.fsmState === 'COAST'); // Coast maintains visual of last state (often COMMIT)
                            if (isCyan) {
                                // COAST keeps Cyan if it was COMMIT-ing
                                if (trail) { trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1); }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                    s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                });
                            } else {
                                if (trail) {
                                    trail.material.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
                                    trail.material.alpha = 0.2;
                                }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 0.5);
                                    s.color2 = new BABYLON.Color4(1, 0.2, 0, 0.2);
                                    this.tuneFireSystem(s, motionVector, scale, intensity, false);
                                });
                            }
                        }
                    } else {
                        systems.forEach(s => s.stop());
                        if (trail) trail.isVisible = false;
                        this.lastPositions[i] = null;

                        // V40: Update Idle Cursor / Leaky Bucket Visuals (Fixed Fading)
                        if (this.idleIndicators[i]) {
                            const ind = this.idleIndicators[i];
                            const fadeAlpha = c.skeletonAlpha !== undefined ? c.skeletonAlpha : 1.0;
                            const showIdle = hasLandmarks && fadeAlpha > 0.01;
                            ind.group.setEnabled(showIdle);

                            if (showIdle) {
                                const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height, (c.normZ || 0) * 1.5);
                                ind.group.position.copyFrom(targetPos);

                                const readiness = systemState.p1.readinessScores[i] || 0;
                                const dwellRatio = readiness;
                                ind.fill.scaling = new BABYLON.Vector3(dwellRatio, dwellRatio, 1);

                                // V40: Sync Alpha with Skeleton fading
                                if (ind.fill.material) ind.fill.material.alpha = 0.5 * fadeAlpha;
                                if (ind.ring.material) ind.ring.material.alpha = 0.4 * fadeAlpha;
                                if (ind.marker && ind.marker.material) ind.marker.material.alpha = 0.2 * fadeAlpha;

                                // Fire color shift
                                if (readiness >= systemState.parameters.fsm.hysteresisHigh) {
                                    ind.fill.material.emissiveColor = new BABYLON.Color3(1, 1, 0.4); // Ignite Yellow
                                } else {
                                    ind.fill.material.emissiveColor = new BABYLON.Color3(1, 0.4, 0.1); // Amber
                                }
                            }
                        }
                    }
                });

                // V24.16: Production Hardening (Prune Lost Emitters)
                // Hide or Dispose emitters for hands not present in cursors
                this.emitterRoots.forEach((root, i) => {
                    if (!activeIndices.has(i)) {
                        this.particleSystems[i]?.forEach(s => s.stop());
                        if (this.trails[i]) this.trails[i].isVisible = false;
                        if (this.skeletons[i]) this.skeletons[i].root.setEnabled(false);
                        if (this.idleIndicators[i]) this.idleIndicators[i].group.setEnabled(false); // V40: Fixed ghost dots on track loss

                        // If tracking is lost entirely (no bucket level), dispose of resources
                        const readiness = systemState.p1.readinessScores[i] || 0;
                        if (readiness <= 0 && this.emitterRoots[i]) {
                            console.log(`[BABYLON] Pruning stale emitter for Hand ${i}`);
                            this.particleSystems[i]?.forEach(s => s.dispose());
                            this.trails[i]?.dispose();
                            this.skeletons[i]?.root.dispose();
                            this.idleIndicators[i]?.group.dispose();
                            this.emitterRoots[i]?.dispose();

                            delete this.particleSystems[i];
                            delete this.trails[i];
                            delete this.skeletons[i];
                            delete this.idleIndicators[i];
                            delete this.emitterRoots[i];
                            this.lastPositions[i] = null;
                        }
                    }
                });

                // --- GEN6 v23: Babylon sword VFX (driven by __hfoSwordTouch2dMarker + swordMeter) ---
                this.updateSwordVfx(width, height);
            }

            _quatFromUnitVectors(from, to) {
                const f = from.normalize();
                const t = to.normalize();
                const dot = BABYLON.Vector3.Dot(f, t);

                if (dot < -0.999999) {
                    let axis = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 1, 0), f);
                    if (axis.lengthSquared() < 1e-6) {
                        axis = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 0, 1), f);
                    }
                    axis.normalize();
                    return BABYLON.Quaternion.RotationAxis(axis, Math.PI);
                }

                const axis = BABYLON.Vector3.Cross(f, t);
                const s = Math.sqrt((1 + dot) * 2);
                const invS = 1 / s;
                const q = new BABYLON.Quaternion(axis.x * invS, axis.y * invS, axis.z * invS, s * 0.5);
                q.normalize();
                return q;
            }

            _ensureSwordVfx() {
                if (this.swordVfx) return this.swordVfx;

                let isMobile = false;
                try {
                    isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
                } catch (_) {
                    isMobile = false;
                }

                const root = new BABYLON.TransformNode('HFO_SWORD_V23_ROOT', this.scene);
                root.setEnabled(false);

                // v23.10: PHOENIX PYREBLADE (historical flamberge, thick amber core)
                // Blade core is a transparent amber flamberge (historical-style waves) with thermal flames wrapped around it.
                // Blade length is along +Y (height), and we rotate the root each frame to align +Y with the marker direction.
                const baseBladeLen = 0.9;
                const segments = 64;
                const y0 = -baseBladeLen * 0.5;

                const halfWidthBySeg = new Array(segments + 1);
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    // Historical-ish profile: thicker overall so the flamberge reads as a real blade, not a wire.
                    const hiltW = 0.165;
                    const tipW = 0.065;
                    const w = hiltW + (tipW - hiltW) * Math.pow(t, 0.85);
                    halfWidthBySeg[i] = w * 0.5;
                }

                const makePaths = (z = 0) => {
                    const left = [];
                    const right = [];
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const y = y0 + baseBladeLen * t;
                        const hw = halfWidthBySeg[i];
                        left.push(new BABYLON.Vector3(-hw, y, z));
                        right.push(new BABYLON.Vector3(hw, y, z));
                    }
                    return [left, right];
                };

                const corePaths = makePaths(0);
                const shellPaths = makePaths(0.004);

                const core = BABYLON.MeshBuilder.CreateRibbon(
                    'HFO_SWORD_V23',
                    {
                        pathArray: corePaths,
                        updatable: true,
                        closeArray: false,
                        closePath: false,
                        sideOrientation: BABYLON.Mesh.DOUBLESIDE
                    },
                    this.scene
                );
                core.parent = root;
                core.isPickable = false;

                const shell = BABYLON.MeshBuilder.CreateRibbon(
                    'HFO_SWORD_V23_SHELL',
                    {
                        pathArray: shellPaths,
                        updatable: true,
                        closeArray: false,
                        closePath: false,
                        sideOrientation: BABYLON.Mesh.DOUBLESIDE
                    },
                    this.scene
                );
                shell.parent = root;
                shell.isPickable = false;

                const coreMat = new BABYLON.StandardMaterial('HFO_SWORD_V23_MAT', this.scene);
                // Core is transparent amber (no black) by default.
                coreMat.diffuseColor = new BABYLON.Color3(1.0, 0.62, 0.2);
                coreMat.emissiveColor = new BABYLON.Color3(0.55, 0.22, 0.05);
                coreMat.specularColor = new BABYLON.Color3(0.05, 0.03, 0.02);
                coreMat.alpha = 0.18;
                try {
                    coreMat.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
                } catch (_) {
                    // ignore
                }
                coreMat.disableLighting = false;
                coreMat.backFaceCulling = false;
                core.material = coreMat;
                shell.scaling.x = 1.25;
                shell.scaling.z = 2.0;

                const waveParams = {
                    amp: 0.034,
                    cycles: 3.2,
                    speedHz: 0.0,
                    taperIn: 0.10,
                    taperOut: 0.10,
                };

                const applyFlambergeWave = (timeSec) => {
                    const p = waveParams;
                    const amp = Math.max(0, Math.min(0.05, Number(p.amp) || 0));
                    const cycles = Math.max(0.0, Math.min(16.0, Number(p.cycles) || 0));
                    const speedHz = Math.max(0.0, Math.min(6.0, Number(p.speedHz) || 0));
                    const taperIn = Math.max(0.0, Math.min(0.35, Number(p.taperIn) || 0));
                    const taperOut = Math.max(0.0, Math.min(0.35, Number(p.taperOut) || 0));

                    const smooth01 = (x) => {
                        const t = Math.max(0, Math.min(1, x));
                        return t * t * (3 - 2 * t);
                    };

                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const y = y0 + baseBladeLen * t;
                        const hw = halfWidthBySeg[i];
                        const tap = smooth01(taperIn > 0 ? t / taperIn : 1) * smooth01(taperOut > 0 ? (1 - t) / taperOut : 1);
                        const phase = 2 * Math.PI * (cycles * t + speedHz * timeSec);
                        // Clamp wave amplitude per-segment to avoid edge-crossing near the tip.
                        const ampSafe = Math.min(amp, Math.max(0.0, hw * 0.95));
                        // Historical-ish flamberge: slightly sharper lobes than a pure sine.
                        const s1 = Math.sin(phase);
                        const s3 = Math.sin(3 * phase);
                        const shape = (s1 + 0.35 * s3) / 1.35;
                        const w = shape * ampSafe * tap;

                        // Wavy edges (centerline stays mostly stable).
                        corePaths[0][i].x = -hw + w;
                        corePaths[0][i].y = y;
                        corePaths[1][i].x = hw - w;
                        corePaths[1][i].y = y;

                        shellPaths[0][i].x = -hw + w;
                        shellPaths[0][i].y = y;
                        shellPaths[1][i].x = hw - w;
                        shellPaths[1][i].y = y;
                    }

                    try {
                        BABYLON.MeshBuilder.CreateRibbon(null, { pathArray: corePaths, instance: core }, this.scene);
                        BABYLON.MeshBuilder.CreateRibbon(null, { pathArray: shellPaths, instance: shell }, this.scene);
                    } catch (_) {
                        // ignore
                    }
                };

                const shellMat = new BABYLON.StandardMaterial('HFO_SWORD_V23_SHELL_MAT', this.scene);
                shellMat.diffuseColor = new BABYLON.Color3(0.0, 0.0, 0.0);
                shellMat.emissiveColor = new BABYLON.Color3(0.0, 0.0, 0.0);
                shellMat.specularColor = new BABYLON.Color3(0.0, 0.0, 0.0);
                shellMat.alpha = 0.0;
                shellMat.disableLighting = true;
                shellMat.backFaceCulling = false;
                try {
                    shellMat.alphaMode = BABYLON.Engine.ALPHA_ADD;
                } catch (_) {
                    // ignore
                }
                shell.material = shellMat;

                // CPU flame sheath (demo preset-1): cloud texture and conservative overdraw.
                const capacity = isMobile ? 900 : 1400;
                const sheath = new BABYLON.ParticleSystem('HFO_SWORD_V23_SHEATH', capacity, this.scene);
                sheath.particleTexture = new BABYLON.Texture('https://playground.babylonjs.com/textures/cloud.png', this.scene);
                sheath.emitter = core;

                // Emit volume (in core local space). Stored so we can mutate without realloc.
                // v23.9: slightly wider volume to reduce visible gaps without huge overdraw.
                // Blade-local emit box (along +Y).
                const emitMin = new BABYLON.Vector3(-0.04, -0.45, -0.03);
                const emitMax = new BABYLON.Vector3(0.04, 0.45, 0.03);
                sheath.minEmitBox = emitMin;
                sheath.maxEmitBox = emitMax;

                sheath.color1 = new BABYLON.Color4(1.0, 0.65, 0.2, 0.72);
                sheath.color2 = new BABYLON.Color4(1.0, 0.25, 0.0, 0.72);
                sheath.colorDead = new BABYLON.Color4(0.2, 0.0, 0.0, 0.0);

                // More temporal overlap => fewer holes.
                sheath.minLifeTime = isMobile ? 0.18 : 0.22;
                sheath.maxLifeTime = isMobile ? 0.46 : 0.58;
                sheath.emitRate = 0;
                sheath.minSize = isMobile ? 0.07 : 0.10;
                sheath.maxSize = isMobile ? 0.24 : 0.32;
                sheath.minEmitPower = 0.35;
                sheath.maxEmitPower = 0.95;
                const baseSheathUpdateSpeed = isMobile ? 0.015 : 0.012;
                sheath.updateSpeed = baseSheathUpdateSpeed;
                sheath.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                sheath.gravity = new BABYLON.Vector3(0, 3.5, 0);

                // Thermal tip flare: hot/whitish flame at the blade tip.
                const tipEmitter = new BABYLON.TransformNode('HFO_SWORD_V23_TIP_EMITTER', this.scene);
                tipEmitter.parent = core;
                tipEmitter.position.y = 0.45;

                const tip = new BABYLON.ParticleSystem('HFO_SWORD_V23_TIP', isMobile ? 240 : 480, this.scene);
                tip.particleTexture = sheath.particleTexture;
                tip.emitter = tipEmitter;
                tip.minEmitBox = new BABYLON.Vector3(-0.015, -0.02, -0.01);
                tip.maxEmitBox = new BABYLON.Vector3(0.015, 0.02, 0.01);
                tip.color1 = new BABYLON.Color4(1.0, 0.95, 0.75, 0.80);
                tip.color2 = new BABYLON.Color4(1.0, 0.75, 0.25, 0.78);
                tip.colorDead = new BABYLON.Color4(0.2, 0.0, 0.0, 0.0);
                tip.minLifeTime = isMobile ? 0.08 : 0.10;
                tip.maxLifeTime = isMobile ? 0.18 : 0.22;
                tip.emitRate = 0;
                tip.minSize = isMobile ? 0.05 : 0.06;
                tip.maxSize = isMobile ? 0.16 : 0.18;
                tip.minEmitPower = 0.35;
                tip.maxEmitPower = 1.05;
                const baseTipUpdateSpeed = isMobile ? 0.014 : 0.012;
                tip.updateSpeed = baseTipUpdateSpeed;
                tip.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                tip.gravity = new BABYLON.Vector3(0, 4.2, 0);

                // Slow embers: longer-lived, slower-moving glow to give "weight".
                const embers = new BABYLON.ParticleSystem('HFO_SWORD_V23_EMBERS', isMobile ? 320 : 680, this.scene);
                embers.particleTexture = sheath.particleTexture;
                embers.emitter = core;
                embers.minEmitBox = new BABYLON.Vector3(-0.02, -0.45, -0.015);
                embers.maxEmitBox = new BABYLON.Vector3(0.02, 0.45, 0.015);
                embers.color1 = new BABYLON.Color4(1.0, 0.55, 0.18, 0.42);
                embers.color2 = new BABYLON.Color4(1.0, 0.25, 0.06, 0.40);
                embers.colorDead = new BABYLON.Color4(0.2, 0.0, 0.0, 0.0);
                embers.minLifeTime = isMobile ? 0.55 : 0.75;
                embers.maxLifeTime = isMobile ? 1.25 : 1.55;
                embers.emitRate = 0;
                embers.minSize = isMobile ? 0.05 : 0.06;
                embers.maxSize = isMobile ? 0.14 : 0.16;
                embers.minEmitPower = 0.10;
                embers.maxEmitPower = 0.35;
                const baseEmbersUpdateSpeed = isMobile ? 0.008 : 0.006;
                embers.updateSpeed = baseEmbersUpdateSpeed;
                embers.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                embers.gravity = new BABYLON.Vector3(0, 1.2, 0);

                try { tip.start(); } catch (_) { }
                try { embers.start(); } catch (_) { }

                try { sheath.start(); } catch (_) { }

                this.swordVfx = {
                    root,
                    core,
                    shell,
                    sheath,
                    tip,
                    embers,
                    tipEmitter,
                    coreMat,
                    shellMat,
                    waveParams,
                    applyFlambergeWave,
                    emitMin,
                    emitMax,
                    isMobile,
                    baseSheathUpdateSpeed,
                    baseTipUpdateSpeed,
                    baseEmbersUpdateSpeed
                };
                return this.swordVfx;
            }

            updateSwordVfx(width, height) {
                try {
                    if (!isFlagEnabled('p2-sword-meter')) {
                        if (this.swordVfx?.root) this.swordVfx.root.setEnabled(false);
                        return;
                    }
                    if (!isFlagEnabled('p2-sword-vfx')) {
                        if (this.swordVfx?.root) this.swordVfx.root.setEnabled(false);
                        return;
                    }

                    const marker = window.__hfoSwordTouch2dMarker;
                    const snap = systemState?.p2?.swordMeter || systemState?.p2?.sword || null;
                    const meter01 = Math.max(0, Math.min(1, Number(snap?.meter01 ?? 0) || 0));
                    const locked = !!(marker?.locked || snap?.locked);
                    const shouldShow = locked || meter01 > 0.01 || !!marker?.active;

                    const vfx = this._ensureSwordVfx();
                    vfx.root.setEnabled(shouldShow);

                    if (!shouldShow) {
                        try { if (vfx.sheath.isStarted()) vfx.sheath.stop(); } catch (_) { }
                        return;
                    }

                    const a = marker?.endpointAUiNorm;
                    const b = marker?.endpointBUiNorm;
                    if (!a || !b) return;

                    const pA = this.projectToWorld(Number(a.x), Number(a.y), width, height, 0);
                    const pB = this.projectToWorld(Number(b.x), Number(b.y), width, height, 0);
                    const dir = pA.subtract(pB);
                    const len = Math.max(0.05, dir.length());
                    const unit = dir.scale(1 / len);
                    const mid = pA.add(pB).scale(0.5);

                    vfx.root.position.copyFrom(mid);
                    vfx.root.rotationQuaternion = this._quatFromUnitVectors(new BABYLON.Vector3(0, 1, 0), unit);

                    // Match demo preset-1 behavior: length is driven by marker endpoints,
                    // emissive + sheath intensity is driven by locked/meter01 (no thickness pumping).
                    // Demo parity: base blade height is 0.9 and scales along Y to match marker endpoint separation.
                    const baseBladeLen = 0.9;
                    const lenScale = len / baseBladeLen;

                    vfx.core.scaling.x = 1.0;
                    vfx.core.scaling.y = lenScale;
                    vfx.core.scaling.z = 1.0;

                    vfx.shell.scaling.x = 1.25;
                    vfx.shell.scaling.y = lenScale;
                    vfx.shell.scaling.z = 2.0;

                    const lerp = (a, b, t) => (a + (b - a) * Math.max(0, Math.min(1, Number(t) || 0)));
                    const tune = systemState?.parameters?.p2?.pyrebladeVfx || {};
                    const vfxEnabled = tune.enabled !== false;

                    const base = locked ? lerp(0.9, 1.55, meter01) : lerp(0.25, 1.15, meter01);
                    const hot = new BABYLON.Color3(1.2 * base, 0.42 * base, 0.07 * base);
                    const rim = new BABYLON.Color3(1.15 * base, 0.55 * base, 0.12 * base);

                    const clamp01 = (n) => Math.max(0, Math.min(1, Number(n) || 0));
                    const bladeDark = Math.max(0.0, Math.min(0.25, Number(tune.bladeDarkness ?? 0.02) || 0.02));
                    const bladeAmber = clamp01(tune.bladeAmber ?? 0.8);
                    const bladeOpacity = clamp01(tune.bladeOpacity ?? 0.06);
                    const glowIntensity = Math.max(0.0, Math.min(6.0, Number(tune.glowIntensity ?? 1.0) || 1.0));
                    const glowAlpha = clamp01(tune.glowAlpha ?? 0.22);
                    const flameIntensity = Math.max(0.0, Math.min(4.0, Number(tune.flameIntensity ?? 1.0) || 1.0));
                    const flameSpeed = Math.max(0.15, Math.min(2.0, Number(tune.flameSpeed ?? 0.55) || 0.55));
                    const tipIntensity = Math.max(0.0, Math.min(4.0, Number(tune.tipIntensity ?? 1.0) || 1.0));
                    const emberIntensity = Math.max(0.0, Math.min(4.0, Number(tune.emberIntensity ?? 0.65) || 0.65));
                    const tipWhiteness = clamp01(tune.tipWhiteness ?? 0.55);

                    const waveAmp = Math.max(0.0, Math.min(0.05, Number(tune.waveAmp ?? 0.034) || 0.034));
                    const waveCycles = Math.max(0.0, Math.min(16.0, Number(tune.waveCycles ?? 3.2) || 3.2));
                    const waveSpeedHz = Math.max(0.0, Math.min(6.0, Number(tune.waveSpeedHz ?? 0.0) || 0.0));
                    const waveTaperIn = Math.max(0.0, Math.min(0.35, Number(tune.waveTaperIn ?? 0.10) || 0.10));
                    const waveTaperOut = Math.max(0.0, Math.min(0.35, Number(tune.waveTaperOut ?? 0.10) || 0.10));

                    // Blade core is optional and subtle: amber-tinted but mostly transparent.
                    const deepAmber = new BABYLON.Color3(0.85, 0.30, 0.08);
                    const amber = new BABYLON.Color3(1.0, 0.62, 0.2);
                    const coreDiffuse = deepAmber.scale(1 - bladeAmber).add(amber.scale(bladeAmber));
                    vfx.coreMat.diffuseColor = coreDiffuse.scale(1.0 - bladeDark);
                    vfx.coreMat.specularColor = new BABYLON.Color3(0.04, 0.03, 0.02);
                    // Keep the core readable even when the glow/flames are disabled (e.g., core-only screenshots).
                    // Use meter/lock state so the blade still feels "alive" without becoming a neon bar.
                    const coreEmissiveGain = locked
                        ? lerp(0.80, 1.25, meter01)
                        : lerp(0.35, 1.05, meter01);
                    vfx.coreMat.emissiveColor = amber.scale(0.55 * bladeAmber * coreEmissiveGain);
                    vfx.coreMat.disableLighting = false;
                    vfx.coreMat.alpha = vfxEnabled ? bladeOpacity : 0.0;

                    if (vfx.waveParams) {
                        vfx.waveParams.amp = waveAmp;
                        vfx.waveParams.cycles = waveCycles;
                        vfx.waveParams.speedHz = waveSpeedHz;
                        vfx.waveParams.taperIn = waveTaperIn;
                        vfx.waveParams.taperOut = waveTaperOut;
                    }

                    try {
                        if (typeof vfx.applyFlambergeWave === 'function') {
                            vfx.applyFlambergeWave(performance.now() / 1000);
                        }
                    } catch (_) {
                        // ignore
                    }

                    // Glow shell provides the amber envelope.
                    vfx.shellMat.emissiveColor = rim.scale(glowIntensity);
                    vfx.shellMat.disableLighting = true;
                    vfx.shellMat.alpha = vfxEnabled ? (locked ? lerp(0.08, 0.22, meter01) : lerp(0.05, 0.14, meter01)) * glowAlpha : 0.0;

                    // Slow, "burning blade" feel: modulate the particle simulation speed.
                    try {
                        vfx.sheath.updateSpeed = (Number(vfx.baseSheathUpdateSpeed ?? 0.012) || 0.012) * flameSpeed;
                        if (vfx.tip) vfx.tip.updateSpeed = (Number(vfx.baseTipUpdateSpeed ?? 0.012) || 0.012) * flameSpeed;
                        if (vfx.embers) vfx.embers.updateSpeed = (Number(vfx.baseEmbersUpdateSpeed ?? 0.006) || 0.006) * flameSpeed;
                    } catch (_) {
                        // ignore
                    }

                    const emitLocked = vfx.isMobile ? [90, 320] : [140, 520];
                    const emitFree = vfx.isMobile ? [0, 140] : [0, 180];
                    vfx.sheath.emitRate = vfxEnabled
                        ? Math.floor((locked
                            ? lerp(emitLocked[0], emitLocked[1], meter01)
                            : lerp(emitFree[0], emitFree[1], meter01)) * flameIntensity)
                        : 0;

                    if (vfx.tip) {
                        const tipBase = locked ? lerp(40, 140, meter01) : lerp(0, 75, meter01);
                        vfx.tip.emitRate = vfxEnabled ? Math.floor(tipBase * tipIntensity) : 0;

                        const hotTip = new BABYLON.Color3(1.0, 0.75, 0.22);
                        const white = new BABYLON.Color3(1.0, 1.0, 1.0);
                        const tipCol = hotTip.scale(1 - tipWhiteness).add(white.scale(tipWhiteness));
                        vfx.tip.color1 = new BABYLON.Color4(tipCol.r, tipCol.g, tipCol.b, 0.78);
                        vfx.tip.color2 = new BABYLON.Color4(1.0, 0.75, 0.25, 0.72);
                    }

                    if (vfx.embers) {
                        const eBase = locked ? lerp(10, 65, meter01) : lerp(0, 35, meter01);
                        vfx.embers.emitRate = vfxEnabled ? Math.floor(eBase * emberIntensity) : 0;
                    }

                    try { if (!vfx.sheath.isStarted()) vfx.sheath.start(); } catch (_) { }
                    try { if (vfx.tip && !vfx.tip.isStarted()) vfx.tip.start(); } catch (_) { }
                    try { if (vfx.embers && !vfx.embers.isStarted()) vfx.embers.start(); } catch (_) { }
                } catch (_) {
                    // ignore (fail-soft visuals)
                }
            }

            projectToWorld(nx, ny, width, height, targetZ = 0) {
                try {
                    if (!this.scene || !this.camera) return BABYLON.Vector3.Zero();
                    if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return BABYLON.Vector3.Zero();

                    // Prefer camera matrices; fall back to scene getters.
                    const view = (this.camera.getViewMatrix?.() || this.scene.getViewMatrix?.()) || null;
                    const proj = (this.camera.getProjectionMatrix?.(true) || this.scene.getProjectionMatrix?.()) || null;
                    if (!view || !proj) {
                        try {
                            window.hfoPortsEffects?.emit?.('p2', 'babylon_projection_skipped', {
                                reason: 'missing_view_or_projection',
                                width,
                                height
                            });
                        } catch (_) {
                            // ignore
                        }
                        return BABYLON.Vector3.Zero();
                    }

                    const vectorNear = new BABYLON.Vector3(nx * width, ny * height, 0);
                    const worldCoordNear = BABYLON.Vector3.Unproject(
                        vectorNear, width, height, BABYLON.Matrix.Identity(),
                        view, proj
                    );
                    const vectorFar = new BABYLON.Vector3(nx * width, ny * height, 1);
                    const worldCoordFar = BABYLON.Vector3.Unproject(
                        vectorFar, width, height, BABYLON.Matrix.Identity(),
                        view, proj
                    );
                    const direction = worldCoordFar.subtract(worldCoordNear).normalize();
                    if (Math.abs(direction.z) > 0.0001) {
                        const distance = (targetZ - worldCoordNear.z) / direction.z;
                        return worldCoordNear.add(direction.scale(distance));
                    }
                    return worldCoordNear;
                } catch (e) {
                    try {
                        window.hfoPortsEffects?.emit?.('p2', 'babylon_projection_error', {
                            error: String(e?.message || e)
                        });
                    } catch (_) {
                        // ignore
                    }
                    return BABYLON.Vector3.Zero();
                }
            }

            tuneFireSystem(s, motionVector, scale, intensity, isHigh) {
                const speed = motionVector.length();
                const densityMultiplier = 1.0 + Math.min(speed * (isHigh ? 20 : 10), isHigh ? 2.5 : 2.0);
                const baseRate = (isHigh ? 600 : 250) * scale;
                s.emitRate = baseRate * densityMultiplier * this.perfMultiplier;

                const jitter = (isHigh ? 0.03 * (1.0 + speed) : 0.06);
                s.minEmitBox = motionVector.scale(isHigh ? -1.0 : -0.8).add(new BABYLON.Vector3(-jitter, isHigh ? -0.02 : -jitter, -jitter));
                s.maxEmitBox = new BABYLON.Vector3(jitter, isHigh ? 0.02 : jitter, jitter);

                s.minSize = (isHigh ? 0.06 : 0.1) * scale;
                s.maxSize = (isHigh ? 0.24 : 0.3) * scale;
                s.minLifeTime = isHigh ? 0.25 : 0.4;
                s.maxLifeTime = isHigh ? 0.5 : 0.8;
                s.gravity = new BABYLON.Vector3(0, (isHigh ? 4 : 2) * intensity, 0);
            }

            createSkeleton(index) {
                const root = new BABYLON.TransformNode("skeleton" + index, this.scene);
                const spheres = [];
                const bones = [];

                const mat = new BABYLON.StandardMaterial("skeletonMat" + index, this.scene);
                mat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Bone White
                mat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                mat.alpha = 0.12; // V24.18: Transparent Bone
                mat.disableLighting = true;

                for (let i = 0; i < 21; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere("tm_" + index + "_" + i, { diameter: 0.12 }, this.scene);
                    sphere.material = mat;
                    sphere.parent = root;
                    spheres.push(sphere);
                }

                // Initial claw line
                const claw = BABYLON.MeshBuilder.CreateLines("claw" + index, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                claw.color = new BABYLON.Color3(0.9, 0.9, 1.0); // Bright Bone Claw
                claw.parent = root;
                claw.alpha = 0.2;

                // Wire skeleton bones
                HAND_CONNECTIONS.forEach((_, bIndex) => {
                    const bone = BABYLON.MeshBuilder.CreateLines("bone" + index + "_" + bIndex, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                    bone.color = new BABYLON.Color3(0.8, 0.8, 0.8);
                    bone.alpha = 0.08; // Delicate Bone Structure
                    bone.parent = root;
                    bones.push(bone);
                });

                return { root, spheres, bones, claw };
            }

            createIdleIndicator(index) {
                const group = new BABYLON.TransformNode("idleGroup" + index, this.scene);

                // V38: Hollow Ring (Background)
                const ring = BABYLON.MeshBuilder.CreateTorus("idleRing" + index, {
                    diameter: 0.22,
                    thickness: 0.015,
                    tessellation: 64
                }, this.scene);
                ring.rotation.x = Math.PI / 2;
                const ringMat = new BABYLON.StandardMaterial("idleRingMat" + index, this.scene);
                ringMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                ringMat.alpha = 0.4;
                ringMat.disableLighting = true;
                ring.material = ringMat;
                ring.parent = group;

                // V38: Readiness Fill (Progress Disc)
                const fill = BABYLON.MeshBuilder.CreateDisc("idleFill" + index, { radius: 0.1, tessellation: 64 }, this.scene);
                const fillMat = new BABYLON.StandardMaterial("idleFillMat" + index, this.scene);
                fillMat.emissiveColor = new BABYLON.Color3(1, 0.4, 0.1); // Amber Fire
                fillMat.alpha = 0.5;
                fillMat.disableLighting = true;
                fill.material = fillMat;
                fill.parent = group;
                fill.scaling = BABYLON.Vector3.Zero();

                // V38: Threshold Marker (High Hysteresis)
                const highThreshold = systemState.parameters.fsm.hysteresisHigh || 0.88;
                const marker = BABYLON.MeshBuilder.CreateTorus("idleMarker" + index, {
                    diameter: 0.22 * highThreshold,
                    thickness: 0.005,
                    tessellation: 64
                }, this.scene);
                marker.rotation.x = Math.PI / 2;
                const markerMat = new BABYLON.StandardMaterial("markerMat" + index, this.scene);
                markerMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                markerMat.alpha = 0.2;
                markerMat.disableLighting = true;
                marker.material = markerMat;
                marker.parent = group;

                group.setEnabled(false);
                return { group, ring, fill, marker };
            }

            createEffect(index) {
                const root = BABYLON.MeshBuilder.CreateSphere("emitter" + index, { diameter: 0.05 }, this.scene);
                root.isVisible = false;
                this.emitterRoots[index] = root;

                // Initialize Skeleton
                this.skeletons[index] = this.createSkeleton(index);

                // Initialize Idle Indicator [V38]
                this.idleIndicators[index] = this.createIdleIndicator(index);

                // V24.16: Hybrid Geometric Core (Exemplar TrailMesh)
                // Diameter 0.08, Length 30, Auto-shrink enabled.
                const trail = new BABYLON.TrailMesh("trail" + index, root, this.scene, 0.08, 30, true);
                const trailMat = new BABYLON.StandardMaterial("trailMat" + index, this.scene);
                trailMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1);
                trailMat.alpha = 0.4;
                trailMat.disableLighting = true;
                trail.material = trailMat;
                trail.isVisible = false;
                this.trails[index] = trail;

                const defaultTexture = "./lib/models/flare.png";

                // PHOENIX CORE EFFECT
                const fire = new BABYLON.ParticleSystem("fire", 2000, this.scene);
                fire.particleTexture = new BABYLON.Texture(defaultTexture, this.scene);
                fire.emitter = root;
                fire.minEmitBox = new BABYLON.Vector3(-0.05, 0, -0.05);
                fire.maxEmitBox = new BABYLON.Vector3(0.05, 0, 0.05);
                fire.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 1.0);
                fire.color2 = new BABYLON.Color4(1, 0.2, 0, 0.5);
                fire.colorDead = new BABYLON.Color4(0, 0, 0, 0);
                fire.minLifeTime = 0.1; fire.maxLifeTime = 0.3;
                fire.emitRate = 400;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(0, 2, 0);
                this.particleSystems[index] = [fire];
            }

            resize() { this.engine.resize(); }
        }

        window.hfoState = systemState;

        // --- P2: AGNOSTIC PHYSICS MANIFOLD ---
        /**
         * IPhysicsAdapter: Interface for vendor-agnostic physics steering.
         * Decouples the FSM and Pointer logic from specific engines (Planck, Matter, Rapier).
         */
        class IPhysicsAdapter {
            update(targetX, targetY, dt) { throw new Error("Not implemented"); }
            setParams(params) { throw new Error("Not implemented"); }
            reset(x, y) { throw new Error("Not implemented"); }
            setBallistic(enabled) { throw new Error("Not implemented"); }
            getTelemetry() { return {}; }
        }

        /**
         * PlanckPhysicsAdapter: High-fidelity deterministic Box2D (Planck.js) implementation.
         * Uses MKS scaling (1 meter = 100 pixels) for numerical stability.
         */
        class PlanckPhysicsAdapter extends IPhysicsAdapter {
            constructor(stiffness = 5.0, damping = 0.7) {
                super();
                this.SCALE = 100.0; // 100px = 1m
                this.world = planck.World({ gravity: planck.Vec2(0, 0) });
                this.stiffness = stiffness;
                this.damping = damping;
                this.isBallistic = false;

                // Cursor Body (Dynamic)
                this.cursor = this.world.createBody({
                    type: 'dynamic',
                    position: planck.Vec2(0, 0),
                    linearDamping: 2.0, // Reduced for smoother glide
                    angularDamping: 5.0
                });
                this.cursor.createFixture(planck.Circle(0.1), { density: 1.0, friction: 0.3 });

                // Target Body (Kinematic)
                this.target = this.world.createBody({ type: 'kinematic', position: planck.Vec2(0, 0) });

                // Constant Distance Joint (Rod) or Spring (DistanceJoint with frequency)
                this.joint = this.world.createJoint(planck.DistanceJoint({
                    bodyA: this.target,
                    bodyB: this.cursor,
                    anchorA: planck.Vec2(0, 0),
                    anchorB: planck.Vec2(0, 0),
                    frequencyHz: stiffness, // Stiffness as frequency
                    dampingRatio: damping,    // Damping
                    length: 0
                }));

                this.lastPos = { x: 0, y: 0 };
            }

            setBallistic(enabled) {
                this.isBallistic = enabled;
                if (enabled) {
                    this.joint.setFrequency(0); // Effectively detach
                } else {
                    this.joint.setFrequency(this.stiffness);
                }
            }

            update(targetX, targetY, dt) {
                if (!this.isBallistic) {
                    const tx = targetX / this.SCALE;
                    const ty = targetY / this.SCALE;
                    this.target.setPosition(planck.Vec2(tx, ty));
                }

                // Step world
                this.world.step(Math.min(dt / 1000, 0.033));

                const pos = this.cursor.getPosition();
                this.lastPos = { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
                return this.lastPos;
            }

            setParams(params) {
                this.stiffness = params.stiffness || 5.0;
                this.damping = params.dampingRatio || 0.7;
                if (!this.isBallistic) {
                    this.joint.setFrequency(this.stiffness);
                }
                this.joint.setDampingRatio(this.damping);
            }

            reset(x, y) {
                const px = x / this.SCALE;
                const py = y / this.SCALE;
                this.cursor.setPosition(planck.Vec2(px, py));
                this.target.setPosition(planck.Vec2(px, py));
                this.cursor.setLinearVelocity(planck.Vec2(0, 0));
            }

            getTelemetry() {
                const vel = this.cursor.getLinearVelocity();
                return {
                    velocity: { x: vel.x * this.SCALE, y: vel.y * this.SCALE },
                    speed: vel.length() * this.SCALE,
                    position: { ...this.lastPos }
                };
            }
        }

        // --- COORDINATE SUBSTRATE: 1EURO ---
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.0) {
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.xPrev = null;
                this.dxPrev = 0;
            }

            filter(x, rate = 30) {
                if (this.xPrev === null) {
                    this.xPrev = x;
                    return x;
                }
                const dx = (x - this.xPrev) * rate;
                const edx = this.alpha(rate, 1.0); // Simple smoothing for derivative
                const dxHat = edx * dx + (1 - edx) * this.dxPrev;
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(rate, cutoff);
                const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat;
                this.dxPrev = dxHat;
                return xHat;
            }

            alpha(rate, cutoff) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                const te = 1.0 / rate;
                return 1.0 / (1.0 + tau / te);
            }
        }

        class MassSpringDampener {
            constructor(stiffness = 0.15, damping = 0.05) {
                this.pos = null;
                this.vel = { x: 0, y: 0 };
                this.stiffness = stiffness;
                this.damping = damping;
            }

            update(targetX, targetY) {
                if (this.pos === null) {
                    this.pos = { x: targetX, y: targetY };
                    return this.pos;
                }
                const forceX = (targetX - this.pos.x) * this.stiffness;
                const forceY = (targetY - this.pos.y) * this.stiffness;

                this.vel.x = this.vel.x * (1 - this.damping) + forceX;
                this.vel.y = this.vel.y * (1 - this.damping) + forceY;

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                return this.pos;
            }
        }

        // --- P1 BRIDGER: CONTRACT ENFORCEMENT ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]];
                    const b = landmarks[indices[i + 1]];
                    const c = landmarks[indices[i + 2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                    const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static validateConfig(config) {
                try {
                    return ConfigSchema.parse(config);
                } catch (e) {
                    console.error("ðŸš¨ P1_CONFIG_CONTRACT_BREACH:", e.errors);
                    return null;
                }
            }

            static fuse(results, dt) {
                const cursors = [];
                const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;

                for (let i = 0; i < numHands; i++) {
                    const landmarks = results.landmarks?.[i];
                    const bestGesture = results.gestures?.[i]?.[0];
                    let cursorData = null;

                    // V26: Tracking Heartbeat
                    if (landmarks) systemState.p1.lastTrackingTimes[i] = now;
                    const tTracking = now - (systemState.p1.lastTrackingTimes[i] || 0);
                    const isTrackingLost = !landmarks;

                    if (landmarks) {
                        try {
                            const validatedLandmarks = landmarks.map(l => LandmarkSchema.parse(l));
                            const { width, height } = systemState.p0.videoBounds || { width: 0, height: 0 };
                            const lm = validatedLandmarks;

                            // V26: Inactivity Detection (Skeleton Dormancy)
                            const lastLms = systemState.p1.lastData[i]?.landmarks;
                            if (lastLms && lastLms[8]) {
                                const dx = lm[8].x - lastLms[8].x;
                                const dy = lm[8].y - lastLms[8].y;
                                if (Math.sqrt(dx * dx + dy * dy) > 0.005) systemState.p1.lastMovementTimes[i] = now;
                            } else {
                                systemState.p1.lastMovementTimes[i] = now;
                            }
                            const tMovement = now - (systemState.p1.lastMovementTimes[i] || now);
                            const dormancyAlpha = tMovement < 3000 ? 1.0 : Math.max(0, 1.0 - (tMovement - 3000) / 1000);

                            // V20.3: ANATOMICAL STABILITY (Hardened Rod)
                            const p5 = lm[5];
                            const p17 = lm[17];
                            const p0_palm = lm[0];

                            // Observed 3D Palm Span (Index MCP to Pinky MCP) - Absolute Measure
                            const observedPalmSpan = Math.sqrt(
                                (p5.x - p17.x) ** 2 +
                                (p5.y - p17.y) ** 2 +
                                (p5.z - p17.z) ** 2
                            ) || 1e-6;

                            // V20.3: Calculate Palm Orientation / normalZ Early for stabilization
                            const v1_palm = { x: p5.x - p0_palm.x, y: p5.y - p0_palm.y, z: p5.z - p0_palm.z };
                            const v2_palm = { x: p17.x - p0_palm.x, y: p17.y - p0_palm.y, z: p17.z - p0_palm.z };
                            const cross_palm = {
                                x: (v1_palm.y * v2_palm.z - v1_palm.z * v2_palm.y) || 0,
                                y: (v1_palm.z * v2_palm.x - v1_palm.x * v2_palm.z) || 0,
                                z: (v1_palm.x * v2_palm.y - v1_palm.y * v2_palm.x) || 1
                            };
                            const mag_palm = Math.sqrt(cross_palm.x ** 2 + cross_palm.y ** 2 + cross_palm.z ** 2) || 1;
                            const nz = cross_palm.z / mag_palm;
                            const normalZ = Math.abs(nz);
                            const palmConeAngle = Math.acos(Math.min(1.0, normalZ));

                            // V20.3: Harden Rod length with Palm Cone Angle damping to stop longitudinal bouncing
                            if (!systemState.p1.rodFilters[i]) {
                                systemState.p1.rodFilters[i] = new OneEuroFilter(systemState.parameters.physics.oneEuroRodMinCutoff, systemState.parameters.physics.oneEuroBeta);
                            }
                            // Adaptive cutoff: smoother if tilting away (noisy Z)
                            systemState.p1.rodFilters[i].minCutoff = normalZ > 0.7 ?
                                systemState.parameters.physics.oneEuroRodMinCutoff :
                                systemState.parameters.physics.oneEuroRodMinCutoff * 0.5;

                            let baseRodLength;
                            const theme = systemState.parameters.physics.cursorTheme;
                            if (theme === 'LI') {
                                // V20.6: User Tunable Fixed Standoff for Fire (Li) stability
                                baseRodLength = systemState.parameters.physics.directProjectionOffset;
                            } else {
                                baseRodLength = observedPalmSpan * systemState.parameters.anatomy.rodExtensionMultiplier;
                            }
                            const rodLength = systemState.p1.rodFilters[i].filter(baseRodLength);

                            // V19.1: Anchor at Index Tip (8), Project further based on Palm Span
                            const mcp = lm[5];
                            const tipRaw = lm[8];
                            const dx_dir = tipRaw.x - mcp.x;
                            const dy_dir = tipRaw.y - mcp.y;
                            const dz_dir = tipRaw.z - mcp.z;
                            const mag_dir = Math.sqrt(dx_dir ** 2 + dy_dir ** 2 + dz_dir ** 2) || 1e-6;

                            // Projected point starts at Tip (8) and extends rodLength
                            const projectedPoint = {
                                x: tipRaw.x + (dx_dir / mag_dir) * rodLength,
                                y: tipRaw.y + (dy_dir / mag_dir) * rodLength,
                                z: tipRaw.z + (dz_dir / mag_dir) * rodLength
                            };

                            // V19.4: MIRROR AWARENESS (Global Port 1 Flip)
                            const isMirror = systemState.parameters.camera.mirror;

                            // V24.17 Fix: Mirror individual landmarks for shared data fabric parity
                            const mirroredLandmarks = lm.map(l => ({
                                x: isMirror ? (1.0 - l.x) : l.x,
                                y: l.y,
                                z: l.z
                            }));

                            const finalProjX = isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x;
                            const finalTipX = isMirror ? (1.0 - tipRaw.x) : tipRaw.x;

                            // V28: OVERSCAN PROJECTION (UPE Enforced - ALL DRAWING IS BUFFER-RELATIVE)
                            const screenX = systemState.p1.toBufferX(finalProjX);
                            const screenY = systemState.p1.toBufferY(projectedPoint.y);

                            // V18: Standardized cursor raw origin for laser beam/firebase
                            const rawX = systemState.p1.toBufferX(finalTipX);
                            const rawY = systemState.p1.toBufferY(tipRaw.y);

                            // V24.17 Fix: Also mirror the raw anchor point and projected point in 3D
                            const mirroredProjected3D = {
                                x: isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x,
                                y: projectedPoint.y,
                                z: projectedPoint.z
                            };

                            // V19.2: Apply Smoothing to Anchor Point (Tip) to stop jitter
                            if (!systemState.p1.anchorFilters[i]) {
                                systemState.p1.anchorFilters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const anchorX = systemState.p1.anchorFilters[i].x.filter(systemState.p1.toBufferX(finalTipX));
                            const anchorY = systemState.p1.anchorFilters[i].y.filter(systemState.p1.toBufferY(tipRaw.y));

                            // Palm Orientation (Calculated bridger_nx, bridger_ny for telemetry/mirroring)
                            let bridger_nx = cross_palm.x / mag_palm;
                            let bridger_ny = cross_palm.y / mag_palm;

                            // V31.1: Distinct Palm vs Back Detection
                            const isPalmVisible = nz < -systemState.parameters.palm.enterThreshold;
                            const isBackVisible = nz > systemState.parameters.palm.enterThreshold;

                            // V19.5: Mirror the normal X-component to match mirrored coordinate space
                            if (isMirror) {
                                bridger_nx = -bridger_nx;
                            }

                            // Palm Facing Hysteresis (80 Enter, 64 Exit)
                            let isPalmFacing = systemState.p1.palmFacingStates[i];
                            if (!isPalmFacing) {
                                // Omni-Hand Tracking: Still support both for basic awareness
                                if (normalZ > systemState.parameters.palm.enterThreshold) isPalmFacing = true;
                            } else {
                                if (normalZ < systemState.parameters.palm.exitThreshold) isPalmFacing = false;
                            }
                            systemState.p1.palmFacingStates[i] = isPalmFacing;

                            let category = bestGesture?.categoryName || 'None';
                            let confidence = bestGesture?.score || 0;

                            // GEN6 v9: Deterministic replay overrides (no camera required).
                            // If present, callers can supply synthetic hand intent signals per-frame.
                            const replayHand = results?.__hfoReplayHands?.[i] || null;
                            if (replayHand) {
                                if (typeof replayHand.categoryName === 'string') category = replayHand.categoryName;
                                if (typeof replayHand.confidence === 'number' && Number.isFinite(replayHand.confidence)) confidence = replayHand.confidence;
                            }

                            // Apply 1EuroFilter (Always applied for landmark jitter)
                            if (!systemState.p1.filters[i]) {
                                systemState.p1.filters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const smoothedX = systemState.p1.filters[i].x.filter(screenX);
                            const smoothedY = systemState.p1.filters[i].y.filter(screenY);

                            // V31.1: FSM Triggers using Emoji Language Logic
                            const fsmState = systemState.p1.fsmStates[i];
                            let isPointing = (category === 'Pointing_Up' && confidence > systemState.parameters.gestures.minGestureConfidence);
                            let hasConfidence = (confidence > systemState.parameters.coasting.confidenceThreshold);

                            let isFacingCamera = isPalmVisible || isBackVisible;
                            if (isFacingCamera) systemState.p1.lastPalmFacingTimes[i] = now;
                            let isCharging = isFacingCamera || (now - systemState.p1.lastPalmFacingTimes[i] < systemState.parameters.fsm.tensionMs);
                            const isCoasting = (fsmState === 'COAST');
                            let shouldFill = isCharging && hasConfidence;

                            if (replayHand) {
                                if (typeof replayHand.isPointing === 'boolean') isPointing = replayHand.isPointing;
                                if (typeof replayHand.hasConfidence === 'boolean') hasConfidence = replayHand.hasConfidence;
                                if (typeof replayHand.isFacingCamera === 'boolean') {
                                    isFacingCamera = replayHand.isFacingCamera;
                                    if (isFacingCamera) systemState.p1.lastPalmFacingTimes[i] = now;
                                }
                                if (typeof replayHand.isCharging === 'boolean') isCharging = replayHand.isCharging;
                                if (typeof replayHand.shouldFill === 'boolean') shouldFill = replayHand.shouldFill;
                            }

                            // GEN6 v16.1: COAST is a low-confidence sink.
                            // It must never fill readiness; COAST only drains readiness until it decays to IDLE.
                            if (isCoasting) shouldFill = false;

                            // Readiness Energy: intent pre-arm for gestures/effects.
                            // Fill when palm/back faces camera, drain when faced away or in COAST.
                            if (shouldFill) {
                                const fillAmount = (1 / systemState.parameters.fsm.chargeTimeMs) * dt;
                                const fillScaled = fillAmount * systemState.parameters.readiness.fillMultiplier;
                                systemState.p1.readinessScores[i] = Math.min(1, systemState.p1.readinessScores[i] + fillScaled);
                            } else {
                                const drainTime = isCoasting
                                    ? systemState.parameters.fsm.coastDrainTimeMs
                                    : systemState.parameters.fsm.releaseTimeMs;
                                const drainAmount = (1 / drainTime) * dt;
                                const coastScale = isCoasting
                                    ? systemState.parameters.readiness.coastDrainMultiplier
                                    : 1.0;
                                const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * coastScale;
                                systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainScaled);
                            }

                            let fsmStateNew = fsmState;
                            const readiness = systemState.p1.readinessScores[i];

                            // GEN6 v11: P2 Mirror Magus owns FSM transition semantics (adapter layer).
                            let p2FsmReason = null;
                            try {
                                const p2Res = window.hfoP2MirrorMagus?.computeSovereignFsmNext?.({
                                    fsmState,
                                    readiness,
                                    isFacingCamera,
                                    isCharging,
                                    hasConfidence,
                                    isPointing,
                                    handIndex: i,
                                    primaryHandIndex: systemState.fsm.primaryHandIndex,
                                    hysteresisHigh: systemState.parameters.fsm.hysteresisHigh,
                                    hysteresisLow: systemState.parameters.fsm.hysteresisLow
                                });
                                if (p2Res && typeof p2Res.nextState === 'string') {
                                    fsmStateNew = p2Res.nextState;
                                    if (p2Res.nextPrimary === null || typeof p2Res.nextPrimary === 'number') {
                                        systemState.fsm.primaryHandIndex = p2Res.nextPrimary;
                                    }
                                    p2FsmReason = p2Res.reason || null;
                                }
                            } catch (_) {
                                // ignore
                            }

                            // GEN6 v16.1 fail-closed: COAST must never transition into READY/COMMIT.
                            // Allowed exits: remain COAST or decay to IDLE.
                            if (fsmState === 'COAST') {
                                if (fsmStateNew === 'READY' || fsmStateNew === 'COMMIT') {
                                    fsmStateNew = 'COAST';
                                    p2FsmReason = 'coast_fail_closed_no_arm';
                                }
                            }

                            if (fsmStateNew !== fsmState) {
                                try {
                                    window.hfoPortsEffects?.emit?.('p2', 'fsm_transition', {
                                        handIndex: i,
                                        from: fsmState,
                                        to: fsmStateNew,
                                        readiness,
                                        reason: p2FsmReason
                                    });
                                } catch (_) {
                                    // ignore
                                }
                            }
                            systemState.p1.fsmStates[i] = fsmStateNew;

                            // GEN6 v11: Dino Runner trigger is an adapter under P2 (still delivered by AdapterHost / P3).
                            // Do not change readiness math: reuse IDLEâ†’READY edge as the action trigger.
                            try {
                                if (isFlagEnabled('p3-dino-ready-edge')) {
                                    const last = systemState.fsm.lastReadyTriggerTimes?.[i] || 0;
                                    const cooldown = systemState.fsm.readyTriggerCooldownMs || 350;
                                    const trigger = window.hfoP2MirrorMagus?.shouldTriggerDinoOnReadyEdge?.({
                                        from: fsmState,
                                        to: fsmStateNew,
                                        now,
                                        last,
                                        cooldownMs: cooldown
                                    });

                                    if (trigger?.ok) {
                                        if (systemState.fsm.lastReadyTriggerTimes) systemState.fsm.lastReadyTriggerTimes[i] = now;
                                        const payload = window.hfoP2MirrorMagus?.buildDinoNematocystPayload?.({ handIndex: i, readiness }) || {
                                            kind: 'keyboard',
                                            action: 'keypress',
                                            key: ' ',
                                            code: 'Space',
                                            handIndex: i,
                                            reason: 'fsm_idle_to_ready'
                                        };

                                        try {
                                            window.hfoPortsEffects?.emit?.('p2', 'dino_ready_edge', {
                                                from: fsmState,
                                                to: fsmStateNew,
                                                handIndex: i,
                                                readiness,
                                                cooldownMs: cooldown,
                                                reason: payload.reason
                                            });
                                        } catch (_) {
                                            // ignore
                                        }

                                        try {
                                            window.hfoPortsEffects?.emit?.('p1', 'fsm_edge', {
                                                from: fsmState,
                                                to: fsmStateNew,
                                                handIndex: i,
                                                readiness,
                                                cooldownMs: cooldown,
                                                reason: payload.reason
                                            });
                                        } catch (_) {
                                            // ignore
                                        }

                                        let delivered = false;
                                        try {
                                            delivered = !!window.hfoAdapterHost?.deliverEffect?.('dino-v1', payload);
                                        } catch (_) {
                                            delivered = false;
                                        }

                                        try {
                                            window.hfoPortsEffects?.emit?.('p3', 'nematocyst_deliver', {
                                                adapterId: 'dino-v1',
                                                ok: delivered,
                                                via: delivered ? 'adapter_host' : 'fallback_p3',
                                                payload: { kind: payload.kind, action: payload.action, key: payload.key, code: payload.code },
                                                handIndex: i,
                                                reason: payload.reason
                                            });
                                        } catch (_) {
                                            // ignore
                                        }

                                        if (!delivered) {
                                            try {
                                                P3InjectorPort?.sendNematocystToDino?.(payload);
                                            } catch (_) {
                                                // ignore
                                            }
                                        }
                                    } else if (trigger?.reason === 'cooldown_suppressed') {
                                        try {
                                            window.hfoPortsEffects?.emit?.('p1', 'cooldown_suppressed', {
                                                handIndex: i,
                                                cooldownMs: trigger.cooldownMs || cooldown,
                                                sinceLastMs: trigger.sinceLastMs || (now - last),
                                                reason: 'fsm_idle_to_ready'
                                            });
                                        } catch (_) {
                                            // ignore
                                        }
                                    }
                                }
                            } catch (_) {
                                // ignore
                            }

                            let finalX, finalY;
                            const forceDirect = systemState.parameters.physics.useDirectProjection;

                            if (systemState.parameters.physics.mode === 'STATIC_ROD' || forceDirect) {
                                finalX = smoothedX;
                                finalY = smoothedY;
                            } else {
                                // PLANCK_SPRING Mode
                                if (isFlagEnabled('physics-planck') && !(systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter)) {
                                    systemState.p1.physicsState[i] = new PlanckPhysicsAdapter(
                                        systemState.parameters.physics.planckStiffness,
                                        systemState.parameters.physics.planckDamping
                                    );
                                    systemState.p1.physicsState[i].reset(smoothedX, smoothedY);
                                }

                                let physicsPos = { x: smoothedX, y: smoothedY };
                                if (systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter) {
                                    systemState.p1.physicsState[i].setBallistic(fsmStateNew === 'COAST');
                                    systemState.p1.physicsState[i].setParams({
                                        stiffness: systemState.parameters.physics.planckStiffness,
                                        dampingRatio: systemState.parameters.physics.planckDamping
                                    });
                                    physicsPos = systemState.p1.physicsState[i].update(smoothedX, smoothedY, dt);
                                }

                                // V19.2: CLAW RIGID PROJECTION
                                const dx = smoothedX - anchorX;
                                const dy = smoothedY - anchorY;
                                const mag = Math.sqrt(dx * dx + dy * dy) || 1e-6;
                                let ux = dx / mag;
                                let uy = dy / mag;

                                if (!systemState.p1.directionFilters[i]) {
                                    systemState.p1.directionFilters[i] = {
                                        x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                        y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                    };
                                }
                                ux = systemState.p1.directionFilters[i].x.filter(ux);
                                uy = systemState.p1.directionFilters[i].y.filter(uy);
                                const mag_filtered = Math.sqrt(ux * ux + uy * uy) || 1e-6;
                                ux /= mag_filtered; uy /= mag_filtered;

                                const vx = physicsPos.x - anchorX;
                                const vy = physicsPos.y - anchorY;
                                const d_proj = vx * ux + vy * uy;

                                finalX = anchorX + ux * d_proj;
                                finalY = anchorY + uy * d_proj;
                            }

                            const curls = {
                                index: this.calculateCurl(lm, [5, 6, 7, 8]),
                                middle: this.calculateCurl(lm, [9, 10, 11, 12]),
                                ring: this.calculateCurl(lm, [13, 14, 15, 16]),
                                pinky: this.calculateCurl(lm, [17, 18, 19, 20])
                            };

                            const rawCursorData = {
                                screenX: finalX, screenY: finalY,
                                normX: finalX / width, normY: finalY / height,
                                uiNormX: finalX / width, // V28.5: Hardened 1:1 Parity
                                uiNormY: finalY / height, // V28.5: Hardened 1:1 Parity
                                normZ: projectedPoint.z,
                                fsmState: fsmStateNew, gesture: category,
                                confidence, isPalmFacing, readinessScore: readiness,
                                skeletonAlpha: dormancyAlpha, // V26: Fades on stillness
                                handIndex: i, pointerId: 10 + i, // V24.4: Stable Hand ID
                                curls,
                                landmarks: mirroredLandmarks, // Fixed: Mirrored landmarks
                                rawX: anchorX, rawY: anchorY,
                                normalZ: normalZ,
                                palmConeAngle: palmConeAngle,
                                palmNormal: { x: bridger_nx, y: bridger_ny, z: nz },
                                timestamp: now
                            };

                            cursorData = FusionSchema.parse(rawCursorData);
                            systemState.p1.lastData[i] = cursorData;
                        } catch (e) {
                            console.error("ðŸš¨ P1_FUSE_CONTRACT_BREACH:", e);
                        }
                    } else {
                        // Coasting Logic for missing landmarks (V24.3: Ballistic Inertia)
                        const last = systemState.p1.lastData[i];
                        const fsmState = systemState.p1.fsmStates[i];
                        const fadeTime = systemState.parameters.landmarks.skeletonFadeTimeMs || 400;

                        if (last && fsmState !== 'IDLE') {
                            const isCoasting = (fsmState === 'COAST' || fsmState === 'COMMIT');
                            const drainTime = systemState.parameters.fsm.coastDrainTimeMs;
                            const drainAmount = (1 / drainTime) * dt;
                            const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * systemState.parameters.readiness.coastDrainMultiplier;
                            systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainScaled);

                            const readiness = systemState.p1.readinessScores[i];
                            const tTrackingLost = now - (systemState.p1.lastTrackingTimes[i] || now);

                            if (readiness > systemState.parameters.fsm.hysteresisLow) {
                                // Update Physics in Ballistic mode to get inertial position
                                let coastPos = { x: last.screenX, y: last.screenY };
                                const adapter = systemState.p1.physicsState[i];
                                if (adapter instanceof PlanckPhysicsAdapter) {
                                    adapter.setBallistic(true);
                                    coastPos = adapter.update(last.screenX, last.screenY, dt);
                                }

                                cursorData = FusionSchema.parse({
                                    ...last,
                                    screenX: coastPos.x,
                                    screenY: coastPos.y,
                                    uiNormX: coastPos.x / (systemState.p0.videoBounds?.width || 1280), // V28.5 Recalculate UI Norms
                                    uiNormY: coastPos.y / (systemState.p0.videoBounds?.height || 720), // V28.5 Recalculate UI Norms
                                    fsmState: 'COAST',
                                    readinessScore: readiness,
                                    skeletonAlpha: Math.max(0, 1.0 - (tTrackingLost / fadeTime)), // V26: Dedicated tracking loss fade
                                    handIndex: i,
                                    landmarks: last.landmarks || [], // V24.22: Keep landmarks for fading
                                    timestamp: now
                                });
                                systemState.p1.fsmStates[i] = 'COAST';
                            } else {
                                // Terminal Drain reached: emit one IDLE frame to ensure pointerup before drop
                                cursorData = FusionSchema.parse({
                                    ...last,
                                    fsmState: 'IDLE',
                                    readinessScore: readiness,
                                    skeletonAlpha: 0,
                                    handIndex: i,
                                    landmarks: last.landmarks || [],
                                    timestamp: now,
                                    uiNormX: last.screenX / (systemState.p0.videoBounds?.width || 1280),
                                    uiNormY: last.screenY / (systemState.p0.videoBounds?.height || 720)
                                });
                                systemState.p1.lastData[i] = null;
                                systemState.p1.fsmStates[i] = 'IDLE';
                                if (systemState.fsm.primaryHandIndex === i) systemState.fsm.primaryHandIndex = null;
                            }
                        }
                    }

                    if (cursorData) {
                        const validated = FusionSchema.parse({ ...cursorData, timestamp: now });
                        cursors.push(validated);
                    }
                }

                // V24.7: MULTI-READY / SINGLE-COMMIT (HOT SEAT V2)
                // Return ALL active cursors for visual feedback.
                const primary = systemState.fsm.primaryHandIndex;
                const primaryHand = cursors.find(c => c.handIndex === primary);

                if (primaryHand) {
                    systemState.fsm.currentState = primaryHand.fsmState;
                } else if (cursors.length > 0) {
                    const states = cursors.map(c => c.fsmState);
                    if (states.includes('COMMIT')) systemState.fsm.currentState = 'COMMIT';
                    else if (states.includes('COAST')) systemState.fsm.currentState = 'COAST';
                    else if (states.includes('READY')) systemState.fsm.currentState = 'READY';
                    else systemState.fsm.currentState = 'IDLE';
                } else {
                    systemState.fsm.currentState = 'IDLE';
                }

                // ðŸŒ UPDATE DATA FABRIC
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });

                return cursors;
            }
        }

        // v23.6: allow URL params to override kiosk defaults
        try {
            systemState.parameters.essentialsMode = kioskMode;
            systemState.parameters.devMode = !kioskMode;
        } catch { }

        // Expose to window for hardened testing [V24.3]
        window.systemState = systemState;
        window.PlanckPhysicsAdapter = PlanckPhysicsAdapter;
        window.P1Bridger = P1Bridger;
        window.drawResults = drawResults;

        // --- GEN6 v17.4: Microkernel UI Shell (minimal shim + deterministic test hooks) ---
        // Goal: provide a stable shell seam (services + tokens) without increasing coupling.
        (function initHfoUiShellV17() {
            try {
                if (typeof isFlagEnabled !== 'function') return;
                if (!isFlagEnabled('ui-microkernel')) return;
                if (window.hfoUiShell || window.HFOUiShell || window.__hfoUiShell) return;

                const STATE_COLOR_TOKENS = Object.freeze({
                    IDLE: Object.freeze({ name: 'gray', hex: '#8E8E93' }),
                    READY: Object.freeze({ name: 'amber', hex: '#FFB300' }),
                    COMMIT: Object.freeze({ name: 'cyan', hex: '#00BCD4' }),
                    COAST: Object.freeze({ name: 'yellow', hex: '#FFEB3B' })
                });

                // GUI registry (testable, non-DOM).
                let advancedEnabled = false;
                const listFolders = () => {
                    const out = [];
                    if (isFlagEnabled('ui-lil-gui')) out.push('Baseline');
                    if (advancedEnabled) out.push('Advanced');
                    return out;
                };

                const shell = Object.freeze({
                    version: 17,
                    services: Object.freeze({
                        events: Object.freeze({
                            subscribe: (handler) => {
                                if (typeof window.hfoPortsEffects?.subscribe === 'function') {
                                    return window.hfoPortsEffects.subscribe(handler);
                                }
                                return () => { };
                            },
                            publishCommand: (_command) => Object.freeze({ ok: false, reason: 'not_implemented' })
                        }),
                        theming: Object.freeze({
                            tokens: Object.freeze({
                                state_colors: Object.freeze({
                                    requirement: 'Global state color mapping (v17 spec).',
                                    mapping: STATE_COLOR_TOKENS
                                })
                            })
                        }),
                        gui: Object.freeze({
                            listFolders
                        })
                    })
                });

                window.hfoUiShell = shell;
                window.__hfoUiShell = shell;
                window.HFOUiShell = shell;

                // Opt-in deterministic test hooks (deny-by-default).
                if (isFlagEnabled('ui-test-plugin')) {
                    const counters = {
                        mountCount: 0,
                        disposeCount: 0,
                        activeSubscriptions: 0,
                        activeIntervals: 0,
                        onShowCount: 0,
                        onHideCount: 0,
                        onResizeCount: 0
                    };

                    let testPluginEnabled = false;
                    let off = null;
                    let intervalId = null;

                    const enableTestPlugin = () => {
                        if (testPluginEnabled) return;
                        testPluginEnabled = true;
                        counters.mountCount++;

                        if (typeof window.hfoPortsEffects?.subscribe === 'function') {
                            off = window.hfoPortsEffects.subscribe((_e) => { });
                            counters.activeSubscriptions = 1;
                        } else {
                            off = null;
                            counters.activeSubscriptions = 0;
                        }

                        intervalId = window.setInterval(() => { }, 1000);
                        counters.activeIntervals = 1;
                    };

                    const disableTestPlugin = () => {
                        if (!testPluginEnabled) return;
                        testPluginEnabled = false;
                        counters.disposeCount++;

                        if (typeof off === 'function') {
                            try { off(); } catch (_) { }
                        }
                        off = null;
                        counters.activeSubscriptions = 0;

                        if (intervalId != null) {
                            try { window.clearInterval(intervalId); } catch (_) { }
                        }
                        intervalId = null;
                        counters.activeIntervals = 0;
                    };

                    const enableTestPanel = () => {
                        // No-op panel shim; counters are driven by simulation helpers.
                        return true;
                    };
                    const simulateTabSwitch = () => {
                        counters.onHideCount++;
                        counters.onShowCount++;
                    };
                    const simulateResize = () => {
                        counters.onResizeCount++;
                    };

                    const enableAdvancedGui = (enable) => {
                        advancedEnabled = Boolean(enable);
                    };

                    window.__hfoUiShellTest = Object.freeze({
                        counters,
                        enableTestPlugin,
                        disableTestPlugin,
                        enableTestPanel,
                        simulateTabSwitch,
                        simulateResize,
                        enableAdvancedGui
                    });
                }
            } catch (_) {
                // Fail-soft: UI shell should never crash the core runtime.
            }
        })();

        // GEN6 v5: Substrate Registry (substrate-agnostic adapter intake)
        // Additive + fail-soft: legacy systemState keys remain authoritative for now.
        (function initHfoSubstrateRegistry() {
            if (window.hfoSubstrateRegistry) return;

            const _entries = new Map();
            const _byRef = new WeakMap();
            let _seq = 1;

            const _normRole = (role) => (typeof role === 'string' ? role.trim() : '');

            const register = ({ role, kind = 'dom', el = null, instance = null, meta = null } = {}) => {
                const r = _normRole(role);
                const ref = el || instance;
                if (!r || !ref) return null;

                let id = _byRef.get(ref);
                if (!id) {
                    id = `sr:${_seq++}`;
                    _byRef.set(ref, id);
                }

                const rec = {
                    id,
                    role: r,
                    kind,
                    el: el || null,
                    instance: instance || null,
                    meta: meta || {},
                    ts: Date.now()
                };
                _entries.set(id, rec);
                return rec;
            };

            const unregister = (ref) => {
                if (!ref) return false;
                const id = _byRef.get(ref);
                if (id) {
                    _entries.delete(id);
                    _byRef.delete(ref);
                    return true;
                }
                // Fallback: scan for legacy refs
                for (const [k, v] of _entries.entries()) {
                    if (v?.el === ref || v?.instance === ref) {
                        _entries.delete(k);
                        return true;
                    }
                }
                return false;
            };

            const listAll = () => Array.from(_entries.values());
            const listByRole = (role) => {
                const r = _normRole(role);
                if (!r) return [];
                return listAll().filter(e => e.role === r);
            };
            const getFirst = (role) => listByRole(role)[0] || null;

            const getPhysicalSubstrateElements = () => {
                const roles = new Set([
                    'physical:overlay-canvas',
                    'physical:juice-canvas',
                    'physical:touch2d',
                    'physical:app-overlay'
                ]);

                const out = [];
                const seen = new Set();
                const addEl = (el) => {
                    if (!el || typeof el !== 'object') return;
                    if (seen.has(el)) return;
                    seen.add(el);
                    out.push(el);
                };

                listAll().forEach((rec) => {
                    if (!rec || !roles.has(rec.role)) return;
                    if (rec.el) return addEl(rec.el);
                    const candidate = rec.instance?.canvas || rec.instance?.el || null;
                    if (candidate) addEl(candidate);
                });

                return out;
            };

            window.hfoSubstrateRegistry = Object.freeze({
                register,
                unregister,
                listAll,
                listByRole,
                getFirst,
                getPhysicalSubstrateElements
            });
        })();

        // --- P0: SENSE ---
        async function initP0() {
            logMission("P0: Initializing V7 Laser Cluster...");
            const vision = await FilesetResolver.forVisionTasks("./lib/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "./lib/models/gesture_recognizer.task",
                    delegate: 'GPU'
                },
                runningMode: "VIDEO",
                numHands: systemState.parameters.landmarks.numHands
            });
            logMission("âœ… P0: Sensing Cluster Online");
        }

        /**
         * ðŸ“– V30 TACTICAL TUTORIAL SYSTEM
         * Enforces User flow: IDLE -> READY (Palm) -> COMMIT (Gesture) -> IDLE
         */
        class TutorialSystem {
            constructor() {
                this.isCompleted = false;
                this.completionTimer = null;
                this.stepTimer = null;
                this.lastActiveStepId = null;
                this.completedPhases = new Set();
                this.steps = {
                    'READY': {
                        header: 'Phase 1: READY ðŸ–ï¸ âž¡ ðŸ”¥',
                        body: 'Welcome Initiate! Show your <span class="tutorial-highlight">Palm Towards</span> the camera to ignite the <span class="tutorial-highlight">READY - Amber Phoenix Core</span>.'
                    },
                    'COMMIT': {
                        header: 'Phase 2: COMMIT â˜ï¸ âž¡ â˜„ï¸',
                        body: 'Excellent! Now <span class="tutorial-highlight">Point your Index Finger Up</span> to focus the core into the <span class="tutorial-highlight">COMMIT - Cyan Phoenix Core</span>.'
                    },
                    'RELEASE_IDLE': {
                        header: 'Phase 3: RELEASE ðŸ«· âž¡ ðŸš«',
                        body: 'Safety first. Turn your hand away (<span class="tutorial-highlight">Side Profile</span>) to extinguish the flame.'
                    },
                    'SETTINGS': {
                        header: 'Phase 4: SETTINGS âš™ï¸ âž¡ ðŸ“ˆ',
                        body: 'Navigator access granted. <span class="tutorial-highlight">Release to interact</span> with the UI, then use the panels to tune parameters. This tutorial will self-destruct in 8s.'
                    }
                };
                this.isVisible = false;
                this.settingsStart = null;
            }

            reset() {
                this.isCompleted = false;
                this.lastActiveStepId = null;
                this.completedPhases.clear();
                this.settingsStart = null;
                if (this.completionTimer) clearTimeout(this.completionTimer);
                if (this.stepTimer) clearTimeout(this.stepTimer);

                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.opacity = '1';
                    systemState.ui.tutorial.style.display = 'block';
                    systemState.ui.tutProgress.style.display = 'none';
                }
                this.isVisible = true;
                logMission("Tutorial Reset.");
            }

            show() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'block';
                    this.isVisible = true;
                }
            }

            hide() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'none';
                    this.isVisible = false;
                }
            }

            update(cursors) {
                if (!systemState.parameters.ui.showTutorial || this.isCompleted) {
                    if (this.isVisible) this.hide();
                    return;
                }

                const now = performance.now();

                // Strictly sequential stateId (one-way progression)
                let stateId = this.lastActiveStepId || 'READY';

                if (cursors.length > 0) {
                    const primary = cursors[0];
                    const fsm = primary.fsmState;

                    // Progression triggers
                    if (stateId === 'READY' && fsm === 'READY') {
                        stateId = 'COMMIT';
                        this.completedPhases.add('READY');
                    }
                    else if (stateId === 'COMMIT' && fsm === 'COMMIT') {
                        stateId = 'RELEASE_IDLE';
                        this.completedPhases.add('COMMIT');
                    }
                    else if (stateId === 'RELEASE_IDLE' && (fsm === 'IDLE' || fsm === 'COAST')) {
                        // RELEASE phase triggers when user drops to IDLE or COAST from COMMIT
                        stateId = 'SETTINGS';
                        this.completedPhases.add('RELEASE_IDLE');
                        this.settingsStart = now;
                    }
                }

                if (stateId === 'SETTINGS') {
                    if (this.settingsStart) {
                        const elapsed = now - this.settingsStart;
                        const duration = 8000;
                        const progress = Math.min(100, (elapsed / duration) * 100);

                        systemState.ui.tutProgress.style.display = 'block';
                        systemState.ui.tutProgressBar.style.width = `${progress}%`;

                        if (elapsed >= duration && !this.isCompleted) {
                            this.isCompleted = true;
                            this.hide();
                            logMission("Tutorial Sequence Complete.");
                        }
                    }
                }

                if (stateId !== this.lastActiveStepId) {
                    this.lastActiveStepId = stateId;
                    const step = this.steps[stateId];

                    if (step) {
                        systemState.ui.tutHeader.innerText = step.header;
                        systemState.ui.tutBody.innerHTML = step.body;

                        this.show();
                        systemState.ui.tutorial.style.opacity = '1';

                        systemState.ui.tutorial.classList.remove('tutorial-step-active');
                        void systemState.ui.tutorial.offsetWidth;
                        systemState.ui.tutorial.classList.add('tutorial-step-active');

                        if (this.stepTimer) clearTimeout(this.stepTimer);
                        this.stepTimer = setTimeout(() => {
                            if (this.lastActiveStepId === stateId && stateId !== 'SETTINGS') {
                                systemState.ui.tutorial.style.opacity = '0.4';
                            }
                        }, 5000);
                    }
                }
            }
        }
        window.hfoTutorial = new TutorialSystem();

        let lastFrameTime = performance.now();
        window.__hfoReplayKeepAlive = window.__hfoReplayKeepAlive || false;
        window.__hfoReplayPredictLoopFrames = window.__hfoReplayPredictLoopFrames || 0;
        window.__hfoReplayPredictLoopLastDt = window.__hfoReplayPredictLoopLastDt || 0;
        window.__hfoPredictLoopRunning = window.__hfoPredictLoopRunning || false;

        function predictLoop() {
            window.__hfoPredictLoopRunning = true;
            if (!systemState.parameters.p0Active) {
                if (window.__hfoReplayKeepAlive) {
                    requestAnimationFrame(predictLoop);
                    return;
                }
                window.__hfoPredictLoopRunning = false;
                return;
            }
            const now = performance.now();
            let dt = now - lastFrameTime;
            lastFrameTime = now;

            // V40.1: Clamp dt to prevent physical "time jumps" from bypassing Leaky Bucket logic.
            // In deterministic replay/mock mode, allow a higher dt ceiling so low-FPS test runs
            // still advance readiness/FSM within wall-clock step durations.
            const dtMax = (window.__hfoReplayKeepAlive || window.hfoMockResults || (window.hfoMockPlayer && window.hfoMockPlayer.isPlaying))
                ? 500
                : 100;
            dt = Math.max(0, Math.min(dtMax, dt));

            try {
                window.__hfoReplayPredictLoopFrames = (window.__hfoReplayPredictLoopFrames || 0) + 1;
                window.__hfoReplayPredictLoopLastDt = dt;
            } catch (_) {
                // ignore
            }

            let results = null; // HOISTED: Ensure results exists in all branches

            // V24.6: Telemetry Replay Logic (Golden Master)
            if (window.hfoPlayer.isPlaying) {
                const frame = window.hfoPlayer.getNextFrame();
                if (frame && frame.phase === 'P1_FUSE') {
                    try {
                        systemState.dataFabric = DataFabricSchema.parse(frame.data);
                        systemState.p1.cursors = systemState.dataFabric.cursors;
                    } catch (e) {
                        console.error("REPLAY CONTRACT BREACH:", e);
                    }
                    // Continue to rendering/tutorial/injection
                }
            } else {
                // ðŸ’‰ P4: INJECTION HOOK (For E2E/Stress Testing)
                if (window.hfoMockPlayer && window.hfoMockPlayer.isPlaying) {
                    results = window.hfoMockPlayer.nextResults();
                }
                if (!results && window.hfoMockResults) {
                    results = window.hfoMockResults;
                }
                if (!results) {
                    if (systemState.p0.recognizer && systemState.p0.video) {
                        results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
                    } else {
                        requestAnimationFrame(predictLoop);
                        return;
                    }
                }

                // P1 BRIDGE: Fusing sensing to coordinates under contract
                // Optional hex path: allow the Port Facade to own the fabric shape.
                if (isFlagEnabled('p1-ports') && window.hfoPorts?.p1?.weave) {
                    window.hfoPorts.p1.weave(results, dt, now);
                } else {
                    const cursors = P1Bridger.fuse(results, dt);

                    // V19.4: VALIDATED SHARED DATA FABRIC ENFORCEMENT
                    try {
                        systemState.dataFabric = DataFabricSchema.parse({
                            cursors: cursors,
                            systemTime: now,
                            frameId: (systemState.dataFabric.frameId || 0) + 1
                        });
                        // Maintain legacy pointer for back-compat with existing FSM logic
                        systemState.p1.cursors = systemState.dataFabric.cursors;

                        // V24.5 Telemetry Recording
                        window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
                    } catch (e) {
                        console.error("PORT 1 CONTRACT BREACH:", e);
                        // Fail-safe to last known good or empty
                    }
                }
            }

            // ðŸ“Š P5: State Transparency (For E2E Testing)
            window.hfoState = {
                hands: systemState.dataFabric.cursors,
                parameters: systemState.parameters,
                fsm: systemState.fsm,
                lineage: 'SHARED_DATA_FABRIC_V19.5'
            };

            // V19.5: Unified Draw Call (Only skeleton receives raw results for ISR overlay)
            // V24.10: Substrate Gating (Prevent visual muddiness when Babylon is active)
            if (isFlagEnabled('engine-canvas')) {
                drawResults(results, systemState.dataFabric);
            }

            if (isFlagEnabled('ui-lil-gui')) {
                updateVisualPanels(results);
            }

            // --- P2 Gesture Language hook (FSMâ†’P3 payload experimentation) ---
            // Runs after P1 fabric is updated, before Port3 injection.
            try {
                window.hfoP2GestureLanguage?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
            } catch (_) {
                // ignore
            }

            // --- P2 Knuckle Keybar Thread hook (v18; deny-by-default) ---
            try {
                window.hfoP2KnuckleKeybarThread?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
            } catch (_) {
                // ignore
            }

            // --- P2 Fail-Closed COAST Governor (low-confidence â†’ COAST) ---
            // Runs after P1 fabric is updated, before other P2/P3 effect ports.
            try {
                window.hfoP2CoastGovernor?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
            } catch (_) {
                // ignore
            }

            // --- P2 Tripwire Thread hook (Planck sensor-band; COMMIT gated) ---
            // Runs after P1 fabric is updated, before Port3 injection.
            try {
                if (isFlagEnabled('p2-tripwire-static')) {
                    window.hfoP2TripwireThread?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
                }
            } catch (_) {
                // ignore
            }

            // --- P2 Knuckle Tripwire Thread hook (v19; hand-anchored; shared primitive) ---
            // Runs after P1 fabric is updated, before Port3 injection.
            try {
                if (isFlagEnabled('p2-tripwire-knuckle')) {
                    window.hfoP2KnuckleTripwireThread?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
                }
            } catch (_) {
                // ignore
            }

            // --- GEN6 v23: P2 Commit Variants Thread hook ---
            try {
                window.hfoP2CommitVariantsThread?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
            } catch (_) {
                // ignore
            }

            // --- GEN6 v23: P2 Sword Meter Thread hook (READY + Thumb_Up/Thumb_Down leaky bucket) ---
            // Runs after P1 fabric is updated, before P3 injection.
            try {
                if (isFlagEnabled('p2-sword-meter')) {
                    window.hfoP2SwordMeterThread?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
                }
            } catch (_) {
                // ignore
            }

            // --- GEN6 v23.2: sword debug HUD (manual camera tuning) ---
            try {
                if (isFlagEnabled('p2-sword-debug-hud')) {
                    window.hfoSwordDebugHudUpdate?.(systemState);
                }
            } catch (_) {
                // ignore
            }

            // --- P3 Planck Sensor Injector tick (deadman + lookahead scheduler) ---
            // Note: injection-on-cross is handled by subscription; tick drives scheduled pre-arm injections.
            try {
                window.hfoP3PlanckSensorInjector?.tick?.({ now, dt, dataFabric: systemState.dataFabric });
            } catch (_) {
                // ignore
            }

            // NOTE: fail-closed COAST logic is handled by a P2 governor (low-confidence â†’ COAST)
            // so downstream ports see COAST and naturally suppress COMMIT-only effects.

            if (isFlagEnabled('p3-injector')) {
                w3cPointerNematocystInjector(); // V20.1: Rebranded Hydra Port
            }

            // ðŸ“– V30 Tutorial Update
            window.hfoTutorial.update(systemState.dataFabric.cursors);

            // BABYLON ENGINE (Standardized V28+)
            systemState.ui.juiceLayers.forEach(layer => {
                if (layer instanceof BabylonJuiceSubstrate) {
                    layer.canvas.style.display = 'block';
                    layer.update(systemState.dataFabric.cursors);
                }
            });

            requestAnimationFrame(predictLoop);
        }

        // --- GEN5: Mock replay start (no camera required) ---
        window.hfoStartMockReplay = () => {
            systemState.parameters.p0Active = true;
            window.__hfoReplayKeepAlive = true;
            if (!systemState.p0.videoBounds || !systemState.p0.videoBounds.width) {
                systemState.p0.videoBounds = { width: 1280, height: 720 };
            }
            lastFrameTime = performance.now();
            if (window.__hfoPredictLoopRunning) return;
            requestAnimationFrame(predictLoop);
        };

        // --- GEN5: Eval harness helpers (readiness drain / diagnostics) ---
        window.hfoEval = {
            getReadinessScores: () => [...systemState.p1.readinessScores],
            setReadinessScore: (handIndex, value) => {
                systemState.p1.readinessScores[handIndex] = Math.max(0, Math.min(1, value));
                return systemState.p1.readinessScores[handIndex];
            },
            setReadinessParams: (params) => {
                systemState.parameters.readiness = { ...systemState.parameters.readiness, ...params };
                return { ...systemState.parameters.readiness };
            },
            fillReadiness: (handIndex, dt) => {
                const fillAmount = (1 / systemState.parameters.fsm.chargeTimeMs) * dt;
                const fillScaled = fillAmount * systemState.parameters.readiness.fillMultiplier;
                systemState.p1.readinessScores[handIndex] = Math.min(1, systemState.p1.readinessScores[handIndex] + fillScaled);
                return systemState.p1.readinessScores[handIndex];
            },
            drainReadiness: (handIndex, dt, useCoast = true) => {
                const drainTime = useCoast
                    ? systemState.parameters.fsm.coastDrainTimeMs
                    : systemState.parameters.fsm.releaseTimeMs;
                const drainAmount = (1 / drainTime) * dt;
                const coastScale = useCoast ? systemState.parameters.readiness.coastDrainMultiplier : 1.0;
                const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * coastScale;
                systemState.p1.readinessScores[handIndex] = Math.max(0, systemState.p1.readinessScores[handIndex] - drainScaled);
                return systemState.p1.readinessScores[handIndex];
            }
        };

        // --- GEN6 v9: Dino Readiness Replay Harness (Golden Sequences) ---
        // Purpose: deterministically drive palm-towards (fill) then palm-away (drain) sequences and
        // capture end-to-end telemetry (FSM edge â†’ nematocyst deliver â†’ dino queue/flush/postMessage).
        window.hfoReplay = window.hfoReplay || (() => {
            const sleep = (ms) => new Promise((r) => setTimeout(r, Math.max(0, Number(ms) || 0)));

            const ReplayHandSchema = z.object({
                handIndex: z.number().min(0).max(3),
                present: z.boolean().optional(),
                isFacingCamera: z.boolean().optional(),
                isCharging: z.boolean().optional(),
                shouldFill: z.boolean().optional(),
                hasConfidence: z.boolean().optional(),
                isPointing: z.boolean().optional(),
                categoryName: z.string().optional(),
                confidence: z.number().min(0).max(1).optional()
            });

            const ReplayStepSchema = z.object({
                ms: z.number().min(1),
                hands: z.array(ReplayHandSchema).optional()
            });

            const ReplaySequenceSchema = z.object({
                id: z.string().min(1),
                description: z.string().optional(),
                config: z.object({
                    numHands: z.number().min(1).max(4).optional(),
                    hysteresisHigh: z.number().min(0).max(1).optional(),
                    hysteresisLow: z.number().min(0).max(1).optional(),
                    chargeTimeMs: z.number().min(1).optional(),
                    releaseTimeMs: z.number().min(1).optional(),
                    coastDrainTimeMs: z.number().min(1).optional(),
                    tensionMs: z.number().min(0).optional(),
                    readyTriggerCooldownMs: z.number().min(0).optional()
                }).optional(),
                expect: z.object({
                    minNematocyst: z.number().min(0).optional(),
                    maxNematocyst: z.number().min(0).optional(),
                    minPostMessageOk: z.number().min(0).optional()
                }).optional(),
                steps: z.array(ReplayStepSchema).min(1)
            });

            const ReplayManifestSchema = z.object({
                version: z.string().optional(),
                sequences: z.array(ReplaySequenceSchema).min(1)
            });

            const dummyLandmarks = () => Array.from({ length: 21 }, (_, j) => ({
                x: 0.5 + (j % 5) * 0.002,
                y: 0.5 + Math.floor(j / 5) * 0.002,
                z: 0
            }));

            const buildResults = (numHands, step) => {
                const handsByIndex = Object.create(null);
                for (const h of (step?.hands || [])) {
                    if (h && Number.isFinite(h.handIndex)) handsByIndex[h.handIndex] = h;
                }

                const landmarks = Array.from({ length: numHands }, (_, i) => {
                    const h = handsByIndex[i];
                    if (h && h.present === false) return null;
                    return dummyLandmarks();
                });

                const gestures = Array.from({ length: numHands }, (_, i) => {
                    const h = handsByIndex[i] || {};
                    const categoryName = typeof h.categoryName === 'string' ? h.categoryName : 'None';
                    const score = (typeof h.confidence === 'number' && Number.isFinite(h.confidence)) ? h.confidence : 1.0;
                    return [{ categoryName, score }];
                });

                const __hfoReplayHands = Array.from({ length: numHands }, (_, i) => {
                    const h = handsByIndex[i];
                    return h ? { ...h } : null;
                });

                return { landmarks, gestures, __hfoReplayHands };
            };

            const applyConfig = (seq) => {
                const cfg = seq?.config || {};
                if (cfg.numHands) systemState.parameters.landmarks.numHands = cfg.numHands;
                if (cfg.hysteresisHigh != null) systemState.parameters.fsm.hysteresisHigh = cfg.hysteresisHigh;
                if (cfg.hysteresisLow != null) systemState.parameters.fsm.hysteresisLow = cfg.hysteresisLow;
                if (cfg.chargeTimeMs) systemState.parameters.fsm.chargeTimeMs = cfg.chargeTimeMs;
                if (cfg.releaseTimeMs) systemState.parameters.fsm.releaseTimeMs = cfg.releaseTimeMs;
                if (cfg.coastDrainTimeMs) systemState.parameters.fsm.coastDrainTimeMs = cfg.coastDrainTimeMs;
                if (cfg.tensionMs != null) systemState.parameters.fsm.tensionMs = cfg.tensionMs;
                if (cfg.readyTriggerCooldownMs != null) systemState.fsm.readyTriggerCooldownMs = cfg.readyTriggerCooldownMs;
            };

            const resetRuntime = (numHands) => {
                systemState.parameters.p0Active = true;
                if (!systemState.p0.videoBounds || !systemState.p0.videoBounds.width) {
                    systemState.p0.videoBounds = { width: 1280, height: 720 };
                }

                try { window.hfoMockResults = null; } catch (_) { }
                try {
                    window.__hfoReplayPredictLoopFrames = 0;
                    window.__hfoReplayPredictLoopLastDt = 0;
                } catch (_) { }

                for (let i = 0; i < numHands; i++) {
                    systemState.p1.readinessScores[i] = 0;
                    systemState.p1.fsmStates[i] = 'IDLE';
                    systemState.p1.lastPalmFacingTimes[i] = 0;
                    systemState.p1.lastTrackingTimes[i] = 0;
                    systemState.p1.lastMovementTimes[i] = 0;
                }
                systemState.fsm.primaryHandIndex = null;
                systemState.fsm.lastReadyTriggerTimes = Array.from({ length: numHands }, () => 0);
                try { window.hfoPortsEffects?.clear?.(); } catch (_) { }
            };

            const ensurePredictLoop = () => {
                try {
                    window.__hfoReplayKeepAlive = true;
                    systemState.parameters.p0Active = true;
                    if (!window.__hfoReplayPredictLoopStarted) {
                        window.__hfoReplayPredictLoopStarted = true;
                    }
                    window.hfoStartMockReplay?.();
                } catch (_) {
                    window.__hfoReplayKeepAlive = true;
                    systemState.parameters.p0Active = true;
                }
            };

            const waitForPredictLoopFrames = async (minFrames = 2, timeoutMs = 2000) => {
                const started = performance.now();
                while (true) {
                    const frames = Number(window.__hfoReplayPredictLoopFrames || 0);
                    if (frames >= minFrames) return true;
                    if (performance.now() - started > timeoutMs) return false;
                    await sleep(16);
                }
            };

            const getFuseCalls = () => {
                try {
                    return Number(systemState?.p0?.diag?.fuseCalls || 0);
                } catch (_) {
                    return 0;
                }
            };

            const waitForFuseCalls = async (minCalls, timeoutMs = 2000) => {
                const started = performance.now();
                while (true) {
                    const calls = getFuseCalls();
                    if (calls >= minCalls) return true;
                    if (performance.now() - started > timeoutMs) return false;
                    await sleep(16);
                }
            };

            const ensureDinoAdapter = () => {
                try { window.hfoPorts?.p7?.adapters?.setActiveId?.('dino-v1'); } catch (_) { }
                try { window.hfoPortsEffects?.emit?.('p7', 'replay_adapter_set', { adapterId: 'dino-v1' }); } catch (_) { }
            };

            const defaultManifest = () => ({
                version: 'gen6_v9_dino_readiness_replay_v1',
                sequences: [
                    {
                        id: 'seq01_basic_fill_then_drain',
                        description: 'Palm towards (fill to READY once) then palm away (drain to IDLE).',
                        config: { numHands: 1, chargeTimeMs: 900, releaseTimeMs: 900, coastDrainTimeMs: 900, tensionMs: 0, hysteresisHigh: 0.88, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 1, maxNematocyst: 1, minPostMessageOk: 1 },
                        steps: [
                            { ms: 1200, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1200, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq02_short_fill_no_trigger',
                        description: 'Short fill burst should not reach hysteresisHigh; expect no nematocyst.',
                        config: { numHands: 1, chargeTimeMs: 2000, releaseTimeMs: 800, coastDrainTimeMs: 800, tensionMs: 0, hysteresisHigh: 0.88, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 0, maxNematocyst: 0, minPostMessageOk: 0 },
                        steps: [
                            { ms: 400, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1200, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq03_fill_hold_ready_no_repeat',
                        description: 'Fill to READY then hold facing; should not retrigger while staying READY.',
                        config: { numHands: 1, chargeTimeMs: 700, releaseTimeMs: 1200, coastDrainTimeMs: 1200, tensionMs: 0, hysteresisHigh: 0.86, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 1, maxNematocyst: 1, minPostMessageOk: 1 },
                        steps: [
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1400, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq04_two_triggers_two_cycles',
                        description: 'Fillâ†’drain below lowâ†’fill again; expect two nematocysts.',
                        config: { numHands: 1, chargeTimeMs: 650, releaseTimeMs: 650, coastDrainTimeMs: 650, tensionMs: 0, hysteresisHigh: 0.86, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 2, maxNematocyst: 2, minPostMessageOk: 2 },
                        steps: [
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] },
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq05_confidence_drop_causes_coast',
                        description: 'Fill then drop confidence (COAST/drain), then recover and fill again.',
                        config: { numHands: 1, chargeTimeMs: 800, releaseTimeMs: 800, coastDrainTimeMs: 500, tensionMs: 0, hysteresisHigh: 0.88, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 2, maxNematocyst: 2, minPostMessageOk: 2 },
                        steps: [
                            { ms: 1100, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 700, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: false, shouldFill: false }] },
                            { ms: 1100, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1000, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq06_tension_holds_charge',
                        description: 'Uses tensionMs to keep charging briefly after palm away.',
                        config: { numHands: 1, chargeTimeMs: 900, releaseTimeMs: 900, coastDrainTimeMs: 900, tensionMs: 500, hysteresisHigh: 0.86, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 1, maxNematocyst: 1, minPostMessageOk: 1 },
                        steps: [
                            { ms: 900, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 300, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1200, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    },
                    {
                        id: 'seq07_multi_hand_seat_isolation',
                        description: 'Two-hand smoke: hand0 triggers, drains, then hand1 triggers (verifies per-hand readiness + FSM isolation under numHands=2).',
                        config: { numHands: 2, chargeTimeMs: 750, releaseTimeMs: 750, coastDrainTimeMs: 750, tensionMs: 0, hysteresisHigh: 0.86, hysteresisLow: 0.52, readyTriggerCooldownMs: 200 },
                        expect: { minNematocyst: 2, maxNematocyst: 2, minPostMessageOk: 2 },
                        steps: [
                            {
                                ms: 1100, hands: [
                                    { handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true },
                                    { handIndex: 1, present: false }
                                ]
                            },
                            {
                                ms: 900, hands: [
                                    { handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false },
                                    { handIndex: 1, present: false }
                                ]
                            },
                            {
                                ms: 1100, hands: [
                                    { handIndex: 0, present: false },
                                    { handIndex: 1, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }
                                ]
                            },
                            {
                                ms: 900, hands: [
                                    { handIndex: 0, present: false },
                                    { handIndex: 1, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'seq08_cooldown_suppression',
                        description: 'Rapid double fill attempts within cooldown should suppress second trigger.',
                        config: { numHands: 1, chargeTimeMs: 400, releaseTimeMs: 600, coastDrainTimeMs: 600, tensionMs: 0, hysteresisHigh: 0.80, hysteresisLow: 0.52, readyTriggerCooldownMs: 900 },
                        expect: { minNematocyst: 1, maxNematocyst: 1, minPostMessageOk: 1 },
                        steps: [
                            { ms: 650, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 250, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] },
                            { ms: 650, hands: [{ handIndex: 0, isFacingCamera: true, isCharging: true, hasConfidence: true, shouldFill: true }] },
                            { ms: 1200, hands: [{ handIndex: 0, isFacingCamera: false, isCharging: false, hasConfidence: true, shouldFill: false }] }
                        ]
                    }
                ]
            });

            let manifest = defaultManifest();
            let lastReport = null;

            const loadManifestObject = (obj) => {
                const parsed = ReplayManifestSchema.parse(obj);
                manifest = parsed;
                return { version: parsed.version || 'unknown', sequences: parsed.sequences.length };
            };

            const loadManifestUrl = async (url) => {
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) throw new Error(`Replay manifest fetch failed: ${res.status}`);
                const json = await res.json();
                return loadManifestObject(json);
            };

            const runSequence = async (seqOrId) => {
                const seq = typeof seqOrId === 'string'
                    ? (manifest?.sequences || []).find(s => s.id === seqOrId)
                    : seqOrId;
                if (!seq) throw new Error('Replay sequence not found');

                const events = [];
                applyConfig(seq);
                const numHands = systemState.parameters.landmarks.numHands || 1;
                resetRuntime(numHands);
                ensureDinoAdapter();
                const off = window.hfoPortsEffects?.subscribe?.((e) => { if (e) events.push(e); }) || (() => { });

                ensurePredictLoop();
                const loopOk = await waitForPredictLoopFrames(3, 8000);
                if (!loopOk) {
                    try { window.hfoPortsEffects?.emit?.('p7', 'replay_loop_timeout', { sequenceId: seq.id }); } catch (_) { }
                }

                const startedAt = performance.now();
                try { window.hfoPortsEffects?.emit?.('p7', 'replay_start', { sequenceId: seq.id }); } catch (_) { }

                for (const step of (seq.steps || [])) {
                    const fuseBefore = getFuseCalls();
                    window.hfoMockResults = buildResults(numHands, step);
                    const consumed = await waitForFuseCalls(fuseBefore + 1, Math.min(2000, Number(step.ms) || 0));
                    if (!consumed) {
                        try { window.hfoPortsEffects?.emit?.('p7', 'replay_step_not_consumed', { sequenceId: seq.id, fuseBefore, fuseAfter: getFuseCalls(), stepMs: step.ms }); } catch (_) { }
                    }
                    await sleep(step.ms);
                }

                window.hfoMockResults = null;
                await sleep(50);

                off();
                const endedAt = performance.now();

                const counts = {
                    fsmEdge: events.filter(e => e.port === 'p1' && e.type === 'fsm_edge').length,
                    cooldownSuppressed: events.filter(e => e.port === 'p1' && e.type === 'cooldown_suppressed').length,
                    nematocyst: events.filter(e => e.port === 'p3' && e.type === 'nematocyst_deliver').length,
                    nematocystOk: events.filter(e => e.port === 'p3' && e.type === 'nematocyst_deliver' && e.payload?.ok).length,
                    dinoQueue: events.filter(e => e.port === 'p7' && e.type === 'dino_queue').length,
                    dinoFlush: events.filter(e => e.port === 'p7' && e.type === 'dino_flush_queue').length,
                    dinoPostMessageOk: events.filter(e => e.port === 'p7' && e.type === 'dino_postMessage' && e.payload?.ok).length,
                    dinoPostMessageErr: events.filter(e => e.port === 'p7' && e.type === 'dino_postMessage' && e.payload && e.payload.ok === false).length
                };

                const final = {
                    readinessScores: [...systemState.p1.readinessScores],
                    fsmStates: [...systemState.p1.fsmStates]
                };

                const report = { sequenceId: seq.id, startedAt, endedAt, durationMs: endedAt - startedAt, expect: seq.expect || {}, counts, final, events };
                lastReport = report;
                try { window.hfoPortsEffects?.emit?.('p7', 'replay_end', { sequenceId: seq.id, counts }); } catch (_) { }
                return report;
            };

            const runAll = async () => {
                const reports = [];
                for (const seq of (manifest?.sequences || [])) {
                    // Small idle gap between sequences to reduce coupling via cooldown windows.
                    reports.push(await runSequence(seq));
                    await sleep(150);
                }
                return { version: manifest?.version || 'unknown', reports };
            };

            const getManifest = () => manifest;
            const getLastReport = () => lastReport;

            return Object.freeze({
                getManifest,
                loadManifestObject,
                loadManifestUrl,
                runSequence,
                runAll,
                getLastReport
            });
        })();

        // --- Tracer Bullet (E2E): traceId tagged injection ---
        // Purpose: fire a single deterministic input through the system and observe it end-to-end.
        // Expected path: P1 fsm_edge â†’ P3 nematocyst_deliver â†’ P7 dino_postMessage â†’ wrapper hfo:nematocyst:ack.
        window.diagnosticTracerBulletVenom = window.diagnosticTracerBulletVenom || (() => {
            const sleep = (ms) => new Promise((r) => setTimeout(r, Math.max(0, Number(ms) || 0)));

            const newTraceId = () => {
                const rand = Math.random().toString(16).slice(2, 8);
                return `tb_${Date.now()}_${rand}`;
            };

            const fire = async (opts = {}) => {
                const traceId = (typeof opts.traceId === 'string' && opts.traceId.length) ? opts.traceId : newTraceId();
                const targetId = (typeof opts.targetId === 'string' && opts.targetId.length)
                    ? opts.targetId
                    : 'p2.fsm_and_dino';
                const sequenceId = (typeof opts.sequenceId === 'string' && opts.sequenceId.length)
                    ? opts.sequenceId
                    : 'seq01_basic_fill_then_drain';

                try {
                    systemState.trace = systemState.trace || {};
                    systemState.trace.traceId = traceId;
                    systemState.trace.targetId = targetId;
                } catch (_) {
                    // ignore
                }

                const effects = [];
                const messages = [];
                const acks = [];

                const onMsg = (event) => {
                    try {
                        const d = event?.data;
                        if (!d || typeof d !== 'object') return;
                        const msgTraceId = (typeof d.traceId === 'string' && d.traceId.length)
                            ? d.traceId
                            : (typeof d.payload?.traceId === 'string' ? d.payload.traceId : null);
                        const msgTargetId = (typeof d.targetId === 'string' && d.targetId.length)
                            ? d.targetId
                            : (typeof d.payload?.targetId === 'string' ? d.payload.targetId : null);
                        const entry = {
                            ts: Date.now(),
                            origin: String(event.origin || ''),
                            type: d.type || null,
                            traceId: msgTraceId,
                            targetId: msgTargetId,
                            payload: d.payload ?? null,
                        };
                        messages.push(entry);
                        if (messages.length > 250) messages.splice(0, messages.length - 250);
                        if (entry.type === 'hfo:nematocyst:ack') {
                            acks.push(entry);
                            if (acks.length > 100) acks.splice(0, acks.length - 100);
                        }
                    } catch (_) {
                        // ignore
                    }
                };

                const off = (typeof window.hfoPortsEffects?.subscribe === 'function')
                    ? window.hfoPortsEffects.subscribe((e) => {
                        try {
                            effects.push(e);
                            if (effects.length > 250) effects.splice(0, effects.length - 250);
                        } catch (_) {
                            // ignore
                        }
                    })
                    : (() => { });

                window.addEventListener('message', onMsg);
                try { window.hfoPortsEffects?.clear?.(); } catch (_) { }

                const waitForAckOk = async (timeoutMs = 5000) => {
                    const started = performance.now();
                    while (true) {
                        const okCount = acks.filter((a) => {
                            try {
                                const tid = a?.traceId || a?.payload?.traceId || null;
                                if (tid !== traceId) return false;
                                return Boolean(a?.payload?.ok);
                            } catch (_) {
                                return false;
                            }
                        }).length;
                        if (okCount >= 1) return true;
                        if (performance.now() - started > timeoutMs) return false;
                        await sleep(50);
                    }
                };

                let replayReport = null;
                try {
                    replayReport = await window.hfoReplay?.runSequence?.(sequenceId);
                } catch (e) {
                    replayReport = { error: String(e?.message || e) };
                }

                // Give the wrapper a chance to emit its postMessage ack.
                await waitForAckOk(6000);
                try { off(); } catch (_) { }
                try { window.removeEventListener('message', onMsg); } catch (_) { }

                const traceEffects = effects.filter((e) => {
                    try {
                        return (e?.traceId === traceId) || (e?.payload?.traceId === traceId);
                    } catch (_) {
                        return false;
                    }
                });

                const traceAcks = acks.filter((a) => a?.traceId === traceId || a?.payload?.traceId === traceId);
                const traceMessages = messages.filter((m) => m?.traceId === traceId || m?.payload?.traceId === traceId);

                const counts = {
                    p1FsmEdge: traceEffects.filter((e) => e?.port === 'p1' && e?.type === 'fsm_edge').length,
                    p2FsmTransition: traceEffects.filter((e) => e?.port === 'p2' && e?.type === 'fsm_transition').length,
                    p2DinoReadyEdge: traceEffects.filter((e) => e?.port === 'p2' && e?.type === 'dino_ready_edge').length,
                    p3Nematocyst: traceEffects.filter((e) => e?.port === 'p3' && e?.type === 'nematocyst_deliver').length,
                    p7PostMessageOk: traceEffects.filter((e) => e?.port === 'p7' && e?.type === 'dino_postMessage' && e?.payload?.ok).length,
                    ackTotal: traceAcks.length,
                    ackOk: traceAcks.filter((a) => a?.payload?.ok).length,
                };

                const coverage = {
                    port2: {
                        fsmTransitions: counts.p2FsmTransition,
                        dinoReadyEdges: counts.p2DinoReadyEdge
                    },
                    adhoc: {
                        p1FsmEdges: counts.p1FsmEdge,
                        note: 'In v11, FSM transitions + dino trigger are expected to emit P2 events; if missing, that path is still ad-hoc.'
                    }
                };

                return { traceId, targetId, sequenceId, counts, coverage, replayReport, effects: traceEffects, acks: traceAcks, messages: traceMessages };
            };

            const strikeP3 = async (opts = {}) => {
                const traceId = (typeof opts.traceId === 'string' && opts.traceId.length) ? opts.traceId : newTraceId();
                const targetId = (typeof opts.targetId === 'string' && opts.targetId.length) ? opts.targetId : 'p3.nematocyst_direct';

                try {
                    systemState.trace = systemState.trace || {};
                    systemState.trace.traceId = traceId;
                    systemState.trace.targetId = targetId;
                } catch (_) {
                    // ignore
                }

                const effects = [];
                const messages = [];
                const acks = [];

                const onMsg = (event) => {
                    try {
                        const d = event?.data;
                        if (!d || typeof d !== 'object') return;
                        const msgTraceId = (typeof d.traceId === 'string' && d.traceId.length)
                            ? d.traceId
                            : (typeof d.payload?.traceId === 'string' ? d.payload.traceId : null);
                        const msgTargetId = (typeof d.targetId === 'string' && d.targetId.length)
                            ? d.targetId
                            : (typeof d.payload?.targetId === 'string' ? d.payload.targetId : null);
                        const entry = {
                            ts: Date.now(),
                            origin: String(event.origin || ''),
                            type: d.type || null,
                            traceId: msgTraceId,
                            targetId: msgTargetId,
                            payload: d.payload ?? null,
                        };
                        messages.push(entry);
                        if (messages.length > 250) messages.splice(0, messages.length - 250);
                        if (entry.type === 'hfo:nematocyst:ack') {
                            acks.push(entry);
                            if (acks.length > 100) acks.splice(0, acks.length - 100);
                        }
                    } catch (_) {
                        // ignore
                    }
                };

                const off = (typeof window.hfoPortsEffects?.subscribe === 'function')
                    ? window.hfoPortsEffects.subscribe((e) => {
                        try {
                            effects.push(e);
                            if (effects.length > 250) effects.splice(0, effects.length - 250);
                        } catch (_) {
                            // ignore
                        }
                    })
                    : (() => { });

                window.addEventListener('message', onMsg);
                try { window.hfoPortsEffects?.clear?.(); } catch (_) { }

                try {
                    const payload = {
                        kind: 'keyboard',
                        action: 'keypress',
                        key: ' ',
                        code: 'Space',
                        reason: 'tracer_p3_direct',
                        traceId,
                        targetId
                    };
                    P3InjectorPort?.sendNematocystToDino?.(payload);
                } catch (_) {
                    // ignore
                }

                const started = performance.now();
                while (performance.now() - started < 6000) {
                    const okCount = acks.filter((a) => {
                        try {
                            const tid = a?.traceId || a?.payload?.traceId || null;
                            if (tid !== traceId) return false;
                            return Boolean(a?.payload?.ok);
                        } catch (_) {
                            return false;
                        }
                    }).length;
                    if (okCount >= 1) break;
                    await sleep(50);
                }

                try { off(); } catch (_) { }
                try { window.removeEventListener('message', onMsg); } catch (_) { }

                const traceEffects = effects.filter((e) => {
                    try {
                        return (e?.traceId === traceId) || (e?.payload?.traceId === traceId);
                    } catch (_) {
                        return false;
                    }
                });

                const traceAcks = acks.filter((a) => a?.traceId === traceId || a?.payload?.traceId === traceId);
                const traceMessages = messages.filter((m) => m?.traceId === traceId || m?.payload?.traceId === traceId);

                const counts = {
                    p3Nematocyst: traceEffects.filter((e) => e?.port === 'p3' && e?.type === 'nematocyst_deliver').length,
                    p7PostMessageOk: traceEffects.filter((e) => e?.port === 'p7' && e?.type === 'dino_postMessage' && e?.payload?.ok).length,
                    ackTotal: traceAcks.length,
                    ackOk: traceAcks.filter((a) => a?.payload?.ok).length,
                };

                return { traceId, targetId, sequenceId: null, counts, replayReport: null, effects: traceEffects, acks: traceAcks, messages: traceMessages };
            };

            const disperse = async (opts = {}) => {
                const sequenceId = (typeof opts.sequenceId === 'string' && opts.sequenceId.length)
                    ? opts.sequenceId
                    : 'seq01_basic_fill_then_drain';
                const baseTraceId = (typeof opts.traceId === 'string' && opts.traceId.length) ? opts.traceId : newTraceId();

                const shots = [];
                shots.push(await fire({ traceId: `${baseTraceId}_a`, targetId: 'p2.fsm', sequenceId }));
                shots.push(await fire({ traceId: `${baseTraceId}_b`, targetId: 'p2.dino', sequenceId }));
                shots.push(await strikeP3({ traceId: `${baseTraceId}_c`, targetId: 'p3.direct' }));

                const summary = {
                    total: shots.length,
                    byTarget: Object.fromEntries(shots.map((s) => [s.targetId, s.counts]))
                };

                return { traceId: baseTraceId, sequenceId, summary, shots };
            };

            return Object.freeze({ fire, strikeP3, disperse });
        })();

        // Backward-compatible alias (older diagnostics may call this).
        window.hfoTraceBullet = window.hfoTraceBullet || window.diagnosticTracerBulletVenom;

        // --- GEN6 v22.1: Tracer Venom Battery (pipeline stage breadcrumbs) ---
        // Purpose: make all time-domain gates observable (schedule decisions, cooldowns, delivery, ack).
        // Fail-closed: emits nothing unless flag-p3-tracer-venom-battery=true.
        window.hfoTracerVenomBattery = window.hfoTracerVenomBattery || (() => {
            const enabled = () => isFlagEnabled('p3-tracer-venom-battery');
            const verbose = () => isFlagEnabled('p3-tracer-venom-battery-verbose');

            const store = () => {
                try {
                    window.__hfoTracerVenomBatteryEvents = window.__hfoTracerVenomBatteryEvents || [];
                    return window.__hfoTracerVenomBatteryEvents;
                } catch (_) {
                    return [];
                }
            };

            const pushRing = (arr, v, maxLen) => {
                try {
                    arr.push(v);
                    if (arr.length > maxLen) arr.splice(0, arr.length - maxLen);
                } catch (_) {
                    // ignore
                }
            };

            let listenerInstalled = false;
            const ensureAckListener = () => {
                if (listenerInstalled) return;
                listenerInstalled = true;
                window.addEventListener('message', (event) => {
                    try {
                        if (!enabled()) return;
                        const d = event?.data;
                        if (!d || typeof d !== 'object') return;
                        if (d.type !== 'hfo:nematocyst:ack') return;
                        const traceId = (typeof d?.payload?.traceId === 'string' && d.payload.traceId.length) ? d.payload.traceId : null;
                        emit('rx.hfo:nematocyst:ack', {
                            origin: String(event?.origin || ''),
                            traceId,
                            ok: Boolean(d?.payload?.ok),
                            payload: d?.payload ?? null,
                        });
                    } catch (_) {
                        // ignore
                    }
                });
            };

            const emit = (stage, data = {}) => {
                if (!enabled()) return false;
                ensureAckListener();

                const entry = Object.freeze({
                    ts: Date.now(),
                    stage: String(stage || 'unknown'),
                    ...data,
                });

                const arr = store();
                pushRing(arr, entry, 600);

                try { window.hfoPortsEffects?.emit?.('p3', 'tracer_venom_battery', entry); } catch (_) { }
                if (verbose()) {
                    try { console.debug('[venom_battery]', entry); } catch (_) { }
                }
                return true;
            };

            const getEvents = () => {
                try { return store().slice(); } catch (_) { return []; }
            };

            return Object.freeze({ emit, enabled, verbose, getEvents });
        })();

        // --- GEN5: Hexagonal Modular Monolith Scaffolding (Option 2 + Option 4) ---
        // Goal: stay single-HTML while enforcing (a) Port Facades and (b) Adapter Registry.
        // This scaffold is intentionally minimal and non-invasive for v10.1 boot safety.

        // --- HFO: Legendary Commanders / Domains / Authority (8 Ports) ---
        // Grounded sources:
        // - hfo_hot_obsidian/bronze/3_resources/mtg_slivers/16_SLIVER_SYNERGY_MANIFOLD.md
        // - hfo_hot_obsidian/bronze/4_archive/*/HFO_LEGENDARY_COMMANDERS_V1.md
        // Notes:
        // - Verb aliases across sources are expected (e.g., BRIDGE/ROUTE/FUSE).
        // - P3 has a known alias discrepancy in deeper notes (Spore Storm vs Harmonic Hydra).
        //
        // P0 SENSE/OBSERVE â€” Commander: Lidless Legion â€” Domain: ISR â€” Authority: sensing/recognition ingest.
        // P1 FUSE/BRIDGE/ROUTE â€” Commander: Web Weaver â€” Domain: Data Fabric â€” Authority: contracts + fusion (canonical fabric).
        // P2 SHAPE â€” Commander: Mirror Magus â€” Domain: Digital Twin â€” Authority: physics/render substrate shaping.
        // P3 INJECT/MODEL/DELIVER â€” Commander: Spore Storm (aka Harmonic Hydra) â€” Domain: Effect Delivery â€” Authority: W3C event injection.
        // P4 DISRUPT â€” Commander: Red Regnant â€” Domain: Coevolving Red Team â€” Authority: fault injection/chaos probes (opt-in).
        // P5 IMMUNIZE/AUDIT/DEFEND â€” Commander: Pyre Praetorian â€” Domain: Force Protection â€” Authority: audits + fail-closed integrity.
        // P6 ASSIMILATE/PERSIST/STORE â€” Commander: Kraken Keeper â€” Domain: AAR â€” Authority: persistence + consolidation.
        // P7 NAVIGATE/PLAN â€” Commander: Spider Sovereign â€” Domain: BMC2 â€” Authority: orchestration + total tool virtualization.

        // --- GEN5 v11: Port Doctrine (blurbs + keyword tags + synergy map) ---
        // Purpose: give agents a scan-friendly, canonical description of each hex port.
        // Invariant: this metadata must not mutate runtime behavior.
        window.hfoPortMeta = window.hfoPortMeta || Object.freeze({
            p0: Object.freeze({
                name: 'SENSE',
                commander: 'Lidless Legion',
                role: 'Observer',
                purpose: 'Convert raw world input (video) into first-pass perception results (MediaPipe hands + gestures).',
                keywords: Object.freeze(['P0', 'OBSERVE', 'ISR', 'mediapipe', 'hands', 'gestures', 'perception', 'frame_time']),
                inputs: Object.freeze(['HTMLVideoElement', 'monotonicMs']),
                outputs: Object.freeze(['recognition results (landmarks/gestures)']),
                synergy: Object.freeze({
                    upstream: Object.freeze([]),
                    downstream: Object.freeze(['p1.fuse'])
                })
            }),
            p1: Object.freeze({
                name: 'FUSE',
                commander: 'Web Weaver',
                role: 'Bridger / Data Fabric Authority',
                purpose: 'Fuse recognition into the canonical DataFabric, enforce Zod contracts, and emit a stable envelope for cross-port transport.',
                keywords: Object.freeze(['P1', 'BRIDGE', 'ROUTE', 'FUSE', 'data_fabric', 'zod', 'contracts', 'envelope', 'schema']),
                inputs: Object.freeze(['recognition results', 'dt', 'monotonicMs']),
                outputs: Object.freeze(['DataFabric', 'FabricEnvelope']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p0.sense']),
                    downstream: Object.freeze(['p2.shape', 'p3.deliver', 'p6.store'])
                })
            }),
            p2: Object.freeze({
                name: 'SHAPE',
                commander: 'Mirror Magus',
                role: 'Shaper / Digital Twin',
                purpose: 'Consume DataFabric and create shape state: physics, visuals, and interaction affordances (without directly injecting app events).',
                keywords: Object.freeze(['P2', 'SHAPE', 'digital_twin', 'physics', 'visuals', 'interaction', 'substrate']),
                inputs: Object.freeze(['DataFabric']),
                outputs: Object.freeze(['physics adapters telemetry', 'render layers']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse']),
                    downstream: Object.freeze(['p3.deliver'])
                })
            }),
            p3: Object.freeze({
                name: 'DELIVER',
                commander: 'Spore Storm (aka Harmonic Hydra)',
                role: 'Injector / Effect Delivery',
                purpose: 'Transform DataFabric into W3C-ish PointerEvents and inject into the target app (including Excalidraw overlay).',
                keywords: Object.freeze(['P3', 'INJECT', 'DELIVER', 'pointerevents', 'w3c', 'nematocyst', 'excalidraw', 'golden_layout']),
                inputs: Object.freeze(['DataFabric', 'target DOM']),
                outputs: Object.freeze(['PointerEvents dispatched into app']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse', 'p2.shape']),
                    downstream: Object.freeze(['p5.defend', 'p6.store'])
                })
            }),
            p4: Object.freeze({
                name: 'DISRUPT',
                commander: 'Red Regnant',
                role: 'Red Team / Chaos Probe',
                purpose: 'Opt-in disruption hooks: feedback loops, suppression heuristics, and bounded chaos probes that stress the other ports without corrupting state.',
                keywords: Object.freeze(['P4', 'DISRUPT', 'red_team', 'chaos', 'fault_injection', 'suppression', 'stability']),
                inputs: Object.freeze(['ports', 'contracts', 'flags']),
                outputs: Object.freeze(['diagnostics', 'bounded perturbations (opt-in)']),
                synergy: Object.freeze({
                    upstream: Object.freeze([]),
                    downstream: Object.freeze(['p5.immunize', 'p7.navigate'])
                })
            }),
            p5: Object.freeze({
                name: 'DEFEND',
                commander: 'Pyre Praetorian',
                role: 'Blue Team / Immunizer',
                purpose: 'Fail-closed integrity: assert required adapters/ports exist, guard contracts, and expose stable evaluation surfaces.',
                keywords: Object.freeze(['P5', 'IMMUNIZE', 'DEFEND', 'audit', 'integrity', 'fail_closed', 'eval_harness']),
                inputs: Object.freeze(['registry', 'tokens', 'contracts']),
                outputs: Object.freeze(['assertions', 'audit signals']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p4.disrupt (opt-in)']),
                    downstream: Object.freeze(['p7.navigate'])
                })
            }),
            p6: Object.freeze({
                name: 'STORE',
                commander: 'Kraken Keeper',
                role: 'Assimilator / AAR',
                purpose: 'Persist telemetry (fabric frames, readiness, injected events) for replay, audit, and long-term learning loops.',
                keywords: Object.freeze(['P6', 'ASSIMILATE', 'STORE', 'telemetry', 'jsonl', 'replay', 'aar']),
                inputs: Object.freeze(['DataFabric', 'events']),
                outputs: Object.freeze(['JSONL telemetry exports']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse', 'p3.deliver']),
                    downstream: Object.freeze(['p7.navigate'])
                })
            }),
            p7: Object.freeze({
                name: 'NAVIGATE',
                commander: 'Spider Sovereign',
                role: 'Orchestrator / BMC2',
                purpose: 'Compose tools over time: parameters, modes, and intent manifests (Mission Thread OMEGA: Total Tool Virtualization).',
                keywords: Object.freeze(['P7', 'NAVIGATE', 'plan', 'orchestrate', 'intent', 'tool_virtualization', 'governance']),
                inputs: Object.freeze(['user intent', 'port surfaces', 'telemetry']),
                outputs: Object.freeze(['parameter patches', 'intent manifests', 'tool selection']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p5.defend', 'p6.store']),
                    downstream: Object.freeze([])
                })
            }),
            synergy_chain: Object.freeze([
                'P0 OBSERVE: MediaPipe hands/gestures',
                'â†’ P1 BRIDGE: Zod-enforced DataFabric + envelope',
                'â†’ P2 SHAPE: physics/visuals/interaction affordances',
                'â†’ P3 INJECT: PointerEvents into app',
                'â†’ Golden layout: Excalidraw overlay ready + stable tool semantics'
            ])
        });

        window.hfoTokens = window.hfoTokens || Object.freeze({
            P0_SENSE: 'p0.sense',
            P0_CAMERA: 'p0.camera',
            P1_FUSE: 'p1.fuse',
            P2_PHYSICS: 'p2.physics',
            P2_RENDER: 'p2.render',
            P3_INJECTOR: 'p3.injector',
            P3_TARGET_ROUTER: 'p3.target_router',
            P4_DISRUPT: 'p4.disrupt',
            P6_STORE: 'p6.store',
            P7_NAVIGATE: 'p7.navigate',
            P7_APPHOST: 'p7.apphost',
            P7_ADAPTER_HOST: 'p7.adapter_host',
            UI_LAYOUT: 'ui.layout',
            EVAL_HFO: 'eval.hfo'
        });

        window.hfoRegistry = window.hfoRegistry || (() => {
            const map = new Map();
            return {
                register(token, impl) {
                    if (map.has(token)) throw new Error(`Adapter already registered: ${token}`);
                    map.set(token, impl);
                },
                resolve(token) {
                    const impl = map.get(token);
                    if (!impl) throw new Error(`Missing adapter: ${token}`);
                    return impl;
                },
                has(token) {
                    return map.has(token);
                }
            };
        })();

        // --- GEN6 v8: Ports Effects Bus (Dev Observability) ---
        // Must be initialized before GoldenLayout loads so debug panels can subscribe immediately.
        window.hfoPortsEffects = window.hfoPortsEffects || (() => {
            const MAX = 250;
            const buffer = [];
            const lastByPort = Object.create(null);
            const state = Object.create(null);

            const nowMs = () => {
                try {
                    return (typeof performance !== 'undefined' && typeof performance.now === 'function')
                        ? performance.now()
                        : Date.now();
                } catch {
                    return Date.now();
                }
            };

            const normPort = (p) => {
                const s = String(p || '').trim().toLowerCase();
                if (!s) return 'unknown';
                if (s.startsWith('p')) return s;
                if (/^[0-7]$/.test(s)) return `p${s}`;
                return s;
            };

            const emit = (port, type, payload) => {
                const p = normPort(port);
                let traceId = null;
                let targetId = null;
                try {
                    traceId = systemState?.trace?.traceId || null;
                    targetId = systemState?.trace?.targetId || null;
                } catch {
                    traceId = null;
                    targetId = null;
                }
                const entry = Object.freeze({
                    port: p,
                    type: String(type || 'event'),
                    payload: payload ?? null,
                    traceId: typeof traceId === 'string' && traceId.length ? traceId : null,
                    targetId: typeof targetId === 'string' && targetId.length ? targetId : null,
                    ts: nowMs()
                });

                buffer.push(entry);
                if (buffer.length > MAX) buffer.splice(0, buffer.length - MAX);
                lastByPort[p] = entry;

                try {
                    window.dispatchEvent(new CustomEvent('hfo:ports-effects', { detail: entry }));
                    window.dispatchEvent(new CustomEvent(`hfo:ports-effects:${p}`, { detail: entry }));
                } catch {
                    // ignore
                }

                return entry;
            };

            const getRecent = (limit = MAX) => {
                const n = Math.max(0, Math.min(MAX, Number(limit) || 0));
                return buffer.slice(-n);
            };

            const clear = () => {
                buffer.splice(0, buffer.length);
                Object.keys(lastByPort).forEach(k => delete lastByPort[k]);
            };

            const setState = (key, value) => {
                const k = String(key || '').trim();
                if (!k) return false;
                state[k] = value;
                try {
                    window.dispatchEvent(new CustomEvent('hfo:ports-effects:state', { detail: { key: k, value } }));
                } catch {
                    // ignore
                }
                return true;
            };

            const getSnapshot = (limit = MAX) => ({
                recent: getRecent(limit),
                lastByPort: { ...lastByPort },
                state: { ...state }
            });

            const subscribe = (handler, port) => {
                const eventName = port ? `hfo:ports-effects:${normPort(port)}` : 'hfo:ports-effects';
                const listener = (e) => handler(e?.detail);
                window.addEventListener(eventName, listener);
                return () => window.removeEventListener(eventName, listener);
            };

            return Object.freeze({ emit, getRecent, getSnapshot, clear, subscribe, setState });
        })();

        // --- GEN6 v18: P3 Knuckle Key Injector (COMMIT-only; deny-by-default) ---
        // Purpose: translate deterministic P2 knuckle_keypress begin events into a P3 knuckle_key_inject payload.
        // NOTE: This emits to the Ports Effects bus for observability and Playwright tests.
        window.hfoP3KnuckleKeyInjector = window.hfoP3KnuckleKeyInjector || (() => {
            let off = null;

            const isEnabled = () => {
                try {
                    return isFlagEnabled('p3-knuckle-key-injector');
                } catch (_) {
                    return false;
                }
            };

            const uninstall = () => {
                if (typeof off === 'function') {
                    try { off(); } catch (_) { }
                }
                off = null;
            };

            const install = () => {
                if (!isEnabled()) return false;
                if (typeof window.hfoPortsEffects?.subscribe !== 'function') return false;
                if (off) return true;

                off = window.hfoPortsEffects.subscribe((entry) => {
                    if (!entry || entry.port !== 'p2' || entry.type !== 'knuckle_keypress') return;

                    const p = entry.payload || {};
                    if (String(p.phase || '') !== 'begin') return;
                    if (String(p.fsmState || '') !== 'COMMIT') return;

                    try {
                        window.hfoPortsEffects?.emit?.('p3', 'knuckle_key_inject', {
                            adapterId: 'dino-v1',
                            payload: { code: 'Space' },
                            source: {
                                port: 'p2',
                                type: 'knuckle_keypress',
                                handIndex: p.handIndex ?? null,
                                pointerId: p.pointerId ?? null,
                                finger: p.finger ?? null,
                                timestampMs: p.timestampMs ?? null
                            }
                        });
                    } catch (_) {
                        // ignore
                    }
                }, 'p2');

                return true;
            };

            // Auto-install if enabled by URL flag.
            try { install(); } catch (_) { }

            return Object.freeze({ install, uninstall, isEnabled });
        })();

        // --- GEN6 v11: P2 SHAPE (Mirror Magus) â€” FSM + Effects Adapter Layer ---
        // Purpose: consolidate state machines, effect synthesis, and data transformations under P2.
        // Gesture semantics can evolve behind adapters; Port 3 remains the injector.
        window.hfoP2MirrorMagus = window.hfoP2MirrorMagus || (() => {
            const getTrace = () => {
                try {
                    return {
                        traceId: (typeof systemState?.trace?.traceId === 'string' && systemState.trace.traceId.length)
                            ? systemState.trace.traceId
                            : null,
                        targetId: (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                            ? systemState.trace.targetId
                            : null
                    };
                } catch (_) {
                    return { traceId: null, targetId: null };
                }
            };

            const computeSovereignFsmNext = (ctx) => {
                const fsmState = ctx?.fsmState;
                const readiness = Number(ctx?.readiness || 0);
                const isFacingCamera = Boolean(ctx?.isFacingCamera);
                const isCharging = Boolean(ctx?.isCharging);
                const hasConfidence = Boolean(ctx?.hasConfidence);
                const isPointing = Boolean(ctx?.isPointing);
                const handIndex = Number(ctx?.handIndex || 0);

                const hysteresisHigh = Number(ctx?.hysteresisHigh);
                const hysteresisLow = Number(ctx?.hysteresisLow);
                const primaryHandIndex = (ctx?.primaryHandIndex === null || typeof ctx?.primaryHandIndex === 'number')
                    ? ctx.primaryHandIndex
                    : null;

                const isSeatAvailable = (primaryHandIndex === null || primaryHandIndex === handIndex);

                let nextState = fsmState;
                let nextPrimary = primaryHandIndex;
                let reason = null;

                // GEN6 v18 doctrine (anti-midas): palm-cone orientation is the READY gate.
                // NOTE: This is an architectural semantic change, so it is feature-flagged (default off).
                // When disabled, legacy semantics apply: READY is gated by (isFacingCamera || isCharging).
                let antiMidasReadyGateEnabled = false;
                try {
                    antiMidasReadyGateEnabled = isFlagEnabled('p2-ready-gate-palm-cone');
                } catch (_) {
                    antiMidasReadyGateEnabled = false;
                }

                const isReadyGateOpen = antiMidasReadyGateEnabled
                    ? isFacingCamera
                    : (isFacingCamera || isCharging);

                if (fsmState === 'IDLE') {
                    if (readiness >= hysteresisHigh && isReadyGateOpen) {
                        nextState = 'READY';
                        reason = antiMidasReadyGateEnabled ? 'p2_idle_to_ready_gate_open' : 'p2_idle_to_ready';
                    }
                } else if (fsmState === 'READY') {
                    if (antiMidasReadyGateEnabled && !isReadyGateOpen) {
                        nextState = 'IDLE';
                        reason = 'p2_ready_gate_closed_to_idle';
                        if (nextPrimary === handIndex) nextPrimary = null;
                    } else
                        if (readiness <= hysteresisLow) {
                            nextState = 'IDLE';
                            reason = 'p2_ready_to_idle';
                            if (nextPrimary === handIndex) nextPrimary = null;
                        } else if (!hasConfidence) {
                            nextState = 'COAST';
                            reason = 'p2_ready_to_coast';
                        } else if (isPointing && isSeatAvailable) {
                            nextState = 'COMMIT';
                            nextPrimary = handIndex;
                            reason = 'p2_ready_to_commit';
                        }
                } else if (fsmState === 'COMMIT') {
                    if (antiMidasReadyGateEnabled && !isReadyGateOpen) {
                        nextState = 'IDLE';
                        reason = 'p2_commit_gate_closed_to_idle';
                        if (nextPrimary === handIndex) nextPrimary = null;
                    } else
                        if (readiness <= hysteresisLow) {
                            nextState = 'IDLE';
                            reason = 'p2_commit_to_idle';
                            if (nextPrimary === handIndex) nextPrimary = null;
                        } else if (!hasConfidence) {
                            nextState = 'COAST';
                            reason = 'p2_commit_to_coast';
                        }
                } else if (fsmState === 'COAST') {
                    if (readiness <= hysteresisLow) {
                        nextState = 'IDLE';
                        reason = 'p2_coast_to_idle';
                        if (nextPrimary === handIndex) nextPrimary = null;
                    } else if (hasConfidence && isReadyGateOpen) {
                        nextState = isPointing ? 'COMMIT' : 'READY';
                        reason = 'p2_coast_recover';
                        if (nextState === 'COMMIT') nextPrimary = handIndex;
                    }
                }

                return Object.freeze({ nextState, nextPrimary, reason });
            };

            const shouldTriggerDinoOnReadyEdge = (ctx) => {
                const from = ctx?.from;
                const to = ctx?.to;
                if (!(from === 'IDLE' && to === 'READY')) return Object.freeze({ ok: false, reason: 'not_ready_edge' });
                const now = Number(ctx?.now || 0);
                const last = Number(ctx?.last || 0);
                const cooldownMs = Math.max(0, Number(ctx?.cooldownMs || 0));
                if ((now - last) >= cooldownMs) return Object.freeze({ ok: true, reason: 'cooldown_ok' });
                return Object.freeze({ ok: false, reason: 'cooldown_suppressed', sinceLastMs: now - last, cooldownMs });
            };

            const buildDinoNematocystPayload = (ctx) => {
                const handIndex = Number(ctx?.handIndex || 0);
                const readiness = Number(ctx?.readiness || 0);
                const t = getTrace();
                return Object.freeze({
                    kind: 'keyboard',
                    action: 'keypress',
                    key: ' ',
                    code: 'Space',
                    handIndex,
                    readiness,
                    reason: 'fsm_idle_to_ready',
                    traceId: t.traceId || undefined,
                    targetId: t.targetId || undefined
                });
            };

            return Object.freeze({
                getTrace,
                computeSovereignFsmNext,
                shouldTriggerDinoOnReadyEdge,
                buildDinoNematocystPayload
            });
        })();

        // --- GEN6 v11: P2 Gesture Language Base (FSMâ†’P3 payload adapters) ---
        // This is a composable substrate to evolve beyond rudimentary gesture methods.
        // Two non-mutually-exclusive concept adapters are included:
        //  1) Spatial zones in touch2d (uiNorm) space with velocity/direction/dwell.
        //  2) Contact substrate (landmark-to-landmark distances + hysteresis + 1D Kalman smoothing).
        window.hfoP2GestureLanguage = window.hfoP2GestureLanguage || (() => {
            const getTrace = () => {
                try {
                    return {
                        traceId: (typeof systemState?.trace?.traceId === 'string' && systemState.trace.traceId.length)
                            ? systemState.trace.traceId
                            : null,
                        targetId: (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                            ? systemState.trace.targetId
                            : null
                    };
                } catch (_) {
                    return { traceId: null, targetId: null };
                }
            };

            const cfg = () => {
                const p = systemState?.parameters?.p2?.gestureLanguage || {};
                return {
                    enabled: Boolean(p.enabled),
                    emitP3: Boolean(p.emitP3),
                    emitTelemetry: (p.emitTelemetry !== false),
                    minReadiness: Math.max(0, Math.min(1, Number(p.minReadiness ?? 0.2) || 0.2))
                };
            };

            class Kalman1D {
                constructor({ q = 0.01, r = 0.1, x0 = null, p0 = 1 } = {}) {
                    this.q = Number.isFinite(q) ? q : 0.01;
                    this.r = Number.isFinite(r) ? r : 0.1;
                    this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                    this.p = Number.isFinite(p0) ? p0 : 1;
                }
                reset(x0 = null) {
                    this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                    this.p = 1;
                }
                update(z) {
                    const meas = Number(z);
                    if (!Number.isFinite(meas)) return this.x;
                    if (this.x === null) {
                        this.x = meas;
                        return this.x;
                    }
                    this.p = this.p + this.q;
                    const k = this.p / (this.p + this.r);
                    this.x = this.x + k * (meas - this.x);
                    this.p = (1 - k) * this.p;
                    return this.x;
                }
            }

            const hysteresisBool = (prev, value, onThreshold, offThreshold, mode) => {
                const v = Number(value);
                const onT = Number(onThreshold);
                const offT = Number(offThreshold);
                if (!Number.isFinite(v) || !Number.isFinite(onT) || !Number.isFinite(offT)) return Boolean(prev);
                const state = Boolean(prev);
                if (mode === 'geq_on_leq_off') {
                    if (!state && v >= onT) return true;
                    if (state && v <= offT) return false;
                    return state;
                }
                if (!state && v <= onT) return true;
                if (state && v >= offT) return false;
                return state;
            };

            const emitP2 = (type, payload) => {
                try {
                    window.hfoPortsEffects?.emit?.('p2', type, payload);
                    return true;
                } catch (_) {
                    return false;
                }
            };

            const dispatchP3 = (payload) => {
                const t = getTrace();
                const enriched = (() => {
                    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) return payload;
                    const out = { ...payload };
                    if (t.traceId && !out.traceId) out.traceId = t.traceId;
                    if (t.targetId && !out.targetId) out.targetId = t.targetId;
                    return out;
                })();

                try {
                    window.hfoPortsEffects?.emit?.('p3', 'gesture_payload', {
                        kind: enriched?.kind || null,
                        action: enriched?.action || enriched?.type || null,
                        handIndex: enriched?.handIndex ?? null,
                        ok: null
                    });
                } catch (_) {
                    // ignore
                }

                if (!cfg().emitP3) return false;

                try {
                    if (enriched?.kind === 'keyboard') {
                        return !!P3InjectorPort?.sendNematocystToDino?.(enriched);
                    }
                    if (enriched?.kind === 'tool') {
                        const nav = window.hfoRegistry?.resolve?.(window.hfoTokens.P7_NAVIGATE);
                        if (nav?.setActiveAdapterTool && typeof enriched?.tool === 'string') {
                            nav.setActiveAdapterTool(enriched.tool);
                            return true;
                        }
                    }
                } catch (_) {
                    return false;
                }
                return false;
            };

            class HfoP2GestureAdapterBase {
                constructor(id) {
                    this.id = String(id || 'adapter');
                    this.state = Object.create(null);
                }
                reset() {
                    this.state = Object.create(null);
                }
                tick(_ctx) {
                    return { p3: [], p2: [] };
                }
            }

            class SpatialZonesAdapter extends HfoP2GestureAdapterBase {
                constructor() {
                    super('p2.spatial_zones');
                    this.zones = [
                        { id: 'center', x0: 0.4, y0: 0.4, x1: 0.6, y1: 0.6, dwellMs: 250 }
                    ];
                }

                tick(ctx) {
                    const outP2 = [];
                    const outP3 = [];
                    const cursors = ctx?.cursors || [];
                    const now = Number(ctx?.now || 0);

                    for (const c of cursors) {
                        const handIndex = Number(c?.handIndex ?? 0);
                        const readiness = Number(c?.readinessScore ?? 0);
                        if (readiness < cfg().minReadiness) continue;

                        const x = Number(c?.uiNormX ?? c?.normX);
                        const y = Number(c?.uiNormY ?? c?.normY);
                        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

                        const handKey = String(handIndex);
                        if (!this.state[handKey]) this.state[handKey] = { last: null, zones: {} };
                        const st = this.state[handKey];

                        const last = st.last;
                        let vx = 0, vy = 0, speed = 0, theta = 0;
                        if (last && Number.isFinite(last.x) && Number.isFinite(last.y) && Number.isFinite(last.t)) {
                            const dtx = Math.max(1, now - last.t);
                            vx = (x - last.x) / dtx;
                            vy = (y - last.y) / dtx;
                            speed = Math.hypot(vx, vy);
                            theta = Math.atan2(vy, vx);
                        }
                        st.last = { x, y, t: now };

                        for (const z of this.zones) {
                            const inside = (x >= z.x0 && x <= z.x1 && y >= z.y0 && y <= z.y1);
                            const zst = st.zones[z.id] || { inside: false, enterMs: 0, lastEmitMs: 0 };

                            if (inside && !zst.inside) {
                                zst.inside = true;
                                zst.enterMs = now;
                                zst.lastEmitMs = 0;
                                outP2.push({ type: 'zone_enter', payload: { adapter: this.id, zoneId: z.id, handIndex, x, y, speed, theta } });
                                outP3.push({ kind: 'tool', tool: 'freedraw', handIndex, reason: `zone_enter:${z.id}` });
                            }

                            if (!inside && zst.inside) {
                                zst.inside = false;
                                outP2.push({ type: 'zone_exit', payload: { adapter: this.id, zoneId: z.id, handIndex, x, y, speed, theta } });
                            }

                            if (inside) {
                                const dwell = now - (zst.enterMs || now);
                                const dwellMs = Math.max(0, Number(z.dwellMs || 250));
                                if (dwell >= dwellMs && (now - (zst.lastEmitMs || 0)) >= dwellMs) {
                                    zst.lastEmitMs = now;
                                    outP2.push({ type: 'zone_dwell', payload: { adapter: this.id, zoneId: z.id, handIndex, dwellMs: dwell, x, y, speed, theta } });
                                }
                            }

                            st.zones[z.id] = zst;
                        }
                    }

                    return { p2: outP2, p3: outP3 };
                }
            }

            class ContactSubstrateAdapter extends HfoP2GestureAdapterBase {
                constructor() {
                    super('p2.contact_substrate');
                    this.filters = new Map();
                    this.contacts = new Map();
                    this.rules = [
                        { id: 'thumb_index_tip', kind: 'distance', a: 4, b: 8, zScale: 0.1, on: 0.035, off: 0.055 },
                        { id: 'index_tip_past_knuckle_line', kind: 'line_cross', tip: 8, a: 5, b: 17, on: 0.01, off: 0.0 }
                    ];
                }

                _key(handIndex, ruleId) {
                    return `${handIndex}:${ruleId}`;
                }

                _getFilter(key) {
                    if (!this.filters.has(key)) this.filters.set(key, new Kalman1D({ q: 0.002, r: 0.02 }));
                    return this.filters.get(key);
                }

                _dist3(a, b, zScale = 0.1) {
                    const dx = (a.x - b.x);
                    const dy = (a.y - b.y);
                    const dz = (a.z - b.z) * zScale;
                    return Math.sqrt(dx * dx + dy * dy + dz * dz);
                }

                _signedLineFeature2D(p, a, b) {
                    const abx = b.x - a.x;
                    const aby = b.y - a.y;
                    const apx = p.x - a.x;
                    const apy = p.y - a.y;
                    return (abx * apy - aby * apx);
                }

                tick(ctx) {
                    const outP2 = [];
                    const outP3 = [];
                    const cursors = ctx?.cursors || [];

                    for (const c of cursors) {
                        const handIndex = Number(c?.handIndex ?? 0);
                        const readiness = Number(c?.readinessScore ?? 0);
                        if (readiness < cfg().minReadiness) continue;

                        const landmarks = Array.isArray(c?.landmarks) ? c.landmarks : null;
                        if (!landmarks || landmarks.length < 21) continue;

                        for (const rule of this.rules) {
                            const key = this._key(handIndex, rule.id);
                            const prev = this.contacts.get(key) || false;
                            let feature = null;
                            let mode = 'leq_on_geq_off';

                            if (rule.kind === 'distance') {
                                const a = landmarks[rule.a];
                                const b = landmarks[rule.b];
                                if (!a || !b) continue;
                                const raw = this._dist3(a, b, rule.zScale ?? 0.1);
                                const kf = this._getFilter(key);
                                feature = kf.update(raw);
                                mode = 'leq_on_geq_off';
                            } else if (rule.kind === 'line_cross') {
                                const tip = landmarks[rule.tip];
                                const a = landmarks[rule.a];
                                const b = landmarks[rule.b];
                                if (!tip || !a || !b) continue;
                                const raw = this._signedLineFeature2D(tip, a, b);
                                const kf = this._getFilter(key);
                                feature = kf.update(raw);
                                mode = 'geq_on_leq_off';
                            } else {
                                continue;
                            }

                            const next = hysteresisBool(prev, feature, rule.on, rule.off, mode);
                            if (next !== prev) {
                                this.contacts.set(key, next);
                                const type = next ? 'contact_down' : 'contact_up';
                                outP2.push({
                                    type,
                                    payload: {
                                        adapter: this.id,
                                        ruleId: rule.id,
                                        handIndex,
                                        feature,
                                        on: rule.on,
                                        off: rule.off,
                                        fsmState: c?.fsmState || null,
                                        readiness
                                    }
                                });

                                if (next && rule.id === 'thumb_index_tip') {
                                    outP3.push({
                                        kind: 'keyboard',
                                        action: 'keypress',
                                        key: ' ',
                                        code: 'Space',
                                        handIndex,
                                        readiness,
                                        reason: 'contact_thumb_index_tip'
                                    });
                                }
                            }
                        }
                    }

                    return { p2: outP2, p3: outP3 };
                }
            }

            const adapters = [new SpatialZonesAdapter(), new ContactSubstrateAdapter()];
            let lastReport = null;

            const tick = ({ now, dt, dataFabric }) => {
                const enabledByFlag = (() => {
                    try { return isFlagEnabled('p2-gesture-language'); } catch (_) { return false; }
                })();
                const c = cfg();
                if (!(enabledByFlag || c.enabled)) return null;

                const cursors = dataFabric?.cursors || [];
                const p2Events = [];
                const p3Payloads = [];

                for (const a of adapters) {
                    const res = a.tick({ now, dt, cursors });
                    if (Array.isArray(res?.p2)) p2Events.push(...res.p2);
                    if (Array.isArray(res?.p3)) p3Payloads.push(...res.p3);
                }

                const t = getTrace();
                for (const e of p2Events) {
                    if (!e?.type) continue;
                    emitP2(e.type, { ...(e.payload || {}), traceId: t.traceId || undefined, targetId: t.targetId || undefined });
                }

                let dispatched = 0;
                for (const p of p3Payloads) {
                    if (dispatchP3(p)) dispatched++;
                }

                lastReport = Object.freeze({
                    ts: new Date().toISOString(),
                    now: Number(now || 0),
                    p2Events: p2Events.length,
                    p3Payloads: p3Payloads.length,
                    p3Dispatched: dispatched,
                    trace: t
                });

                try {
                    window.hfoPortsEffects?.setState?.('p2_gesture_language', lastReport);
                } catch (_) {
                    // ignore
                }

                return lastReport;
            };

            const debugEvaluate = (opts) => {
                const now = Number(opts?.now || performance.now());
                const dt = Number(opts?.dt || 16);
                const handIndex = Number(opts?.handIndex || 0);
                const uiNormX = Number(opts?.uiNormX ?? 0.5);
                const uiNormY = Number(opts?.uiNormY ?? 0.5);
                const readinessScore = Number(opts?.readinessScore ?? 0.9);
                const fsmState = String(opts?.fsmState || 'READY');
                const landmarks = Array.isArray(opts?.landmarks) ? opts.landmarks : null;

                const pseudo = Object.freeze({
                    handIndex,
                    pointerId: 10 + handIndex,
                    uiNormX,
                    uiNormY,
                    normX: uiNormX,
                    normY: uiNormY,
                    readinessScore,
                    fsmState,
                    landmarks
                });

                const p2Events = [];
                const p3Payloads = [];
                for (const a of adapters) {
                    const res = a.tick({ now, dt, cursors: [pseudo] });
                    if (Array.isArray(res?.p2)) p2Events.push(...res.p2);
                    if (Array.isArray(res?.p3)) p3Payloads.push(...res.p3);
                }
                return Object.freeze({ now, dt, cursor: pseudo, p2Events, p3Payloads });
            };

            return Object.freeze({
                Kalman1D,
                HfoP2GestureAdapterBase,
                adapters,
                tick,
                debugEvaluate,
                getLastReport: () => lastReport
            });
        })();

        // --- GEN6 v18: P2 Knuckle Keybar Thread (knuckle/palm-width sensor thread) ---
        // Emits: p2/knuckle_keypress { phase: begin|end } when index tip crosses the knuckle bar.
        // State: window.hfoP2KnuckleKeybarThread.getLastReport()/getSnapshot() for deterministic tests + UI.
        if (!window.hfoP2KnuckleKeybarThread) {
            let enabled = false;
            try { enabled = isFlagEnabled('p2-knuckle-keybar'); } catch (_) { enabled = false; }

            if (enabled) {
                window.hfoP2KnuckleKeybarThread = (() => {
                    class Kalman1D {
                        constructor({ q = 0.002, r = 0.02, x0 = null, p0 = 1 } = {}) {
                            this.q = Number.isFinite(q) ? q : 0.002;
                            this.r = Number.isFinite(r) ? r : 0.02;
                            this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                            this.p = Number.isFinite(p0) ? p0 : 1;
                        }
                        reset(x0 = null) {
                            this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                            this.p = 1;
                        }
                        update(z) {
                            const meas = Number(z);
                            if (!Number.isFinite(meas)) return this.x;
                            if (this.x === null) {
                                this.x = meas;
                                return this.x;
                            }
                            this.p = this.p + this.q;
                            const k = this.p / (this.p + this.r);
                            this.x = this.x + k * (meas - this.x);
                            this.p = (1 - k) * this.p;
                            return this.x;
                        }
                    }

                    const hysteresisBool = (prev, value, onThreshold, offThreshold) => {
                        const v = Number(value);
                        const onT = Number(onThreshold);
                        const offT = Number(offThreshold);
                        if (!Number.isFinite(v) || !Number.isFinite(onT) || !Number.isFinite(offT)) return Boolean(prev);
                        const state = Boolean(prev);
                        // geq_on_leq_off
                        if (!state && v >= onT) return true;
                        if (state && v <= offT) return false;
                        return state;
                    };

                    const signedLineFeature2D = (p, a, b) => {
                        const abx = b.x - a.x;
                        const aby = b.y - a.y;
                        const apx = p.x - a.x;
                        const apy = p.y - a.y;
                        return (abx * apy - aby * apx);
                    };

                    const filters = new Map();
                    const pressedByKey = new Map();
                    let lastReport = null;
                    let lastSnapshot = null;

                    const keyFor = (handIndex, pointerId) => `${handIndex}:${pointerId ?? 'na'}`;
                    const getFilter = (k) => {
                        if (!filters.has(k)) filters.set(k, new Kalman1D({ q: 0.002, r: 0.02 }));
                        return filters.get(k);
                    };

                    const cfg = () => {
                        const p = systemState?.parameters?.p2?.knuckleKeybar || {};
                        return {
                            on: Number(p.on ?? 0.01),
                            off: Number(p.off ?? 0.0),
                            minReadiness: Math.max(0, Math.min(1, Number(p.minReadiness ?? 0.2) || 0.2)),
                            finger: String(p.finger || 'index')
                        };
                    };

                    const emitP2 = (type, payload) => {
                        try {
                            window.hfoPortsEffects?.emit?.('p2', type, payload);
                            return true;
                        } catch (_) {
                            return false;
                        }
                    };

                    const tick = ({ now, dt, dataFabric }) => {
                        const c = cfg();
                        const cursors = dataFabric?.cursors || [];
                        const events = [];
                        const hands = [];

                        for (const cursor of cursors) {
                            const handIndex = Number(cursor?.handIndex ?? 0);
                            const pointerId = cursor?.pointerId ?? null;
                            const readinessScore = Number(cursor?.readinessScore ?? 0);
                            const fsmState = String(cursor?.fsmState || '');

                            if (readinessScore < c.minReadiness) continue;

                            const landmarks = Array.isArray(cursor?.landmarks) ? cursor.landmarks : null;
                            if (!landmarks || landmarks.length < 21) continue;

                            const tip = landmarks[8];
                            const a = landmarks[5];
                            const b = landmarks[17];
                            if (!tip || !a || !b) continue;

                            const raw = signedLineFeature2D(tip, a, b);
                            const k = keyFor(handIndex, pointerId);
                            const feature = getFilter(k).update(raw);

                            const prevPressed = Boolean(pressedByKey.get(k) || false);
                            const nextPressed = hysteresisBool(prevPressed, feature, c.on, c.off);
                            pressedByKey.set(k, nextPressed);

                            hands.push({
                                handIndex,
                                pointerId,
                                fsmState,
                                readinessScore,
                                feature,
                                rawFeature: raw,
                                bar: { a: { x: a.x, y: a.y, z: a.z }, b: { x: b.x, y: b.y, z: b.z } },
                                tip: { x: tip.x, y: tip.y, z: tip.z }
                            });

                            if (nextPressed !== prevPressed) {
                                const phase = nextPressed ? 'begin' : 'end';
                                const payload = {
                                    handIndex,
                                    pointerId,
                                    finger: c.finger,
                                    fsmState,
                                    readinessScore,
                                    isPalmFacing: (cursor?.isPalmFacing ?? null),
                                    timestampMs: Number(now || 0),
                                    phase,
                                    feature,
                                    rawFeature: raw,
                                    bar: { a: { x: a.x, y: a.y, z: a.z }, b: { x: b.x, y: b.y, z: b.z } }
                                };

                                // COMMIT-only emission to respect the injector boundary.
                                if (fsmState === 'COMMIT') {
                                    emitP2('knuckle_keypress', payload);
                                    events.push(payload);
                                }
                            }
                        }

                        lastSnapshot = Object.freeze({ now: Number(now || 0), dt: Number(dt || 0), hands });
                        lastReport = Object.freeze({
                            ts: new Date().toISOString(),
                            now: Number(now || 0),
                            hands: hands.length,
                            events: events.length
                        });

                        try {
                            window.hfoPortsEffects?.setState?.('p2_knuckle_keybar', lastReport);
                        } catch (_) {
                            // ignore
                        }

                        return lastReport;
                    };

                    const debugEvaluate = (opts) => {
                        const now = Number(opts?.now || performance.now());
                        const dt = Number(opts?.dt || 16);
                        const handIndex = Number(opts?.handIndex || 0);
                        const pointerId = Number(opts?.pointerId ?? 10 + handIndex);
                        const readinessScore = Number(opts?.readinessScore ?? 0.9);
                        const fsmState = String(opts?.fsmState || 'COMMIT');
                        const landmarks = Array.isArray(opts?.landmarks) ? opts.landmarks : null;

                        const pseudo = Object.freeze({ handIndex, pointerId, readinessScore, fsmState, landmarks });
                        return Object.freeze({ now, dt, cursor: pseudo, report: tick({ now, dt, dataFabric: { cursors: [pseudo] } }) });
                    };

                    return Object.freeze({
                        tick,
                        debugEvaluate,
                        getLastReport: () => lastReport,
                        getSnapshot: () => lastSnapshot
                    });
                })();
            }
        }

        // --- GEN6 v19: P2 Knuckle Tripwire Thread (hand-anchored tripwire; shared primitive) ---
        // Emits: p2/tripwire_cross { sensorId:'knuckle', sensor:{engine:'knuckle',phase:'begin|end',bar,tip} }
        // Policy: COMMIT-only emission (defense-in-depth). P3 routing controls injection.
        if (!window.hfoP2KnuckleTripwireThread) {
            let enabled = false;
            try { enabled = isFlagEnabled('p2-tripwire-knuckle'); } catch (_) { enabled = false; }

            if (enabled) {
                window.hfoP2KnuckleTripwireThread = (() => {
                    class Kalman1D {
                        constructor({ q = 0.002, r = 0.02, x0 = null, p0 = 1 } = {}) {
                            this.q = Number.isFinite(q) ? q : 0.002;
                            this.r = Number.isFinite(r) ? r : 0.02;
                            this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                            this.p = Number.isFinite(p0) ? p0 : 1;
                        }
                        reset(x0 = null) {
                            this.x = (typeof x0 === 'number' && Number.isFinite(x0)) ? x0 : null;
                            this.p = 1;
                        }
                        update(z) {
                            const meas = Number(z);
                            if (!Number.isFinite(meas)) return this.x;
                            if (this.x === null) {
                                this.x = meas;
                                return this.x;
                            }
                            this.p = this.p + this.q;
                            const k = this.p / (this.p + this.r);
                            this.x = this.x + k * (meas - this.x);
                            this.p = (1 - k) * this.p;
                            return this.x;
                        }
                    }

                    const hysteresisBool = (prev, value, onThreshold, offThreshold) => {
                        const v = Number(value);
                        const onT = Number(onThreshold);
                        const offT = Number(offThreshold);
                        if (!Number.isFinite(v) || !Number.isFinite(onT) || !Number.isFinite(offT)) return Boolean(prev);
                        const state = Boolean(prev);
                        if (!state && v >= onT) return true;
                        if (state && v <= offT) return false;
                        return state;
                    };

                    const signedLineFeature2D = (p, a, b) => {
                        const abx = b.x - a.x;
                        const aby = b.y - a.y;
                        const apx = p.x - a.x;
                        const apy = p.y - a.y;
                        return (abx * apy - aby * apx);
                    };

                    const getTrace = () => {
                        try {
                            return {
                                traceId: (typeof systemState?.trace?.traceId === 'string' && systemState.trace.traceId.length)
                                    ? systemState.trace.traceId
                                    : null,
                                targetId: (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                                    ? systemState.trace.targetId
                                    : null
                            };
                        } catch (_) {
                            return { traceId: null, targetId: null };
                        }
                    };

                    const filters = new Map();
                    const pressedByKey = new Map();
                    const lastCursorByKey = new Map();
                    let lastReport = null;
                    let lastSnapshot = null;
                    let seq = 0;

                    const keyFor = (handIndex, pointerId) => `${handIndex}:${pointerId ?? 'na'}`;
                    const getFilter = (k) => {
                        if (!filters.has(k)) filters.set(k, new Kalman1D({ q: 0.002, r: 0.02 }));
                        return filters.get(k);
                    };

                    const cfg = () => {
                        const p = systemState?.parameters?.p2?.knuckleTripwire || systemState?.parameters?.p2?.knuckleKeybar || {};
                        const baseA = Number(p.barExtensionFracA ?? 0.5);
                        const baseB = Number(p.barExtensionFracB ?? 0.5);
                        // Port7/microkernel override knobs (URL):
                        // - p2-knuckle-tripwire-ext-a-frac
                        // - p2-knuckle-tripwire-ext-b-frac
                        const urlA = getFlagNumber('p2-knuckle-tripwire-ext-a-frac', baseA);
                        const urlB = getFlagNumber('p2-knuckle-tripwire-ext-b-frac', baseB);

                        // Predictive window for tripplane lookahead (TOI/TTC). Default is tuned to typical 1â€“2 frame latency.
                        const lookaheadWindowMs = Math.max(1, Math.min(500, Number(getFlagNumber('p2-knuckle-tripwire-lookahead-window-ms', Number(p.lookaheadWindowMs ?? 120))) || 120));
                        return {
                            on: Number(p.on ?? 0.01),
                            off: Number(p.off ?? 0.0),
                            barExtensionFracA: Math.max(0, Math.min(3, Number(urlA) || 0)),
                            barExtensionFracB: Math.max(0, Math.min(3, Number(urlB) || 0)),
                            minReadiness: Math.max(0, Math.min(1, Number(p.minReadiness ?? 0.2) || 0.2)),
                            lookaheadWindowMs,
                        };
                    };

                    const emitP2 = (type, payload) => {
                        try {
                            window.hfoPortsEffects?.emit?.('p2', type, payload);
                            return true;
                        } catch (_) {
                            return false;
                        }
                    };

                    const tick = ({ now, dt, dataFabric }) => {
                        const c = cfg();
                        const cursors = dataFabric?.cursors || [];
                        const events = [];
                        const hands = [];

                        for (const cursor of cursors) {
                            const handIndex = Number(cursor?.handIndex ?? 0);
                            const pointerId = cursor?.pointerId ?? null;
                            const readiness = Number(cursor?.readinessScore ?? 0);
                            const fsmState = String(cursor?.fsmState || '');
                            if (readiness < c.minReadiness) continue;

                            const landmarks = Array.isArray(cursor?.landmarks) ? cursor.landmarks : null;
                            if (!landmarks || landmarks.length < 21) continue;

                            const tip = landmarks[8];
                            const a = landmarks[5];
                            const b = landmarks[17];
                            const wrist = landmarks[0];
                            if (!tip || !a || !b) continue;

                            const rawCross = signedLineFeature2D(tip, a, b);
                            const abx = (b.x - a.x);
                            const aby = (b.y - a.y);
                            const barLen = Math.hypot(abx, aby);
                            if (!(barLen > 1e-6)) continue;

                            // v22: extend the trip-plane out to the sides so lateral aiming is easier.
                            // Extension amount is expressed as a fraction of barLen for scale-invariance.
                            const ux = abx / barLen;
                            const uy = aby / barLen;
                            const extA = barLen * (Number(c.barExtensionFracA) || 0);
                            const extB = barLen * (Number(c.barExtensionFracB) || 0);
                            const aExt = { x: a.x - ux * extA, y: a.y - uy * extA, z: a.z };
                            const bExt = { x: b.x + ux * extB, y: b.y + uy * extB, z: b.z };

                            // Convert cross product to signed distance (uiNorm) from the bar line.
                            const rawDistance = rawCross / barLen;

                            // Normalize sign so that the wrist is always on the positive side.
                            // This makes "cross fingertip down toward palm past knuckle line" consistent across hand orientation.
                            let sign = 1;
                            if (wrist) {
                                const wristCross = signedLineFeature2D(wrist, a, b);
                                const wristDistance = wristCross / barLen;
                                if (Number.isFinite(wristDistance) && wristDistance < 0) sign = -1;
                            }
                            const orientedDistance = rawDistance * sign;

                            // v22 semantics: treat the tripwire as a finite segment (with optional endpoint extension).
                            // If the fingertip is outside the (extended) segment, it must not trigger a crossing.
                            // This avoids infinite-line false positives when aiming laterally.
                            const tipT = ((tip.x - a.x) * ux + (tip.y - a.y) * uy);
                            const inExtendedSegment = (tipT >= (-extA - 1e-6)) && (tipT <= (barLen + extB + 1e-6));
                            const orientedDistanceForHysteresis = inExtendedSegment ? orientedDistance : 0;

                            const k = keyFor(handIndex, pointerId);
                            const featureDistanceUiNorm = getFilter(k).update(orientedDistanceForHysteresis);

                            // NOTE: v21 hysteresis thresholds are interpreted as uiNorm distance.

                            // Cursor-style velocity in uiNorm space (same physics surface as the cursor).
                            const nowNum = Number(now || 0);
                            const uiNormX = Number.isFinite(cursor?.uiNormX) ? Number(cursor.uiNormX) : Number(cursor?.normX);
                            const uiNormY = Number.isFinite(cursor?.uiNormY) ? Number(cursor.uiNormY) : Number(cursor?.normY);

                            const prevCur = lastCursorByKey.get(k) || null;
                            const prevNow = Number(prevCur?.now ?? NaN);
                            const prevX = Number(prevCur?.x ?? NaN);
                            const prevY = Number(prevCur?.y ?? NaN);
                            const prevRawDistance = Number(prevCur?.rawDistance ?? NaN);
                            const prevOrientedDistance = Number(prevCur?.orientedDistance ?? NaN);
                            const prevFeatureDistance = Number(prevCur?.featureDistance ?? NaN);

                            let vxPerS = 0;
                            let vyPerS = 0;
                            let rawDistanceVelPerS = 0;
                            let orientedDistanceVelPerS = 0;
                            let featureDistanceVelPerS = 0;
                            if (Number.isFinite(prevNow) && Number.isFinite(prevX) && Number.isFinite(prevY) && Number.isFinite(nowNum)) {
                                const dtS = Math.max(1e-6, (nowNum - prevNow) / 1000);
                                const dx = (Number.isFinite(uiNormX) ? uiNormX : 0) - prevX;
                                const dy = (Number.isFinite(uiNormY) ? uiNormY : 0) - prevY;
                                vxPerS = dx / dtS;
                                vyPerS = dy / dtS;

                                if (Number.isFinite(prevRawDistance)) rawDistanceVelPerS = (rawDistance - prevRawDistance) / dtS;
                                if (Number.isFinite(prevOrientedDistance)) orientedDistanceVelPerS = (orientedDistance - prevOrientedDistance) / dtS;
                                if (Number.isFinite(prevFeatureDistance)) featureDistanceVelPerS = (featureDistanceUiNorm - prevFeatureDistance) / dtS;
                            }
                            const speedPerS = Math.hypot(vxPerS, vyPerS);

                            const prevPressed = Boolean(pressedByKey.get(k) || false);

                            // v22: predictive tripplane lookahead (TOI/TTC).
                            // Emit when COMMIT-gated and the next threshold crossing is imminent.
                            try {
                                // Only emit lookahead while not yet pressed (predict the begin edge only).
                                if (!prevPressed && fsmState === 'COMMIT') {
                                    const enterDistanceUiNorm = Number(c.on);
                                    const exitDistanceUiNorm = Number(c.off);
                                    const vel = orientedDistanceVelPerS;

                                    // Only predict approach toward wrist-side ("down") crossings (press).
                                    if (Number.isFinite(enterDistanceUiNorm) && Number.isFinite(vel) && vel > 1e-6) {
                                        // Compute TTC to the enter threshold.
                                        // If the sample already crossed the threshold (common in minimal fixtures), clamp TTC to 0
                                        // so we still emit a lookahead event (ordering is preserved by emitting before tripwire_cross).
                                        const ttcMsRaw = (enterDistanceUiNorm - orientedDistance) / vel * 1000;
                                        const ttcMs = Math.max(0, ttcMsRaw);
                                        if (Number.isFinite(ttcMs) && ttcMs <= 500) {
                                            // Only emit if within the lookahead window.
                                            if (ttcMs <= Number(c.lookaheadWindowMs || 120)) {
                                                const t = getTrace();
                                                const nowLookahead = (ttcMsRaw <= 0) ? Math.max(0, nowNum - 1) : nowNum;
                                                const payload = Object.freeze({
                                                    ts: new Date().toISOString(),
                                                    sensorId: 'knuckle',
                                                    now: nowLookahead,
                                                    dt: Number(dt || 0),
                                                    seq: ++seq,
                                                    handIndex,
                                                    pointerId: Number(pointerId ?? 0),
                                                    fsmState: 'COMMIT',
                                                    readiness,
                                                    uiNormX: Number.isFinite(uiNormX) ? uiNormX : 0,
                                                    uiNormY: Number.isFinite(uiNormY) ? uiNormY : 0,
                                                    ttcMs: Math.max(0, ttcMs),
                                                    lookaheadWindowMs: Number(c.lookaheadWindowMs || 120),
                                                    orientedDistanceUiNorm: orientedDistance,
                                                    orientedDistanceVelUiNormPerS: vel,
                                                    enterDistanceUiNorm,
                                                    exitDistanceUiNorm,
                                                    barExtensionUiNorm: (extA + extB),
                                                    barExtensionUiNormA: extA,
                                                    barExtensionUiNormB: extB,
                                                    traceId: t.traceId || undefined,
                                                    targetId: t.targetId || undefined,
                                                });

                                                emitP2('tripplane_lookahead', payload);
                                            }
                                        }
                                    }
                                }
                            } catch (_) {
                                // ignore
                            }

                            lastCursorByKey.set(k, {
                                now: nowNum,
                                x: Number.isFinite(uiNormX) ? uiNormX : 0,
                                y: Number.isFinite(uiNormY) ? uiNormY : 0,
                                rawDistance,
                                orientedDistance,
                                featureDistance: featureDistanceUiNorm
                            });

                            const nextPressed = hysteresisBool(prevPressed, featureDistanceUiNorm, c.on, c.off);
                            pressedByKey.set(k, nextPressed);

                            hands.push({
                                handIndex,
                                pointerId,
                                fsmState,
                                readiness,
                                pressed: nextPressed,
                                inExtendedSegment,
                                feature: featureDistanceUiNorm,
                                rawFeature: rawCross,
                                bar: { a: { x: aExt.x, y: aExt.y, z: aExt.z }, b: { x: bExt.x, y: bExt.y, z: bExt.z } },
                                tip: { x: tip.x, y: tip.y, z: tip.z }
                            });

                            if (nextPressed !== prevPressed) {
                                const phase = nextPressed ? 'begin' : 'end';
                                const t = getTrace();
                                const dtNum = Number(dt || 0);

                                // Direction semantics: prefer signed distance velocity across the bar.
                                // With wrist normalized to the positive side, +velocity means moving toward wrist/palm.
                                let direction = (orientedDistanceVelPerS > 0) ? 'down' : (orientedDistanceVelPerS < 0 ? 'up' : null);
                                if (!direction) direction = (vyPerS > 0) ? 'down' : (vyPerS < 0 ? 'up' : null);
                                if (!direction) direction = (phase === 'begin') ? 'down' : 'up';

                                const payload = Object.freeze({
                                    ts: new Date().toISOString(),
                                    sensorId: 'knuckle',
                                    now: nowNum,
                                    dt: dtNum,
                                    seq: ++seq,
                                    handIndex,
                                    pointerId: Number(pointerId ?? 0),
                                    fsmState,
                                    readiness,
                                    uiNormX: Number.isFinite(uiNormX) ? uiNormX : 0,
                                    uiNormY: Number.isFinite(uiNormY) ? uiNormY : 0,
                                    direction,
                                    vxUiNormPerS: vxPerS,
                                    vyUiNormPerS: vyPerS,
                                    speedUiNormPerS: speedPerS,
                                    traceId: t.traceId || undefined,
                                    targetId: t.targetId || undefined,
                                    sensor: Object.freeze({
                                        engine: 'knuckle',
                                        phase,
                                        bar: { a: { x: aExt.x, y: aExt.y, z: aExt.z }, b: { x: bExt.x, y: bExt.y, z: bExt.z } },
                                        tip: { x: tip.x, y: tip.y, z: tip.z },
                                        // v21: distance semantics (uiNorm units)
                                        distance: Object.freeze({
                                            featureDistanceUiNorm,
                                            rawDistanceUiNorm: rawDistance,
                                            orientedDistanceUiNorm: orientedDistance,
                                            rawDistanceVelUiNormPerS: rawDistanceVelPerS,
                                            orientedDistanceVelUiNormPerS: orientedDistanceVelPerS,
                                            featureDistanceVelUiNormPerS: featureDistanceVelPerS,
                                            barLenUiNorm: barLen,
                                            onDistanceUiNorm: c.on,
                                            offDistanceUiNorm: c.off
                                        }),
                                        feature: featureDistanceUiNorm,
                                        rawFeature: rawCross,
                                    })
                                });

                                // COMMIT-only emission to respect the injector boundary.
                                if (fsmState === 'COMMIT') {
                                    emitP2('tripwire_cross', payload);
                                    events.push(payload);
                                }
                            }
                        }

                        lastSnapshot = Object.freeze({ now: Number(now || 0), dt: Number(dt || 0), hands });
                        lastReport = Object.freeze({
                            ts: new Date().toISOString(),
                            now: Number(now || 0),
                            hands: hands.length,
                            events: events.length
                        });

                        try {
                            window.hfoPortsEffects?.setState?.('p2_knuckle_tripwire_thread', lastReport);
                        } catch (_) {
                            // ignore
                        }

                        return lastReport;
                    };

                    const debugEvaluate = (opts) => {
                        const now = Number(opts?.now || performance.now());
                        const dt = Number(opts?.dt || 16);
                        const handIndex = Number(opts?.handIndex || 0);
                        const pointerId = Number(opts?.pointerId ?? 10 + handIndex);
                        const readinessScore = Number(opts?.readinessScore ?? 0.9);
                        const fsmState = String(opts?.fsmState || 'COMMIT');
                        const landmarks = Array.isArray(opts?.landmarks) ? opts.landmarks : null;
                        const uiNormX = Number(opts?.uiNormX ?? 0.5);
                        const uiNormY = Number(opts?.uiNormY ?? 0.5);

                        const pseudo = Object.freeze({ handIndex, pointerId, readinessScore, fsmState, landmarks, uiNormX, uiNormY });
                        return Object.freeze({ now, dt, cursor: pseudo, report: tick({ now, dt, dataFabric: { cursors: [pseudo] } }) });
                    };

                    return Object.freeze({
                        tick,
                        debugEvaluate,
                        getLastReport: () => lastReport,
                        getSnapshot: () => lastSnapshot
                    });
                })();
            }
        }

        // --- GEN6 v23: P2 Commit Variants Thread (orthogonal atop base FSM) ---
        // Contract surface: systemState.p2.commitVariantByHand
        // Emits: p2/commit_variant (schema-valid) for deterministic tests and downstream routing.
        if (!window.hfoP2CommitVariantsThread) {
            window.hfoP2CommitVariantsThread = (() => {
                const mapGestureToVariant = ({ fsmState, gesture }) => {
                    const g = String(gesture || '');
                    const s = String(fsmState || '');
                    // v23.2: real camera inference often reports Thumb_Up/Down while already in COMMIT.
                    // Keep READY support (tests/legacy), but allow COMMIT so downstream logic can rely on commitVariantByHand.
                    if (s !== 'READY' && s !== 'COMMIT') return 'NONE';
                    if (g === 'Pointing_Up') return 'COMMIT_POINTER_UP';
                    if (g === 'Thumb_Up') return 'COMMIT_THUMBS_UP';
                    if (g === 'Thumb_Down') return 'COMMIT_THUMBS_DOWN';
                    return 'NONE';
                };

                const emitP2 = (payload) => {
                    try {
                        window.hfoPortsEffects?.emit?.('p2', 'commit_variant', payload);
                        return true;
                    } catch (_) {
                        return false;
                    }
                };

                const tick = ({ now, dt, dataFabric }) => {
                    const cursors = dataFabric?.cursors || [];
                    const nowNum = Number(now || 0);
                    const dtNum = Number(dt || 0);
                    const ts = new Date().toISOString();

                    const next = { ...(systemState?.p2?.commitVariantByHand || {}) };

                    for (const cursor of cursors) {
                        const handIndex = Number(cursor?.handIndex ?? 0);
                        const pointerId = Number(cursor?.pointerId ?? 0);
                        const fsmState = String(cursor?.fsmState || '');
                        const gesture = String(cursor?.gesture || 'None');
                        const confidence = Math.max(0, Math.min(1, Number(cursor?.confidence ?? 0)));

                        const commitVariant = mapGestureToVariant({ fsmState, gesture });
                        const key = `hand${handIndex}`;
                        const prev = String(next[key] || 'NONE');
                        next[key] = commitVariant;

                        if (commitVariant !== prev) {
                            emitP2({
                                ts,
                                now: nowNum,
                                dt: dtNum,
                                handIndex,
                                pointerId,
                                fsmState,
                                commitVariant,
                                sourceCategory: 'gesture',
                                confidence,
                            });
                        }
                    }

                    systemState.p2.commitVariantByHand = next;
                    try { window.hfoPortsEffects?.setState?.('p2_commit_variants', next); } catch (_) { }
                    return next;
                };

                return Object.freeze({ tick });
            })();
        }

        // --- GEN6 v23: P2 Sword Meter Thread (READY + Thumb_Up/Thumb_Down leaky bucket) ---
        // Contract surface (RED tests): systemState.p2.swordMeter (and alias systemState.p2.sword)
        // Inspectable markers: window.__hfoSwordTouch2dMarker + window.__hfoSwordBabylonMarker
        if (!window.hfoP2SwordMeterThread) {
            window.hfoP2SwordMeterThread = (() => {
                const clamp01 = (x) => Math.max(0, Math.min(1, Number(x) || 0));

                const cfg = () => {
                    const p = systemState?.parameters?.p2?.swordMeter || {};
                    const kt = systemState?.parameters?.p2?.knuckleTripwire || {};
                    return {
                        fillMs: Math.max(1, Number(p.fillMs ?? 800) || 800),
                        drainMs: Math.max(1, Number(p.drainMs ?? 800) || 800),
                        minConfidence: Math.max(0, Math.min(1, Number(p.minConfidence ?? 0.64) || 0.64)),
                        lockAt01: Math.max(0, Math.min(1, Number(p.lockAt01 ?? 1.0) || 1.0)),
                        unlockAt01: Math.max(0, Math.min(1, Number(p.unlockAt01 ?? 0.0) || 0.0)),
                        baseScale01: Math.max(0, Math.min(1, Number(p.baseScale01 ?? 0.2) || 0.2)),
                        extensionFracA: Number(p.knuckleSpanMultiplierA ?? kt.barExtensionFracA ?? 8.0) || 8.0,
                        extensionFracB: Number(p.knuckleSpanMultiplierB ?? kt.barExtensionFracB ?? 0.25) || 0.25,
                    };
                };

                const emitP2 = (type, payload) => {
                    try {
                        window.hfoPortsEffects?.emit?.('p2', type, payload);
                        return true;
                    } catch (_) {
                        return false;
                    }
                };

                const updateMarkers = ({ active, locked, meter01, centerX, centerY, extensionFracA, extensionFracB, baseEndpointA, baseEndpointB, axisUiNorm, baseLenUiNorm }) => {
                    try {
                        const weaponName = 'PHOENIX_PYREBLADE';
                        const baseLen = (Number.isFinite(baseLenUiNorm) && Number(baseLenUiNorm) > 0.0001)
                            ? Number(baseLenUiNorm)
                            : 0.12;

                        const axis = (axisUiNorm && Number.isFinite(axisUiNorm.x) && Number.isFinite(axisUiNorm.y))
                            ? { x: Number(axisUiNorm.x), y: Number(axisUiNorm.y) }
                            : { x: 1.0, y: 0.0 }; // pinkyâ†’index (rightwards)

                        const fallbackB = { x: centerX - baseLen / 2, y: centerY };
                        const fallbackA = { x: centerX + baseLen / 2, y: centerY };
                        const baseEndpointBFinal = (baseEndpointB && Number.isFinite(baseEndpointB.x) && Number.isFinite(baseEndpointB.y))
                            ? { x: Number(baseEndpointB.x), y: Number(baseEndpointB.y) }
                            : fallbackB;
                        const baseEndpointAFinal = (baseEndpointA && Number.isFinite(baseEndpointA.x) && Number.isFinite(baseEndpointA.y))
                            ? { x: Number(baseEndpointA.x), y: Number(baseEndpointA.y) }
                            : fallbackA;

                        const scale01 = Math.max(0, Math.min(1, Number(cfg().baseScale01) + (1 - Number(cfg().baseScale01)) * clamp01(meter01)));
                        const extA = baseLen * Number(extensionFracA || 0) * scale01;
                        const extB = baseLen * Number(extensionFracB || 0) * scale01;

                        const endpointA = { x: baseEndpointAFinal.x + axis.x * extA, y: baseEndpointAFinal.y + axis.y * extA };
                        const endpointB = { x: baseEndpointBFinal.x - axis.x * extB, y: baseEndpointBFinal.y - axis.y * extB };

                        // Marker contract is unconditional (exists even when inactive) for deterministic tests.
                        window.__hfoSwordTouch2dMarker = {
                            weaponName,
                            active: !!active,
                            locked: !!locked,
                            endpointPinkyUiNorm: baseEndpointBFinal,
                            endpointIndexUiNorm: baseEndpointAFinal,
                            endpointAUiNorm: endpointA,
                            endpointBUiNorm: endpointB,
                            axisUiNorm: axis,
                            thicknessUiNorm: 0.01,
                            baseEndpointAUiNorm: baseEndpointAFinal,
                            baseEndpointBUiNorm: baseEndpointBFinal,
                        };

                        window.__hfoSwordBabylonMarker = { weaponName, active: !!active, locked: !!locked, meshName: 'HFO_SWORD_V23' };
                        window.__hfoSwordMeshName = 'HFO_SWORD_V23';
                    } catch (_) {
                        // ignore
                    }
                };

                const tick = ({ now, dt, dataFabric }) => {
                    const c = cfg();
                    const cursors = dataFabric?.cursors || [];
                    const tNow = Number(now || 0);
                    const dtMs = Math.max(0, Number(dt || 0));

                    const ts = new Date().toISOString();

                    // Default: keep last snapshot (and markers) coherent even without cursors.
                    const snap = systemState?.p2?.swordMeter || null;
                    if (!snap) return null;

                    // Use the first cursor as the controlling hand for v23 MVP.
                    const cursor = cursors.length ? cursors[0] : null;
                    const handIndex = Number(cursor?.handIndex ?? snap.lockedBy?.handIndex ?? 0);
                    const pointerId = Number(cursor?.pointerId ?? snap.lockedBy?.pointerId ?? 0);
                    const fsmState = String(cursor?.fsmState || '');
                    const gesture = String(cursor?.gesture || 'None');
                    const confidence = Number(cursor?.confidence ?? 0);
                    // v23.1 hardening: allow control while in READY or COMMIT.
                    // Real camera inference can switch base FSM to COMMIT when Thumb_Up/Down is detected.
                    const inArmed = (fsmState === 'READY' || fsmState === 'COMMIT');

                    let meter01 = clamp01(snap.meter01);
                    let locked = !!snap.locked;
                    let active = !!snap.active;

                    // Best-effort: source of truth is the commit-variants thread; fallback to local mapping.
                    const byHand = systemState?.p2?.commitVariantByHand || {};
                    const k = `hand${handIndex}`;
                    const fallbackVariant = (gesture === 'Pointing_Up') ? 'COMMIT_POINTER_UP'
                        : (gesture === 'Thumb_Up') ? 'COMMIT_THUMBS_UP'
                            : (gesture === 'Thumb_Down') ? 'COMMIT_THUMBS_DOWN'
                                : 'NONE';
                    const byHandVariant = String(byHand?.[k] || '');
                    const lastCommitVariant = (byHandVariant && byHandVariant !== 'NONE')
                        ? byHandVariant
                        : String(fallbackVariant || 'NONE');

                    const thumbUp = (lastCommitVariant === 'COMMIT_THUMBS_UP');
                    const thumbDown = (lastCommitVariant === 'COMMIT_THUMBS_DOWN');
                    const confident = (confidence >= c.minConfidence);

                    let changed = false;

                    if (inArmed && confident && thumbUp) {
                        meter01 = clamp01(meter01 + (dtMs / c.fillMs));
                        changed = true;
                        if (!locked && meter01 >= c.lockAt01) {
                            locked = true;
                            active = true;
                            emitP2('sword', {
                                ts,
                                now: tNow,
                                dt: dtMs,
                                handIndex,
                                pointerId,
                                fsmState,
                                active,
                                locked,
                                meter01,
                                lockedBy: { handIndex, pointerId },
                                lastCommitVariant,
                                reason: 'lock'
                            });
                        }
                    }

                    if (inArmed && confident && thumbDown) {
                        meter01 = clamp01(meter01 - (dtMs / c.drainMs));
                        changed = true;
                        if (locked && meter01 <= c.unlockAt01) {
                            locked = false;
                            active = false;
                            emitP2('sword', {
                                ts,
                                now: tNow,
                                dt: dtMs,
                                handIndex,
                                pointerId,
                                fsmState,
                                active,
                                locked,
                                meter01,
                                lockedBy: { handIndex, pointerId },
                                lastCommitVariant,
                                reason: 'unlock'
                            });
                        }
                    }

                    // Sticky: once locked, remain active across base FSM states.
                    if (locked) active = true;

                    const next = {
                        weaponName: 'PHOENIX_PYREBLADE',
                        active,
                        locked,
                        meter01,
                        lockedBy: { handIndex, pointerId },
                        lastCommitVariant,
                        extensionFracA: c.extensionFracA,
                        extensionFracB: c.extensionFracB,
                    };

                    systemState.p2.swordMeter = next;
                    systemState.p2.sword = next;

                    // Update inspectable markers (required by RED geometry tests).
                    const centerX = Number.isFinite(cursor?.uiNormX) ? Number(cursor.uiNormX) : 0.5;
                    const centerY = Number.isFinite(cursor?.uiNormY) ? Number(cursor.uiNormY) : 0.5;

                    let baseEndpointA = null;
                    let baseEndpointB = null;
                    let axisUiNorm = null;
                    let baseLenUiNorm = null;

                    // v23.2: when landmarks are present, treat the knuckle trip-lane (pinkyâ†’index) as the sword core.
                    // This matches your intent: a blade from pinky toward index that extends out.
                    try {
                        if (isFlagEnabled('p2-sword-marker-live-landmarks')) {
                            const lms = cursor?.landmarks;
                            const a = lms?.[5];
                            const b = lms?.[17];
                            if (a && b && Number.isFinite(a.x) && Number.isFinite(a.y) && Number.isFinite(b.x) && Number.isFinite(b.y)) {
                                baseEndpointA = { x: Number(a.x), y: Number(a.y) }; // index knuckle
                                baseEndpointB = { x: Number(b.x), y: Number(b.y) }; // pinky knuckle
                                const dx = baseEndpointA.x - baseEndpointB.x;
                                const dy = baseEndpointA.y - baseEndpointB.y;
                                const len = Math.sqrt(dx * dx + dy * dy);
                                if (len > 1e-6) {
                                    axisUiNorm = { x: dx / len, y: dy / len };
                                    baseLenUiNorm = len;
                                }
                            }
                        }
                    } catch (_) {
                        // ignore
                    }

                    updateMarkers({
                        active,
                        locked,
                        meter01,
                        centerX,
                        centerY,
                        extensionFracA: c.extensionFracA,
                        extensionFracB: c.extensionFracB,
                        baseEndpointA,
                        baseEndpointB,
                        axisUiNorm,
                        baseLenUiNorm,
                    });

                    if (changed) {
                        emitP2('sword', {
                            ts,
                            now: tNow,
                            dt: dtMs,
                            handIndex,
                            pointerId,
                            fsmState,
                            active,
                            locked,
                            meter01,
                            lockedBy: { handIndex, pointerId },
                            lastCommitVariant,
                            reason: thumbUp ? 'fill' : thumbDown ? 'drain' : 'tick'
                        });
                    }

                    try {
                        window.hfoPortsEffects?.setState?.('p2_sword_meter', next);
                    } catch (_) {
                        // ignore
                    }

                    return next;
                };

                return Object.freeze({ tick });
            })();
        }

        // --- GEN6 v23.2: sword debug HUD (manual camera tuning) ---
        // Non-contract UI overlay: shows confidence/variant/meter/lock so real-camera tuning is fast.
        if (!window.hfoSwordDebugHudUpdate) {
            window.hfoSwordDebugHudUpdate = (() => {
                let el = null;
                let lastMs = 0;

                const ensure = () => {
                    if (el && el.isConnected) return el;

                    el = document.createElement('div');
                    el.id = 'hfo-sword-debug-hud';
                    el.style.position = 'fixed';
                    el.style.left = '8px';
                    el.style.top = '40px';
                    el.style.zIndex = '999999';
                    el.style.pointerEvents = 'none';
                    el.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                    el.style.fontSize = '12px';
                    el.style.lineHeight = '1.25';
                    el.style.color = '#d6ffe1';
                    el.style.background = 'rgba(0,0,0,0.55)';
                    el.style.border = '1px solid rgba(0,255,65,0.35)';
                    el.style.borderRadius = '6px';
                    el.style.padding = '6px 8px';
                    el.style.whiteSpace = 'pre';
                    el.style.userSelect = 'none';
                    el.textContent = 'HFO sword HUDâ€¦';

                    document.body.appendChild(el);
                    return el;
                };

                const fmt01 = (x) => {
                    const n = Number(x);
                    if (!Number.isFinite(n)) return 'n/a';
                    return n.toFixed(2);
                };

                const tick = (systemState) => {
                    const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                    if (nowMs - lastMs < 100) return; // ~10 Hz
                    lastMs = nowMs;

                    const snap = systemState?.p2?.swordMeter || systemState?.p2?.sword || null;
                    const cursor = systemState?.dataFabric?.cursors?.[0] || null;

                    const fsmState = String(cursor?.fsmState || '');
                    const gesture = String(cursor?.gesture || 'None');
                    const confidence = Number(cursor?.confidence);
                    const inArmed = (fsmState === 'READY' || fsmState === 'COMMIT');

                    const byHand = systemState?.p2?.commitVariantByHand || {};
                    const handIndex = Number(cursor?.handIndex ?? snap?.lockedBy?.handIndex ?? 0);
                    const k = `hand${handIndex}`;
                    const byHandVariant = String(byHand?.[k] || '');

                    const minConfidence = Number(systemState?.parameters?.p2?.swordMeter?.minConfidence);

                    const lines = [
                        '[HFO Sword HUD v23.5]',
                        `weapon=PHOENIX_PYREBLADE`,
                        `fsm=${fsmState || 'n/a'} armed=${inArmed ? 'Y' : 'N'}`,
                        `gesture=${gesture}`,
                        `confidence=${fmt01(confidence)} min=${fmt01(minConfidence)}`,
                        `variant(hand${handIndex})=${byHandVariant || 'n/a'}`,
                        `meter01=${fmt01(snap?.meter01)} locked=${snap?.locked ? 'Y' : 'N'} active=${snap?.active ? 'Y' : 'N'}`,
                        `lastCommitVariant=${String(snap?.lastCommitVariant || 'n/a')}`,
                        `markerLiveLandmarks=${isFlagEnabled('p2-sword-marker-live-landmarks') ? 'Y' : 'N'}`,
                        `babylon=${isFlagEnabled('engine-babylon') ? 'Y' : 'N'} vfx=${isFlagEnabled('p2-sword-vfx') ? 'Y' : 'N'}`,
                    ];

                    const node = ensure();
                    node.textContent = lines.join('\n');
                };

                return Object.freeze(tick);
            })();
        }

        // --- GEN6 v16: P2 SensorThread (Tripwire Thread / pluck semantics) ---
        // Concept: a horizontal sensor-thread (string) that can be "plucked" by a COMMIT pointer crossing.
        // v16 goal: direction + velocity aware; contact-only mode emits begin/end from Planck sensor contacts.
        window.hfoP2TripwireThread = window.hfoP2TripwireThread || (() => {
            const getTrace = () => {
                try {
                    return {
                        traceId: (typeof systemState?.trace?.traceId === 'string' && systemState.trace.traceId.length)
                            ? systemState.trace.traceId
                            : null,
                        targetId: (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                            ? systemState.trace.targetId
                            : null
                    };
                } catch (_) {
                    return { traceId: null, targetId: null };
                }
            };

            const cfg = () => {
                const p = systemState?.parameters?.p2?.tripwireThread || systemState?.parameters?.p2?.tripwire || {};
                const band = p.band || {};
                const fallbackWindowMs = Number(p.lookaheadWindowMs ?? 0);
                const windowMsFromUrl = getFlagNumber('p2-tripwire-lookahead-window-ms', fallbackWindowMs);
                const lookaheadWindowMs = Math.max(0, Math.min(500, Number(windowMsFromUrl) || 0));
                const lookaheadEnabled = (p.lookaheadEnabled === true) || isFlagEnabled('p2-tripwire-lookahead');
                return {
                    enabled: (p.enabled !== false),
                    emitTelemetry: (p.emitTelemetry !== false),
                    // v14: allow repeated down-cross triggers with cooldown.
                    cooldownMs: Math.max(0, Number(p.cooldownMs ?? 250) || 250),
                    emitDownOnly: (p.emitDownOnly !== false),
                    commitOnly: (p.commitOnly !== false),
                    // v17: analytic lookahead (TTC) event for predictive pre-arm.
                    lookaheadEnabled,
                    lookaheadWindowMs,
                    // Contact-only implies we must rely on Planck contacts.
                    usePlanckContact: isFlagEnabled('p2-tripwire-planck-contact') || isFlagEnabled('p2-tripwire-contact-only'),
                    // v16: when enabled, suppress geometric crossing fallback and drive events by Planck begin/end.
                    contactOnly: isFlagEnabled('p2-tripwire-contact-only'),
                    // NOTE: Port3 mapping is intentionally not performed here (P3 is sole injector).
                    band: {
                        centerUiNormY: Number(band.centerUiNormY ?? 0.5),
                        thicknessUiNorm: Math.max(0, Number(band.thicknessUiNorm ?? 0.06) || 0.06),
                        spanUiNormXMin: Math.max(0, Number(band.spanUiNormXMin ?? 0.0) || 0.0),
                        spanUiNormXMax: Math.min(1, Number(band.spanUiNormXMax ?? 1.0) || 1.0)
                    }
                };
            };

            const emitP2 = (type, payload) => {
                try {
                    if (!cfg().emitTelemetry) return false;
                    window.hfoPortsEffects?.emit?.('p2', type, payload);
                    return true;
                } catch (_) {
                    return false;
                }
            };

            // Planck world in uiNorm units (0..1). Deterministic replay target.
            const world = planck.World({ gravity: planck.Vec2(0, 0) });
            const bandBody = world.createBody({ type: 'static' });
            const cursorBodies = new Map(); // key: pointerId -> { body, fixture }

            const stableId = (prefix, extra) => {
                const s = (typeof extra === 'string' && extra.length) ? extra : 'v1';
                return `${prefix}:${s}`;
            };

            try {
                bandBody.setUserData({ role: 'tripwire_band', bodyId: stableId('body', 'tripwire_band') });
            } catch (_) {
                // ignore
            }

            // Sensor fixtures: recreated on demand if band params change.
            let bandFixture = null;
            let lastBandKey = null;

            let contactListenersInstalled = false;
            let contactQueue = [];
            let lastStepError = null;
            let lastContactCount = 0;

            const ensureCursorBody = (pointerId) => {
                const pid = String(Number(pointerId ?? 0));
                if (!pid || pid === 'NaN') return null;
                if (cursorBodies.has(pid)) return cursorBodies.get(pid);
                try {
                    const body = world.createBody({
                        type: 'dynamic',
                        bullet: true,
                        allowSleep: false,
                        position: planck.Vec2(0.5, 0.5)
                    });
                    const bodyId = stableId('body', `cursor:${pid}`);
                    body.setUserData({ role: 'cursor', bodyId, pointerId: Number(pointerId ?? 0) });
                    const fixture = body.createFixture(planck.Circle(0.005), { isSensor: true, density: 1.0 });
                    fixture.setUserData({
                        role: 'cursor',
                        fixtureId: stableId('fix', `cursor:${pid}`),
                        bodyId,
                        pointerId: Number(pointerId ?? 0)
                    });
                    const entry = { body, fixture };
                    cursorBodies.set(pid, entry);
                    return entry;
                } catch (_) {
                    return null;
                }
            };

            const ensureContactListeners = () => {
                if (contactListenersInstalled) return;
                contactListenersInstalled = true;

                const tryManifold = (contact) => {
                    try {
                        if (typeof contact?.getWorldManifold !== 'function') return null;
                        const wm = contact.getWorldManifold(null);
                        if (!wm) return null;
                        const normal = wm.normal ? { x: Number(wm.normal.x || 0), y: Number(wm.normal.y || 0) } : undefined;
                        const points = Array.isArray(wm.points)
                            ? wm.points.map((p) => ({ x: Number(p?.x || 0), y: Number(p?.y || 0) }))
                            : undefined;
                        return { normal, points };
                    } catch (_) {
                        return null;
                    }
                };

                const onContact = (phase, contact) => {
                    try {
                        if (!bandFixture) return;
                        const fa = contact?.getFixtureA?.();
                        const fb = contact?.getFixtureB?.();
                        if (!fa || !fb) return;

                        const uda = (typeof fa.getUserData === 'function') ? fa.getUserData() : null;
                        const udb = (typeof fb.getUserData === 'function') ? fb.getUserData() : null;
                        const roles = new Set([String(uda?.role || ''), String(udb?.role || '')]);
                        if (!(roles.has('cursor') && roles.has('tripwire_band'))) return;

                        const cursorUD = (String(uda?.role || '') === 'cursor') ? uda : udb;
                        const bandUD = (String(uda?.role || '') === 'tripwire_band') ? uda : udb;
                        const manifold = tryManifold(contact);

                        const pid = Number(cursorUD?.pointerId ?? 0);

                        contactQueue.push(Object.freeze({
                            phase,
                            pointerId: pid,
                            cursor: {
                                role: 'cursor',
                                bodyId: String(cursorUD?.bodyId || stableId('body', `cursor:${pid || 'unknown'}`)),
                                fixtureId: String(cursorUD?.fixtureId || stableId('fix', `cursor:${pid || 'unknown'}`))
                            },
                            band: {
                                role: 'tripwire_band',
                                bodyId: String(bandUD?.bodyId || stableId('body', 'tripwire_band')),
                                fixtureId: String(bandUD?.fixtureId || stableId('fix', `tripwire_band:${lastBandKey || 'unknown'}`)),
                                bandKey: String(bandUD?.bandKey || (lastBandKey || 'unknown'))
                            },
                            manifold: manifold || undefined
                        }));
                    } catch (_) {
                        // ignore
                    }
                };

                try {
                    world.on('begin-contact', (contact) => onContact('begin', contact));
                    world.on('end-contact', (contact) => onContact('end', contact));
                } catch (_) {
                    // ignore
                }
            };

            const ensureBandFixture = () => {
                const c = cfg();
                const y = c.band.centerUiNormY;
                const t = c.band.thicknessUiNorm;
                const xMin = c.band.spanUiNormXMin;
                const xMax = c.band.spanUiNormXMax;
                const key = `${y}:${t}:${xMin}:${xMax}`;
                if (key === lastBandKey && bandFixture) return;
                lastBandKey = key;

                try {
                    // Remove all prior fixtures.
                    for (let f = bandBody.getFixtureList(); f;) {
                        const next = f.getNext();
                        bandBody.destroyFixture(f);
                        f = next;
                    }
                } catch (_) {
                    // ignore
                }

                const width = Math.max(0, xMax - xMin);
                const hx = Math.max(0.0001, width / 2);
                const hy = Math.max(0.0001, t / 2);
                const cx = xMin + hx;
                const cy = y;
                bandFixture = bandBody.createFixture(planck.Box(hx, hy, planck.Vec2(cx, cy), 0), { isSensor: true });

                try {
                    bandFixture.setUserData({
                        role: 'tripwire_band',
                        fixtureId: stableId('fix', `tripwire_band:${key}`),
                        bodyId: (typeof bandBody.getUserData === 'function' && bandBody.getUserData()?.bodyId)
                            ? bandBody.getUserData().bodyId
                            : stableId('body', 'tripwire_band'),
                        bandKey: key
                    });
                } catch (_) {
                    // ignore
                }

                // Cursor fixtures are per-pointer (ensureCursorBody).
            };

            const perPointer = new Map();
            let lastCross = null;

            const tick = ({ now, dt, dataFabric }) => {
                const c0 = cfg();
                if (!c0.enabled) return null;

                ensureBandFixture();
                ensureContactListeners();

                const nowNum = Number(now || 0);
                const dtMs = Math.max(1, Number(dt || 16));
                const dtSec = Math.min(dtMs / 1000, 0.033);
                const cursors = Array.isArray(dataFabric?.cursors) ? dataFabric.cursors : [];
                const bandY = c0.band.centerUiNormY;

                // Stage pointer samples.
                const staged = [];
                for (const cur of cursors) {
                    const handIndex = Number(cur?.handIndex ?? 0);
                    const pointerId = Number(cur?.pointerId ?? (10 + handIndex));
                    const x = Number(cur?.uiNormX ?? cur?.normX);
                    const y = Number(cur?.uiNormY ?? cur?.normY);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

                    const fsmState = String(cur?.fsmState || '');
                    const seq = (typeof cur?.seq === 'string' && cur.seq.length)
                        ? cur.seq
                        : (fsmState && typeof fsmState === 'string')
                            ? `${fsmState.toLowerCase()}_cross`
                            : null;

                    staged.push({ cur, handIndex, pointerId, x, y, fsmState, seq });

                    // Update Planck cursor body position for this pointer.
                    const entry = ensureCursorBody(pointerId);
                    try {
                        const pidKey = String(Number(pointerId ?? 0));
                        const prev = perPointer.get(pidKey) || null;
                        const dx = prev ? (x - Number(prev.x || 0)) : 0;
                        const dy = prev ? (y - Number(prev.y || 0)) : 0;
                        const vxPerS = dx / (dtMs / 1000);
                        const vyPerS = dy / (dtMs / 1000);
                        entry?.body?.setTransform?.(planck.Vec2(x, y), 0);
                        entry?.body?.setLinearVelocity?.(planck.Vec2(vxPerS, vyPerS));
                        entry?.body?.setAwake?.(true);
                    } catch (_) {
                        // ignore
                    }
                }

                // Step physics once per frame and collect contacts across all pointers.
                try {
                    contactQueue = [];
                    world.step(dtSec);
                    lastStepError = null;
                } catch (_) {
                    try {
                        lastStepError = String(_?.message || _);
                    } catch {
                        lastStepError = 'unknown';
                    }
                }

                lastContactCount = Array.isArray(contactQueue) ? contactQueue.length : 0;

                const byPointerContacts = new Map();
                for (const ev of (Array.isArray(contactQueue) ? contactQueue : [])) {
                    const pid = String(Number(ev?.pointerId ?? 0));
                    if (!pid || pid === 'NaN') continue;
                    if (!byPointerContacts.has(pid)) byPointerContacts.set(pid, []);
                    byPointerContacts.get(pid).push(ev);
                }

                const t = getTrace();

                const emitCross = (phase, s, planckEv, direction, vxPerS, vyPerS, speedPerS) => {
                    const c2 = cfg();

                    const pidKey = String(Number(s.pointerId ?? 0));
                    const stPrev = perPointer.get(pidKey) || null;
                    const lastBegin = Number(stPrev?.lastEmitBeginNow || 0);
                    const lastLook = Number(stPrev?.lastEmitLookaheadNow || 0);

                    const persistSample = () => {
                        perPointer.set(pidKey, {
                            x: s.x,
                            y: s.y,
                            now: nowNum,
                            fsmState: s.fsmState,
                            seq: s.seq,
                            lastEmitBeginNow: lastBegin,
                            lastEmitLookaheadNow: lastLook
                        });
                    };

                    // Even if a potential cross is suppressed, we still need to track the pointer sample
                    // so subsequent frames can detect fresh crossings.
                    if (c2.emitDownOnly && direction !== 'down') {
                        persistSample();
                        return false;
                    }
                    if (c2.commitOnly && s.fsmState !== 'COMMIT') {
                        persistSample();
                        return false;
                    }
                    if (String(phase || '') === 'begin' && (nowNum - lastBegin) < c2.cooldownMs) {
                        persistSample();
                        return false;
                    }

                    // Persist state for cooldown tracking (begin-only).
                    perPointer.set(pidKey, {
                        x: s.x,
                        y: s.y,
                        now: nowNum,
                        fsmState: s.fsmState,
                        seq: s.seq,
                        lastEmitBeginNow: (String(phase || '') === 'begin') ? nowNum : lastBegin,
                        lastEmitLookaheadNow: lastLook
                    });

                    const readiness = Number(s.cur?.readinessScore ?? 0);

                    lastCross = Object.freeze({
                        ts: new Date().toISOString(),
                        sensorId: 'static',
                        now: nowNum,
                        dt: dtMs,
                        seq: s.seq,
                        handIndex: Number(s.handIndex ?? 0),
                        pointerId: Number(s.pointerId ?? 0),
                        fsmState: s.fsmState,
                        readiness,
                        uiNormX: s.x,
                        uiNormY: s.y,
                        direction,
                        vxUiNormPerS: vxPerS,
                        vyUiNormPerS: vyPerS,
                        speedUiNormPerS: speedPerS,
                        traceId: t.traceId || undefined,
                        targetId: t.targetId || undefined,
                        sensor: (planckEv && c2.usePlanckContact)
                            ? Object.freeze({
                                engine: 'planck',
                                phase: String(planckEv?.phase || phase || 'begin'),
                                cursor: planckEv.cursor,
                                band: planckEv.band,
                                manifold: planckEv?.manifold || undefined
                            })
                            : undefined
                    });

                    emitP2('tripwire_cross', lastCross);
                    try {
                        window.hfoPortsEffects?.setState?.('p2_tripwire_thread', lastCross);
                    } catch (_) {
                        // ignore
                    }
                    return true;
                };

                const emitLookahead = (s, direction, vxPerS, vyPerS, speedPerS) => {
                    const c2 = cfg();
                    if (!c2.lookaheadEnabled) return false;
                    const windowMs = Number(c2.lookaheadWindowMs ?? 0);
                    if (!Number.isFinite(windowMs) || windowMs <= 0) return false;

                    // Hard gate: COMMIT intent only.
                    if (String(s?.fsmState || '') !== 'COMMIT') return false;

                    // Initial policy: down direction only.
                    if (String(direction || '') !== 'down') return false;

                    if (!Number.isFinite(vyPerS) || vyPerS <= 0) return false;
                    if (!Number.isFinite(s?.y) || s.y >= bandY) return false;

                    const ttcMs = ((bandY - Number(s.y)) / vyPerS) * 1000;
                    if (!Number.isFinite(ttcMs) || ttcMs <= 0 || ttcMs > windowMs) return false;

                    const pidKey = String(Number(s.pointerId ?? 0));
                    const prev = perPointer.get(pidKey) || null;
                    const lastLook = Number(prev?.lastEmitLookaheadNow || 0);

                    // Prevent spam: reuse cooldownMs as a simple lookahead cooldown.
                    if ((nowNum - lastLook) < Number(c2.cooldownMs || 0)) return false;

                    const readiness = Number(s.cur?.readinessScore ?? 0);
                    const t = getTrace();

                    const payload = Object.freeze({
                        ts: new Date().toISOString(),
                        now: nowNum,
                        dt: dtMs,
                        seq: s.seq,
                        handIndex: Number(s.handIndex ?? 0),
                        pointerId: Number(s.pointerId ?? 0),
                        fsmState: String(s.fsmState || ''),
                        readiness,
                        uiNormX: s.x,
                        uiNormY: s.y,
                        direction,
                        vxUiNormPerS: vxPerS,
                        vyUiNormPerS: vyPerS,
                        speedUiNormPerS: speedPerS,
                        bandY: Number(bandY),
                        ttcMs: Number(ttcMs),
                        lookaheadWindowMs: Number(windowMs),
                        traceId: t.traceId || undefined,
                        targetId: t.targetId || undefined,
                    });

                    emitP2('tripwire_lookahead', payload);
                    try {
                        window.hfoPortsEffects?.setState?.('p2_tripwire_lookahead', payload);
                    } catch (_) {
                        // ignore
                    }

                    // Persist pointer state with updated lookahead timestamp.
                    const keepLastBegin = Number(prev?.lastEmitBeginNow || 0);
                    perPointer.set(pidKey, {
                        x: s.x,
                        y: s.y,
                        now: nowNum,
                        fsmState: s.fsmState,
                        seq: s.seq,
                        lastEmitBeginNow: keepLastBegin,
                        lastEmitLookaheadNow: nowNum
                    });

                    return true;
                };

                for (const s of staged) {
                    const pidKey = String(Number(s.pointerId ?? 0));
                    const prev = perPointer.get(pidKey) || null;
                    const dx = prev ? (s.x - Number(prev.x || 0)) : 0;
                    const dy = prev ? (s.y - Number(prev.y || 0)) : 0;
                    const vxPerS = dx / (dtMs / 1000);
                    const vyPerS = dy / (dtMs / 1000);
                    const speedPerS = Math.sqrt((vxPerS * vxPerS) + (vyPerS * vyPerS));

                    const directionFromGeo = (prev && Number.isFinite(prev.y) && Number.isFinite(s.y))
                        ? (Number(prev.y) < bandY && s.y >= bandY)
                            ? 'down'
                            : (Number(prev.y) > bandY && s.y <= bandY)
                                ? 'up'
                                : null
                        : null;

                    const directionFromVy = (vyPerS > 0) ? 'down' : (vyPerS < 0) ? 'up' : null;
                    const directionResolved = directionFromGeo || directionFromVy || (s.y >= bandY ? 'down' : 'up');

                    // v17.3 lookahead: attempt emission before crossing (TTC prediction).
                    // Note: emits only when within window and COMMIT-gated.
                    try {
                        emitLookahead(s, directionResolved, vxPerS, vyPerS, speedPerS);
                    } catch (_) {
                        // ignore
                    }

                    const c2 = cfg();
                    const contacts = byPointerContacts.get(pidKey) || [];
                    const beginEv = c2.usePlanckContact ? contacts.find((e) => String(e?.phase || '') === 'begin') : null;
                    const endEv = c2.usePlanckContact ? contacts.find((e) => String(e?.phase || '') === 'end') : null;

                    // v16 contact-only: drive by Planck begin/end, no geometric fallback.
                    if (c2.contactOnly) {
                        const syntheticPlanckEvent = (phase) => {
                            try {
                                const cursorEntry = cursorBodies.get(pidKey) || null;
                                const cursorUD = (cursorEntry?.fixture && typeof cursorEntry.fixture.getUserData === 'function')
                                    ? cursorEntry.fixture.getUserData()
                                    : (cursorEntry?.body && typeof cursorEntry.body.getUserData === 'function')
                                        ? cursorEntry.body.getUserData()
                                        : null;
                                const bandUD = (bandFixture && typeof bandFixture.getUserData === 'function') ? bandFixture.getUserData() : null;
                                const pidNum = Number(s.pointerId ?? 0);

                                return Object.freeze({
                                    phase: String(phase || 'begin'),
                                    pointerId: pidNum,
                                    cursor: {
                                        role: 'cursor',
                                        bodyId: String(cursorUD?.bodyId || stableId('body', `cursor:${pidKey || pidNum || 'unknown'}`)),
                                        fixtureId: String(cursorUD?.fixtureId || stableId('fix', `cursor:${pidKey || pidNum || 'unknown'}`))
                                    },
                                    band: {
                                        role: 'tripwire_band',
                                        bodyId: String(bandUD?.bodyId || stableId('body', 'tripwire_band')),
                                        fixtureId: String(bandUD?.fixtureId || stableId('fix', `tripwire_band:${lastBandKey || 'unknown'}`)),
                                        bandKey: String(bandUD?.bandKey || (lastBandKey || 'unknown'))
                                    },
                                    manifold: undefined
                                });
                            } catch (_) {
                                return null;
                            }
                        };

                        if (beginEv) {
                            emitCross('begin', s, beginEv, directionResolved, vxPerS, vyPerS, speedPerS);
                        }
                        if (endEv) {
                            // End events must not be blocked by begin cooldown; emitCross enforces cooldown on begin only.
                            emitCross('end', s, endEv, directionResolved, vxPerS, vyPerS, speedPerS);
                        }

                        // Geometric fallback for sparse samples / missed CCD contacts: preserves v15-style reliability.
                        if (!beginEv && !endEv && directionFromGeo) {
                            const synth = syntheticPlanckEvent('begin');
                            emitCross('begin', s, synth, directionResolved, vxPerS, vyPerS, speedPerS);
                        }

                        // Persist last sample every frame (preserve begin cooldown timestamp).
                        const keepLastBegin = Number((perPointer.get(pidKey) || {})?.lastEmitBeginNow || 0);
                        const keepLastLook = Number((perPointer.get(pidKey) || {})?.lastEmitLookaheadNow || 0);
                        perPointer.set(pidKey, {
                            x: s.x,
                            y: s.y,
                            now: nowNum,
                            fsmState: s.fsmState,
                            seq: s.seq,
                            lastEmitBeginNow: keepLastBegin,
                            lastEmitLookaheadNow: keepLastLook
                        });
                        continue;
                    }

                    // v15/v16 fallback: geometric crossing (works with sparse samples), optionally enriched with Planck begin metadata.
                    const crossed = !!(prev && Number.isFinite(prev.y) && ((prev.y < bandY && s.y >= bandY) || (prev.y > bandY && s.y <= bandY)));
                    const direction = (!prev)
                        ? null
                        : (prev.y < bandY && s.y >= bandY)
                            ? 'down'
                            : (prev.y > bandY && s.y <= bandY)
                                ? 'up'
                                : null;

                    if (!crossed) {
                        perPointer.set(pidKey, {
                            x: s.x,
                            y: s.y,
                            now: nowNum,
                            fsmState: s.fsmState,
                            seq: s.seq,
                            lastEmitBeginNow: Number(prev?.lastEmitBeginNow || 0),
                            lastEmitLookaheadNow: Number(prev?.lastEmitLookaheadNow || 0)
                        });
                        continue;
                    }

                    emitCross('begin', s, beginEv, direction, vxPerS, vyPerS, speedPerS);
                }

                return lastCross;
            };

            const getDebugState = () => {
                const c = cfg();
                return Object.freeze({
                    band: { ...c.band },
                    lastCross,
                    pointersTracked: perPointer.size,
                    lastContactCount,
                    lastStepError
                });
            };

            return Object.freeze({
                tick,
                getDebugState
            });
        })();

        // Formal alias for the sensor-thread concept.
        window.hfoP2SensorThread = window.hfoP2SensorThread || window.hfoP2TripwireThread;

        // --- GEN6 v16: P2 Fail-Closed COAST Governor ---
        // Purpose: Centralize "low confidence" conditions into COAST so downstream ports naturally fail-closed.
        // Current low-confidence condition: deadman stillness (impossibly still pointer).
        window.hfoP2CoastGovernor = window.hfoP2CoastGovernor || (() => {
            const perPointer = new Map();

            const cfg = () => {
                const base = systemState?.parameters?.coasting || {};
                const dm = base?.deadman || {};
                const enabled = dm?.enabled !== false;
                const timeoutMs = Number(dm?.timeoutMs ?? 60_000);
                const epsilonUiNorm = Math.max(0, Number(dm?.epsilonUiNorm ?? 0));
                const rearmOnMove = dm?.rearmOnMove !== false;
                return {
                    enabled,
                    timeoutMs: Number.isFinite(timeoutMs) && timeoutMs >= 0 ? timeoutMs : 60_000,
                    epsilonUiNorm: Number.isFinite(epsilonUiNorm) ? epsilonUiNorm : 0,
                    rearmOnMove
                };
            };

            const getUiNorm = (cursor) => {
                const x = Number.isFinite(cursor?.uiNormX) ? Number(cursor.uiNormX) : Number(cursor?.normX);
                const y = Number.isFinite(cursor?.uiNormY) ? Number(cursor.uiNormY) : Number(cursor?.normY);
                return {
                    x: Number.isFinite(x) ? x : 0,
                    y: Number.isFinite(y) ? y : 0
                };
            };

            const emitTransition = ({ handIndex, from, to, readiness, reason }) => {
                try {
                    window.hfoPortsEffects?.emit?.('p2', 'fsm_transition', {
                        handIndex: Number(handIndex ?? 0),
                        from: String(from || ''),
                        to: String(to || ''),
                        readiness: Number(readiness ?? 0),
                        reason: reason || null
                    });
                } catch (_) {
                    // ignore
                }
            };

            const emitPointerCancel = (payload) => {
                try {
                    window.hfoPortsEffects?.emit?.('p3', 'pointer_cancel', payload);
                    window.hfoPortsEffects?.setState?.('p3_pointer_cancel', payload);
                } catch (_) {
                    // ignore
                }
            };

            const tick = ({ now, dt, dataFabric }) => {
                const c = cfg();
                if (!c.enabled) return false;

                const nowMs = Number(now ?? dataFabric?.systemTime ?? 0);
                if (!Number.isFinite(nowMs)) return false;

                const cursors = Array.isArray(dataFabric?.cursors) ? dataFabric.cursors : [];
                if (!cursors.length) return false;

                for (let idx = 0; idx < cursors.length; idx++) {
                    const cur = cursors[idx];
                    const handIndex = Number(cur?.handIndex ?? 0);
                    const pid = String(Number(cur?.pointerId ?? 0));
                    const fsmState = String(cur?.fsmState || 'IDLE');

                    // Only apply deadman when not IDLE (we want COAST to represent low confidence while active).
                    if (fsmState === 'IDLE') {
                        perPointer.delete(pid);
                        continue;
                    }

                    const { x, y } = getUiNorm(cur);
                    const prev = perPointer.get(pid) || { lastX: x, lastY: y, lastMoveNow: nowMs, tripped: false };
                    const dist = Math.hypot(x - prev.lastX, y - prev.lastY);

                    if (dist > c.epsilonUiNorm) {
                        perPointer.set(pid, {
                            lastX: x,
                            lastY: y,
                            lastMoveNow: nowMs,
                            tripped: c.rearmOnMove ? false : prev.tripped
                        });
                        continue;
                    }

                    const stillFor = nowMs - Number(prev.lastMoveNow ?? nowMs);
                    if (!prev.tripped && stillFor >= c.timeoutMs) {
                        // Trip once: force COAST and emit pointer_cancel telemetry.
                        const cancel = Object.freeze({
                            pointerId: Number(cur?.pointerId ?? 0),
                            handIndex,
                            fsmState,
                            reason: 'deadman_stillness',
                            stillForMs: Number(stillFor),
                            timeoutMs: Number(c.timeoutMs),
                            epsilonUiNorm: Number(c.epsilonUiNorm)
                        });
                        emitPointerCancel(cancel);

                        const from = fsmState;
                        const to = 'COAST';

                        // Force the authoritative per-hand FSM state so readiness drains using COAST math.
                        try {
                            if (Array.isArray(systemState?.p1?.fsmStates)) {
                                systemState.p1.fsmStates[handIndex] = 'COAST';
                            }
                        } catch (_) {
                            // ignore
                        }

                        // Mutate the fabric cursor so downstream ports fail-closed this frame.
                        try {
                            cursors[idx] = Object.freeze({ ...cur, fsmState: 'COAST' });
                        } catch (_) {
                            // ignore
                        }

                        emitTransition({
                            handIndex,
                            from,
                            to,
                            readiness: Number(cur?.readinessScore ?? 0),
                            reason: 'deadman_stillness'
                        });

                        perPointer.set(pid, { ...prev, tripped: true });
                        continue;
                    }

                    perPointer.set(pid, prev);
                }

                return true;
            };

            const reset = (pointerId) => {
                if (pointerId === undefined || pointerId === null) {
                    perPointer.clear();
                    return true;
                }
                const pid = String(Number(pointerId ?? 0));
                perPointer.delete(pid);
                return true;
            };

            return Object.freeze({ tick, reset, _debug: () => ({ pointers: Array.from(perPointer.entries()) }) });
        })();

        // Register adapters we can safely wrap today.
        if (!window.hfoRegistry.has(window.hfoTokens.EVAL_HFO)) {
            window.hfoRegistry.register(window.hfoTokens.EVAL_HFO, window.hfoEval);
        }

        // P1 is the "Web Weaver": the single authority that shapes the universal DataFabric.
        // It owns (a) fusion, (b) contract validation, and (c) the canonical fabric envelope.
        if (!window.hfoRegistry.has(window.hfoTokens.P1_FUSE)) {
            window.hfoRegistry.register(window.hfoTokens.P1_FUSE, {
                fuseToDataFabric: (results, dt, nowMs) => {
                    const cursors = P1Bridger.fuse(results, dt);
                    try {
                        const next = DataFabricSchema.parse({
                            cursors,
                            systemTime: nowMs,
                            frameId: (systemState.dataFabric.frameId || 0) + 1
                        });

                        const wallTimeMs = Date.now();
                        const candidateEnvelope = {
                            specversion: '0.1',
                            id: `hfo-gen6-${wallTimeMs}-${next.frameId}`,
                            type: 'hfo.gen6.p1.fuse.v23',
                            source: window.location?.pathname || 'unknown',
                            subject: 'p1.fuse',
                            time: new Date(wallTimeMs).toISOString(),
                            datacontenttype: 'application/json',
                            monotonicMs: nowMs,
                            dt,
                            data: next
                        };
                        const envelopeParsed = FabricEnvelopeSchema.safeParse(candidateEnvelope);

                        return { cursors, dataFabric: next, envelope: envelopeParsed.success ? envelopeParsed.data : null };
                    } catch (e) {
                        console.error("PORT 1 CONTRACT BREACH:", e);
                        return { cursors: [], dataFabric: null, envelope: null };
                    }
                }
            });
        }

        if (window.hfoTelemetry && !window.hfoRegistry.has(window.hfoTokens.P6_STORE)) {
            window.hfoRegistry.register(window.hfoTokens.P6_STORE, {
                record: (...args) => window.hfoTelemetry.record(...args),
                start: () => window.hfoTelemetry.start(),
                stop: () => window.hfoTelemetry.stop(),
                exportJSONL: () => window.hfoTelemetry.exportJSONL()
            });
        }

        if (!window.hfoRegistry.has(window.hfoTokens.P0_SENSE)) {
            window.hfoRegistry.register(window.hfoTokens.P0_SENSE, {
                readForVideo: (nowMs) => {
                    const recognizer = systemState?.p0?.recognizer;
                    const video = systemState?.p0?.video;
                    if (!recognizer || !video) return null;
                    return recognizer.recognizeForVideo(video, nowMs);
                }
            });
        }

        // P0 v11.2: shared camera substrate (single getUserMedia stream cached across views).
        // Default-inert: no side-effects unless `getStream()` is called.
        if (!window.hfoRegistry.has(window.hfoTokens.P0_CAMERA)) {
            const cameraAdapter = (() => {
                let stream = null;
                let streamPromise = null;
                let gumCalls = 0;

                const parseResolution = () => {
                    try {
                        const r = String(systemState?.parameters?.camera?.resolution || '1280x720');
                        const [w, h] = r.split('x');
                        return { width: parseInt(w, 10) || 1280, height: parseInt(h, 10) || 720 };
                    } catch {
                        return { width: 1280, height: 720 };
                    }
                };

                const getStream = async (opts = {}) => {
                    if (stream) return stream;
                    if (streamPromise) return streamPromise;

                    const mediaDevices = navigator?.mediaDevices;
                    if (!mediaDevices || typeof mediaDevices.getUserMedia !== 'function') {
                        throw new Error('navigator.mediaDevices.getUserMedia unavailable');
                    }

                    const { width, height } = parseResolution();
                    const requested = {
                        width: typeof opts?.width === 'number' ? opts.width : width,
                        height: typeof opts?.height === 'number' ? opts.height : height
                    };

                    gumCalls += 1;
                    streamPromise = mediaDevices.getUserMedia({
                        video: { width: requested.width, height: requested.height }
                    }).then((s) => {
                        stream = s;
                        return stream;
                    }).catch((e) => {
                        streamPromise = null;
                        throw e;
                    });

                    return streamPromise;
                };

                const getUserMediaCallCount = () => gumCalls;

                const reset = (stopTracks = true) => {
                    try {
                        if (stopTracks && stream && typeof stream.getTracks === 'function') {
                            stream.getTracks().forEach((t) => {
                                try { t.stop(); } catch { }
                            });
                        }
                    } catch { }
                    stream = null;
                    streamPromise = null;
                    gumCalls = 0;
                    return true;
                };

                return Object.freeze({ getStream, getUserMediaCallCount, reset });
            })();

            window.hfoRegistry.register(window.hfoTokens.P0_CAMERA, cameraAdapter);
        }

        if (!window.hfoRegistry.has(window.hfoTokens.P2_PHYSICS)) {
            window.hfoRegistry.register(window.hfoTokens.P2_PHYSICS, {
                getAdapters: () => (systemState?.p1?.physicsState ? [...systemState.p1.physicsState] : []),
                getTelemetry: () => {
                    const adapters = systemState?.p1?.physicsState || [];
                    return adapters.map((a) => (typeof a?.getTelemetry === 'function' ? a.getTelemetry() : {}));
                }
            });
        }

        // Render adapter is intentionally side-effect-free in v10.1 scaffolding.
        if (!window.hfoRegistry.has(window.hfoTokens.P2_RENDER)) {
            window.hfoRegistry.register(window.hfoTokens.P2_RENDER, {
                listJuiceLayers: () => (systemState?.ui?.juiceLayers ? [...systemState.ui.juiceLayers] : [])
            });
        }

        // P7 is NAVIGATE: long-horizon orchestration and total tool virtualization intent.
        // Non-breaking v10.1: exposes safe parameter patching + a mission vision object.
        if (!window.hfoRegistry.has(window.hfoTokens.P7_NAVIGATE)) {
            const deepMerge = (target, patch) => {
                if (!patch || typeof patch !== 'object') return target;
                Object.keys(patch).forEach((k) => {
                    const pv = patch[k];
                    if (pv && typeof pv === 'object' && !Array.isArray(pv)) {
                        if (!target[k] || typeof target[k] !== 'object') target[k] = {};
                        deepMerge(target[k], pv);
                    } else {
                        target[k] = pv;
                    }
                });
                return target;
            };

            const navigateAdapter = {
                currentIntent: null,
                postMessageToActiveAdapter: (message) => {
                    try {
                        const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                        const iframeEl = host?.getActiveTargetRootElement?.();
                        const win = iframeEl?.contentWindow;
                        if (!win || typeof win.postMessage !== 'function') return false;
                        win.postMessage(message, '*');
                        return true;
                    } catch (_) {
                        return false;
                    }
                },
                getMissionVision: () => {
                    return {
                        mission_thread: 'OMEGA',
                        title: 'Total Tool Virtualization',
                        north_star: 'Gesture + multimodal intent manifests virtual tools with evaluation harness feedback.',
                        capabilities: {
                            current_slice: ['Excalidraw overlay', 'parameter hot-swap via Navigator', 'P1 DataFabric + envelope', 'P3 pointer injection'],
                            near_term: ['rapid gesture/visual/app swapping', 'passive props + tool presets', 'multi-user primacy/hot-seat'],
                            long_term: ['any tool on demand (e.g., phoenix fireball, scalpel trainer, cockpit controls)', 'multi-sensor inputs (e.g., thermal camera)', 'archive-backed curricula from beginnerâ†’master', 'AI-assisted evaluation + coaching']
                        }
                    };
                },
                getParameters: () => systemState.parameters,
                patchParameters: (patch) => {
                    deepMerge(systemState.parameters, patch);
                    return systemState.parameters;
                },
                setActiveAdapterTool: (tool) => {
                    const activeId = window.hfoPorts?.p7?.apps?.getActiveId?.() || null;
                    if (activeId === 'excalidraw') {
                        systemState.parameters.excalidraw.activeTool = tool;
                    } else {
                        systemState.parameters.apps = systemState.parameters.apps || {};
                        systemState.parameters.apps.activeTool = tool;
                    }
                    navigateAdapter.postMessageToActiveAdapter({
                        type: 'SET_TOOL',
                        data: { tool }
                    });
                    return tool;
                },
                setExcalidrawTool: (tool) => {
                    // Backward-compatible shim: Excalidraw is just one adapter.
                    return navigateAdapter.setActiveAdapterTool(tool);
                },
                setVisualEngine: (engine) => {
                    systemState.parameters.visuals.engine = engine;
                    return systemState.parameters.visuals.engine;
                },
                setIntent: (intent) => {
                    const wallTimeMs = Date.now();
                    navigateAdapter.currentIntent = {
                        ts: new Date(wallTimeMs).toISOString(),
                        intent
                    };
                    return navigateAdapter.currentIntent;
                }
            };

            window.hfoRegistry.register(window.hfoTokens.P7_NAVIGATE, navigateAdapter);
        }

        // P7 v11.1: APPHOST (Multi-app runtime)
        // Default-inert: only affects DOM visibility when `?flag-ui-multiapp=true`.
        if (!window.hfoRegistry.has(window.hfoTokens.P7_APPHOST)) {
            const validateAppManifest = (candidate) => {
                if (window.Contracts?.AppManifestSchema?.parse) {
                    return window.Contracts.AppManifestSchema.parse(candidate);
                }
                return candidate;
            };

            const appHostAdapter = (() => {
                const apps = new Map();
                let activeAppId = null;

                const register = (manifest) => {
                    const parsed = validateAppManifest(manifest);
                    if (!parsed?.appId) throw new Error('AppManifest missing appId');
                    apps.set(parsed.appId, parsed);
                    return parsed;
                };

                // Register default demo apps (same-origin iframes).
                register({
                    appId: 'excalidraw',
                    title: 'Excalidraw',
                    kind: 'iframe',
                    entrypoint: 'excalidraw_v20_wrapper.html',
                    tags: ['demo', 'whiteboard'],
                    pointerAdapter: 'excalidraw',
                    targetPolicy: 'ACTIVE_APP_OR_FALLBACK',
                    runtime: { overlayKey: 'excalidrawOverlay', iframeKey: 'excalidrawIframe' }
                });
                register({
                    appId: 'sandbox',
                    title: 'Sandbox Canvas',
                    kind: 'iframe',
                    entrypoint: 'sandbox_canvas_app.html',
                    tags: ['demo', 'canvas'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'sandboxOverlay', iframeKey: 'sandboxIframe' }
                });

                // GEN5 v12: Pointer Lab (same-origin; touch + stylus validation surface).
                register({
                    appId: 'pointer-lab',
                    title: 'Pointer Lab',
                    kind: 'iframe',
                    entrypoint: 'pointer_lab_app.html',
                    tags: ['demo', 'touch', 'pointer'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'pointerLabOverlay', iframeKey: 'pointerLabIframe' }
                });

                // OFFICIAL adapter: MDN Breakout workshop (vendored, same-origin).
                register({
                    appId: 'breakout-mdn',
                    title: 'Breakout (MDN Workshop)',
                    kind: 'iframe',
                    entrypoint: 'official_adapters/mdn_breakout_end3r/index.html',
                    tags: ['official', 'breakout', 'canvas'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'breakoutOverlay', iframeKey: 'breakoutIframe' }
                });

                // NOTE: Bespoke Gen5 game demos were removed. Only vendor "official" upstream demos into the repo.

                const getActiveId = () => activeAppId;
                const getActive = () => (activeAppId ? apps.get(activeAppId) || null : null);

                const getRuntimeEl = (key) => {
                    const ui = systemState?.ui || {};
                    return ui?.[key] || null;
                };

                const getOverlayTuningForApp = (appId) => {
                    const p = systemState?.parameters?.apps;
                    if (!p) return { opacity: 1.0, zoom: 1.0 };
                    if (p?.overlay?.rememberPerApp && appId && p?.perApp?.[appId]) {
                        const o = p.perApp[appId] || {};
                        return {
                            opacity: typeof o.opacity === 'number' ? o.opacity : (p.overlay.opacity ?? 1.0),
                            zoom: typeof o.zoom === 'number' ? o.zoom : (p.overlay.zoom ?? 1.0)
                        };
                    }
                    return {
                        opacity: typeof p?.overlay?.opacity === 'number' ? p.overlay.opacity : 1.0,
                        zoom: typeof p?.overlay?.zoom === 'number' ? p.overlay.zoom : 1.0
                    };
                };

                const applyOverlayTuningToManifest = (manifest) => {
                    const overlayKey = manifest?.runtime?.overlayKey;
                    const iframeKey = manifest?.runtime?.iframeKey;
                    if (!overlayKey || !iframeKey) return false;

                    const overlay = getRuntimeEl(overlayKey);
                    const iframe = getRuntimeEl(iframeKey);
                    if (!overlay || !iframe) return false;

                    const { opacity, zoom } = getOverlayTuningForApp(manifest?.appId);

                    overlay.style.opacity = String(Math.max(0, Math.min(1, Number(opacity) || 0)));

                    const z = Math.max(1.0, Math.min(2.0, Number(zoom) || 1.0));
                    overlay.style.width = `${z * 100}%`;
                    overlay.style.height = `${z * 100}%`;
                    overlay.style.left = `${(1 - z) * 50}%`;
                    overlay.style.top = `${(1 - z) * 50}%`;
                    overlay.style.position = 'absolute';

                    // Ensure iframe remains a full-bleed surface inside the tuned overlay box.
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';

                    return true;
                };

                const setOverlayVisible = (manifest, visible) => {
                    const overlayKey = manifest?.runtime?.overlayKey;
                    if (!overlayKey) return;
                    const overlay = getRuntimeEl(overlayKey);
                    if (!overlay) return;
                    overlay.style.display = visible ? 'block' : 'none';
                    if (visible) applyOverlayTuningToManifest(manifest);
                };

                const hideAllOverlays = () => {
                    for (const m of apps.values()) setOverlayVisible(m, false);
                };

                const emit = (type, detail) => {
                    try {
                        window.hfoStigmergy?.emit?.(type, detail);
                    } catch (_) {
                        // ignore
                    }
                };

                const activate = (appId) => {
                    if (!apps.has(appId)) throw new Error(`Unknown appId: ${appId}`);
                    activeAppId = appId;
                    if (isFlagEnabled('ui-multiapp')) {
                        hideAllOverlays();
                        setOverlayVisible(apps.get(appId), true);
                    }
                    emit('apphost.activate', { appId, ts: new Date().toISOString() });
                    return getActive();
                };

                const deactivate = () => {
                    const prev = activeAppId;
                    activeAppId = null;
                    if (isFlagEnabled('ui-multiapp')) hideAllOverlays();
                    emit('apphost.deactivate', { prevAppId: prev, ts: new Date().toISOString() });
                    return true;
                };

                const getActiveTargetRootElement = () => {
                    const active = getActive();
                    if (!active) return null;
                    if (active.kind !== 'iframe') return null;
                    const iframeKey = active?.runtime?.iframeKey;
                    if (!iframeKey) return null;
                    return getRuntimeEl(iframeKey);
                };

                const applyActiveOverlayTuning = () => {
                    const active = getActive();
                    if (!active || active.kind !== 'iframe') return false;

                    const p = systemState?.parameters?.apps;
                    if (p?.overlay?.rememberPerApp && active?.appId && p?.perApp?.[active.appId]) {
                        const stored = p.perApp[active.appId] || {};
                        if (typeof stored.opacity === 'number') p.overlay.opacity = stored.opacity;
                        if (typeof stored.zoom === 'number') p.overlay.zoom = stored.zoom;
                    }

                    return applyOverlayTuningToManifest(active);
                };

                return Object.freeze({
                    register,
                    registerIframeAdapter: ({
                        appId,
                        title,
                        entrypoint,
                        overlayKey,
                        iframeKey,
                        tags = [],
                        targetPolicy = 'ACTIVE_APP_ONLY',
                        pointerAdapter = 'standard'
                    }) => {
                        return register({
                            appId,
                            title,
                            kind: 'iframe',
                            entrypoint,
                            tags,
                            pointerAdapter,
                            targetPolicy,
                            runtime: { overlayKey, iframeKey }
                        });
                    },
                    list: () => Array.from(apps.values()),
                    activate,
                    deactivate,
                    getActiveId,
                    getActive,
                    getActiveTargetRootElement,
                    applyActiveOverlayTuning
                });
            })();

            window.hfoRegistry.register(window.hfoTokens.P7_APPHOST, appHostAdapter);
        }

        // UI layout adapter (placeholder surface for v11.1 integration; does not mutate state).
        if (!window.hfoRegistry.has(window.hfoTokens.UI_LAYOUT)) {
            window.hfoRegistry.register(window.hfoTokens.UI_LAYOUT, {
                getActiveAppId: () => {
                    try {
                        return window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveId();
                    } catch (_) {
                        return null;
                    }
                }
            });
        }

        // P3 v11.1: Target router. When enabled, constrains pointer hit-testing to the active app.
        if (!window.hfoRegistry.has(window.hfoTokens.P3_TARGET_ROUTER)) {
            const safeElementFromPointInIframe = (iframeEl, x, y) => {
                if (!iframeEl) return null;
                try {
                    const doc = iframeEl.contentDocument;
                    if (!doc || typeof doc.elementFromPoint !== 'function') return null;
                    return doc.elementFromPoint(x, y);
                } catch (_) {
                    return null;
                }
            };

            window.hfoRegistry.register(window.hfoTokens.P3_TARGET_ROUTER, {
                getActivePolicy: () => {
                    try {
                        const active = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive();
                        return active?.targetPolicy || 'ACTIVE_APP_OR_FALLBACK';
                    } catch (_) {
                        return 'ACTIVE_APP_OR_FALLBACK';
                    }
                },
                isTargetAllowed: (target) => {
                    try {
                        const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                        const active = host.getActive();
                        if (!active) return true;
                        if (active.kind === 'iframe') {
                            const iframeEl = host.getActiveTargetRootElement();
                            const doc = iframeEl?.contentDocument;
                            return !!(target && doc && target.ownerDocument === doc);
                        }
                        return target?.ownerDocument === document;
                    } catch (_) {
                        return true;
                    }
                },
                resolveTargetAt: (viewX, viewY) => {
                    const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                    const active = host.getActive();
                    if (!active) return null;
                    if (active.kind !== 'iframe') return null;

                    const iframeEl = host.getActiveTargetRootElement();
                    if (!iframeEl) return null;

                    // Prefer overlay rect if present (overlays are positioned absolute to the hero container).
                    const overlayKey = active?.runtime?.overlayKey;
                    const overlay = overlayKey ? (systemState?.ui?.[overlayKey] || null) : null;
                    const rect = (overlay && overlay.style.display !== 'none') ? overlay.getBoundingClientRect() : iframeEl.getBoundingClientRect();

                    if (viewX < rect.left || viewX > rect.right || viewY < rect.top || viewY > rect.bottom) return null;

                    const subX = viewX - rect.left;
                    const subY = viewY - rect.top;
                    const inner = safeElementFromPointInIframe(iframeEl, subX, subY);
                    if (!inner) return null;
                    return { target: inner, clientX: subX, clientY: subY };
                }
            });
        }

        // P4 is DISRUPT: red-team coevolution. Must be explicitly enabled; otherwise it is inert.
        // Critical invariant: no side-effects unless a caller invokes the adapter.
        if (!window.hfoRegistry.has(window.hfoTokens.P4_DISRUPT)) {
            window.hfoRegistry.register(window.hfoTokens.P4_DISRUPT, {
                isEnabled: () => isFlagEnabled('p4-disrupt'),
                noOp: () => {
                    const wallTimeMs = Date.now();
                    return {
                        ok: true,
                        enabled: isFlagEnabled('p4-disrupt'),
                        ts: new Date(wallTimeMs).toISOString(),
                        note: 'P4 DISRUPT is inert unless you call it.'
                    };
                },
                probeAdapters: () => {
                    return {
                        p0: window.hfoRegistry.has(window.hfoTokens.P0_SENSE),
                        p1: window.hfoRegistry.has(window.hfoTokens.P1_FUSE),
                        p2_physics: window.hfoRegistry.has(window.hfoTokens.P2_PHYSICS),
                        p2_render: window.hfoRegistry.has(window.hfoTokens.P2_RENDER),
                        p3: window.hfoRegistry.has(window.hfoTokens.P3_INJECTOR),
                        p5_eval: window.hfoRegistry.has(window.hfoTokens.EVAL_HFO),
                        p6: window.hfoRegistry.has(window.hfoTokens.P6_STORE),
                        p7: window.hfoRegistry.has(window.hfoTokens.P7_NAVIGATE)
                    };
                }
            });
        }

        /**
         * ðŸ”± PORT 3: POINTER INJECTION (Polymorphic Hexagonal Adapter)
         *
         * Goal:
         * - Standard W3C PointerEvents pipeline as the default substrate.
         * - Optional UI adapter behavior (Excalidraw) without polluting the core.
         */
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            const video = systemState.p0.video;
            if (!video) return;

            const videoWidth = video.videoWidth || parseInt(systemState.parameters.camera.resolution.split('x')[0]) || 1280;
            const videoHeight = video.videoHeight || parseInt(systemState.parameters.camera.resolution.split('x')[1]) || 720;
            const rect = video.getBoundingClientRect();
            const rectWidth = rect.width || videoWidth;
            const rectHeight = rect.height || videoHeight;
            const rectLeft = rect.left || 0;
            const rectTop = rect.top || 0;

            const currentIds = new Set();

            cursors.forEach(cursor => {
                const pid = cursor.pointerId;

                // V24.7: Hot Seat V2 Interaction Gating
                // Ensures only ONE hand can interact with the system at a time.
                // READY hands provide multiple visual fireballs, but only the primary hand injects events.
                const isPrimary = (systemState.fsm.primaryHandIndex === cursor.handIndex);
                let pState = systemState.fsm.activePointers[pid];

                // If not primary, only allow processing if it was previously active (to cleanup)
                if (!isPrimary && (!pState || !pState.wasDown)) return;

                currentIds.add(pid);

                // V28.0: UNIVERSAL PROJECTION ENGINE (UPE) ENFORCEMENT
                // V28.5 HARDENED: Use pre-calculated uiNorms for cross-substrate parity
                const viewX = systemState.p1.toViewportX(cursor.uiNormX || cursor.normX);
                const viewY = systemState.p1.toViewportY(cursor.uiNormY || cursor.normY);

                // V39.3: HARDENED INTERACTION GATE
                // "there is no injection layer EXCEPT for COMMIT"
                const isDown = (cursor.fsmState === 'COMMIT');
                const pressure = isDown ? 1.0 : 0.0;

                if (!pState) {
                    systemState.fsm.activePointers[pid] = {
                        lastTarget: null,
                        lock: null,
                        wasDown: false,
                        downClientX: null,
                        downClientY: null,
                        downTarget: null,
                        downControl: null,
                        downDoc: null,
                        moved: false
                    };
                    pState = systemState.fsm.activePointers[pid];
                }

                let target = pState.lock;
                let finalX = viewX;
                let finalY = viewY;

                const targetRoutingEnabled = isFlagEnabled('p3-target-active-app');
                let targetRouter = null;
                let targetPolicy = 'ACTIVE_APP_OR_FALLBACK';
                if (targetRoutingEnabled) {
                    try {
                        targetRouter = window.hfoRegistry.resolve(window.hfoTokens.P3_TARGET_ROUTER);
                        targetPolicy = targetRouter?.getActivePolicy?.() || 'ACTIVE_APP_OR_FALLBACK';
                    } catch (_) {
                        targetRouter = null;
                    }
                }

                // If a lock exists but is no longer allowed under active-app routing, clear it.
                if (target && targetRouter && !targetRouter.isTargetAllowed(target)) {
                    pState.lock = null;
                    target = null;
                }

                if (!target) {
                    // v11.1: active-app routing (same-origin iframe probing) before legacy global hit-test.
                    if (targetRouter) {
                        const routed = targetRouter.resolveTargetAt?.(viewX, viewY);
                        if (routed?.target) {
                            target = routed.target;
                            finalX = routed.clientX;
                            finalY = routed.clientY;
                        } else if (targetPolicy === 'ACTIVE_APP_ONLY') {
                            return;
                        }
                    }

                    if (!target) {
                        let probe = document.elementFromPoint(viewX, viewY) || document.body;
                        if (probe && probe.tagName === 'IFRAME') {
                            try {
                                const iframeRect = probe.getBoundingClientRect();
                                const subX = viewX - iframeRect.left;
                                const subY = viewY - iframeRect.top;
                                const inner = probe.contentDocument.elementFromPoint(subX, subY);
                                if (inner) {
                                    probe = inner;
                                    finalX = subX;
                                    finalY = subY;
                                }
                            } catch (e) {
                                // Cross-origin or hidden iframe access failure is expected but logged in dev
                                if (systemState.parameters.devMode) console.warn("[P3] Deep Target Search Failure:", e);
                            }
                        }
                        target = probe;
                    }
                } else {
                    if (target.ownerDocument !== document) {
                        const iframe = Array.from(document.querySelectorAll('iframe')).find(f => f.contentDocument === target.ownerDocument);
                        if (iframe) {
                            const r = iframe.getBoundingClientRect();
                            finalX = viewX - r.left;
                            finalY = viewY - r.top;
                        }
                    }
                }

                const eventInit = {
                    bubbles: true, cancelable: true, pointerId: pid, pointerType: 'mouse',
                    clientX: finalX, clientY: finalY, screenX: viewX, screenY: viewY,
                    pressure: pressure, buttons: isDown ? 1 : 0, button: isDown ? 0 : -1,
                    width: 1, height: 1, isPrimary: pid === 10
                };

                if (target !== pState.lastTarget) {
                    if (pState.lastTarget) {
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerout', eventInit), pState);
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerleave', eventInit), pState);
                    }
                    if (target) {
                        dispatchToHydraHydrant(target, new PointerEvent('pointerover', eventInit), pState);
                        dispatchToHydraHydrant(target, new PointerEvent('pointerenter', eventInit), pState);
                    }
                    pState.lastTarget = target;
                }

                if (isDown && !pState.wasDown) {
                    pState.lock = target;
                    pState.downClientX = finalX;
                    pState.downClientY = finalY;
                    pState.downTarget = target;
                    pState.downDoc = target?.ownerDocument || document;
                    // Prefer resolving a UI control, even when elementFromPoint returns a wrapper node.
                    pState.downControl = P3InjectorPort.findControl(target);
                    if (!pState.downControl) {
                        try {
                            const probe = (pState.downDoc || document).elementFromPoint?.(finalX, finalY);
                            pState.downControl = P3InjectorPort.findControl(probe);
                        } catch (e) {
                            // ignore
                        }
                    }
                    pState.moved = false;
                    if (target.setPointerCapture) {
                        try {
                            target.setPointerCapture(pid);
                        } catch (e) {
                            if (systemState.parameters.devMode) console.warn("[P3] SetPointerCapture failed:", e);
                        }
                    }
                    dispatchToHydraHydrant(target, new PointerEvent('pointerdown', eventInit), pState);
                }

                // Track movement while down to avoid false "release-click" on drags.
                if (isDown && pState.downClientX != null && pState.downClientY != null) {
                    const cfg = P3InjectorPort.getConfig();
                    const dx = finalX - pState.downClientX;
                    const dy = finalY - pState.downClientY;
                    if (!pState.moved && Math.hypot(dx, dy) > cfg.tapMoveThresholdPx) {
                        pState.moved = true;
                    }
                }

                dispatchToHydraHydrant(target, new PointerEvent('pointermove', eventInit), pState);

                if (!isDown && pState.wasDown) {
                    dispatchToHydraHydrant(target, new PointerEvent('pointerup', { ...eventInit, pressure: 0.0, buttons: 0, button: 0 }), pState);
                    if (target.releasePointerCapture) {
                        try {
                            target.releasePointerCapture(pid);
                        } catch (e) {
                            if (systemState.parameters.devMode) console.warn("[P3] ReleasePointerCapture failed:", e);
                        }
                    }
                    pState.lock = null;
                    pState.downClientX = null;
                    pState.downClientY = null;
                    pState.downTarget = null;
                    pState.downControl = null;
                    pState.downDoc = null;
                    pState.moved = false;
                }

                pState.wasDown = isDown;
            });

            // V24.4: Real pointercancel path for lost tracking
            Object.keys(systemState.fsm.activePointers).forEach(pidStr => {
                const pid = parseInt(pidStr);
                if (!currentIds.has(pid)) {
                    const pState = systemState.fsm.activePointers[pid];
                    if (pState.wasDown && pState.lock) {
                        dispatchToHydraHydrant(pState.lock, new PointerEvent('pointercancel', {
                            pointerId: pid, bubbles: true, pointerType: 'mouse'
                        }), pState);
                        if (pState.lock.releasePointerCapture) {
                            try {
                                pState.lock.releasePointerCapture(pid);
                            } catch (e) {
                                if (systemState.parameters.devMode) console.warn("[P3] Cancel: ReleasePointerCapture failed:", e);
                            }
                        }
                        if (systemState.parameters.devMode) console.log(`[P3] Handled pointer-loss cancel for id: ${pid}`);
                    }
                    delete systemState.fsm.activePointers[pid];
                }
            });
        }

        // --- TEST HARNESS: Expose injector for Playwright guards ---
        if (!window.hfoTestHarness) window.hfoTestHarness = {};
        window.hfoTestHarness.injectPointers = () => {
            try {
                w3cPointerNematocystInjector();
            } catch (e) {
                if (systemState.parameters.devMode) console.warn('[P3] Test harness inject failed:', e);
            }
        };

        /**
         * ðŸ”± HYDRA HYDRANT: Payload Delivery Mechanism (W3C PointerEvents)
         * Optimized for React/Excalidraw and universal target discovery.
         */
        // --- P3: Injector Port (Adapter Boundary) ---
        const P3InjectorPort = (() => {
            const DEFAULTS = {
                // 'standard' = pure PointerEvents; 'excalidraw' = allows guarded click synthesis for UI controls
                adapter: 'auto',
                enableClickSynthesis: true,
                tapMoveThresholdPx: 6,
                // 'down' = switch tools on COMMIT (pointerdown). 'up' = legacy click-on-release.
                clickSynthesisPhase: 'down'
            };

            const sendNematocystToDino = (payload) => {
                try {
                    window.hfoTracerVenomBattery?.emit?.('p3.dino.send.attempt', {
                        kind: payload?.kind ?? null,
                        action: payload?.action ?? null,
                        traceId: (typeof payload?.traceId === 'string' && payload.traceId.length) ? payload.traceId : (typeof payload?.payload?.traceId === 'string' ? payload.payload.traceId : null),
                    });
                } catch (_) {
                    // ignore
                }
                // Allow a diagnostic shorthand payload.
                // Purpose: inject a single trace-tagged input through the normal P3 delivery path.
                if (payload && typeof payload === 'object' && !Array.isArray(payload) && payload.kind === 'tracer_bullet_venom') {
                    // Fail-closed: only allow tracer venom when explicitly enabled.
                    if (!isFlagEnabled('p3-tracer-bullet-venom')) {
                        try {
                            window.hfoTracerVenomBattery?.emit?.('p3.dino.tracer_suppressed', {
                                reason: 'flag_disabled',
                                traceId: (typeof payload.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                                targetId: (typeof payload.targetId === 'string' && payload.targetId.length) ? payload.targetId : null,
                            });
                        } catch (_) {
                            // ignore
                        }
                        try {
                            window.hfoPortsEffects?.emit?.('p3', 'tracer_venom_suppressed', {
                                reason: 'flag_disabled',
                                traceId: (typeof payload.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                                targetId: (typeof payload.targetId === 'string' && payload.targetId.length) ? payload.targetId : null,
                            });
                        } catch (_) {
                            // ignore
                        }
                        return false;
                    }

                    try {
                        const nextTraceId = (typeof payload.traceId === 'string' && payload.traceId.length) ? payload.traceId : null;
                        const nextTargetId = (typeof payload.targetId === 'string' && payload.targetId.length) ? payload.targetId : null;
                        if (nextTraceId || nextTargetId) {
                            systemState.trace = systemState.trace || {};
                            if (nextTraceId) systemState.trace.traceId = nextTraceId;
                            if (nextTargetId) systemState.trace.targetId = nextTargetId;
                        }
                    } catch (_) {
                        // ignore
                    }

                    try {
                        const reason = (typeof payload.reason === 'string' && payload.reason.length)
                            ? payload.reason
                            : 'tracer_bullet_venom';
                        payload = {
                            kind: 'keyboard',
                            action: 'keypress',
                            key: ' ',
                            code: 'Space',
                            reason,
                            handIndex: payload.handIndex,
                            pointerId: payload.pointerId,
                            readiness: payload.readiness,
                            traceId: payload.traceId,
                            targetId: payload.targetId
                        };
                    } catch (_) {
                        // ignore
                    }
                }

                let traceId = null;
                try {
                    traceId = systemState?.trace?.traceId || null;
                } catch (_) {
                    traceId = null;
                }

                const payloadWithTrace = (() => {
                    if (!traceId || typeof traceId !== 'string') return payload;
                    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) return payload;
                    if (typeof payload.traceId === 'string' && payload.traceId.length) return payload;
                    try {
                        return { ...payload, traceId };
                    } catch (_) {
                        return payload;
                    }
                })();

                // GEN6 v5: prefer polymorphic AdapterHost (adapter boundary)
                try {
                    const ok = window.hfoAdapterHost?.deliverEffect?.('dino-v1', payloadWithTrace);
                    try {
                        window.hfoTracerVenomBattery?.emit?.('p3.dino.deliverEffect', {
                            ok: Boolean(ok),
                            traceId: (typeof payloadWithTrace?.traceId === 'string' && payloadWithTrace.traceId.length) ? payloadWithTrace.traceId : traceId,
                            action: payloadWithTrace?.action ?? null,
                            kind: payloadWithTrace?.kind ?? null,
                        });
                    } catch (_) {
                        // ignore
                    }
                    if (ok) return true;
                } catch (_) {
                    // ignore
                }

                try {
                    window.hfoPortsEffects?.emit?.('p3', 'nematocyst_deliver', {
                        adapterId: 'dino-v1',
                        ok: false,
                        via: 'fallback_p3',
                        payload: payloadWithTrace ?? null,
                        reason: 'legacy_sendNematocystToDino'
                    });
                } catch (_) {
                    // ignore
                }

                const message = Object.freeze({
                    type: 'hfo:nematocyst',
                    traceId: (typeof traceId === 'string' && traceId.length) ? traceId : undefined,
                    targetId: (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                        ? systemState.trace.targetId
                        : undefined,
                    payload: payloadWithTrace ?? null
                });

                const iframe = systemState?.ui?.dinoWrapperIframe || null;
                if (!iframe) {
                    try {
                        if (!systemState.ui.dinoPendingNematocystPayloads) systemState.ui.dinoPendingNematocystPayloads = [];
                        systemState.ui.dinoPendingNematocystPayloads.push(payloadWithTrace ?? null);
                        if (systemState.ui.dinoPendingNematocystPayloads.length > 25) {
                            systemState.ui.dinoPendingNematocystPayloads.splice(0, systemState.ui.dinoPendingNematocystPayloads.length - 25);
                        }
                    } catch (_) {
                        // ignore
                    }

                    try {
                        window.hfoPortsEffects?.setState?.('dino', {
                            iframePresent: false,
                            queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                            lastAttempt: { ok: false, reason: 'missing_iframe' }
                        });
                    } catch (_) {
                        // ignore
                    }
                    return false;
                }

                // Best-effort readiness check; avoid throwing in cross-origin or early-load states.
                try {
                    const readyState = iframe.contentDocument?.readyState;
                    if (readyState && readyState !== 'complete') {
                        if (!systemState.ui.dinoPendingNematocystPayloads) systemState.ui.dinoPendingNematocystPayloads = [];
                        systemState.ui.dinoPendingNematocystPayloads.push(payload ?? null);

                        try {
                            window.hfoPortsEffects?.setState?.('dino', {
                                iframePresent: true,
                                readyState,
                                queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                                lastAttempt: { ok: false, reason: 'iframe_not_ready' }
                            });
                        } catch (_) {
                            // ignore
                        }
                        return false;
                    }
                } catch (_) {
                    // ignore
                }

                try {
                    iframe.contentWindow?.postMessage(message, '*');

                    try {
                        window.hfoPortsEffects?.setState?.('dino', {
                            iframePresent: true,
                            queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                            lastAttempt: { ok: true, reason: 'postMessage' }
                        });
                    } catch (_) {
                        // ignore
                    }
                    return true;
                } catch (e) {
                    if (systemState?.parameters?.devMode) console.warn('[P3] Dino nematocyst send failed:', e);

                    try {
                        window.hfoPortsEffects?.setState?.('dino', {
                            iframePresent: true,
                            queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                            lastAttempt: { ok: false, reason: 'postMessage_error', error: String(e?.message || e) }
                        });
                    } catch (_) {
                        // ignore
                    }
                    return false;
                }
            };

            const getActiveManifest = () => {
                try {
                    return window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive?.() || null;
                } catch (_) {
                    return null;
                }
            };

            const getEffectiveAdapterKind = (cfg) => {
                const forced = cfg?.adapter;
                if (forced === 'standard' || forced === 'excalidraw') return forced;

                const active = getActiveManifest();
                const byManifest = active?.pointerAdapter;
                if (byManifest === 'excalidraw' || byManifest === 'standard') return byManifest;
                if (active?.appId === 'excalidraw') return 'excalidraw';
                return 'standard';
            };

            const getConfig = () => {
                if (!systemState.parameters) systemState.parameters = {};
                if (!systemState.parameters.p3) systemState.parameters.p3 = {};
                return { ...DEFAULTS, ...systemState.parameters.p3 };
            };

            const isInteractive = (el) => {
                if (!el) return false;
                const tag = el.tagName ? el.tagName.toLowerCase() : '';
                const role = el.getAttribute ? el.getAttribute('role') : null;
                return (
                    tag === 'button' || tag === 'a' || tag === 'input' || tag === 'select' ||
                    role === 'button' || role === 'link' || role === 'checkbox' ||
                    el.classList?.contains('ToolIcon') || !!el.onclick
                );
            };

            // Find nearest interactive ancestor; returns null if none.
            // Excalidraw UI DOM can be deep; keep this generous but bounded.
            const findControl = (el) => {
                let curr = el;
                for (let i = 0; i < 25 && curr; i++) {
                    if (isInteractive(curr)) return curr;
                    if (curr === curr.ownerDocument?.body || curr === curr.ownerDocument?.documentElement) break;
                    curr = curr.parentElement;
                }
                return null;
            };

            const focusPriming = (target) => {
                const control = findControl(target);
                if (control?.focus) control.focus();
            };

            const resolveSynthesizedClickControl = (target, e, pState, phase) => {
                const cfg = getConfig();
                const effective = getEffectiveAdapterKind(cfg);
                if (effective !== 'excalidraw') return null;
                if (!cfg.enableClickSynthesis) return null;
                if (!pState) return null;
                if (pState.moved) return null;

                // Only synthesize clicks for real UI controls (not canvas / background)
                let downControl = pState.downControl;
                if (!downControl && pState.downTarget) downControl = findControl(pState.downTarget);

                // Avoid cross-document / cross-iframe mismatches
                const upDoc = target?.ownerDocument || document;
                if (pState.downDoc && upDoc !== pState.downDoc) return null;

                const isBlockedClickTarget = (el) => {
                    if (!el || !el.tagName) return true;
                    const tag = el.tagName.toLowerCase();
                    return tag === 'canvas' || tag === 'html' || tag === 'body' || tag === 'svg';
                };

                // Require release on the same control to avoid "wrong tool" clicks
                if (phase === 'down') {
                    const candidate = downControl || findControl(target);
                    if (!candidate || !isInteractive(candidate) || isBlockedClickTarget(candidate)) return null;

                    // During pointerdown (COMMIT), we expect a left-button style press.
                    if (e.buttons !== 1) return null;

                    return candidate;
                }

                // phase === 'up'
                let upControl = findControl(target);
                if (!upControl) {
                    try {
                        const probe = upDoc.elementFromPoint?.(e.clientX, e.clientY);
                        upControl = findControl(probe);
                    } catch (err) {
                        // ignore
                    }
                }

                // Only when the pointerup is a left-button-style release
                if (e.buttons !== 0) return null;

                // Prefer strict same-control semantics when possible.
                if (downControl && upControl) {
                    if (downControl !== upControl) return null;
                    if (!isInteractive(downControl) || isBlockedClickTarget(downControl)) return null;
                    return downControl;
                }

                // Fallback: if one side couldn't resolve a control, still allow a click
                // when the other side resolves a real UI control (prevents dead taps on wrappers).
                const candidate = downControl || upControl;
                if (!candidate || !isInteractive(candidate) || isBlockedClickTarget(candidate)) return null;

                return candidate;
            };

            const synthesizeClick = (control, e) => {
                const clickEv = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    view: control.ownerDocument?.defaultView || window
                });
                control.dispatchEvent(clickEv);
            };

            const dispatch = (target, e, pState) => {
                if (!target) return;
                target.dispatchEvent(e);

                if (e.type === 'pointerdown') {
                    focusPriming(target);

                    const cfg = getConfig();
                    if (cfg.clickSynthesisPhase === 'down') {
                        const control = resolveSynthesizedClickControl(target, e, pState, 'down');
                        if (control) synthesizeClick(control, e);
                    }
                }

                if (e.type === 'pointerup') {
                    // Click the control that was pressed, not the current hover target.
                    const cfg = getConfig();
                    if (cfg.clickSynthesisPhase !== 'down') {
                        const control = resolveSynthesizedClickControl(target, e, pState, 'up');
                        if (control) synthesizeClick(control, e);
                    }
                }
            };

            return { getConfig, getEffectiveAdapterKind, findControl, dispatch, sendNematocystToDino };
        })();

        function dispatchToHydraHydrant(t, e, pState) {
            P3InjectorPort.dispatch(t, e, pState);
        }

        // --- SPARKLINE HELPER ---
        function drawSparkline(ctx, x, y, w, h, data, color, markers = []) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            const step = w / 64;
            data.forEach((val, i) => {
                const px = x + i * step;
                const py = y + h - (val * h);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Draw Markers
            markers.forEach(m => {
                const my = y + h - (m.val * h);
                ctx.strokeStyle = m.color;
                ctx.setLineDash([2, 1]);
                ctx.beginPath(); ctx.moveTo(x, my); ctx.lineTo(x + w, my); ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        // --- ðŸŒ  ELEMENTAL JUICE HELPERS ---
        function drawFireball(ctx, x, y, size, intensity, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 236, 61, 0.9)', 'rgba(255, 77, 79, 0.8)', 'rgba(255, 30, 0, 0)'],
                'READY': ['rgba(255, 255, 255, 0.8)', 'rgba(255, 251, 143, 0.7)', 'rgba(255, 169, 64, 0.6)', 'rgba(255, 169, 64, 0)'],
                'COAST': ['rgba(255, 255, 255, 0.4)', 'rgba(145, 213, 255, 0.3)', 'rgba(9, 109, 217, 0.2)', 'rgba(9, 109, 217, 0)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Outer Gloom/Heat Distortion
            const bloomSize = size * (4 + Math.sin(time / 150) * 0.5);
            const bloomGrad = ctx.createRadialGradient(x, y, 0, x, y, bloomSize);
            bloomGrad.addColorStop(0, c[2]);
            bloomGrad.addColorStop(0.4, c[3]);
            ctx.fillStyle = bloomGrad;
            ctx.beginPath(); ctx.arc(x, y, bloomSize, 0, Math.PI * 2); ctx.fill();

            // Core Plasma
            const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
            coreGrad.addColorStop(0, c[0]);
            coreGrad.addColorStop(0.3, c[1]);
            coreGrad.addColorStop(0.7, c[2]);
            coreGrad.addColorStop(1, c[3]);

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Pulsing spikes/tendrils
            if (state === 'COMMIT') {
                ctx.strokeStyle = c[1];
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (time / 200) + (i * Math.PI / 4);
                    const length = size * (2.5 + Math.sin(time / 50 + i) * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- ðŸŒŠ WATER ELEMENT CURSOR (V20.4) ---
        function drawWaterCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(0, 191, 255, 0.8)', 'rgba(0, 123, 255, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(173, 216, 230, 0.5)', 'rgba(0, 191, 255, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(224, 247, 250, 0.2)', 'rgba(178, 235, 242, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Fluid Laser / Beam Path
            if (systemState.parameters.physics.showLaserBeam) {
                const dist = Math.sqrt((x - rawX) ** 2 + (y - rawY) ** 2);
                const steps = 10;
                ctx.lineWidth = state === 'COMMIT' ? 8 : 4;
                ctx.strokeStyle = c[1];
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);

                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    // Sine wave distortion for water feel
                    const wave = Math.sin(time / 200 + ratio * 10) * 5 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();

                // Inner white fluid core
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    const wave = Math.sin(time / 200 + ratio * 10) * 2 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();
            }

            // 2. Ripple Effect at Tip
            const rippleSize = (state === 'COMMIT' ? 20 : 12) + Math.sin(time / 300) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, rippleSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.5, c[1]);
            grad.addColorStop(1, 'rgba(0, 123, 255, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, rippleSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Bubbles/Droplets if committed
            if (state === 'COMMIT') {
                for (let i = 0; i < 3; i++) {
                    const bTime = (time + i * 1000) % 2000;
                    const bScale = bTime / 2000;
                    const bx = x + Math.cos(i * 2 + time / 500) * 20 * bScale;
                    const by = y - 30 * bScale; // Rise up
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - bScale) + ')';
                    ctx.beginPath(); ctx.arc(bx, by, 2 * (1 - bScale), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        // --- ðŸ”¥ FIRE ELEMENT CURSOR (V20.4) ---
        function drawFireCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 69, 0, 0.8)', 'rgba(255, 140, 0, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(255, 195, 0, 0.5)', 'rgba(255, 69, 0, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(255, 140, 0, 0.2)', 'rgba(128, 0, 0, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Heat Distortion Beam
            if (systemState.parameters.physics.showLaserBeam) {
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = c[1];
                ctx.lineWidth = state === 'COMMIT' ? 12 : 6;
                ctx.lineCap = 'round';
                ctx.globalAlpha = 0.6;
                ctx.stroke();

                // Subtler Flicker Core (V20.5: Reduced magnitude to stop "perceived" oscillation)
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x + (Math.random() - 0.5) * 3, y + (Math.random() - 0.5) * 3);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.2;
                ctx.stroke();
            }

            // 2. Rising Fireball at Tip (V20.5: Slower pulse)
            const fireSize = (state === 'COMMIT' ? 25 : 15) + Math.sin(time / 250) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, fireSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.4, c[1]);
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, fireSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Emitted Sparks
            if (state === 'COMMIT' || state === 'READY') {
                for (let i = 0; i < (state === 'COMMIT' ? 5 : 2); i++) {
                    const sparkTime = (time + i * 500) % 1000;
                    const sRatio = sparkTime / 1000;
                    const angle = (i * Math.PI * 2 / 5) + time / 1000;
                    const sx = x + Math.cos(angle) * 30 * sRatio;
                    // Rise up in screen space
                    const sy = y + Math.sin(angle) * 10 * sRatio - 60 * sRatio;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = 1 - sRatio;
                    ctx.beginPath(); ctx.arc(sx, sy, 2 * (1 - sRatio), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawElementalJuice(ctx, landmarks, readinessScore, canvasWidth, canvasHeight) {
            if (readinessScore <= 0.05) return;
            const intensity = readinessScore;
            const time = Date.now();

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Scale points based on intensity (0=wrist, 20=tips)
            const targetPoints = [0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 16, 17, 20];
            const activeCount = Math.floor(targetPoints.length * intensity);

            for (let i = 0; i < activeCount; i++) {
                const lm = landmarks[targetPoints[i]];
                const x = lm.x * canvasWidth;
                const y = lm.y * canvasHeight;

                const size = (15 + Math.sin(time / 100 + i) * 5) * intensity;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(0, `rgba(255, ${100 + Math.random() * 50}, 50, ${0.6 * intensity})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();

                // Upward Ash/Sparks
                if (Math.random() > 0.7) {
                    const sx = x + (Math.random() - 0.5) * 20;
                    const sy = y - (time % 1000 / 1000) * 40 * intensity;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = Math.random() * intensity;
                    ctx.beginPath(); ctx.arc(sx, sy, 1.5, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }

        // --- GEN5: Mirror-aware Handedness ---
        function getMirrorAwareHandedness(results, handIndex) {
            const name = results?.handedness?.[handIndex]?.[0]?.categoryName || 'Unknown';
            if (!systemState.parameters.camera.mirror) return name;
            if (name === 'Left') return 'Right';
            if (name === 'Right') return 'Left';
            return name;
        }

        function updateVisualPanels(results) {
            // Update Gestures Panel
            if (systemState.ui.gestures) {
                let html = '<div class="scrollable-panel">';
                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((cursor, i) => {
                        const hIdx = cursor.handIndex;
                        const gesture = cursor.gesture;
                        const score = cursor.confidence;
                        // Handedness still comes from raw results for now
                        const handedness = getMirrorAwareHandedness(results, hIdx);

                        const isCoasting = cursor.fsmState === 'COAST';
                        const stateColor = cursor.fsmState === 'COMMIT' ? 'var(--hfo-red)' : (isCoasting ? '#FFA500' : 'var(--md-sys-color-primary)');

                        // Deep Debug Data
                        const phys = systemState.p1.physicsState[hIdx];
                        const telemetry = phys && phys.getTelemetry ? phys.getTelemetry() : { speed: 0 };
                        const speed = telemetry.speed.toFixed(2);

                        const isPrimary = systemState.fsm.primaryHandIndex === hIdx;
                        const labelPrefix = isPrimary ? 'ðŸŽ–ï¸ [PRIMARY] ' : '';

                        html += `
                            <div class="m3-card" style="border-left: 4px solid ${stateColor}">
                                <div class="m3-label">${labelPrefix}Hand ${hIdx} | ${handedness}</div>
                                <div class="m3-stat">
                                    <span>Gesture | Confidence</span>
                                    <span style="font-weight:bold">${gesture} | ${(score * 100).toFixed(0)}%</span>
                                </div>
                                <div class="m3-stat" style="margin-top:8px">
                                    <span>Planck Speed (px/s)</span>
                                    <span style="color:var(--hfo-gold)">${speed}</span>
                                </div>
                                <div class="m3-stat">
                                    <span>Readiness Score</span>
                                    <span>${((cursor.readinessScore || 0) * 100).toFixed(1)}%</span>
                                </div>
                                <div class="m3-progress-container">
                                    <div class="m3-progress-bar" style="width: ${(cursor.readinessScore || 0) * 100}%; background: ${stateColor}"></div>
                                </div>
                                <div class="m3-stat">
                                    <span>Rod Sync (Projected)</span>
                                    <span style="font-family:monospace">${cursor.screenX.toFixed(0)}/${cursor.screenY.toFixed(0)}</span>
                                </div>
                                <div class="m3-stat" style="margin-top:4px; font-size:10px; opacity:0.7">
                                    <span>FSM State</span>
                                    <span>${cursor.fsmState || 'IDLE'}</span>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += '<div style="color:var(--md-sys-color-outline); text-align:center; margin-top:40px;">No hands detected</div>';
                }
                html += '</div>';
                systemState.ui.gestures.innerHTML = html;
            }

            // Update Palm Panel
            if (systemState.ui.palmCtx) {
                const ctx = systemState.ui.palmCtx;
                const canvas = systemState.ui.palm;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((c, i) => {
                        const x = (i === 0 ? canvas.width * 0.25 : canvas.width * 0.75);
                        const y = canvas.height * 0.5;
                        const radius = 40;

                        // ðŸŸ¢ Palm Orientation Sphere (Enhanced V14)
                        const enterT = systemState.parameters.palm.enterThreshold;
                        const exitT = systemState.parameters.palm.exitThreshold;

                        // Background Sphere
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = c.isPalmFacing ? 'rgba(0, 255, 65, 0.05)' : 'rgba(255, 65, 54, 0.05)';
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Hysteresis Rings (Target Zones)
                        ctx.setLineDash([2, 4]);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath(); ctx.arc(x, y, radius * enterT, 0, Math.PI * 2); ctx.stroke(); // Enter Ring
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.beginPath(); ctx.arc(x, y, radius * exitT, 0, Math.PI * 2); ctx.stroke();  // Exit Ring
                        ctx.setLineDash([]);

                        // Face Dot & Normal (Fabric Driven)
                        const nx = c.palmNormal.x;
                        const ny = c.palmNormal.y;
                        const nz = c.normalZ;

                        if (c.palmNormal) { // Fabric always has normal data if cursor exists
                            // ðŸ“Š UPDATE SPARKLINE BUFFERS
                            if (!systemState.ui.history) systemState.ui.history = [];
                            if (!systemState.ui.history[i]) systemState.ui.history[i] = { zNorm: [], readiness: [] };

                            systemState.ui.history[i].zNorm.push(nz);
                            systemState.ui.history[i].readiness.push(c.readinessScore);
                            if (systemState.ui.history[i].zNorm.length > 88) { // Pareto-length history
                                systemState.ui.history[i].zNorm.shift();
                                systemState.ui.history[i].readiness.shift();
                            }

                            // Dynamic Color based on facing status
                            const stateColor = c.isPalmFacing ? '#00FF41' : '#FF4136';

                            // Depth Progress Ring (Fidelity Visualization)
                            ctx.beginPath();
                            ctx.arc(x, y, radius * nz, 0, Math.PI * 2);
                            ctx.strokeStyle = stateColor;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;

                            // Draw Normal Vector Shadow/Pointer
                            const dotX = x + nx * radius;
                            const dotY = y + ny * radius;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(dotX, dotY);
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.stroke();

                            // Facing Dot (Orientation Feedback)
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 6, 0, Math.PI * 2);
                            ctx.fillStyle = stateColor;
                            ctx.shadowBlur = c.isPalmFacing ? 15 : 0;
                            ctx.shadowColor = stateColor;
                            ctx.fill();
                            ctx.shadowBlur = 0;

                            // Crosshair if inside "Goldilocks" area (approx)
                            if (nz > 0.88) {
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(dotX - 10, dotY); ctx.lineTo(dotX + 10, dotY); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(dotX, dotY - 10); ctx.lineTo(dotX, dotY + 10); ctx.stroke();
                            }

                            // ðŸ“Š Z-NORM Hysteresis Gauge
                            const gageW = 8, gageH = 80;
                            const gageX = x + radius + 15, gageY = y - gageH / 2;

                            // Track
                            ctx.fillStyle = '#111';
                            ctx.fillRect(gageX, gageY, gageW, gageH);

                            // ðŸ“Š SPARKLINE: Z-NORM HISTORY
                            const zHistory = systemState.ui.history[i].zNorm;
                            drawSparkline(ctx, gageX - 5, gageY, gageW + 10, gageH, zHistory, '#00FF4144');

                            // Thresholds (0.80 & 0.64) & Goldilocks (0.88)
                            const enterY = gageY + gageH * (1 - systemState.parameters.palm.enterThreshold);
                            const exitY = gageY + gageH * (1 - systemState.parameters.palm.exitThreshold);
                            const goldY = gageY + gageH * (1 - 0.88); // 88% Pareto Target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(gageX - 5, enterY); ctx.lineTo(gageX + gageW + 5, enterY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(gageX - 5, exitY); ctx.lineTo(gageX + gageW + 5, exitY); ctx.stroke();

                            // 88% Goldilocks Marker
                            ctx.strokeStyle = '#FFD700'; // Gold
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(gageX - 8, goldY); ctx.lineTo(gageX + gageW + 8, goldY); ctx.stroke();
                            ctx.setLineDash([]);

                            // Fill
                            const normFill = gageH * Math.max(0, Math.min(1, nz));
                            ctx.fillStyle = c.isPalmFacing ? '#00FF41' : '#444';
                            ctx.fillRect(gageX, gageY + gageH - normFill, gageW, normFill);

                            // âš–ï¸ Readiness Hysteresis Visualizer
                            const rgW = 12, rgH = 80;
                            const rgX = x - radius - 27, rgY = y - rgH / 2;
                            const readinessScore = systemState.p1.readinessScores[i] || 0;

                            ctx.fillStyle = '#111';
                            ctx.fillRect(rgX, rgY, rgW, rgH);

                            // ðŸ“Š SPARKLINE: READINESS HISTORY
                            const bHistory = systemState.ui.history[i].readiness;
                            drawSparkline(ctx, rgX - 5, rgY, rgW + 10, rgH, bHistory, '#D0BCFF44');

                            const highY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisHigh);
                            const lowY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisLow);
                            const targetY = rgY + rgH * (1 - 0.88); // 88% HIVE target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(rgX - 2, highY); ctx.lineTo(rgX + rgW + 2, highY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(rgX - 2, lowY); ctx.lineTo(rgX + rgW + 2, lowY); ctx.stroke();

                            // 88% Target Marker
                            ctx.strokeStyle = '#D0BCFF';
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(rgX - 5, targetY); ctx.lineTo(rgX + rgW + 5, targetY); ctx.stroke();
                            ctx.setLineDash([]);

                            const fillH = rgH * readinessScore;
                            ctx.fillStyle = c.fsmState === 'READY' ? '#FFD700' : (c.fsmState === 'COMMIT' ? '#FF4136' : '#D0BCFF');
                            ctx.fillRect(rgX, rgY + rgH - fillH, rgW, fillH);

                            // Textual readout
                            ctx.fillStyle = '#AAA';
                            ctx.font = '9px Roboto';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${(systemState.parameters.fsm.hysteresisHigh * 100).toFixed(0)}/${(systemState.parameters.fsm.hysteresisLow * 100).toFixed(0)} Z`, gageX + gageW / 2, gageY - 5);
                            ctx.fillText(`88% HFO`, rgX + rgW / 2, rgY - 5);
                            ctx.fillText(`Z: ${nz.toFixed(2)}`, gageX + gageW / 2, gageY + gageH + 12);
                            ctx.fillText(`READINESS: ${(readinessScore * 100).toFixed(0)}%`, rgX + rgW / 2, rgY + rgH + 12);
                            ctx.fillText(`FSM: ${c.fsmState}`, x, y + radius + 35);
                        }
                    });
                }
            }

            // --- V18: TACTICAL VIEW (P3 GHOST CURSOR) ---
            if (systemState.ui.tacticalCtx) {
                const ctx = systemState.ui.tacticalCtx;
                const canvas = systemState.ui.tactical;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // GEN6 v2: Touch2D color palette by FSM state
                // IDLE uses a neutral white/gray, READY is orange, COMMIT is cyan, COAST is yellow.
                const stateStroke = {
                    IDLE: '#D0D0D0',
                    READY: '#FF8C00',
                    COMMIT: '#00FFFF',
                    COAST: '#FFD700'
                };
                const getStroke = (state) => stateStroke[String(state || '').toUpperCase()] || '#D0D0D0';

                // Grid lines for tactical feel
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const gx = (i / 10) * canvas.width;
                    const gy = (i / 10) * canvas.height;
                    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
                }

                const toTx = (nx) => (Number(nx) * canvas.width);
                const toTy = (ny) => (Number(ny) * canvas.height);

                // --- GEN6 v20: STATIC TRIPWIRE (2-line hysteresis band edges) ---
                try {
                    const band = systemState?.parameters?.p2?.tripwireThread?.band || {};
                    const centerY = Number(band.centerUiNormY ?? 0.5);
                    const thickness = Math.max(0, Number(band.thicknessUiNorm ?? 0.06) || 0.06);
                    const xMin = Math.max(0, Number(band.spanUiNormXMin ?? 0.0) || 0.0);
                    const xMax = Math.min(1, Number(band.spanUiNormXMax ?? 1.0) || 1.0);
                    const yTop = centerY - (thickness / 2);
                    const yBot = centerY + (thickness / 2);

                    ctx.save();
                    ctx.strokeStyle = 'rgba(208, 188, 255, 0.85)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 2]);
                    ctx.beginPath();
                    ctx.moveTo(toTx(xMin), toTy(yTop));
                    ctx.lineTo(toTx(xMax), toTy(yTop));
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(toTx(xMin), toTy(yBot));
                    ctx.lineTo(toTx(xMax), toTy(yBot));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Center marker (subtle)
                    ctx.strokeStyle = 'rgba(208, 188, 255, 0.25)';
                    ctx.beginPath();
                    ctx.moveTo(toTx(xMin), toTy(centerY));
                    ctx.lineTo(toTx(xMax), toTy(centerY));
                    ctx.stroke();
                    ctx.restore();
                } catch (_) {
                    // ignore
                }

                if (systemState.p1.cursors.length > 0) {
                    systemState.p1.cursors.forEach((c) => {
                        const tx = (c.screenX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ty = (c.screenY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        // Origin Pointer (Raw Sensing)
                        const rx = (c.rawX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ry = (c.rawY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        ctx.beginPath();
                        ctx.moveTo(rx, ry);
                        ctx.lineTo(tx, ty);
                        ctx.strokeStyle = '#555';
                        ctx.setLineDash([1, 1]);
                        ctx.stroke();

                        // Ghost Cursor (Tactical UI)
                        ctx.beginPath();
                        ctx.arc(tx, ty, 6, 0, Math.PI * 2);
                        ctx.strokeStyle = getStroke(c.fsmState);
                        ctx.setLineDash([]);
                        ctx.stroke();

                        // Pressure Indicator
                        if (c.fsmState === 'COMMIT') {
                            ctx.beginPath();
                            ctx.arc(tx, ty, 10 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(0, 255, 255, 0.18)';
                            ctx.fill();
                        }

                        // Identifier
                        ctx.fillStyle = getStroke(c.fsmState);
                        ctx.font = '9px monospace';
                        ctx.fillText(`H${c.handIndex}:${c.fsmState}`, tx + 10, ty - 10);

                        // --- GEN6 v22: PALM TRIANGLE + KNUCKLE TRIPWIRE (triangle + 2 top hysteresis lines) ---
                        try {
                            const handIndex = Number(c?.handIndex ?? 0);
                            const landmarks = (Array.isArray(c?.landmarks) && c.landmarks.length >= 21)
                                ? c.landmarks
                                : (Array.isArray(systemState?.p1?.lastLandmarks?.[handIndex]) ? systemState.p1.lastLandmarks[handIndex] : null);
                            if (!landmarks || landmarks.length < 21) return;

                            const wrist = landmarks[0];
                            const indexMcp = landmarks[5];
                            const pinkyMcp = landmarks[17];
                            const indexTip = landmarks[8];
                            if (!wrist || !indexMcp || !pinkyMcp || !indexTip) return;

                            // Palm triangle (wrist, index MCP, pinky MCP)
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(toTx(wrist.x), toTy(wrist.y));
                            ctx.lineTo(toTx(indexMcp.x), toTy(indexMcp.y));
                            ctx.lineTo(toTx(pinkyMcp.x), toTy(pinkyMcp.y));
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(0, 255, 255, 0.06)';
                            ctx.strokeStyle = 'rgba(0, 255, 255, 0.22)';
                            ctx.lineWidth = 1;
                            ctx.fill();
                            ctx.stroke();
                            ctx.restore();

                            // Knuckle tripwire bar is the line segment (index MCP -> pinky MCP)
                            const ax = Number(indexMcp.x);
                            const ay = Number(indexMcp.y);
                            const bx = Number(pinkyMcp.x);
                            const by = Number(pinkyMcp.y);
                            const abx = bx - ax;
                            const aby = by - ay;
                            const len = Math.hypot(abx, aby);
                            if (!(len > 1e-6)) return;

                            // v22: show endpoint extensions (same semantics as P2 knuckle tripwire thread)
                            const pK = (systemState?.parameters?.p2?.knuckleTripwire || systemState?.parameters?.p2?.knuckleKeybar || {});
                            const baseA = Number(pK.barExtensionFracA ?? 0.5);
                            const baseB = Number(pK.barExtensionFracB ?? 0.5);
                            const extFracA = Math.max(0, Math.min(3, Number(getFlagNumber('p2-knuckle-tripwire-ext-a-frac', baseA)) || 0));
                            const extFracB = Math.max(0, Math.min(3, Number(getFlagNumber('p2-knuckle-tripwire-ext-b-frac', baseB)) || 0));
                            const ux = abx / len;
                            const uy = aby / len;
                            const extA = len * extFracA;
                            const extB = len * extFracB;
                            const aExt = { x: ax - ux * extA, y: ay - uy * extA };
                            const bExt = { x: bx + ux * extB, y: by + uy * extB };

                            // Unit normal such that dot((P-A), n) == signedDistance and signedLineFeature2D == len * signedDistance
                            let nx = (-aby / len);
                            let ny = (abx / len);

                            // Orient normal so wrist is negative side (top lines are on fingertip side).
                            const wristDist = ((Number(wrist.x) - ax) * nx) + ((Number(wrist.y) - ay) * ny);
                            if (Number.isFinite(wristDist) && wristDist > 0) {
                                nx = -nx;
                                ny = -ny;
                            }

                            const on = Number(pK.on ?? 0.01);
                            const off = Number(pK.off ?? 0.0);
                            const dOn = on;
                            const dOff = off;

                            // Segment gating (finite segment semantics). If tip is outside extended segment, dim the overlay.
                            const tipT = ((Number(indexTip.x) - ax) * ux + (Number(indexTip.y) - ay) * uy);
                            const inSegFallback = (tipT >= (-extA - 1e-6)) && (tipT <= (len + extB + 1e-6));

                            // Micro-FSM: try to use pressed state from P2 snapshot (authoritative), else null.
                            let isPressed = null;
                            let inExtendedSegment = null;
                            try {
                                const snap = window.hfoP2KnuckleTripwireThread?.getSnapshot?.();
                                const hands = Array.isArray(snap?.hands) ? snap.hands : [];
                                const match = hands.find((h) => Number(h?.handIndex ?? -1) === handIndex && Number(h?.pointerId ?? -1) === Number(c?.pointerId ?? -1));
                                if (match && typeof match.pressed === 'boolean') isPressed = match.pressed;
                                if (match && typeof match.inExtendedSegment === 'boolean') inExtendedSegment = match.inExtendedSegment;
                            } catch (_) {
                                // ignore
                            }
                            if (typeof inExtendedSegment !== 'boolean') inExtendedSegment = inSegFallback;

                            const state = String(c?.fsmState || '').toUpperCase();
                            const strokeActive = (isPressed === true)
                                ? 'rgba(255, 65, 54, 0.9)'
                                : (state === 'COMMIT'
                                    ? 'rgba(0, 255, 255, 0.7)'
                                    : (state === 'READY' ? 'rgba(255, 140, 0, 0.65)' : 'rgba(208, 208, 208, 0.55)'));
                            const strokeDim = (inExtendedSegment === false) ? 'rgba(120, 120, 120, 0.28)' : 'rgba(0, 255, 255, 0.18)';

                            const drawOffsetLine = (x0, y0, x1, y1, d, rgba, dash) => {
                                ctx.save();
                                ctx.strokeStyle = rgba;
                                ctx.lineWidth = 1;
                                if (dash) ctx.setLineDash(dash);
                                ctx.beginPath();
                                ctx.moveTo(toTx(x0 + nx * d), toTy(y0 + ny * d));
                                ctx.lineTo(toTx(x1 + nx * d), toTy(y1 + ny * d));
                                ctx.stroke();
                                ctx.setLineDash([]);
                                ctx.restore();
                            };

                            // Base bar (unextended, dashed)
                            drawOffsetLine(ax, ay, bx, by, 0, strokeDim, [3, 3]);

                            // Extended bar (solid) + endpoints
                            ctx.save();
                            ctx.strokeStyle = strokeActive;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([]);
                            ctx.beginPath();
                            ctx.moveTo(toTx(aExt.x), toTy(aExt.y));
                            ctx.lineTo(toTx(bExt.x), toTy(bExt.y));
                            ctx.stroke();
                            ctx.fillStyle = strokeActive;
                            ctx.beginPath();
                            ctx.arc(toTx(aExt.x), toTy(aExt.y), 2.5, 0, Math.PI * 2);
                            ctx.arc(toTx(bExt.x), toTy(bExt.y), 2.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();

                            // Hysteresis edges (offset lines along the extended segment)
                            drawOffsetLine(aExt.x, aExt.y, bExt.x, bExt.y, dOn, 'rgba(0, 255, 0, 0.55)', null);
                            drawOffsetLine(aExt.x, aExt.y, bExt.x, bExt.y, dOff, 'rgba(0, 180, 255, 0.55)', null);

                            // Index tip marker
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(toTx(indexTip.x), toTy(indexTip.y), 3, 0, Math.PI * 2);
                            ctx.fillStyle = (inExtendedSegment === false)
                                ? 'rgba(160, 160, 160, 0.45)'
                                : (isPressed === true ? 'rgba(255, 65, 54, 0.75)' : 'rgba(255, 255, 255, 0.55)');
                            ctx.fill();
                            ctx.restore();
                        } catch (_) {
                            // ignore
                        }
                    });
                }
            }

            // Update FSM Visualization Panel
            if (systemState.ui.fsmCtx) {
                const ctx = systemState.ui.fsmCtx;
                const canvas = systemState.ui.fsm;
                if (canvas.width === 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const nodes = [
                    { id: 'IDLE', x: 0.15, y: 0.5 },
                    { id: 'READY', x: 0.4, y: 0.5 },
                    { id: 'COMMIT', x: 0.65, y: 0.5 },
                    { id: 'COAST', x: 0.9, y: 0.5 }
                ];

                const nodeWidth = 70, nodeHeight = 35;
                const current = systemState.fsm.currentState;

                // Draw Transitions
                ctx.strokeStyle = '#333';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                // IDLE -> READY
                ctx.moveTo(canvas.width * 0.15 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.4 - nodeWidth / 2, canvas.height * 0.5);
                // READY -> COMMIT
                ctx.moveTo(canvas.width * 0.4 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.65 - nodeWidth / 2, canvas.height * 0.5);
                // COMMIT -> COAST
                ctx.moveTo(canvas.width * 0.65 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.9 - nodeWidth / 2, canvas.height * 0.5);
                // Transitions back and to IDLE omitted for clarity in simple viz
                ctx.stroke();
                ctx.setLineDash([]);

                nodes.forEach(node => {
                    const nx = canvas.width * node.x;
                    const ny = canvas.height * node.y;
                    const isActive = node.id === current;

                    // Glow for active node
                    if (isActive) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF')));
                    }

                    ctx.fillStyle = isActive ? '#000' : '#111';
                    ctx.strokeStyle = isActive ? (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF'))) : '#444';
                    ctx.beginPath();
                    ctx.roundRect(nx - nodeWidth / 2, ny - nodeHeight / 2, nodeWidth, nodeHeight, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = isActive ? '#FFF' : '#888';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.id, nx, ny + 5);

                    // Draw Readiness Gauge for active state
                    if (isActive && node.id !== 'IDLE') {
                        const pIdx = systemState.fsm.primaryHandIndex !== null ? systemState.fsm.primaryHandIndex : 0;
                        const charge = systemState.p1.readinessScores[pIdx] || 0;
                        const high = systemState.parameters.fsm.hysteresisHigh;
                        const low = systemState.parameters.fsm.hysteresisLow;

                        ctx.fillStyle = '#222';
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth, 6);

                        // Fill
                        ctx.fillStyle = (node.id === 'COAST' ? '#FFA500' : '#FFD700');
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth * charge, 6);

                        // HFO Threshold Markers (80/64)
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * high, ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * high, ny + 30);
                        ctx.stroke();

                        ctx.strokeStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * low, ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * low, ny + 30);
                        ctx.stroke();
                    }
                });
            }
        }

        function updateFSM(state) {
            if (systemState.fsm.currentState !== state) {
                systemState.fsm.currentState = state;
                const status = document.getElementById('state-indicator');
                status.innerText = `P1: CONTRACTS ACTIVE | FSM: ${state}`;
            }
        }

        function drawResults(rawResults, fabric) {
            const { ctx, canvas } = systemState.p0;
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cursors = fabric.cursors;
            const isMirror = systemState.parameters.camera.mirror;

            // --- V19.6: INTEGRATED TACTICAL GRID ---
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const gx = (i / 10) * canvas.width;
                const gy = (i / 10) * canvas.height;
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }
            ctx.restore();

            // --- P0 ISR SKELETON (Restricted Bypass) ---
            // V24.18: Consolidated skeleton drawing to Port 1 Fabric loop below for state-awareness.

            // --- PORT 1 FABRIC VISUALS (Enforced) ---
            cursors.forEach((c, i) => {
                const { screenX, screenY, fsmState, rawX, rawY, landmarks } = c;

                // V24.19 Parity Fix: landmarks are already mirrored/processed by P1Bridger.
                // Do NOT re-mirror them here.
                if ((fsmState === 'IDLE' || fsmState === 'READY' || fsmState === 'COMMIT') && landmarks && landmarks.length > 0 && systemState.parameters.landmarks.showSkeleton) {
                    const utils = new DrawingUtils(ctx);

                    // V28.0: UPE-AWARE SKELETON
                    // We must project landmarks into buffer space using UPE to maintain parity
                    const bufferLandmarks = landmarks.map(l => ({
                        x: systemState.p1.toBufferX(l.x) / canvas.width,
                        y: systemState.p1.toBufferY(l.y) / canvas.height,
                        z: l.z
                    }));

                    utils.drawConnectors(bufferLandmarks, GestureRecognizer.HAND_CONNECTIONS, { color: 'rgba(255, 255, 255, 0.15)', lineWidth: 1.2 });
                    utils.drawLandmarks(bufferLandmarks, { color: 'rgba(255, 255, 255, 0.2)', radius: 1 });
                }

                // V28.5: DIAGNOSTIC CROSSHAIRS (Red Truth Calibration)
                if (isFlagEnabled('dev-mode') && fsmState !== 'IDLE') {
                    ctx.save();
                    ctx.strokeStyle = (fsmState === 'COMMIT') ? '#00ffff' : '#ff9900';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 20, screenY); ctx.lineTo(screenX + 20, screenY);
                    ctx.moveTo(screenX, screenY - 20); ctx.lineTo(screenX, screenY + 20);
                    ctx.stroke();
                    ctx.restore();
                }

                if (fsmState === 'IDLE') return;

                const theme = systemState.parameters.physics.cursorTheme;

                if (theme === 'LI') {
                    drawFireCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'DUI') {
                    drawWaterCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'QIAN') {
                    // Legacy Rigid Rod Logic (Metal/Heaven)
                    const color = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                    if (systemState.parameters.physics.showLaserBeam) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = fsmState === 'COMMIT' ? 10 : 6;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = fsmState === 'COMMIT' ? 0.9 : 0.6;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = fsmState === 'COMMIT' ? 3 : 2;
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 8 : 5, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Placeholder for other 5 elements (ZHEN, XUN, KAN, GEN, KUN)
                    const themeColors = {
                        'ZHEN': '#9400D3', 'XUN': '#00FF00', 'KAN': '#00008B',
                        'GEN': '#8B4513', 'KUN': '#A52A2A'
                    };
                    const color = themeColors[theme] || '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 10 : 6, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }

                // --- V19.6: INTEGRATED GHOST CURSOR (Tactical Layer) ---
                const ghostColor = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                ctx.save();
                ctx.beginPath();
                ctx.arc(screenX, screenY, 12, 0, Math.PI * 2);
                ctx.strokeStyle = ghostColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.restore();

                // Focal Crosshair (Goldilocks Zone)
                if (fsmState === 'COMMIT') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 10, screenY); ctx.lineTo(screenX + 10, screenY);
                    ctx.moveTo(screenX, screenY - 10); ctx.lineTo(screenX, screenY + 10);
                    ctx.stroke();
                }
            });
        }

        // --- P7: NAVIGATOR (Settings Shell) ---
        class P7Navigator {
            static applyTooltip(control, text) {
                if (!control || !text) return;
                const el = control.domElement || control?.$?.container || control?.$?.root;
                if (el) el.title = text;
            }

            static init(container) {
                const div = document.createElement('div');
                div.className = 'scrollable-panel';
                container.appendChild(div);

                const gui = new GUI({ container: div, title: 'ðŸ›°ï¸ NAVIGATOR CONFIG', autoPlace: false });
                gui._hfoFolders = {}; // V39: Custom registry to avoid lil-gui namespace collision

                // V39: ESSENTIALS / DEVELOPER TOGGLE (PROGRESSIVE DISCLOSURE)
                gui.add(systemState.parameters, 'essentialsMode')
                    .name('ESSENTIALS (KIOSK)')
                    .onChange(val => {
                        logMission(`UX Mode: ${val ? 'ESSENTIALS' : 'DEVELOPER'}`);
                        initLayout(val);
                        // Refresh GUI visibility (though the rebuild will recreate it)
                        P7Navigator.applyVisibility(gui, val);
                    });

                const fTelem = gui.addFolder('P6: Telemetry & Replay [V24.6]');
                gui._hfoFolders.fTelem = fTelem;
                fTelem.add(window.hfoTelemetry, 'isRecording').name('RECORDING ACTIVE').listen();
                fTelem.add({ start: () => window.hfoTelemetry.start() }, 'start').name('Start Recording');
                fTelem.add({ stop: () => window.hfoTelemetry.stop() }, 'stop').name('Stop Recording');
                fTelem.add({ export: () => window.hfoTelemetry.exportJSONL() }, 'export').name('Export .jsonl');

                // Replay Controls (Golden Master)
                fTelem.add(window.hfoPlayer, 'isPlaying').name('REPLAY ACTIVE').listen();
                fTelem.add(window.hfoPlayer, 'loop').name('Loop Replay');
                fTelem.add({
                    load: () => {
                        const inp = document.createElement('input');
                        inp.type = 'file';
                        inp.accept = '.jsonl';
                        inp.onchange = (e) => {
                            const file = e.target.files[0];
                            if (file) window.hfoPlayer.load(file);
                        };
                        inp.click();
                    }
                }, 'load').name('Load JSONL Replay');
                fTelem.add({ start: () => window.hfoPlayer.start() }, 'start').name('â–¶ Start Replay');
                fTelem.add({ stop: () => window.hfoPlayer.stop() }, 'stop').name('â¹ Stop Replay');
                fTelem.add({ pause: () => window.hfoPlayer.pause() }, 'pause').name('â¸ Pause Replay');

                // ðŸ’  HEXAGONAL PORTS (MOSA ALIGNMENT)
                const fPorts = gui.addFolder('ðŸ’  JADC2 MOSAIC PORTS');
                gui._hfoFolders.fPorts = fPorts;
                fPorts.add(systemState.parameters.apps.overlay, 'zoom', 0.5, 2.0, 0.01).name('Overscan Zoom').onChange(() => {
                    try {
                        window.hfoPorts?.p7?.apps?.applyActiveOverlayTuning?.();
                    } catch (_) {
                        // ignore
                    }
                });
                fPorts.add(systemState.parameters.ports, 'p0_recognizer', ['MEDIAPIPE_HANDS', 'TENSORFLOW_JS', 'OPENCV_STUB']).name('P0: Sensing Shard').onChange(val => {
                    logMission(`P0 Shard Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p1_fusion', ['UNIVERSAL_PROJECTION_V28', 'LEGACY_PIXI_MAP']).name('P1: Fusion Bridge').onChange(val => {
                    logMission(`P1 Bridge Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p2_fsm', ['SOVEREIGN_4_STATE', 'LEGACY_3_STATE', 'BFT_CONSENSUS']).name('P2: FSM Controller').onChange(val => {
                    logMission(`P2 Controller Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p3_injector', ['HYDRA_ADAPTER_PULSE', 'DIRECT_DOM_CLICK']).name('P3: Effect Injector').onChange(val => {
                    logMission(`P3 Injector Swapped: ${val}`);
                });

                const fP3 = gui.addFolder('P3: Pointer Injector (Adapter)');
                gui._hfoFolders.fP3 = fP3;
                fP3.add(systemState.parameters.p3, 'adapter', ['auto', 'excalidraw', 'standard']).name('Adapter').onChange(val => {
                    logMission(`P3 Adapter: ${val}`);
                });
                fP3.add(systemState.parameters.p3, 'enableClickSynthesis').name('Click Synthesis (Legacy)').onChange(val => {
                    logMission(`P3 Click Synthesis: ${val ? 'ENABLED' : 'DISABLED'}`);
                });
                fP3.add(systemState.parameters.p3, 'tapMoveThresholdPx', 0, 20, 1).name('Tap Threshold (px)').onChange(val => {
                    logMission(`P3 Tap Threshold: ${val}px`);
                });

                fPorts.add(systemState.parameters.visuals, 'engine', ['BABYLON', 'PIXI', 'CANVAS']).name('P4: Visual Substrate').onChange(val => {
                    logMission(`Port 4: Visual Engine Swapping to ${val}...`);
                    if (val === 'BABYLON') {
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'block';
                        }
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    } else if (val === 'CANVAS') {
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'block';
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'none';
                        }
                    } else if (val === 'PIXI') {
                        logMission("âš ï¸ PIXI Engine selected. Stub mode active.", "#FFA500");
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    }
                });

                const fVisuals = gui.addFolder('ðŸš€ P4: Visual Engines');
                gui._hfoFolders.fVisuals = fVisuals;
                fVisuals.add(systemState.parameters.visuals, 'variant').disable().name('Active: PHOENIX_CORE (BabylonJS) â€” Weapon: PHOENIX_PYREBLADE');
                fVisuals.add(systemState.parameters.physics, 'showTrailMesh').name('Show Trail Ribbon (Legacy)');
                fVisuals.add(systemState.parameters.physics, 'showHFOClaw').name('Show HFO Pointer Claw');

                const fCam = gui.addFolder('P0: Camera Range');
                gui._hfoFolders.fCam = fCam;
                fCam.add(systemState.parameters.camera, 'resolution', ['640x480', '1280x720', '1920x1080']).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'fpsTarget', 15, 60, 1).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'mirror').onChange(syncConfig);

                const fLand = gui.addFolder('P0: Neural Shards');
                gui._hfoFolders.fLand = fLand;
                fLand.add(systemState.parameters.landmarks, 'minConfidence', 0.1, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'numHands', 1, 4, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'showSkeleton');
                fLand.add(systemState.parameters.landmarks, 'skeletonFadeTimeMs', 100, 2000, 10).name('Skeleton Fade (ms)');
                fLand.add(systemState.parameters.landmarks, 'skeletonInactivityTimeoutMs', 500, 5000, 10).name('Dormancy Timeout (ms)');

                const fGest = gui.addFolder('P1: Gesture Confidence');
                gui._hfoFolders.fGest = fGest;
                fGest.add(systemState.parameters.gestures, 'minGestureConfidence', 0, 1).name('Confidence Threshold');
                fGest.add(systemState.parameters.gestures, 'preferredHand', ['Any', 'Left', 'Right']);

                const fPalm = gui.addFolder('P1: Palm Cone Orientation');
                gui._hfoFolders.fPalm = fPalm;
                fPalm.add(systemState.parameters.palm, 'enterThreshold', 0, 1).name('Enter Threshold (80)');
                fPalm.add(systemState.parameters.palm, 'exitThreshold', 0, 1).name('Exit Threshold (64)');

                const fFSM = gui.addFolder('P2: Sharding & Hysteresis (Dev)');
                gui._hfoFolders.fFSM = fFSM;
                fFSM.add(systemState.parameters.fsm, 'hysteresisHigh', 0, 1, 0.01).name('Ready Threshold (0-1)');
                fFSM.add(systemState.parameters.fsm, 'hysteresisLow', 0, 1, 0.01).name('Idle Threshold (0-1)');
                const ctrlCharge = fFSM.add(systemState.parameters.fsm, 'chargeTimeMs', 10, 1000).name('Charge Time (ms)');
                const ctrlRelease = fFSM.add(systemState.parameters.fsm, 'releaseTimeMs', 10, 1000).name('Release Time (ms)');
                const ctrlCoastDrain = fFSM.add(systemState.parameters.fsm, 'coastDrainTimeMs', 10, 3000).name('Coast Drain (ms)');
                P7Navigator.applyTooltip(ctrlCharge, 'Readiness energy fill time. Lower = faster arm.');
                P7Navigator.applyTooltip(ctrlRelease, 'Readiness energy drain time when facing away.');
                P7Navigator.applyTooltip(ctrlCoastDrain, 'Readiness drain time during COAST/tracking loss.');
                fFSM.add(systemState.parameters.fsm, 'tensionMs', 0, 500).name('Tension/Coyote (ms)');

                const fReadiness = gui.addFolder('P2: Readiness Energy');
                gui._hfoFolders.fReadiness = fReadiness;
                const ctrlFill = fReadiness.add(systemState.parameters.readiness, 'fillMultiplier', 0.1, 3.0).name('Fill Ratio');
                const ctrlDrain = fReadiness.add(systemState.parameters.readiness, 'drainMultiplier', 0.1, 3.0).name('Drain Ratio');
                const ctrlCoastMult = fReadiness.add(systemState.parameters.readiness, 'coastDrainMultiplier', 0.1, 3.0).name('Coast Drain Ratio');
                P7Navigator.applyTooltip(ctrlFill, 'Multiplier for readiness fill when palm/back faces camera.');
                P7Navigator.applyTooltip(ctrlDrain, 'Multiplier for readiness drain when facing away.');
                P7Navigator.applyTooltip(ctrlCoastMult, 'Extra drain multiplier during COAST/tracking loss.');

                const fSword = gui.addFolder('P2: PHOENIX_PYREBLADE');
                gui._hfoFolders.fSword = fSword;
                const sm = systemState?.parameters?.p2?.swordMeter;
                const pvfx = systemState?.parameters?.p2?.pyrebladeVfx;
                if (sm) {
                    const ctrlSwordEnabled = fSword.add(sm, 'enabled').name('Enabled');
                    const ctrlSwordFill = fSword.add(sm, 'fillMs', 50, 3000, 10).name('Fill (ms)');
                    const ctrlSwordDrain = fSword.add(sm, 'drainMs', 50, 3000, 10).name('Drain (ms)');
                    const ctrlSwordMinConf = fSword.add(sm, 'minConfidence', 0, 1, 0.01).name('Min Confidence');
                    const ctrlSwordBaseScale = fSword.add(sm, 'baseScale01', 0, 1, 0.01).name('Base Scale');
                    const ctrlSwordA = fSword.add(sm, 'knuckleSpanMultiplierA', 0.5, 20.0, 0.25).name('Forward Span (Ã—)');
                    const ctrlSwordB = fSword.add(sm, 'knuckleSpanMultiplierB', 0.0, 2.0, 0.05).name('Back Span (Ã—)');

                    P7Navigator.applyTooltip(ctrlSwordEnabled, 'Enable/disable the sword meter subsystem (P2)');
                    P7Navigator.applyTooltip(ctrlSwordFill, 'Time to fill meter to lock under COMMIT_THUMBS_UP');
                    P7Navigator.applyTooltip(ctrlSwordDrain, 'Time to drain meter to unlock under COMMIT_THUMBS_DOWN');
                    P7Navigator.applyTooltip(ctrlSwordMinConf, 'Minimum cursor confidence required to fill/drain');
                    P7Navigator.applyTooltip(ctrlSwordBaseScale, 'Minimum extension scale even at meter=0');
                    P7Navigator.applyTooltip(ctrlSwordA, 'Forward extension beyond index knuckle, in knuckle-span multiples');
                    P7Navigator.applyTooltip(ctrlSwordB, 'Backward extension beyond pinky knuckle, in knuckle-span multiples');

                    // Keep the runtime marker math in sync when tuning live.
                    for (const c of [ctrlSwordEnabled, ctrlSwordFill, ctrlSwordDrain, ctrlSwordMinConf, ctrlSwordBaseScale, ctrlSwordA, ctrlSwordB]) {
                        try {
                            c.onChange(() => {
                                try { window.hfoPortsEffects?.emit?.('p7', 'navigator_tune', { subsystem: 'p2.swordMeter' }); } catch (_) { }
                            });
                        } catch (_) {
                            // ignore
                        }
                    }
                } else {
                    fSword.add({ note: 'swordMeter unavailable' }, 'note').disable();
                }

                if (pvfx) {
                    try {
                        const fVfx = fSword.addFolder('VFX: Thermal Flame Focus');
                        gui._hfoFolders.fSwordVfx = fVfx;
                        const cEnabled = fVfx.add(pvfx, 'enabled').name('VFX Enabled');
                        const cDark = fVfx.add(pvfx, 'bladeDarkness', 0.0, 0.25, 0.005).name('Blade Darkness');
                        const cAmber = fVfx.add(pvfx, 'bladeAmber', 0.0, 1.0, 0.01).name('Blade Amber');
                        const cOp = fVfx.add(pvfx, 'bladeOpacity', 0.0, 1.0, 0.01).name('Blade Opacity');
                        const cGlowI = fVfx.add(pvfx, 'glowIntensity', 0.0, 6.0, 0.05).name('Glow Intensity');
                        const cGlowA = fVfx.add(pvfx, 'glowAlpha', 0.0, 1.0, 0.01).name('Glow Alpha');
                        const cFlame = fVfx.add(pvfx, 'flameIntensity', 0.0, 4.0, 0.05).name('Flame Intensity');
                        const cFlameSpeed = fVfx.add(pvfx, 'flameSpeed', 0.15, 2.0, 0.01).name('Flame Speed');
                        const cTip = fVfx.add(pvfx, 'tipIntensity', 0.0, 4.0, 0.05).name('Tip Intensity');
                        const cEmber = fVfx.add(pvfx, 'emberIntensity', 0.0, 4.0, 0.05).name('Ember Intensity');
                        const cTipWhite = fVfx.add(pvfx, 'tipWhiteness', 0.0, 1.0, 0.01).name('Tip Whiteness');

                        const fWave = fVfx.addFolder('Core: Flamberge Wave');
                        const cWAmp = fWave.add(pvfx, 'waveAmp', 0.0, 0.05, 0.001).name('Wave Amp');
                        const cWCycles = fWave.add(pvfx, 'waveCycles', 0.0, 16.0, 0.1).name('Wave Cycles');
                        const cWSpeed = fWave.add(pvfx, 'waveSpeedHz', 0.0, 6.0, 0.05).name('Wave Speed (Hz)');
                        const cWTaperIn = fWave.add(pvfx, 'waveTaperIn', 0.0, 0.35, 0.01).name('Taper In');
                        const cWTaperOut = fWave.add(pvfx, 'waveTaperOut', 0.0, 0.35, 0.01).name('Taper Out');

                        P7Navigator.applyTooltip(cEnabled, 'Master enable for the obsidian blade + amber flame visuals (Babylon-only).');
                        P7Navigator.applyTooltip(cDark, 'Higher = lighter blade. Lower = deeper obsidian silhouette.');
                        P7Navigator.applyTooltip(cAmber, 'Amber tint amount for the (subtle) core material.');
                        P7Navigator.applyTooltip(cOp, 'Blade opacity; lower if it hides the flame too much.');
                        P7Navigator.applyTooltip(cGlowI, 'Multiply the amber glow shell emissive.');
                        P7Navigator.applyTooltip(cGlowA, 'Scale the glow shell alpha (additive).');
                        P7Navigator.applyTooltip(cFlame, 'Multiply the flame sheath emit rate.');
                        P7Navigator.applyTooltip(cFlameSpeed, 'Particle simulation speed. Lower = slower, "burning" flames.');
                        P7Navigator.applyTooltip(cTip, 'Boost hot tip flare layer (thermal gradient).');
                        P7Navigator.applyTooltip(cEmber, 'Boost slow ember layer (long-lived glow).');
                        P7Navigator.applyTooltip(cTipWhite, 'Whiteness of the hot tip (0=amber, 1=white).');

                        P7Navigator.applyTooltip(cWAmp, 'Max lateral edge displacement of the flamberge wave (world units before scaling).');
                        P7Navigator.applyTooltip(cWCycles, 'Number of sine cycles along the blade length.');
                        P7Navigator.applyTooltip(cWSpeed, 'Temporal wave speed in Hz. 0 = static flamberge shape.');
                        P7Navigator.applyTooltip(cWTaperIn, 'Fade in the wave near the hilt (fraction of blade length).');
                        P7Navigator.applyTooltip(cWTaperOut, 'Fade out the wave near the tip (fraction of blade length).');
                    } catch (_) {
                        // ignore
                    }
                }

                const fTripwire = gui.addFolder('P2/P3: Tripwire Lookahead (Predictive)');
                gui._hfoFolders.fTripwire = fTripwire;
                const tw = systemState.parameters?.p2?.tripwireThread;
                const inj = systemState.parameters?.p3?.tripwireInjector;
                if (tw && inj) {
                    const ctrlTwEnabled = fTripwire.add(tw, 'lookaheadEnabled').name('P2 Emit Lookahead').onChange(val => {
                        logMission(`P2 Tripwire Lookahead: ${val ? 'ENABLED' : 'DISABLED'}`);
                    });
                    const ctrlTwWindow = fTripwire.add(tw, 'lookaheadWindowMs', 0, 500, 10).name('Window (ms)').onChange(val => {
                        logMission(`Tripwire Lookahead Window: ${val}ms`);
                    });
                    const ctrlP3Enabled = fTripwire.add(inj, 'lookaheadEnabled').name('P3 Pre-arm Inject').onChange(val => {
                        logMission(`P3 Pre-arm Inject: ${val ? 'ENABLED' : 'DISABLED'}`);
                    });

                    P7Navigator.applyTooltip(ctrlTwEnabled, 'When enabled (COMMIT-only), P2 emits p2/tripwire_lookahead when analytic TTC-to-band is within Window (ms).');
                    P7Navigator.applyTooltip(ctrlTwWindow, 'Lookahead window in ms. Higher = earlier pre-arm (more risk). 0 disables lookahead emission.');
                    P7Navigator.applyTooltip(ctrlP3Enabled, 'When enabled, P3 schedules an early Space inject up to Window (ms) before the predicted crossing time (still COMMIT-gated at fire time).');

                    // --- GEN6 v22: KNUCKLE TRIPPLANE (TOI/TTC) lookahead knobs (user-tunable) ---
                    // Knuckle tripplane uses its own URL flag:
                    // - p2-knuckle-tripwire-lookahead-window-ms
                    // Predictive enable/disable is represented as an opt-out URL flag:
                    // - p3-tripwire-lookahead-disable=true
                    // Predictive scheduling lead and bias are P3 knobs:
                    // - p3-tripwire-lookahead-window-ms
                    // - p3-tripwire-lookahead-bias-ms
                    try {
                        const p2Knuckle = systemState?.parameters?.p2?.knuckleTripwire || systemState?.parameters?.p2?.knuckleKeybar || {};
                        const baseWindow = Number(p2Knuckle?.lookaheadWindowMs ?? tw?.lookaheadWindowMs ?? 120);

                        const ctrlKnuckleWindow = fTripwire
                            .add({ knuckleLookaheadWindowMs: Math.max(1, Math.min(500, Number(getFlagNumber('p2-knuckle-tripwire-lookahead-window-ms', baseWindow)) || 120)) }, 'knuckleLookaheadWindowMs', 1, 500, 1)
                            .name('Knuckle Window (ms)')
                            .onChange((val) => {
                                const v = Math.max(1, Math.min(500, Number(val) || 120));
                                try { setFlagNumber('p2-knuckle-tripwire-lookahead-window-ms', v); } catch (_) { /* ignore */ }
                                try {
                                    if (tw) tw.lookaheadWindowMs = v;
                                } catch (_) {
                                    // ignore
                                }
                                logMission(`Knuckle Tripplane Lookahead Window: ${v}ms`);
                            });

                        const ctrlKnucklePredictive = fTripwire
                            .add({ knucklePredictiveEnabled: !isFlagEnabled('p3-tripwire-lookahead-disable') }, 'knucklePredictiveEnabled')
                            .name('Knuckle Predictive Enabled')
                            .onChange((val) => {
                                const enabled = Boolean(val);
                                try {
                                    setFlagEnabled('p3-tripwire-lookahead-disable', !enabled);
                                } catch (_) {
                                    // ignore
                                }
                                try {
                                    if (inj) inj.lookaheadEnabled = enabled;
                                } catch (_) {
                                    // ignore
                                }
                                logMission(`Knuckle Predictive: ${enabled ? 'ENABLED' : 'DISABLED'}`);
                            });

                        const ctrlKnucklePredictiveLead = fTripwire
                            .add({ knucklePredictiveLeadMs: Math.max(1, Math.min(500, Number(getFlagNumber('p3-tripwire-lookahead-window-ms', baseWindow)) || baseWindow)) }, 'knucklePredictiveLeadMs', 1, 500, 1)
                            .name('Knuckle Predictive Lead (ms)')
                            .onChange((val) => {
                                const v = Math.max(1, Math.min(500, Number(val) || baseWindow));
                                try { setFlagNumber('p3-tripwire-lookahead-window-ms', v); } catch (_) { /* ignore */ }
                                try {
                                    if (inj) inj.lookaheadWindowMs = v;
                                } catch (_) {
                                    // ignore
                                }
                                logMission(`Knuckle Predictive Lead: ${v}ms`);
                            });

                        const ctrlKnucklePredictiveBias = fTripwire
                            .add({ knucklePredictiveBiasMs: Math.max(-300, Math.min(300, Number(getFlagNumber('p3-tripwire-lookahead-bias-ms', -100)) || -100)) }, 'knucklePredictiveBiasMs', -300, 300, 1)
                            .name('Knuckle Predictive Bias (ms)')
                            .onChange((val) => {
                                const v = Math.max(-300, Math.min(300, Number(val) || -100));
                                try { setFlagNumber('p3-tripwire-lookahead-bias-ms', v); } catch (_) { /* ignore */ }
                                logMission(`Knuckle Predictive Bias: ${v}ms`);
                            });

                        P7Navigator.applyTooltip(ctrlKnuckleWindow, 'Knuckle tripplane TTC window (ms). Drives p2/tripplane_lookahead emission when the begin-edge crossing is imminent.');
                        P7Navigator.applyTooltip(ctrlKnucklePredictive, 'When enabled, allows P3 to use p2/tripplane_lookahead for early Space keydown scheduling. Stored as flag-p3-tripwire-lookahead-disable opt-out.');
                        P7Navigator.applyTooltip(ctrlKnucklePredictiveLead, 'P3 scheduling lead time (ms). If set lower than the P2 window, P3 will schedule a delayed fire (setTimeout) to inject at (crossing - lead).');
                        P7Navigator.applyTooltip(ctrlKnucklePredictiveBias, 'P3 scheduling bias (ms). Negative = earlier fire, positive = later. Stored as flag-p3-tripwire-lookahead-bias-ms.');
                    } catch (_) {
                        // ignore
                    }
                } else {
                    fTripwire.add({ note: 'Tripwire knobs unavailable' }, 'note').disable();
                }

                const fCoast = gui.addFolder('P4: Coasting Control');
                gui._hfoFolders.fCoast = fCoast;
                const ctrlCoastTimeout = fCoast.add(systemState.parameters.coasting, 'timeoutMs', 0, 1000).name('Coast Timeout (ms)');
                const ctrlCoastConf = fCoast.add(systemState.parameters.coasting, 'confidenceThreshold', 0, 1).name('Min Signal Confidence');
                P7Navigator.applyTooltip(ctrlCoastTimeout, 'How long to coast on tracking loss before decay to IDLE.');
                P7Navigator.applyTooltip(ctrlCoastConf, 'Minimum confidence required to avoid COAST.');

                // GEN6 v16: Unified low-confidence deadman (stillness â†’ COAST).
                const fDeadman = fCoast.addFolder('Deadman (Stillness â†’ COAST)');
                const dm2 = systemState.parameters.coasting.deadman;
                const ctrlDm2Enabled = fDeadman.add(dm2, 'enabled').name('Enabled').onChange(val => {
                    logMission(`COAST Deadman: ${val ? 'ENABLED' : 'DISABLED'}`);
                });
                const ctrlDm2Timeout = fDeadman.add(dm2, 'timeoutMs', 0, 120000, 250).name('Timeout (ms)').onChange(val => {
                    logMission(`COAST Deadman Timeout: ${val}ms`);
                });
                const ctrlDm2Eps = fDeadman.add(dm2, 'epsilonUiNorm', 0, 0.01, 0.0001).name('Epsilon (uiNorm)').onChange(val => {
                    logMission(`COAST Deadman Epsilon: ${val}`);
                });
                const ctrlDm2Rearm = fDeadman.add(dm2, 'rearmOnMove').name('Re-arm On Move').onChange(val => {
                    logMission(`COAST Deadman Rearm: ${val ? 'ON' : 'OFF'}`);
                });
                fDeadman.add({
                    reset: () => {
                        try {
                            window.hfoP2CoastGovernor?.reset?.();
                            logMission('COAST Deadman: reset');
                        } catch (_) {
                            logMission('COAST Deadman: reset failed', '#ff4136');
                        }
                    }
                }, 'reset').name('Reset');
                P7Navigator.applyTooltip(ctrlDm2Enabled, 'Fail-closed: if a non-IDLE pointer is perfectly still beyond the timeout, force COAST and emit p3/pointer_cancel.');
                P7Navigator.applyTooltip(ctrlDm2Timeout, 'Stillness duration threshold (ms). Default 60000ms = 1 minute.');
                P7Navigator.applyTooltip(ctrlDm2Eps, 'Stillness threshold in uiNorm space (0..1). 0 = exact equality only.');
                P7Navigator.applyTooltip(ctrlDm2Rearm, 'If enabled, movement beyond epsilon clears the deadman tripped state.');

                const fPhys = gui.addFolder('P2: Coordinate Substrate');
                gui._hfoFolders.fPhys = fPhys;
                fPhys.add(systemState.parameters.physics, 'mode', ['STATIC_ROD', 'PLANCK_SPRING']).name('Physics Mode').onChange(syncConfig);
                fPhys.add(systemState.parameters.physics, 'useDirectProjection').name('Direct Projection Flag');
                fPhys.add(systemState.parameters.physics, 'directProjectionOffset', 0, 0.5, 0.01).name('Direct Offset (LI)');
                fPhys.add(systemState.parameters.physics, 'cursorTheme', ['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']).name('HFO Element (Trigram)');
                fPhys.add(systemState.parameters.physics, 'oneEuroMinCutoff', 0.1, 5).name('Smoothing MinCutoff');
                fPhys.add(systemState.parameters.physics, 'oneEuroBeta', 0, 0.5).name('Smoothing Beta');
                fPhys.add(systemState.parameters.physics, 'planckStiffness', 0.1, 20).name('Planck Stiffness (Hz)');
                fPhys.add(systemState.parameters.physics, 'planckDamping', 0.0, 1.0).name('Planck Damping Ratio');
                fPhys.add(systemState.parameters.physics, 'palmRodMultiplier', 0.5, 10.0).step(0.1).name('Rod Length Factor');
                fPhys.add(systemState.parameters.physics, 'showLaserBeam').name('Show Beam Path');
                fPhys.add(systemState.parameters.physics, 'predictiveLookahead', 0, 5).name('Lookahead Factor');

                // v11.4: Active App overlay tuning (opacity + overscan zoom).
                const fAppsOverlay = gui.addFolder('P7: Active App Overlay');
                gui._hfoFolders.fAppsOverlay = fAppsOverlay;

                const applyActiveOverlay = () => {
                    const activeId = window.hfoPorts?.p7?.apps?.getActiveId?.();
                    const p = systemState?.parameters?.apps;
                    if (p?.overlay?.rememberPerApp && activeId) {
                        p.perApp = p.perApp || {};
                        p.perApp[activeId] = {
                            opacity: p.overlay.opacity,
                            zoom: p.overlay.zoom
                        };
                    }
                    try {
                        window.hfoPorts?.p7?.apps?.applyActiveOverlayTuning?.();
                    } catch (_) {
                        // ignore
                    }
                };

                fAppsOverlay.add(systemState.parameters.apps.overlay, 'opacity', 0, 1, 0.01).name('Opacity').listen().onChange(applyActiveOverlay);
                fAppsOverlay.add(systemState.parameters.apps.overlay, 'zoom', 1.0, 2.0, 0.01).name('Overscan Zoom').listen().onChange(applyActiveOverlay);
                fAppsOverlay.add(systemState.parameters.apps.overlay, 'rememberPerApp').name('Remember Per App');

                const fTools = gui.addFolder('P7: Adapter Tools (Message)');
                gui._hfoFolders.fTools = fTools;
                fTools.add(systemState.parameters.excalidraw, 'activeTool', [
                    'selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'freedraw', 'text', 'eraser'
                ]).name('Active Tool').onChange(val => {
                    try {
                        window.hfoPorts?.p7?.navigate?.setActiveAdapterTool?.(val);
                    } catch (_) {
                        // ignore
                    }
                });

                const fAnat = gui.addFolder('P1: Anatomical Constraints');
                gui._hfoFolders.fAnat = fAnat;
                fAnat.add(systemState.parameters.anatomy, 'palmWidthCm', 4, 12, 0.1).name('Palm Width (cm)').onChange(syncConfig);
                fAnat.add(systemState.parameters.anatomy, 'rodExtensionMultiplier', 0.1, 5, 0.1).name('Rod Extension Factor').onChange(syncConfig);

                const fSystem = gui.addFolder('ðŸ›°ï¸ P7: SYSTEM & ONBOARDING');
                gui._hfoFolders.fSystem = fSystem;
                fSystem.add(systemState.parameters.ui, 'showTutorial').name('ONBOARDING ACTIVE').listen();
                fSystem.add({ reset: () => { window.hfoTutorial.reset(); } }, 'reset').name('Reset Tutorial');

                const fDebug = gui.addFolder('P5: Deep Visual Debugging');
                gui._hfoFolders.fDebug = fDebug;
                fDebug.add(systemState.parameters, 'devMode').name('Enable Full Telemetry').onChange(syncConfig);
                fDebug.add(systemState.parameters.landmarks, 'showSkeleton').name('Draw Skeleton');

                function syncConfig() {
                    const valid = P1Bridger.validateConfig(systemState.parameters);
                    if (valid && systemState.p0.recognizer) {
                        systemState.p0.recognizer.setOptions({
                            numHands: valid.landmarks.numHands,
                            minHandDetectionConfidence: valid.landmarks.minConfidence
                        });
                        logMission("P7: Configuration Synchronized & Validated");
                    }
                }

                // V39: Apply initial visibility
                P7Navigator.applyVisibility(gui, systemState.parameters.essentialsMode);
            }

            // V39: Gating Visibility Logic for Progressive Disclosure
            static applyVisibility(gui, isEssentials) {
                console.log(`[P7] applyVisibility called: isEssentials=${isEssentials}`);
                const folders = gui._hfoFolders;
                if (!folders) {
                    console.log("[P7] No folders found in registry!");
                    return;
                }

                // Folders to Keep in Essentials/Kiosk Mode
                const whitelist = ['fExcal', 'fPorts', 'fTelem', 'fTools', 'fSystem', 'fP3', 'fAppsOverlay', 'fTripwire'];

                Object.keys(folders).forEach(key => {
                    const folder = folders[key];
                    if (isEssentials && !whitelist.includes(key)) {
                        console.log(`[P7] Hiding folder: ${key}`);
                        folder.hide();
                    } else {
                        console.log(`[P7] Showing folder: ${key}`);
                        folder.show();
                    }
                });
            }
        }

        function resizeCanvas() {
            const { video, canvas } = systemState.p0;
            if (!video || !canvas) return;

            // V28: Fallback resolution for headless/mock testing
            const [w_param, h_param] = systemState.parameters.camera.resolution.split('x').map(Number);
            const vw = video.videoWidth || w_param || 1280;
            const vh = video.videoHeight || h_param || 720;

            systemState.p0.videoBounds = { width: vw, height: vh };

            const vRatio = vw / vh;
            const userZoom = systemState.parameters.excalidraw.zoomFactor || 1.0;

            const computeCover = (parentWidth, parentHeight) => {
                let drawW_base = parentWidth;
                let drawH_base = parentWidth / vRatio;
                if (drawH_base > parentHeight) {
                    drawH_base = parentHeight;
                    drawW_base = drawH_base * vRatio;
                }
                const coverZoom = Math.max(parentWidth / drawW_base, parentHeight / drawH_base);
                const zoom = coverZoom * userZoom;
                const drawW = drawW_base * zoom;
                const drawH = drawH_base * zoom;
                const offsetX = (parentWidth - drawW) / 2;
                const offsetY = (parentHeight - drawH) / 2;
                return { drawW, drawH, offsetX, offsetY };
            };

            const applyPhysicalTransform = (el, { isVideo = false } = {}) => {
                const parent = el?.parentElement;
                if (!parent) return null;
                const pRect = parent.getBoundingClientRect();
                const parentWidth = pRect.width;
                const parentHeight = pRect.height;
                if (parentWidth <= 0 || parentHeight <= 0) return null;

                const { drawW, drawH, offsetX, offsetY } = computeCover(parentWidth, parentHeight);

                el.style.position = 'absolute';
                el.style.left = `${offsetX}px`;
                el.style.top = `${offsetY}px`;
                el.style.width = `${drawW}px`;
                el.style.height = `${drawH}px`;

                if (isVideo) {
                    el.style.objectFit = 'fill';
                    const isMirror = systemState.parameters.camera.mirror;
                    el.style.transform = isMirror ? 'scaleX(-1)' : 'none';
                }

                return {
                    width: drawW,
                    height: drawH,
                    offsetX,
                    offsetY,
                    containerRect: pRect
                };
            };

            // V32: SAFESTEP DIMENSIONS (Avoid GL Transition Flicker)
            // If the video host isn't laid out yet, retry.
            const videoBounds = applyPhysicalTransform(video, { isVideo: true });
            if (!videoBounds) {
                if (!window._resizeRetry) {
                    window._resizeRetry = true;
                    setTimeout(() => { window._resizeRetry = false; resizeCanvas(); }, 150);
                }
                return;
            }

            // Set buffer size to match video source (High-fidelity sensing baseline)
            canvas.width = vw;
            canvas.height = vh;
            applyPhysicalTransform(canvas);

            // Backward-compatible: viewBounds is sourced from the Video SRP view.
            systemState.ui.viewBounds = videoBounds;

            // GEN6 v6: SRP-safe sizing for other physical substrates (each sized in its own host).
            const tacticalCanvas = systemState.ui.tactical;
            if (tacticalCanvas?.id === 'touch2d-hero-canvas') {
                tacticalCanvas.width = vw;
                tacticalCanvas.height = vh;
                applyPhysicalTransform(tacticalCanvas);
            }

            try {
                (systemState.ui.juiceLayers || []).forEach((l) => {
                    if (l?.canvas) applyPhysicalTransform(l.canvas);
                });
            } catch (_) {
                // ignore
            }

            // V36: DECOUPLE EXCALIDRAW (NO CLIPPING)
            if (systemState.ui.excalidrawOverlay) {
                const el = systemState.ui.excalidrawOverlay;
                el.style.position = 'absolute';
                el.style.left = '0px';
                el.style.top = '0px';
                el.style.width = '100%';
                el.style.height = '100%';
                // The iframe inside already has width/height 100%
            }

            // V28.5: Calibration Markers (UPE Parity Verification)
            let calWrap = document.getElementById('upe-calibration-overlay');
            if (isFlagEnabled('dev-mode')) {
                if (!calWrap) {
                    calWrap = document.createElement('div');
                    calWrap.id = 'upe-calibration-overlay';
                    calWrap.style.position = 'absolute';
                    calWrap.style.pointerEvents = 'none';
                    calWrap.style.zIndex = '1000';
                    video.parentElement?.appendChild(calWrap);
                }
                calWrap.style.left = `${videoBounds.offsetX}px`;
                calWrap.style.top = `${videoBounds.offsetY}px`;
                calWrap.style.width = `${videoBounds.width}px`;
                calWrap.style.height = `${videoBounds.height}px`;
                calWrap.innerHTML = `
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:red; font-size:10px; font-weight:bold;">UPE PARITY BOX</div>
                `;
            } else if (calWrap) {
                calWrap.remove();
            }

            // Trigger engine resizes to match the new CSS bounds
            systemState.ui.juiceLayers.forEach(l => {
                if (l.resize) l.resize(videoBounds.width, videoBounds.height);
            });
        }

        function logMission(msg, color = '#00ff41') {
            const logs = document.getElementById('mission-logs');
            if (!logs) return;
            const entry = document.createElement('div');
            entry.style.color = color;
            entry.innerText = `[${new Date().toLocaleTimeString('en-GB')}] ${msg}`;
            logs.prepend(entry);
        }

        // --- LAYOUT ENGINE ---
        const container = document.getElementById('layout-container');
        let layout = new GoldenLayout(container);

        function initLayout(isEssentials = false) {
            // V39: CLEAR PREVIOUS LAYOUT IF IT EXISTS
            if (layout) {
                try {
                    layout.destroy();
                } catch (e) { console.warn("Layout Destroy Error:", e); }
            }
            layout = new GoldenLayout(container);

            // Register components (Must re-register after destroy/init in GL v2)
            registerAllComponents(layout);

            // GEN6 v7: Prevent DOM id collisions when switching between SRP and HERO layouts.
            // SRP layers are singletons that may still exist in a hidden parking node; HERO mounts
            // a fresh set of elements with the same ids. Tear SRP down before mounting HERO.
            if (isEssentials) {
                try {
                    window.__hfoGen6SrpStore?.teardownAll?.();
                } catch (_) {
                    // ignore
                }
            }

            const isMultiApp = isFlagEnabled('ui-multiapp');
            const isMultiView = isFlagEnabled('ui-multiview');

            const gameSelectorTabs = [];

            const appSelectorStack = {
                type: 'stack',
                height: 10,
                content: [
                    { type: 'component', componentType: 'app-excalidraw', title: 'App: Excalidraw' },
                    { type: 'component', componentType: 'app-sandbox', title: 'App: Sandbox' },
                    { type: 'component', componentType: 'app-pointer-lab', title: 'App: Pointer Lab' },
                    ...gameSelectorTabs
                ]
            };

            // GEN6 v7: SRP visualization components (dev sidecars)
            // Goal: allow each visualization to run concurrently and be composable later.
            const videoView = {
                type: 'component',
                componentType: 'srp-video',
                title: 'Video',
                minWidth: 280,
                minHeight: 200
            };

            const touch2dView = {
                type: 'component',
                componentType: 'srp-touch2d',
                title: 'Touch2D',
                minWidth: 280,
                minHeight: 200
            };

            const babylonView = {
                type: 'component',
                componentType: 'srp-babylon',
                title: 'Babylon',
                minWidth: 280,
                minHeight: 200
            };

            const excalidrawView = {
                type: 'component',
                componentType: 'excalidraw',
                title: 'Excalidraw',
                minWidth: 280,
                minHeight: 200
            };

            const dinoView = {
                type: 'component',
                componentType: 'srp-dino',
                title: 'Dino Runner',
                minWidth: 280,
                minHeight: 200
            };

            const tripwireDebugView = {
                type: 'component',
                componentType: 'tripwire-debug',
                title: 'Tripwire Debug (P2)',
                minWidth: 280,
                minHeight: 200
            };

            const knuckleTripwireDebugView = {
                type: 'component',
                componentType: 'knuckle-tripwire-debug',
                title: 'Knuckle Tripwire (P2)',
                minWidth: 280,
                minHeight: 200
            };

            // Default SRP grid: all visualizations visible concurrently.
            const srpGrid = {
                type: 'column',
                height: 90,
                content: [
                    { type: 'row', height: 60, content: [videoView, touch2dView, babylonView] },
                    {
                        type: 'row',
                        height: 40,
                        content: [
                            {
                                type: 'stack',
                                content: [
                                    tripwireDebugView,
                                    ...(isFlagEnabled('ui-knuckle-tripwire-panel')
                                        ? [knuckleTripwireDebugView]
                                        : [])
                                ]
                            },
                            { type: 'stack', content: [dinoView, excalidrawView] }
                        ]
                    }
                ]
            };

            const mirrorComponent = {
                type: 'component',
                componentType: 'camera-mirror',
                title: 'Background Video (P0 Mirror)',
                minWidth: 240,
                minHeight: 180
            };

            // GEN6 v7: HERO mode (user-facing) is available in essentials/kiosk.
            const heroComponent = {
                type: 'component',
                componentType: 'hero-touch2d',
                title: 'Hero',
                minWidth: 400,
                minHeight: 300
            };

            const heroTabs = {
                type: 'stack',
                height: 90,
                content: [heroComponent]
            };

            const mainView = isEssentials ? heroTabs : srpGrid;

            const heroArea = isMultiView
                ? { type: 'row', height: 90, content: [mainView, mirrorComponent] }
                : mainView;

            const leftPane = isMultiApp
                ? { type: 'column', width: 75, content: [appSelectorStack, heroArea] }
                : (isMultiView
                    ? { type: 'row', width: 75, content: [heroArea, mirrorComponent] }
                    : heroArea
                );

            const heroWithSidebarPlan = {
                root: {
                    type: 'row',
                    content: [
                        { type: 'component', componentType: 'hero-touch2d', title: 'Hero', width: 80 },
                        { type: 'component', componentType: 'navigator', title: 'Tuning', width: 20, minWidth: 280 }
                    ]
                }
            };

            const devPlan = {
                root: {
                    type: 'row', content: [
                        (isMultiApp
                            ? { type: 'column', width: 60, content: [appSelectorStack, heroArea] }
                            : (isMultiView
                                ? { type: 'row', width: 60, content: [heroArea, mirrorComponent] }
                                : heroArea
                            )
                        ),
                        {
                            type: 'column', width: 40, minWidth: 300, content: [
                                { type: 'row', height: 35, content: [mirrorComponent] },
                                {
                                    type: 'row', height: 35, content: [
                                        { type: 'component', componentType: 'gestures', title: 'P1: Gestures' },
                                        { type: 'component', componentType: 'palm', title: 'P1: Palm Orientation' },
                                        ...(isFlagEnabled('ui-knuckle-keybar-overlay')
                                            ? [{ type: 'component', componentType: 'knuckle-keybar-overlay', title: 'P2: Knuckle Keybar' }]
                                            : [])
                                    ]
                                },
                                { type: 'component', componentType: 'fsm-viz', title: 'FSM / Readiness Viz', height: 15 },
                                { type: 'component', componentType: 'effects', title: 'Ports Effects', height: 12 },
                                { type: 'component', componentType: 'navigator', title: 'Port 7: Navigator', height: isFlagEnabled('ui-intent') ? 12 : 16 },
                                ...(isFlagEnabled('ui-intent')
                                    ? [{ type: 'component', componentType: 'intent', title: 'Intent Injector', height: 10 }]
                                    : []),
                                { type: 'component', componentType: 'logs', title: 'System Telemetry', height: 5 }
                            ]
                        }
                    ]
                }
            };

            layout.loadLayout(isEssentials ? (heroMode ? heroWithSidebarPlan : devPlan) : devPlan);

            // GEN5 v11.1: Wire GoldenLayout tab activation â†’ P7 AppHost activation.
            // Invariant: no behavior change unless `?flag-ui-multiapp=true`.
            if (isFlagEnabled('ui-multiapp')) {
                const safeActivate = (appId) => {
                    try {
                        window.hfoPorts?.p7?.apps?.activate?.(appId);
                    } catch (e) {
                        console.warn('[v11.1] AppHost activate failed:', e);
                    }
                };

                const resolveAppIdFromComponentType = (componentType) => {
                    if (!componentType || typeof componentType !== 'string') return null;
                    if (componentType === 'app-excalidraw') return 'excalidraw';
                    if (componentType === 'app-sandbox') return 'sandbox';
                    if (componentType === 'app-pointer-lab') return 'pointer-lab';
                    if (componentType === 'app-game-tap') return 'game-tap';
                    if (componentType === 'app-game-paddle') return 'game-paddle';
                    if (componentType === 'app-game-runner') return 'game-runner';
                    if (componentType === 'app-game-bricks') return 'game-bricks';
                    return null;
                };

                const onActiveChanged = (contentItem) => {
                    const componentType =
                        contentItem?.componentType ||
                        contentItem?.config?.componentType ||
                        contentItem?.componentItemConfig?.componentType ||
                        null;
                    const appId = resolveAppIdFromComponentType(componentType);
                    if (appId) {
                        safeActivate(appId);
                    }
                };

                try {
                    layout.on?.('activeContentItemChanged', onActiveChanged);
                } catch (e) {
                    console.warn('[v11.1] Failed to wire activeContentItemChanged:', e);
                }

                // Default active app (best-effort) so routing gates have a deterministic baseline.
                setTimeout(() => {
                    try {
                        const apps = window.hfoPorts?.p7?.apps;
                        if (!apps?.getActiveId?.()) {
                            const list = apps?.list?.() || [];
                            const hasPointerLab = !!list.find(m => m?.appId === 'pointer-lab');
                            safeActivate(hasPointerLab ? 'pointer-lab' : 'excalidraw');
                        }
                    } catch (_) {
                        // ignore
                    }
                }, 0);
            }

            window.addEventListener('resize', () => {
                layout.updateSize();
                resizeCanvas();
            });
        }

        function registerAllComponents(layout) {
            // --- GEN6 v6: SRP Layer Singletons ---
            // Each visualization layer is a single DOM instance (unique IDs) that can be hosted
            // inside any GoldenLayout component without duplicating DOM ids/state.
            const getSrpStore = () => {
                if (window.__hfoGen6SrpStore) return window.__hfoGen6SrpStore;

                const parking = document.createElement('div');
                parking.id = 'hfo-srp-layer-parking';
                parking.style.display = 'none';
                document.body.appendChild(parking);

                const store = {
                    parking,
                    nodes: new Map(),
                    teardowns: new Map(),
                    teardownAll: () => {
                        try {
                            // Run teardowns (best-effort)
                            Array.from(store.teardowns.values()).forEach((fn) => {
                                try { fn?.(); } catch (_) { }
                            });
                        } catch (_) {
                            // ignore
                        }
                        try {
                            // Remove SRP nodes from DOM
                            Array.from(store.nodes.values()).forEach((node) => {
                                try { node?.remove?.(); } catch (_) { }
                            });
                        } catch (_) {
                            // ignore
                        }
                        store.nodes.clear();
                        store.teardowns.clear();
                    }
                };
                window.__hfoGen6SrpStore = store;
                return store;
            };

            const ensureLayer = (key, createFn) => {
                const store = getSrpStore();
                if (!store.nodes.has(key)) {
                    const out = createFn(store);
                    store.nodes.set(key, out);
                }
                return store.nodes.get(key);
            };

            const parkLayer = (key) => {
                const store = getSrpStore();
                const node = store.nodes.get(key);
                if (node && node.parentElement !== store.parking) {
                    store.parking.appendChild(node);
                }
            };

            const hostLayer = (key, hostEl, createFn) => {
                const node = ensureLayer(key, createFn);
                if (node && node.parentElement !== hostEl) {
                    hostEl.appendChild(node);
                }
                return node;
            };

            const createSrpRoot = (titleText) => {
                const root = document.createElement('div');
                root.className = 'hero-view-container';
                root.dataset.hfoLayer = 'substrate-root';
                root.style.position = 'relative';
                root.style.overflow = 'hidden';
                root.style.background = '#000';

                const label = document.createElement('div');
                label.textContent = titleText;
                label.style.position = 'absolute';
                label.style.top = '8px';
                label.style.right = '10px';
                label.style.zIndex = '26';
                label.style.padding = '6px 10px';
                label.style.borderRadius = '10px';
                label.style.background = 'rgba(0,0,0,0.55)';
                label.style.color = '#7CFC90';
                label.style.fontFamily = 'monospace';
                label.style.fontSize = '11px';
                label.style.opacity = '0.95';
                label.style.pointerEvents = 'none';
                root.appendChild(label);
                return root;
            };

            const ensureVideoLayer = (store) => {
                const root = createSrpRoot('SRP: VIDEO');

                const video = document.createElement('video');
                video.id = 'video-feed';
                video.autoplay = true;
                video.playsInline = true;
                video.dataset.hfoLayer = 'video';
                root.appendChild(video);

                const canvas = document.createElement('canvas');
                canvas.id = 'overlay-canvas';
                canvas.style.zIndex = '11';
                canvas.dataset.hfoLayer = 'overlay-canvas';
                root.appendChild(canvas);

                // Tutorial overlay (kept; SRP components are visualizations, not ports)
                const tutorial = document.createElement('div');
                tutorial.id = 'hfo-tutorial';
                tutorial.className = 'tutorial-overlay';
                tutorial.innerHTML = `
                    <div class="m3-label" id="tut-header">Tactical Instruction</div>
                    <div class="tutorial-step" id="tut-body">Initializing Mission Profile...</div>
                    <div id="tut-progress-container" class="m3-progress-container" style="display:none; margin-top: 12px; height: 2px;">
                        <div id="tut-progress-bar" class="m3-progress-bar" style="width: 0%; background: var(--md-sys-color-primary);"></div>
                    </div>
                `;
                tutorial.dataset.hfoLayer = 'ui-tutorial';
                root.appendChild(tutorial);

                systemState.ui.tutorial = tutorial;
                systemState.ui.tutHeader = tutorial.querySelector('#tut-header');
                systemState.ui.tutBody = tutorial.querySelector('#tut-body');
                systemState.ui.tutProgress = tutorial.querySelector('#tut-progress-container');
                systemState.ui.tutProgressBar = tutorial.querySelector('#tut-progress-bar');

                const ignite = document.createElement('button');
                ignite.id = 'btn-ignite';
                ignite.className = 'hfo-btn';
                ignite.textContent = 'IGNITE OMEGA';
                ignite.style.position = 'absolute';
                ignite.style.bottom = '30px';
                ignite.style.zIndex = '20';
                ignite.dataset.hfoLayer = 'ui-ignite';
                root.appendChild(ignite);

                try {
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'physical:video',
                        kind: 'dom',
                        el: video,
                        meta: { owner: 'srp-video', layer: 'video' }
                    });
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'physical:overlay-canvas',
                        kind: 'dom',
                        el: canvas,
                        meta: { owner: 'srp-video', layer: 'overlay-canvas' }
                    });
                } catch (_) { }

                systemState.p0.video = video;
                systemState.p0.canvas = canvas;
                systemState.p0.ctx = canvas.getContext('2d');

                ignite.onclick = async (e) => {
                    e.target.style.display = 'none';

                    // Start Tutorial
                    window.hfoTutorial.show();

                    const disableCamera = isFlagEnabled('disable-camera');
                    if (!disableCamera) {
                        await initP0();
                    }

                    const [w, h] = systemState.parameters.camera.resolution.split('x');
                    if (disableCamera) {
                        systemState.parameters.p0Active = true;
                        resizeCanvas();
                        predictLoop();
                    } else {
                        try {
                            const camera = window.hfoRegistry?.resolve?.(window.hfoTokens.P0_CAMERA) || null;
                            const stream = camera
                                ? await camera.getStream({ width: parseInt(w), height: parseInt(h) })
                                : await navigator.mediaDevices.getUserMedia({ video: { width: parseInt(w), height: parseInt(h) } });
                            systemState.p0.video.srcObject = stream;
                            systemState.p0.video.onloadeddata = () => {
                                systemState.parameters.p0Active = true;
                                resizeCanvas();
                                predictLoop();
                            };
                        } catch (err) {
                            console.warn('P0 Camera Error:', err);
                            systemState.parameters.p0Active = true;
                            resizeCanvas();
                            predictLoop();
                        }
                    }
                };

                const teardown = () => {
                    try { ignite.onclick = null; } catch (_) { }
                    try { video.srcObject = null; } catch (_) { }
                    if (systemState.p0.video === video) systemState.p0.video = null;
                    if (systemState.p0.canvas === canvas) systemState.p0.canvas = null;
                    if (systemState.p0.ctx && systemState.p0.canvas === null) systemState.p0.ctx = null;

                    try { window.hfoSubstrateRegistry?.unregister?.(video); } catch (_) { }
                    try { window.hfoSubstrateRegistry?.unregister?.(canvas); } catch (_) { }
                };
                store.teardowns.set('srp-video', teardown);
                return root;
            };

            const ensureTouch2DLayer = (store) => {
                const root = createSrpRoot('SRP: TOUCH2D');

                const canvas = document.createElement('canvas');
                canvas.id = 'touch2d-hero-canvas';
                canvas.style.position = 'absolute';
                canvas.style.zIndex = '10';
                canvas.style.pointerEvents = 'none';
                canvas.dataset.hfoLayer = 'touch2d-cursor';
                root.appendChild(canvas);

                try {
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'physical:touch2d',
                        kind: 'dom',
                        el: canvas,
                        meta: { owner: 'srp-touch2d', layer: 'touch2d-cursor' }
                    });
                } catch (_) { }

                systemState.ui.tactical = canvas;
                systemState.ui.tacticalCtx = canvas.getContext('2d');

                const teardown = () => {
                    if (systemState.ui.tactical === canvas) {
                        systemState.ui.tactical = null;
                        systemState.ui.tacticalCtx = null;
                    }
                    try { window.hfoSubstrateRegistry?.unregister?.(canvas); } catch (_) { }
                };
                store.teardowns.set('srp-touch2d', teardown);
                return root;
            };

            const ensureBabylonLayer = (store) => {
                const root = createSrpRoot('SRP: BABYLON');

                const babylonWrap = document.createElement('div');
                babylonWrap.id = 'babylon-juice-overlay';
                babylonWrap.style.position = 'absolute';
                babylonWrap.style.width = '100%';
                babylonWrap.style.height = '100%';
                babylonWrap.style.pointerEvents = 'none';
                babylonWrap.style.zIndex = '9';
                babylonWrap.dataset.hfoLayer = 'babylon';
                root.appendChild(babylonWrap);

                try {
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'physical:babylon-wrap',
                        kind: 'dom',
                        el: babylonWrap,
                        meta: { owner: 'srp-babylon', layer: 'babylon-wrap' }
                    });
                } catch (_) { }

                let babylonJuice = null;
                if (isFlagEnabled('engine-babylon')) {
                    babylonJuice = new BabylonJuiceSubstrate(babylonWrap);
                }
                systemState.ui.juiceLayers = [babylonJuice].filter(l => l !== null);

                try {
                    if (babylonJuice?.canvas) {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:juice-canvas',
                            kind: 'dom',
                            el: babylonJuice.canvas,
                            meta: { owner: 'srp-babylon', layer: 'babylon-juice-canvas' }
                        });
                    }
                    if (babylonJuice) {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:juice-layer',
                            kind: 'instance',
                            instance: babylonJuice,
                            meta: { owner: 'srp-babylon', layer: 'babylon-juice' }
                        });
                    }
                } catch (_) { }

                const teardown = () => {
                    try {
                        if (babylonJuice) window.hfoLifecycle.unregister(babylonJuice);
                    } catch (_) { }
                    systemState.ui.juiceLayers = [];

                    try {
                        if (babylonJuice?.canvas) window.hfoSubstrateRegistry?.unregister?.(babylonJuice.canvas);
                    } catch (_) { }
                    try {
                        if (babylonJuice) window.hfoSubstrateRegistry?.unregister?.(babylonJuice);
                    } catch (_) { }
                    try { window.hfoSubstrateRegistry?.unregister?.(babylonWrap); } catch (_) { }
                };
                store.teardowns.set('srp-babylon', teardown);
                return root;
            };

            const ensureDinoLayer = (store) => {
                const root = createSrpRoot('SRP: DINO');

                const dinoOverlay = document.createElement('div');
                dinoOverlay.id = 'dino-hero-overlay';
                dinoOverlay.style.position = 'absolute';
                dinoOverlay.style.width = '100%';
                dinoOverlay.style.height = '100%';
                dinoOverlay.style.zIndex = '7';
                dinoOverlay.style.opacity = '1.0';
                dinoOverlay.style.display = 'block';
                dinoOverlay.style.pointerEvents = 'auto';
                dinoOverlay.dataset.hfoLayer = 'dino-overlay';
                root.appendChild(dinoOverlay);

                try {
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'physical:app-overlay',
                        kind: 'dom',
                        el: dinoOverlay,
                        meta: { owner: 'srp-dino', appId: 'dino-v1' }
                    });
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'app:dino-overlay',
                        kind: 'dom',
                        el: dinoOverlay,
                        meta: { owner: 'srp-dino', appId: 'dino-v1' }
                    });
                } catch (_) { }

                const iframe = document.createElement('iframe');
                iframe.id = 'dino-wrapper-iframe';
                iframe.src = 'dino_v1_wrapper.html';
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = '#000';
                iframe.setAttribute('allow', 'clipboard-read; clipboard-write');
                iframe.dataset.hfoLayer = 'dino-iframe';
                dinoOverlay.appendChild(iframe);

                try {
                    window.hfoSubstrateRegistry?.register?.({
                        role: 'app:dino-iframe',
                        kind: 'dom',
                        el: iframe,
                        meta: { owner: 'srp-dino', appId: 'dino-v1' }
                    });
                } catch (_) { }

                systemState.ui.dinoOverlay = dinoOverlay;
                systemState.ui.dinoWrapperIframe = iframe;
                systemState.ui.dinoPendingNematocystPayloads = systemState.ui.dinoPendingNematocystPayloads || [];

                const flushQueue = () => {
                    try {
                        const q = systemState.ui.dinoPendingNematocystPayloads || [];
                        if (!q.length) return;
                        systemState.ui.dinoPendingNematocystPayloads = [];

                        try {
                            window.hfoPortsEffects?.emit?.('p7', 'dino_flush_queue', { owner: 'srp-dino', count: q.length });
                            window.hfoPortsEffects?.setState?.('dino', {
                                iframePresent: true,
                                queueLength: 0,
                                lastAttempt: { ok: true, reason: 'flush_queue' }
                            });
                        } catch (_) {
                            // ignore
                        }

                        q.forEach((payload) => {
                            try {
                                iframe.contentWindow?.postMessage({
                                    type: 'hfo:nematocyst',
                                    payload: payload ?? null
                                }, '*');
                            } catch (_) {
                                // ignore
                            }
                        });
                    } catch (_) {
                        // ignore
                    }
                };

                iframe.addEventListener('load', () => {
                    flushQueue();
                    try { iframe.contentWindow?.focus?.(); } catch (_) { }
                    try { window.hfoPortsEffects?.emit?.('p7', 'dino_iframe_load', { owner: 'srp-dino' }); } catch (_) { }
                });

                const teardown = () => {
                    if (systemState.ui.dinoWrapperIframe === iframe) systemState.ui.dinoWrapperIframe = null;
                    if (systemState.ui.dinoOverlay === dinoOverlay) systemState.ui.dinoOverlay = null;
                    systemState.ui.dinoPendingNematocystPayloads = [];
                    try { window.hfoSubstrateRegistry?.unregister?.(iframe); } catch (_) { }
                    try { window.hfoSubstrateRegistry?.unregister?.(dinoOverlay); } catch (_) { }
                };
                store.teardowns.set('srp-dino', teardown);
                return root;
            };

            const mountTouch2DHero = (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                container.getElement().appendChild(wrap);

                const root = document.createElement('div');
                root.className = 'hero-view-container';
                root.dataset.hfoLayer = 'substrate-root';
                wrap.appendChild(root);

                const teardowns = [];
                const registerTeardown = (fn) => {
                    if (typeof fn === 'function') teardowns.push(fn);
                };

                // --- SRP Layers (Gen6 v4) ---
                const mountVideoLayer = () => {
                    const video = document.createElement('video');
                    video.id = 'video-feed';
                    video.autoplay = true;
                    video.playsInline = true;
                    video.dataset.hfoLayer = 'video';
                    root.appendChild(video);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:video',
                            kind: 'dom',
                            el: video,
                            meta: { owner: 'hero-touch2d', layer: 'video' }
                        });
                    } catch (_) { }

                    systemState.p0.video = video;
                    registerTeardown(() => {
                        try { video.srcObject = null; } catch (_) { }
                        if (systemState.p0.video === video) systemState.p0.video = null;
                        try { window.hfoSubstrateRegistry?.unregister?.(video); } catch (_) { }
                    });
                    return video;
                };

                const mountOverlayCanvasLayer = () => {
                    const canvas = document.createElement('canvas');
                    canvas.id = 'overlay-canvas';
                    canvas.style.zIndex = '11';
                    canvas.dataset.hfoLayer = 'overlay-canvas';
                    root.appendChild(canvas);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:overlay-canvas',
                            kind: 'dom',
                            el: canvas,
                            meta: { owner: 'hero-touch2d', layer: 'overlay-canvas' }
                        });
                    } catch (_) { }

                    systemState.p0.canvas = canvas;
                    systemState.p0.ctx = canvas.getContext('2d');
                    registerTeardown(() => {
                        if (systemState.p0.canvas === canvas) systemState.p0.canvas = null;
                        if (systemState.p0.ctx && systemState.p0.canvas === null) systemState.p0.ctx = null;
                        try { window.hfoSubstrateRegistry?.unregister?.(canvas); } catch (_) { }
                    });
                    return canvas;
                };

                const mountTouch2DCursorLayer = () => {
                    const canvas = document.createElement('canvas');
                    canvas.id = 'touch2d-hero-canvas';
                    canvas.style.position = 'absolute';
                    canvas.style.zIndex = '10';
                    canvas.style.pointerEvents = 'none';
                    canvas.dataset.hfoLayer = 'touch2d-cursor';
                    root.appendChild(canvas);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:touch2d',
                            kind: 'dom',
                            el: canvas,
                            meta: { owner: 'hero-touch2d', layer: 'touch2d-cursor' }
                        });
                    } catch (_) { }

                    systemState.ui.tactical = canvas;
                    systemState.ui.tacticalCtx = canvas.getContext('2d');
                    registerTeardown(() => {
                        if (systemState.ui.tactical === canvas) {
                            systemState.ui.tactical = null;
                            systemState.ui.tacticalCtx = null;
                        }
                        try { window.hfoSubstrateRegistry?.unregister?.(canvas); } catch (_) { }
                    });
                    return canvas;
                };

                const mountBabylonLayer = () => {
                    const babylonWrap = document.createElement('div');
                    babylonWrap.id = 'babylon-juice-overlay';
                    babylonWrap.style.position = 'absolute';
                    babylonWrap.style.width = '100%';
                    babylonWrap.style.height = '100%';
                    babylonWrap.style.pointerEvents = 'none';
                    babylonWrap.style.zIndex = '12';
                    babylonWrap.dataset.hfoLayer = 'babylon';
                    root.appendChild(babylonWrap);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:babylon-wrap',
                            kind: 'dom',
                            el: babylonWrap,
                            meta: { owner: 'hero-touch2d', layer: 'babylon-wrap' }
                        });
                    } catch (_) { }

                    let babylonJuice = null;
                    if (isFlagEnabled('engine-babylon') && babylonWrap) {
                        babylonJuice = new BabylonJuiceSubstrate(babylonWrap);
                    }
                    systemState.ui.juiceLayers = [babylonJuice].filter(l => l !== null);

                    try {
                        if (babylonJuice?.canvas) {
                            window.hfoSubstrateRegistry?.register?.({
                                role: 'physical:juice-canvas',
                                kind: 'dom',
                                el: babylonJuice.canvas,
                                meta: { owner: 'hero-touch2d', layer: 'babylon-juice-canvas' }
                            });
                        }
                        if (babylonJuice) {
                            window.hfoSubstrateRegistry?.register?.({
                                role: 'physical:juice-layer',
                                kind: 'instance',
                                instance: babylonJuice,
                                meta: { owner: 'hero-touch2d', layer: 'babylon-juice' }
                            });
                        }
                    } catch (_) { }

                    registerTeardown(() => {
                        try {
                            if (babylonJuice) window.hfoLifecycle.unregister(babylonJuice);
                        } catch (_) { }
                        systemState.ui.juiceLayers = [];

                        try {
                            if (babylonJuice?.canvas) window.hfoSubstrateRegistry?.unregister?.(babylonJuice.canvas);
                        } catch (_) { }
                        try {
                            if (babylonJuice) window.hfoSubstrateRegistry?.unregister?.(babylonJuice);
                        } catch (_) { }
                        try { window.hfoSubstrateRegistry?.unregister?.(babylonWrap); } catch (_) { }
                    });

                    return { babylonWrap, babylonJuice };
                };

                const mountDinoRunnerLayer = () => {
                    const dinoOverlay = document.createElement('div');
                    dinoOverlay.id = 'dino-hero-overlay';
                    dinoOverlay.style.position = 'absolute';
                    dinoOverlay.style.width = '100%';
                    dinoOverlay.style.height = '100%';
                    dinoOverlay.style.zIndex = '7';
                    dinoOverlay.style.opacity = '1.0';
                    dinoOverlay.style.display = 'none';
                    dinoOverlay.style.pointerEvents = 'auto';
                    dinoOverlay.dataset.hfoLayer = 'dino-overlay';
                    root.appendChild(dinoOverlay);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'physical:app-overlay',
                            kind: 'dom',
                            el: dinoOverlay,
                            meta: { owner: 'hero-touch2d', appId: 'dino-v1' }
                        });
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'app:dino-overlay',
                            kind: 'dom',
                            el: dinoOverlay,
                            meta: { owner: 'hero-touch2d', appId: 'dino-v1' }
                        });
                    } catch (_) { }

                    const iframe = document.createElement('iframe');
                    iframe.id = 'dino-wrapper-iframe';
                    iframe.src = 'dino_v1_wrapper.html';
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = 'none';
                    iframe.style.background = '#000';
                    iframe.setAttribute('allow', 'clipboard-read; clipboard-write');
                    iframe.dataset.hfoLayer = 'dino-iframe';
                    dinoOverlay.appendChild(iframe);

                    try {
                        window.hfoSubstrateRegistry?.register?.({
                            role: 'app:dino-iframe',
                            kind: 'dom',
                            el: iframe,
                            meta: { owner: 'hero-touch2d', appId: 'dino-v1' }
                        });
                    } catch (_) { }

                    systemState.ui.dinoOverlay = dinoOverlay;
                    systemState.ui.dinoWrapperIframe = iframe;
                    systemState.ui.dinoPendingNematocystPayloads = systemState.ui.dinoPendingNematocystPayloads || [];

                    const flushQueue = () => {
                        try {
                            const q = systemState.ui.dinoPendingNematocystPayloads || [];
                            if (!q.length) return;
                            systemState.ui.dinoPendingNematocystPayloads = [];

                            try {
                                window.hfoPortsEffects?.emit?.('p7', 'dino_flush_queue', { owner: 'hero-touch2d', count: q.length });
                                window.hfoPortsEffects?.setState?.('dino', {
                                    iframePresent: true,
                                    queueLength: 0,
                                    lastAttempt: { ok: true, reason: 'flush_queue' }
                                });
                            } catch (_) {
                                // ignore
                            }

                            q.forEach((payload) => {
                                try {
                                    iframe.contentWindow?.postMessage({
                                        type: 'hfo:nematocyst',
                                        payload: payload ?? null
                                    }, '*');
                                } catch (_) {
                                    // ignore
                                }
                            });
                        } catch (_) {
                            // ignore
                        }
                    };

                    iframe.addEventListener('load', () => {
                        flushQueue();
                        try { iframe.contentWindow?.focus?.(); } catch (_) { }
                        try { window.hfoPortsEffects?.emit?.('p7', 'dino_iframe_load', { owner: 'hero-touch2d' }); } catch (_) { }
                    });

                    registerTeardown(() => {
                        if (systemState.ui.dinoWrapperIframe === iframe) systemState.ui.dinoWrapperIframe = null;
                        if (systemState.ui.dinoOverlay === dinoOverlay) systemState.ui.dinoOverlay = null;
                        systemState.ui.dinoPendingNematocystPayloads = [];

                        try { window.hfoSubstrateRegistry?.unregister?.(iframe); } catch (_) { }
                        try { window.hfoSubstrateRegistry?.unregister?.(dinoOverlay); } catch (_) { }
                    });

                    return { dinoOverlay, iframe };
                };

                const mountUiLayer = (babylonJuice) => {
                    const label = document.createElement('div');
                    label.textContent = 'SUBSTRATE HERO';
                    label.style.position = 'absolute';
                    label.style.top = '8px';
                    label.style.right = '10px';
                    label.style.zIndex = '26';
                    label.style.padding = '6px 10px';
                    label.style.borderRadius = '10px';
                    label.style.background = 'rgba(0,0,0,0.55)';
                    label.style.color = '#7CFC90';
                    label.style.fontFamily = 'monospace';
                    label.style.fontSize = '11px';
                    label.style.opacity = '0.95';
                    label.style.pointerEvents = 'none';
                    label.dataset.hfoLayer = 'ui-label';
                    root.appendChild(label);

                    const modeWrap = document.createElement('div');
                    modeWrap.id = 'hero-mode-switch';
                    modeWrap.style.position = 'absolute';
                    modeWrap.style.top = '8px';
                    modeWrap.style.left = '8px';
                    modeWrap.style.zIndex = '27';
                    modeWrap.style.display = 'flex';
                    modeWrap.style.gap = '6px';
                    modeWrap.style.alignItems = 'center';
                    modeWrap.dataset.hfoLayer = 'ui-mode-switch';
                    modeWrap.innerHTML = `
                        <button id="btn-hero-mode-touch2d" class="hfo-btn" style="padding:6px 10px; font-size:11px; border-radius:14px;">Touch2D</button>
                        <button id="btn-hero-mode-dino" class="hfo-btn" style="padding:6px 10px; font-size:11px; border-radius:14px;">Dino</button>
                    `;
                    root.appendChild(modeWrap);

                    // Tutorial overlay (kept as-is; not part of the SRP split target list)
                    const tutorial = document.createElement('div');
                    tutorial.id = 'hfo-tutorial';
                    tutorial.className = 'tutorial-overlay';
                    tutorial.innerHTML = `
                        <div class="m3-label" id="tut-header">Tactical Instruction</div>
                        <div class="tutorial-step" id="tut-body">Initializing Mission Profile...</div>
                        <div id="tut-progress-container" class="m3-progress-container" style="display:none; margin-top: 12px; height: 2px;">
                            <div id="tut-progress-bar" class="m3-progress-bar" style="width: 0%; background: var(--md-sys-color-primary);"></div>
                        </div>
                    `;
                    tutorial.dataset.hfoLayer = 'ui-tutorial';
                    root.appendChild(tutorial);

                    systemState.ui.tutorial = tutorial;
                    systemState.ui.tutHeader = tutorial.querySelector('#tut-header');
                    systemState.ui.tutBody = tutorial.querySelector('#tut-body');
                    systemState.ui.tutProgress = tutorial.querySelector('#tut-progress-container');
                    systemState.ui.tutProgressBar = tutorial.querySelector('#tut-progress-bar');

                    const ignite = document.createElement('button');
                    ignite.id = 'btn-ignite';
                    ignite.className = 'hfo-btn';
                    ignite.textContent = 'IGNITE OMEGA';
                    ignite.style.position = 'absolute';
                    ignite.style.bottom = '30px';
                    ignite.style.zIndex = '20';
                    ignite.dataset.hfoLayer = 'ui-ignite';
                    root.appendChild(ignite);

                    const btnTouch2d = modeWrap.querySelector('#btn-hero-mode-touch2d');
                    const btnDino = modeWrap.querySelector('#btn-hero-mode-dino');
                    const setHeroMode = (mode) => {
                        systemState.ui.heroMode = mode;
                        if (systemState.ui.dinoOverlay) {
                            systemState.ui.dinoOverlay.style.display = (mode === 'dino') ? 'block' : 'none';
                        }
                        try {
                            if (btnTouch2d) btnTouch2d.style.opacity = (mode === 'touch2d') ? '1.0' : '0.7';
                            if (btnDino) btnDino.style.opacity = (mode === 'dino') ? '1.0' : '0.7';
                        } catch (_) {
                            // ignore
                        }
                        if (mode === 'dino') {
                            try { systemState.ui.dinoWrapperIframe?.contentWindow?.focus?.(); } catch (_) { }
                        }
                    };
                    if (btnTouch2d) btnTouch2d.onclick = () => setHeroMode('touch2d');
                    if (btnDino) btnDino.onclick = () => setHeroMode('dino');
                    setHeroMode(systemState.ui.heroMode || 'touch2d');

                    ignite.onclick = async (e) => {
                        e.target.style.display = 'none';

                        // Ensure only enabled engines are displayed
                        if (babylonJuice) babylonJuice.canvas.style.display = 'block';

                        // Start Tutorial
                        window.hfoTutorial.show();

                        const disableCamera = isFlagEnabled('disable-camera');
                        if (!disableCamera) {
                            await initP0();
                        }

                        const [w, h] = systemState.parameters.camera.resolution.split('x');
                        if (disableCamera) {
                            systemState.parameters.p0Active = true;
                            resizeCanvas();
                            predictLoop();
                        } else {
                            try {
                                const camera = window.hfoRegistry?.resolve?.(window.hfoTokens.P0_CAMERA) || null;
                                const stream = camera
                                    ? await camera.getStream({ width: parseInt(w), height: parseInt(h) })
                                    : await navigator.mediaDevices.getUserMedia({ video: { width: parseInt(w), height: parseInt(h) } });
                                systemState.p0.video.srcObject = stream;
                                systemState.p0.video.onloadeddata = () => {
                                    systemState.parameters.p0Active = true;
                                    resizeCanvas();
                                    predictLoop();
                                };
                            } catch (err) {
                                console.warn('P0 Camera Error:', err);
                                systemState.parameters.p0Active = true;
                                resizeCanvas();
                                predictLoop();
                            }
                        }
                    };

                    registerTeardown(() => {
                        try { ignite.onclick = null; } catch (_) { }
                    });
                };

                // --- Mount layers ---
                mountVideoLayer();
                mountOverlayCanvasLayer();
                const touch2dCanvas = mountTouch2DCursorLayer();
                const { babylonJuice } = mountBabylonLayer();
                mountDinoRunnerLayer();
                mountUiLayer(babylonJuice);

                // Resize observer ensures parity box + transforms stay correct.
                const heroObserver = new ResizeObserver(() => {
                    resizeCanvas();
                });
                heroObserver.observe(wrap);
                registerTeardown(() => {
                    try { heroObserver.disconnect(); } catch (_) { }
                });

                container.on('resize', () => {
                    resizeCanvas();
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        try {
                            systemState.ui.juiceLayers.forEach(l => l?.resize?.());
                        } catch (_) {
                            // ignore
                        }
                    }
                });

                container.on('destroy', () => {
                    console.log('[LIFECYCLE] Destroying Hero Component...');
                    teardowns.splice(0).reverse().forEach((fn) => {
                        try { fn(); } catch (_) { }
                    });
                    if (systemState.ui.tactical === touch2dCanvas) {
                        systemState.ui.tactical = null;
                        systemState.ui.tacticalCtx = null;
                    }
                });
            };

            // GEN6 v7: HERO mode is allowed but is mutually exclusive with SRP mode.
            // initLayout() tears down SRP singletons before mounting HERO to avoid duplicate DOM ids/state.
            layout.registerComponentFactoryFunction('hero-touch2d', (container) => mountTouch2DHero(container));

            // GEN6 v6: SRP components
            layout.registerComponentFactoryFunction('srp-video', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                container.getElement().appendChild(wrap);

                const root = hostLayer('srp-video', wrap, ensureVideoLayer);

                const obs = new ResizeObserver(() => resizeCanvas());
                obs.observe(wrap);

                container.on('resize', () => resizeCanvas());
                container.on('destroy', () => {
                    try { obs.disconnect(); } catch (_) { }
                    parkLayer('srp-video');
                });
            });

            layout.registerComponentFactoryFunction('srp-touch2d', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                container.getElement().appendChild(wrap);

                hostLayer('srp-touch2d', wrap, ensureTouch2DLayer);
                const obs = new ResizeObserver(() => resizeCanvas());
                obs.observe(wrap);

                container.on('resize', () => resizeCanvas());
                container.on('destroy', () => {
                    try { obs.disconnect(); } catch (_) { }
                    parkLayer('srp-touch2d');
                });
            });

            layout.registerComponentFactoryFunction('srp-babylon', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                container.getElement().appendChild(wrap);

                hostLayer('srp-babylon', wrap, ensureBabylonLayer);
                const obs = new ResizeObserver(() => resizeCanvas());
                obs.observe(wrap);

                container.on('resize', () => resizeCanvas());
                container.on('destroy', () => {
                    try { obs.disconnect(); } catch (_) { }
                    parkLayer('srp-babylon');
                });
            });

            layout.registerComponentFactoryFunction('srp-dino', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                container.getElement().appendChild(wrap);

                hostLayer('srp-dino', wrap, ensureDinoLayer);
                container.on('resize', () => resizeCanvas());
                container.on('destroy', () => {
                    parkLayer('srp-dino');
                });
            });

            // GEN5 v11.2: multiview mirror (shares stream via P0_CAMERA).
            layout.registerComponentFactoryFunction('camera-mirror', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.innerHTML = `
                    <div class="hero-view-container" style="background:#000;">
                        <video class="video-mirror" autoplay playsinline muted style="width:100%; height:100%; object-fit:cover;"></video>
                        <div style="position:absolute; top:8px; left:8px; z-index:20; color:#7CFC90; font-family:monospace; font-size:11px; opacity:0.9;">MULTIVIEW MIRROR</div>
                    </div>
                `;
                container.getElement().appendChild(wrap);

                const video = wrap.querySelector('video');
                const attach = async () => {
                    if (!video) return;
                    if (isFlagEnabled('disable-camera')) return;
                    try {
                        const camera = window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA);
                        const stream = await camera.getStream();
                        video.srcObject = stream;
                    } catch (e) {
                        console.warn('[v11.2] camera-mirror attach failed:', e);
                    }
                };

                if (isFlagEnabled('ui-multiview') || !systemState.parameters.essentialsMode) {
                    // Best-effort attach immediately; shared adapter ensures only one getUserMedia call.
                    attach();
                }

                container.on('destroy', () => {
                    try {
                        if (video) video.srcObject = null;
                    } catch { }
                });
            });

            // GEN5 v11.1: App selector components (tabs live in GoldenLayout; AppHost controls overlay visibility).
            // These components intentionally have no side-effects; activation is wired at the layout level.
            layout.registerComponentFactoryFunction('app-excalidraw', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Excalidraw';
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('app-sandbox', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Sandbox';
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('app-pointer-lab', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Pointer Lab';
                container.getElement().appendChild(wrap);
            });

            // NOTE: Bespoke Gen5 game component factories removed (official vendoring only).

            layout.registerComponentFactoryFunction('navigator', (container) => {
                P7Navigator.init(container.getElement());
            });

            layout.registerComponentFactoryFunction('logs', (container) => {
                const div = document.createElement('div');
                div.id = 'mission-logs';
                div.className = 'scrollable-panel';
                div.style.background = '#000'; div.style.fontSize = '10px'; div.style.fontFamily = 'monospace';
                container.getElement().appendChild(div);
                logMission("SYSTEM_LOGS: READY");
            });

            layout.registerComponentFactoryFunction('effects', (container) => {
                const wrap = document.createElement('div');
                wrap.id = 'ports-effects-panel';
                wrap.setAttribute('data-testid', 'ports-effects-panel');
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.height = '100%';
                wrap.style.width = '100%';
                wrap.style.background = '#000';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '11px';
                wrap.style.boxSizing = 'border-box';
                wrap.style.padding = '10px';
                wrap.style.gap = '8px';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.justifyContent = 'space-between';

                const title = document.createElement('div');
                title.textContent = 'Ports Effects (P0â€“P7)';
                title.style.opacity = '0.9';

                const controls = document.createElement('div');
                controls.style.display = 'flex';
                controls.style.gap = '8px';

                const mkBtn = (label) => {
                    const b = document.createElement('button');
                    b.textContent = label;
                    b.style.background = 'rgba(124,252,144,0.12)';
                    b.style.color = '#7CFC90';
                    b.style.border = '1px solid rgba(124,252,144,0.25)';
                    b.style.borderRadius = '10px';
                    b.style.padding = '6px 10px';
                    b.style.cursor = 'pointer';
                    b.style.fontFamily = 'monospace';
                    b.style.fontSize = '11px';
                    return b;
                };

                let paused = false;
                const btnPause = mkBtn('Pause');
                const btnClear = mkBtn('Clear');

                controls.appendChild(btnPause);
                controls.appendChild(btnClear);
                header.appendChild(title);
                header.appendChild(controls);
                wrap.appendChild(header);

                const summary = document.createElement('pre');
                summary.id = 'ports-effects-summary';
                summary.style.margin = '0';
                summary.style.whiteSpace = 'pre-wrap';
                summary.style.opacity = '0.9';
                summary.style.border = '1px solid rgba(124,252,144,0.12)';
                summary.style.borderRadius = '10px';
                summary.style.padding = '8px';
                summary.style.background = '#050a05';
                wrap.appendChild(summary);

                const log = document.createElement('pre');
                log.id = 'ports-effects-log';
                log.style.margin = '0';
                log.style.flex = '1 1 auto';
                log.style.overflow = 'auto';
                log.style.whiteSpace = 'pre';
                log.style.border = '1px solid rgba(124,252,144,0.12)';
                log.style.borderRadius = '10px';
                log.style.padding = '8px';
                log.style.background = '#050a05';
                wrap.appendChild(log);

                const fmtTs = (ts) => {
                    try {
                        const d = new Date(ts);
                        if (!Number.isFinite(d.getTime())) return String(ts);
                        return d.toISOString().replace('T', ' ').replace('Z', 'Z');
                    } catch {
                        return String(ts);
                    }
                };

                const render = () => {
                    const snap = window.hfoPortsEffects?.getSnapshot?.() || { recent: [], lastByPort: {}, state: {} };
                    const last = snap.lastByPort || {};
                    const dino = (snap.state || {}).dino || {};

                    summary.textContent = [
                        `p1 last: ${last.p1 ? `${last.p1.type}` : 'â€”'}`,
                        `p3 last: ${last.p3 ? `${last.p3.type}` : 'â€”'}`,
                        `p7 last: ${last.p7 ? `${last.p7.type}` : 'â€”'}`,
                        `dino: iframe=${dino.iframePresent ? 'yes' : 'no'} readyState=${dino.readyState || 'n/a'} q=${Number.isFinite(dino.queueLength) ? dino.queueLength : 'n/a'} lastOk=${dino.lastAttempt?.ok ?? 'n/a'} (${dino.lastAttempt?.reason || 'n/a'})`
                    ].join('\n');

                    const lines = (snap.recent || []).slice(-80).map((e) => {
                        const port = e.port || '??';
                        const t = e.type || 'event';
                        const ts = fmtTs(e.ts);
                        let body = '';
                        try {
                            body = JSON.stringify(e.payload ?? null);
                        } catch {
                            body = String(e.payload ?? '');
                        }
                        return `[${ts}] ${port} ${t} ${body}`;
                    });
                    log.textContent = lines.join('\n');
                };

                btnPause.onclick = () => {
                    paused = !paused;
                    btnPause.textContent = paused ? 'Resume' : 'Pause';
                    if (!paused) render();
                };

                btnClear.onclick = () => {
                    try { window.hfoPortsEffects?.clear?.(); } catch (_) { }
                    render();
                };

                let unsub = null;
                try {
                    unsub = window.hfoPortsEffects?.subscribe?.(() => {
                        if (!paused) render();
                    });
                } catch (_) {
                    // ignore
                }

                try {
                    container.on?.('destroy', () => {
                        try { if (typeof unsub === 'function') unsub(); } catch (_) { }
                    });
                } catch (_) {
                    // ignore
                }

                render();
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('knuckle-tripwire-debug', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.boxSizing = 'border-box';
                wrap.style.height = '100%';
                wrap.style.width = '100%';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.gap = '10px';
                wrap.style.padding = '10px';
                wrap.setAttribute('data-testid', 'knuckle-tripwire-panel');

                const title = document.createElement('div');
                title.textContent = 'Knuckle Tripwire (P2)';
                title.style.fontSize = '12px';
                title.style.fontWeight = '700';
                title.style.letterSpacing = '0.6px';
                title.style.opacity = '0.95';
                wrap.appendChild(title);

                const stateRow = document.createElement('div');
                stateRow.style.display = 'flex';
                stateRow.style.flexWrap = 'wrap';
                stateRow.style.gap = '8px';
                stateRow.style.alignItems = 'center';
                wrap.appendChild(stateRow);

                const mkChip = (label) => {
                    const s = document.createElement('span');
                    s.textContent = label;
                    s.style.display = 'inline-flex';
                    s.style.alignItems = 'center';
                    s.style.gap = '6px';
                    s.style.padding = '6px 10px';
                    s.style.borderRadius = '999px';
                    s.style.border = '1px solid rgba(124,252,144,0.25)';
                    s.style.background = 'rgba(124,252,144,0.10)';
                    s.style.color = '#7CFC90';
                    s.style.fontSize = '11px';
                    s.style.whiteSpace = 'nowrap';
                    return s;
                };

                const chipState = mkChip('FSM: â€”');
                const chipVel = mkChip('VEL: â€”');
                const chipZone = mkChip('ZONE: â€”');
                const chipLast = mkChip('LAST: â€”');
                stateRow.appendChild(chipState);
                stateRow.appendChild(chipVel);
                stateRow.appendChild(chipZone);
                stateRow.appendChild(chipLast);

                // --- v22: User-tunable predictive lookahead (TOI window) ---
                const ctlRow = document.createElement('div');
                ctlRow.style.display = 'flex';
                ctlRow.style.flexWrap = 'wrap';
                ctlRow.style.gap = '10px';
                ctlRow.style.alignItems = 'center';
                ctlRow.style.padding = '6px 0 0 0';
                wrap.appendChild(ctlRow);

                const mkLabel = (txt) => {
                    const s = document.createElement('span');
                    s.textContent = txt;
                    s.style.fontSize = '11px';
                    s.style.opacity = '0.9';
                    return s;
                };

                const mkBox = () => {
                    const d = document.createElement('div');
                    d.style.display = 'inline-flex';
                    d.style.alignItems = 'center';
                    d.style.gap = '8px';
                    d.style.padding = '6px 10px';
                    d.style.borderRadius = '10px';
                    d.style.border = '1px solid rgba(124,252,144,0.12)';
                    d.style.background = '#050a05';
                    return d;
                };

                const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

                const getP2LookaheadWindowMs = () => {
                    try {
                        const p2 = systemState?.parameters?.p2?.tripwireThread || systemState?.parameters?.p2?.tripwire || {};
                        const raw = Number(p2?.lookaheadWindowMs ?? 120);
                        const n = Number.isFinite(raw) ? raw : 120;
                        return clamp(Math.round(n), 1, 500);
                    } catch (_) {
                        return 120;
                    }
                };

                const setP2LookaheadWindowMs = (ms) => {
                    const v = clamp(Math.round(Number(ms) || 120), 1, 500);
                    try {
                        systemState.parameters = systemState.parameters || {};
                        systemState.parameters.p2 = systemState.parameters.p2 || {};
                        // Prefer the thread namespace (consistent with cfg() reads in P2/P3).
                        systemState.parameters.p2.tripwireThread = systemState.parameters.p2.tripwireThread || {};
                        systemState.parameters.p2.tripwireThread.lookaheadWindowMs = v;
                    } catch (_) {
                        // ignore
                    }

                    // Persist into URL flag for shareable/manual testing.
                    try {
                        // getFlagNumber reads from the shared urlParams object; mutate it if present.
                        try { if (typeof urlParams?.set === 'function') urlParams.set('flag-p2-knuckle-tripwire-lookahead-window-ms', String(v)); } catch (_) { }
                        const u = new URL(window.location.href);
                        u.searchParams.set('flag-p2-knuckle-tripwire-lookahead-window-ms', String(v));
                        window.history.replaceState({}, '', u.toString());
                    } catch (_) {
                        // ignore
                    }

                    return v;
                };

                const isPredictiveEnabled = () => {
                    // Predictive scheduling is enabled by default; explicit disable flag opts out.
                    return !isFlagEnabled('p3-tripwire-lookahead-disable');
                };

                const setPredictiveEnabled = (enabled) => {
                    const wantEnabled = !!enabled;
                    try {
                        const u = new URL(window.location.href);
                        if (wantEnabled) {
                            u.searchParams.delete('flag-p3-tripwire-lookahead-disable');
                        } else {
                            u.searchParams.set('flag-p3-tripwire-lookahead-disable', 'true');
                        }
                        window.history.replaceState({}, '', u.toString());
                    } catch (_) {
                        // ignore
                    }
                };

                const boxLookahead = mkBox();
                ctlRow.appendChild(boxLookahead);
                boxLookahead.appendChild(mkLabel('Lookahead (ms):'));

                const inputRange = document.createElement('input');
                inputRange.type = 'range';
                inputRange.min = '1';
                inputRange.max = '500';
                inputRange.step = '1';
                inputRange.style.width = '160px';
                inputRange.value = String(getP2LookaheadWindowMs());
                boxLookahead.appendChild(inputRange);

                const inputNum = document.createElement('input');
                inputNum.type = 'number';
                inputNum.min = '1';
                inputNum.max = '500';
                inputNum.step = '1';
                inputNum.value = String(getP2LookaheadWindowMs());
                inputNum.style.width = '74px';
                inputNum.style.background = '#000';
                inputNum.style.color = '#7CFC90';
                inputNum.style.border = '1px solid rgba(124,252,144,0.20)';
                inputNum.style.borderRadius = '8px';
                inputNum.style.padding = '4px 6px';
                boxLookahead.appendChild(inputNum);

                const note = document.createElement('span');
                note.textContent = 'disable via Predictive toggle';
                note.style.fontSize = '10px';
                note.style.opacity = '0.6';
                boxLookahead.appendChild(note);

                const boxPredictive = mkBox();
                ctlRow.appendChild(boxPredictive);
                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.checked = isPredictiveEnabled();
                boxPredictive.appendChild(chk);
                boxPredictive.appendChild(mkLabel('Predictive'));

                const syncControls = () => {
                    const v = getP2LookaheadWindowMs();
                    inputRange.value = String(v);
                    inputNum.value = String(v);
                    chk.checked = isPredictiveEnabled();
                };

                inputRange.oninput = () => {
                    const v = setP2LookaheadWindowMs(inputRange.value);
                    inputNum.value = String(v);
                };
                inputNum.onchange = () => {
                    const v = setP2LookaheadWindowMs(inputNum.value);
                    inputRange.value = String(v);
                };
                chk.onchange = () => {
                    setPredictiveEnabled(chk.checked);
                    syncControls();
                };

                const barWrap = document.createElement('div');
                barWrap.style.flex = '1 1 auto';
                barWrap.style.borderRadius = '14px';
                barWrap.style.border = '1px solid rgba(124,252,144,0.12)';
                barWrap.style.background = '#050a05';
                barWrap.style.padding = '12px';
                barWrap.style.display = 'flex';
                barWrap.style.flexDirection = 'column';
                barWrap.style.gap = '10px';
                wrap.appendChild(barWrap);

                const legend = document.createElement('div');
                legend.style.display = 'flex';
                legend.style.flexWrap = 'wrap';
                legend.style.gap = '10px';
                legend.style.alignItems = 'center';
                legend.style.fontSize = '11px';
                legend.style.opacity = '0.95';
                legend.innerHTML = `
                    <span style="display:inline-flex; gap:6px; align-items:center;"><span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#9E9E9E;"></span>IDLE</span>
                    <span style="display:inline-flex; gap:6px; align-items:center;"><span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#FFB300;"></span>READY</span>
                    <span style="display:inline-flex; gap:6px; align-items:center;"><span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#00BCD4;"></span>COMMIT</span>
                    <span style="display:inline-flex; gap:6px; align-items:center;"><span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#FFEB3B;"></span>COAST</span>
                `;
                barWrap.appendChild(legend);

                const bar = document.createElement('div');
                bar.style.height = '18px';
                bar.style.borderRadius = '999px';
                bar.style.border = '1px solid rgba(255,255,255,0.14)';
                bar.style.background = '#9E9E9E';
                bar.style.boxShadow = '0 0 0 1px rgba(0,0,0,0.3) inset';
                bar.setAttribute('data-testid', 'knuckle-tripwire-bar');
                barWrap.appendChild(bar);

                const detail = document.createElement('pre');
                detail.style.margin = '0';
                detail.style.whiteSpace = 'pre-wrap';
                detail.style.opacity = '0.92';
                detail.style.border = '1px solid rgba(124,252,144,0.12)';
                detail.style.borderRadius = '10px';
                detail.style.padding = '8px';
                detail.style.background = '#050a05';
                detail.textContent = 'awaiting dataâ€¦';
                barWrap.appendChild(detail);

                const fsmColor = (fsm) => {
                    const s = String(fsm || '').toUpperCase();
                    if (s === 'COMMIT') return '#00BCD4';
                    if (s === 'READY') return '#FFB300';
                    if (s === 'COAST') return '#FFEB3B';
                    return '#9E9E9E';
                };

                const zoneForX = (x) => {
                    const v = Number(x);
                    if (!Number.isFinite(v)) return 'â€”';
                    if (v < 0.33) return 'LEFT';
                    if (v > 0.66) return 'RIGHT';
                    return 'MID';
                };

                let lastKnuckleCross = null;

                const getPrimaryCursor = () => {
                    try {
                        const cursors = Array.isArray(systemState?.dataFabric?.cursors) ? systemState.dataFabric.cursors : [];
                        return (cursors && cursors.length) ? cursors[0] : null;
                    } catch (_) {
                        return null;
                    }
                };

                const renderOnce = () => {
                    const cur = getPrimaryCursor();
                    const fsm = String(cur?.fsmState || lastKnuckleCross?.fsmState || 'IDLE');
                    const c = fsmColor(fsm);
                    bar.style.background = c;

                    const x = Number.isFinite(cur?.uiNormX) ? Number(cur.uiNormX) : Number(cur?.normX);
                    const y = Number.isFinite(cur?.uiNormY) ? Number(cur.uiNormY) : Number(cur?.normY);
                    const vx = Number(lastKnuckleCross?.vxUiNormPerS ?? NaN);
                    const vy = Number(lastKnuckleCross?.vyUiNormPerS ?? NaN);
                    const sp = Number(lastKnuckleCross?.speedUiNormPerS ?? NaN);

                    chipState.textContent = `FSM: ${fsm}`;
                    chipVel.textContent = `VEL: ${Number.isFinite(sp) ? sp.toFixed(2) : 'â€”'} (${Number.isFinite(vx) ? vx.toFixed(2) : 'â€”'},${Number.isFinite(vy) ? vy.toFixed(2) : 'â€”'})`;
                    chipZone.textContent = `ZONE: ${zoneForX(x)}`;
                    chipLast.textContent = `LAST: ${lastKnuckleCross ? `seq=${String(lastKnuckleCross?.seq ?? 'â€”')} phase=${String(lastKnuckleCross?.sensor?.phase || 'â€”')}` : 'â€”'}`;

                    detail.textContent = JSON.stringify({
                        fsm,
                        cursor: { x: Number.isFinite(x) ? x : null, y: Number.isFinite(y) ? y : null },
                        lastKnuckleCross
                    }, null, 2);

                    return { fsm, color: c };
                };

                let unsub = null;
                try {
                    unsub = window.hfoPortsEffects?.subscribe?.((entry) => {
                        if (entry?.port !== 'p2') return;
                        if (entry?.type !== 'tripwire_cross') return;
                        const p = entry?.payload || null;
                        if (String(p?.sensorId || '') !== 'knuckle') return;
                        lastKnuckleCross = p;
                        renderOnce();
                    }, 'p2');
                } catch (_) {
                    unsub = null;
                }

                // Deterministic test hook.
                window.hfoUiKnuckleTripwirePanel = Object.freeze({
                    renderOnce,
                    getLastCross: () => lastKnuckleCross,
                    getColorForState: (s) => fsmColor(s)
                });

                const interval = setInterval(() => {
                    try { renderOnce(); } catch (_) { }
                }, 120);

                const intervalControls = setInterval(() => {
                    try { syncControls(); } catch (_) { }
                }, 750);

                try {
                    container.on?.('destroy', () => {
                        try { if (typeof unsub === 'function') unsub(); } catch (_) { }
                        try { clearInterval(interval); } catch (_) { }
                        try { clearInterval(intervalControls); } catch (_) { }
                    });
                } catch (_) {
                    // ignore
                }

                renderOnce();
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('tripwire-debug', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.boxSizing = 'border-box';
                wrap.style.height = '100%';
                wrap.style.width = '100%';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.gap = '8px';
                wrap.style.padding = '10px';

                const mkChip = (label) => {
                    const s = document.createElement('span');
                    s.textContent = label;
                    s.style.display = 'inline-flex';
                    s.style.alignItems = 'center';
                    s.style.gap = '6px';
                    s.style.padding = '6px 10px';
                    s.style.borderRadius = '999px';
                    s.style.border = '1px solid rgba(124,252,144,0.25)';
                    s.style.background = 'rgba(124,252,144,0.10)';
                    s.style.color = '#7CFC90';
                    s.style.fontSize = '11px';
                    s.style.whiteSpace = 'nowrap';
                    return s;
                };

                const headerRow = document.createElement('div');
                headerRow.style.display = 'flex';
                headerRow.style.flexWrap = 'wrap';
                headerRow.style.gap = '8px';
                headerRow.style.alignItems = 'center';

                const chipArmed = mkChip('ARMED: â€”');
                const chipCursor = mkChip('CURSOR: â€”');
                const chipVel = mkChip('VEL: â€”');
                const chipLast = mkChip('LAST: â€”');

                // Make ARMED stand out.
                chipArmed.style.border = '1px solid rgba(255,255,255,0.18)';
                chipArmed.style.background = 'rgba(255,255,255,0.06)';

                headerRow.appendChild(chipArmed);
                headerRow.appendChild(chipCursor);
                headerRow.appendChild(chipVel);
                headerRow.appendChild(chipLast);
                wrap.appendChild(headerRow);

                const vizWrap = document.createElement('div');
                vizWrap.style.position = 'relative';
                vizWrap.style.flex = '1 1 auto';
                vizWrap.style.borderRadius = '12px';
                vizWrap.style.border = '1px solid rgba(124,252,144,0.12)';
                vizWrap.style.background = '#050a05';
                vizWrap.style.overflow = 'hidden';
                wrap.appendChild(vizWrap);

                const canvas = document.createElement('canvas');
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                vizWrap.appendChild(canvas);
                const ctx = canvas.getContext('2d');

                const legend = document.createElement('div');
                legend.style.position = 'absolute';
                legend.style.left = '10px';
                legend.style.bottom = '10px';
                legend.style.zIndex = '10';
                legend.style.pointerEvents = 'none';
                legend.style.display = 'flex';
                legend.style.flexDirection = 'column';
                legend.style.gap = '6px';
                legend.style.opacity = '0.92';
                legend.innerHTML = `
                    <div style="display:flex; gap:8px; align-items:center; font-size:11px;">
                        <span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#9E9E9E;"></span><span>IDLE</span>
                        <span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#FFB300;"></span><span>READY</span>
                        <span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#42A5F5;"></span><span>COMMIT</span>
                        <span style="display:inline-block; width:10px; height:10px; border-radius:50%; background:#FFEB3B;"></span><span>COAST</span>
                    </div>
                    <div style="font-size:11px; color:#7CFC90;">Band = sensor, dot = cursor, pulse = last tripwire_cross</div>
                `;
                vizWrap.appendChild(legend);

                const resize = () => {
                    const r = vizWrap.getBoundingClientRect();
                    const dpr = Math.max(1, window.devicePixelRatio || 1);
                    canvas.width = Math.max(2, Math.floor(r.width * dpr));
                    canvas.height = Math.max(2, Math.floor(r.height * dpr));
                };

                const fsmColor = (fsm) => {
                    const s = String(fsm || '').toUpperCase();
                    if (s === 'COMMIT') return '#42A5F5';
                    if (s === 'READY') return '#FFB300';
                    if (s === 'COAST') return '#FFEB3B';
                    return '#9E9E9E';
                };

                let lastEvent = null;
                let lastPulseTs = 0;
                let lastCursor = null;
                let raf = 0;

                // Capture tripwire events from Port2.
                let unsub = null;
                try {
                    unsub = window.hfoPortsEffects?.subscribe?.((entry) => {
                        if (entry?.port !== 'p2') return;
                        if (entry?.type !== 'tripwire_cross') return;
                        lastEvent = entry.payload || null;
                        lastPulseTs = (typeof entry.ts === 'number') ? entry.ts : (typeof performance?.now === 'function' ? performance.now() : Date.now());
                    }, 'p2');
                } catch (_) {
                    unsub = null;
                }

                const pickCursor = () => {
                    const cursors = systemState?.dataFabric?.cursors;
                    if (!Array.isArray(cursors) || !cursors.length) return null;
                    // Prefer primary/handIndex 0 if available.
                    let best = cursors.find(c => Number(c?.handIndex ?? 0) === 0) || cursors[0];
                    const x = Number(best?.uiNormX ?? best?.normX);
                    const y = Number(best?.uiNormY ?? best?.normY);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        best = cursors.find(c => Number.isFinite(Number(c?.uiNormX ?? c?.normX)) && Number.isFinite(Number(c?.uiNormY ?? c?.normY))) || null;
                    }
                    return best || null;
                };

                const fmt = (n, d = 3) => {
                    const x = Number(n);
                    if (!Number.isFinite(x)) return 'â€”';
                    return x.toFixed(d);
                };

                const draw = () => {
                    raf = requestAnimationFrame(draw);
                    if (!ctx) return;

                    const dpr = Math.max(1, window.devicePixelRatio || 1);
                    const w = canvas.width;
                    const h = canvas.height;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, w, h);

                    // Background
                    ctx.fillStyle = '#050a05';
                    ctx.fillRect(0, 0, w, h);

                    const dbg = window.hfoP2TripwireThread?.getDebugState?.() || null;
                    const band = dbg?.band || { centerUiNormY: 0.5, thicknessUiNorm: 0.06, spanUiNormXMin: 0.0, spanUiNormXMax: 1.0 };
                    const bandY = Number(band.centerUiNormY ?? 0.5);
                    const bandT = Number(band.thicknessUiNorm ?? 0.06);
                    const bandX0 = Number(band.spanUiNormXMin ?? 0.0);
                    const bandX1 = Number(band.spanUiNormXMax ?? 1.0);

                    // Sensor band
                    const pxX0 = Math.max(0, Math.min(1, bandX0)) * w;
                    const pxX1 = Math.max(0, Math.min(1, bandX1)) * w;
                    const pxY = Math.max(0, Math.min(1, bandY)) * h;
                    const pxH = Math.max(1, Math.abs(bandT) * h);

                    ctx.fillStyle = 'rgba(124,252,144,0.15)';
                    ctx.fillRect(pxX0, pxY - pxH / 2, Math.max(1, pxX1 - pxX0), pxH);
                    ctx.strokeStyle = 'rgba(124,252,144,0.45)';
                    ctx.lineWidth = Math.max(1, 1.5 * dpr);
                    ctx.strokeRect(pxX0, pxY - pxH / 2, Math.max(1, pxX1 - pxX0), pxH);

                    // Midline
                    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                    ctx.lineWidth = Math.max(1, 1 * dpr);
                    ctx.beginPath();
                    ctx.moveTo(0, pxY);
                    ctx.lineTo(w, pxY);
                    ctx.stroke();

                    const c = pickCursor();
                    if (c) {
                        const fsm = String(c?.fsmState || '');
                        const readiness = Number(c?.readinessScore ?? 0);
                        const x = Number(c?.uiNormX ?? c?.normX);
                        const y = Number(c?.uiNormY ?? c?.normY);

                        const px = Math.max(0, Math.min(1, x)) * w;
                        const py = Math.max(0, Math.min(1, y)) * h;

                        // Velocity estimate (uiNorm/sec)
                        let vx = 0, vy = 0, speed = 0;
                        const nowMs = (typeof performance?.now === 'function') ? performance.now() : Date.now();
                        if (lastCursor && Number.isFinite(lastCursor.x) && Number.isFinite(lastCursor.y) && Number.isFinite(lastCursor.t)) {
                            const dtMs = Math.max(1, nowMs - lastCursor.t);
                            vx = (x - lastCursor.x) / (dtMs / 1000);
                            vy = (y - lastCursor.y) / (dtMs / 1000);
                            speed = Math.hypot(vx, vy);
                        }
                        lastCursor = { x, y, t: nowMs, fsm };

                        const armed = (String(fsm).toUpperCase() === 'COMMIT');
                        chipArmed.textContent = armed ? 'ARMED: COMMIT' : `ARMED: ${String(fsm || 'â€”').toUpperCase() || 'â€”'}`;
                        chipArmed.style.background = armed ? 'rgba(66,165,245,0.18)' : 'rgba(255,255,255,0.06)';
                        chipArmed.style.border = armed ? '1px solid rgba(66,165,245,0.42)' : '1px solid rgba(255,255,255,0.18)';
                        chipArmed.style.color = armed ? '#B3DAFF' : '#7CFC90';

                        chipCursor.textContent = `CURSOR: hand=${Number(c?.handIndex ?? 0)} ptr=${Number(c?.pointerId ?? 0)} fsm=${String(fsm || 'â€”').toUpperCase()} r=${fmt(readiness, 2)} x=${fmt(x, 3)} y=${fmt(y, 3)}`;
                        chipVel.textContent = `VEL: vx=${fmt(vx, 3)} vy=${fmt(vy, 3)} |v|=${fmt(speed, 3)} (uiNorm/s)`;

                        // Cursor dot
                        const col = fsmColor(fsm);
                        const insideBand = (y >= (bandY - bandT / 2)) && (y <= (bandY + bandT / 2)) && (x >= bandX0) && (x <= bandX1);

                        // Velocity vector
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = Math.max(1, 1 * dpr);
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + vx * 0.08 * w, py + vy * 0.08 * h);
                        ctx.stroke();

                        // Dot
                        ctx.beginPath();
                        ctx.fillStyle = col;
                        ctx.arc(px, py, Math.max(5 * dpr, 6 * dpr), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = insideBand ? 'rgba(255,255,255,0.75)' : 'rgba(0,0,0,0.55)';
                        ctx.lineWidth = Math.max(2 * dpr, 2);
                        ctx.stroke();

                        // Label
                        ctx.fillStyle = 'rgba(255,255,255,0.80)';
                        ctx.font = `${Math.max(11 * dpr, 12)}px monospace`;
                        ctx.fillText(`${String(fsm || '').toUpperCase()} ${insideBand ? 'IN_BAND' : ''}`.trim(), px + 10 * dpr, py - 10 * dpr);
                    } else {
                        chipArmed.textContent = 'ARMED: â€”';
                        chipCursor.textContent = 'CURSOR: â€”';
                        chipVel.textContent = 'VEL: â€”';
                    }

                    // Last event chip + pulse
                    if (lastEvent) {
                        const dir = String(lastEvent?.direction || 'â€”');
                        const sp = lastEvent?.speedUiNormPerS;
                        const seq = String(lastEvent?.seq || 'â€”');
                        chipLast.textContent = `LAST: tripwire_cross seq=${seq} dir=${dir} speed=${fmt(sp, 3)} y=${fmt(lastEvent?.uiNormY, 3)} now=${String(lastEvent?.now ?? 'â€”')}`;

                        const nowPulse = (typeof performance?.now === 'function') ? performance.now() : Date.now();
                        const age = Math.max(0, nowPulse - lastPulseTs);
                        const t = Math.max(0, 1 - age / 650);
                        if (t > 0.001) {
                            ctx.fillStyle = `rgba(255,255,255,${0.22 * t})`;
                            ctx.fillRect(pxX0, pxY - pxH / 2, Math.max(1, pxX1 - pxX0), pxH);
                            ctx.strokeStyle = `rgba(255,255,255,${0.6 * t})`;
                            ctx.lineWidth = Math.max(2 * dpr, 2);
                            ctx.strokeRect(pxX0, pxY - pxH / 2, Math.max(1, pxX1 - pxX0), pxH);
                        }
                    } else {
                        chipLast.textContent = 'LAST: â€”';
                    }
                };

                // Initial sizing and resize wiring
                resize();
                const obs = new ResizeObserver(() => resize());
                obs.observe(vizWrap);

                raf = requestAnimationFrame(draw);

                container.on('resize', () => {
                    resize();
                });

                container.on('destroy', () => {
                    try { obs.disconnect(); } catch (_) { }
                    try { if (raf) cancelAnimationFrame(raf); } catch (_) { }
                    try { if (typeof unsub === 'function') unsub(); } catch (_) { }
                });

                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('intent', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.gap = '8px';
                wrap.style.padding = '10px';
                wrap.style.boxSizing = 'border-box';

                const title = document.createElement('div');
                title.textContent = 'Intent Injector (P7)';
                title.style.fontFamily = 'monospace';
                title.style.fontSize = '12px';
                title.style.color = '#7CFC90';
                title.style.opacity = '0.9';

                const textarea = document.createElement('textarea');
                textarea.spellcheck = false;
                textarea.style.width = '100%';
                textarea.style.flex = '1 1 auto';
                textarea.style.minHeight = '80px';
                textarea.style.resize = 'vertical';
                textarea.style.background = '#050a05';
                textarea.style.color = '#7CFC90';
                textarea.style.border = '1px solid rgba(124,252,144,0.25)';
                textarea.style.borderRadius = '10px';
                textarea.style.padding = '10px';
                textarea.style.fontFamily = 'monospace';
                textarea.style.fontSize = '12px';
                textarea.value = JSON.stringify({
                    goal: 'touch validation',
                    app: 'pointer-lab',
                    notes: 'set ACTIVE_APP_ONLY routing; verify stylus + multi-touch'
                }, null, 2);

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.alignItems = 'center';

                const btnApply = document.createElement('button');
                btnApply.textContent = 'Apply Intent';
                btnApply.style.background = 'rgba(124,252,144,0.12)';
                btnApply.style.color = '#7CFC90';
                btnApply.style.border = '1px solid rgba(124,252,144,0.25)';
                btnApply.style.borderRadius = '10px';
                btnApply.style.padding = '8px 10px';
                btnApply.style.cursor = 'pointer';
                btnApply.style.fontFamily = 'monospace';
                btnApply.style.fontSize = '12px';

                const btnEmit = document.createElement('button');
                btnEmit.textContent = 'Emit Stigmergy';
                btnEmit.style.background = 'rgba(0,255,255,0.10)';
                btnEmit.style.color = '#7CFC90';
                btnEmit.style.border = '1px solid rgba(124,252,144,0.25)';
                btnEmit.style.borderRadius = '10px';
                btnEmit.style.padding = '8px 10px';
                btnEmit.style.cursor = 'pointer';
                btnEmit.style.fontFamily = 'monospace';
                btnEmit.style.fontSize = '12px';

                const status = document.createElement('div');
                status.style.fontFamily = 'monospace';
                status.style.fontSize = '11px';
                status.style.opacity = '0.8';
                status.style.color = '#7CFC90';
                status.textContent = 'Ready.';

                const parseIntent = () => {
                    const raw = String(textarea.value || '').trim();
                    if (!raw) return null;
                    return JSON.parse(raw);
                };

                const apply = () => {
                    try {
                        const intent = parseIntent();
                        const out = window.hfoPorts?.p7?.navigate?.setIntent?.(intent);
                        status.textContent = out?.ts ? `Applied @ ${out.ts}` : 'Applied.';
                    } catch (e) {
                        status.textContent = `ERROR: ${String(e?.message || e)}`;
                    }
                };

                const emit = () => {
                    try {
                        const intent = parseIntent();
                        const entry = window.hfoStigmergy?.emit?.('intent.set', {
                            intent,
                            ts: new Date().toISOString()
                        });
                        status.textContent = entry?.ts ? `Emitted intent.set @ ${entry.ts}` : 'Emitted.';
                    } catch (e) {
                        status.textContent = `ERROR: ${String(e?.message || e)}`;
                    }
                };

                btnApply.addEventListener('click', apply);
                btnEmit.addEventListener('click', emit);

                row.appendChild(btnApply);
                row.appendChild(btnEmit);
                wrap.appendChild(title);
                wrap.appendChild(textarea);
                wrap.appendChild(row);
                wrap.appendChild(status);
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('excalidraw', (container) => {
                if (!isFlagEnabled('ui-excalidraw')) {
                    container.getElement().innerHTML = '<div style="color:red; padding:20px;">EXCALIDRAW_DISABLED</div>';
                    return;
                }
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.innerHTML = `
                    <iframe
                        id="excalidraw-wrapper-iframe"
                        src="./excalidraw_v20_wrapper.html"
                        style="width:100%; height:100%; border:none; opacity: 0.8; filter: contrast(1.2) brightness(0.8);">
                    </iframe>
                    <div style="position:absolute; top:10px; right:10px; color:#555; font-size:9px; pointer-events:none;">OBSIDIAN MIRROR V9.0</div>
                `;
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('gestures', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container scrollable-panel';
                container.getElement().appendChild(wrap);
                systemState.ui.gestures = wrap;
            });

            layout.registerComponentFactoryFunction('tactical', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.innerHTML = `
                    <canvas id="tactical-canvas"></canvas>
                `;
                container.getElement().appendChild(wrap);
                const canvas = wrap.querySelector('#tactical-canvas');
                systemState.ui.tactical = canvas;
                systemState.ui.tacticalCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);

                // V24.5: Tactical Teardown
                container.on('destroy', () => {
                });
            });

            layout.registerComponentFactoryFunction('fsm-viz', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.justifyContent = 'center';
                wrap.style.background = '#050505';
                const canvas = document.createElement('canvas');
                canvas.id = 'fsm-visualizer';
                wrap.appendChild(canvas);
                container.getElement().appendChild(wrap);
                systemState.ui.fsm = canvas;
                systemState.ui.fsmCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                    }
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);
            });

            layout.registerComponentFactoryFunction('palm', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                const canvas = document.createElement('canvas');
                canvas.id = 'palm-orientation-visualizer';
                wrap.appendChild(canvas);
                container.getElement().appendChild(wrap);

                systemState.ui.palm = canvas;
                systemState.ui.palmCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                    }
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);
            });

            layout.registerComponentFactoryFunction('knuckle-keybar-overlay', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#050505';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.position = 'relative';
                wrap.innerHTML = `
                    <canvas style="width:100%; height:100%;"></canvas>
                    <div style="position:absolute; top:8px; left:8px; z-index:5; color:#9aa0a6; font-family:monospace; font-size:11px; opacity:0.9;">KNUCKLE KEYBAR (v18)</div>
                `;
                container.getElement().appendChild(wrap);

                const canvas = wrap.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                let raf = 0;

                const resize = () => {
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                    }
                };

                const draw = () => {
                    raf = requestAnimationFrame(draw);
                    if (!ctx || !canvas.width || !canvas.height) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const snap = window.hfoP2KnuckleKeybarThread?.getSnapshot?.() || null;
                    const hand = Array.isArray(snap?.hands) ? snap.hands[0] : null;

                    // Background bar (knuckle/palm width; schematic)
                    const barY = Math.round(canvas.height * 0.8);
                    const barX0 = Math.round(canvas.width * 0.15);
                    const barX1 = Math.round(canvas.width * 0.85);

                    ctx.lineWidth = 10;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(barX0, barY);
                    ctx.lineTo(barX1, barY);
                    ctx.stroke();

                    // State color (grey/amber/cyan)
                    let stateColor = '#555';
                    const fsm = String(hand?.fsmState || '');
                    if (fsm === 'COMMIT') stateColor = '#00d5ff';
                    else if (fsm === 'READY') stateColor = '#ffbf00';
                    else if (fsm === 'COAST') stateColor = 'rgba(160,160,160,0.35)';

                    ctx.lineWidth = 6;
                    ctx.strokeStyle = stateColor;
                    ctx.beginPath();
                    ctx.moveTo(barX0, barY);
                    ctx.lineTo(barX1, barY);
                    ctx.stroke();

                    // Cursor marker + line (schematic)
                    const x = Math.round(canvas.width * 0.5);
                    const y = Math.round(canvas.height * 0.35);
                    ctx.fillStyle = stateColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(180,180,180,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, barY);
                    ctx.stroke();

                    // Debug text
                    ctx.fillStyle = 'rgba(210,210,210,0.85)';
                    ctx.font = '11px monospace';
                    const feature = (typeof hand?.feature === 'number') ? hand.feature.toFixed(4) : 'n/a';
                    ctx.fillText(`fsm=${fsm || 'n/a'} feature=${feature}`, 10, canvas.height - 10);
                };

                container.on('resize', resize);
                setTimeout(resize, 50);
                raf = requestAnimationFrame(draw);

                container.on('destroy', () => {
                    if (raf) cancelAnimationFrame(raf);
                });
            });
        }

        // Initialize with default mode (GEN6 v1 defaults Developer)
        initLayout(systemState.parameters.essentialsMode);

        window.addEventListener('resize', () => {
            layout.updateSize();
            resizeCanvas();
        });

        // Lifecycle Hardening: Guaranteed resource disposal [V24.4]
        window.addEventListener('beforeunload', () => {
            console.log("ðŸŒ€ [HFO LIFECYCLE]: Initiating global disposal sequence...");
            window.hfoLifecycle.disposeAll();
        });

        // ðŸŒ‰ HFO BRIDGE: Sync initial state with Excalidraw on Ready
        window.addEventListener('message', (event) => {
            const { type } = event.data;
            if (type === 'EXCALIDRAW_READY') {
                console.log("ðŸŽ¨ [P3] Excalidraw Ready. Syncing initial tool:", systemState.parameters.excalidraw.activeTool);
                if (systemState.ui.excalidrawIframe) {
                    systemState.ui.excalidrawIframe.contentWindow.postMessage({
                        type: 'SET_TOOL',
                        data: { tool: systemState.parameters.excalidraw.activeTool }
                    }, '*');
                }
            }
        });

        // --- GEN5 v11: Stigmergy surface (additive, inert-by-default) ---
        // Purpose: provide a minimal, contract-friendly emission channel for indirect coordination.
        // Invariant: do not emit anything automatically; only emit when explicitly called.
        window.hfoStigmergy = window.hfoStigmergy || (() => {
            const MAX = 200;
            const buffer = [];

            const nowMs = () => {
                try {
                    return (typeof performance !== 'undefined' && typeof performance.now === 'function')
                        ? performance.now()
                        : Date.now();
                } catch {
                    return Date.now();
                }
            };

            const emit = (type, payload) => {
                const entry = Object.freeze({
                    type: String(type),
                    payload: payload ?? null,
                    ts: nowMs()
                });

                buffer.push(entry);
                if (buffer.length > MAX) buffer.splice(0, buffer.length - MAX);

                try {
                    window.dispatchEvent(new CustomEvent('hfo:stigmergy', { detail: entry }));
                    window.dispatchEvent(new CustomEvent(`hfo:stigmergy:${entry.type}`, { detail: entry }));
                } catch {
                    // ignore: safe in older browsers / restrictive contexts
                }

                return entry;
            };

            const getRecent = (limit = MAX) => {
                const n = Math.max(0, Math.min(MAX, Number(limit) || 0));
                return buffer.slice(-n);
            };

            const subscribe = (handler, type) => {
                const eventName = type ? `hfo:stigmergy:${String(type)}` : 'hfo:stigmergy';
                const listener = (e) => handler(e?.detail);
                window.addEventListener(eventName, listener);
                return () => window.removeEventListener(eventName, listener);
            };

            return Object.freeze({ emit, getRecent, subscribe });
        })();

        // --- GEN6 v5: Polymorphic Adapter Host ---
        // Purpose: keep adapters (app-specific delivery / mapping) separate from port logic.
        // Common fabric: Touch2D -> DataFabric -> (P3) W3C PointerEvents.
        // Adapters may additionally deliver non-pointer effects (e.g., keyboard nematocyst).
        window.hfoAdapterHost = window.hfoAdapterHost || (() => {
            const adapters = new Map();
            let activeId = null;

            const register = (adapter) => {
                const id = adapter?.id;
                if (!id || typeof id !== 'string') return false;
                adapters.set(id, Object.freeze({ ...adapter }));
                if (!activeId) activeId = id;
                return true;
            };

            const unregister = (id) => adapters.delete(id);
            const list = () => Array.from(adapters.keys());
            const get = (id) => adapters.get(id) || null;
            const getActiveId = () => activeId;
            const setActiveId = (id) => {
                if (!id || !adapters.has(id)) return false;
                activeId = id;
                return true;
            };

            // Generic side-effect delivery channel.
            // Example effect: { kind:'keyboard', action:'keypress', key:' ', code:'Space', ... }
            const deliverEffect = (id, effect) => {
                const resolvedId = id || activeId;
                const adapter = resolvedId ? adapters.get(resolvedId) : null;
                if (!adapter?.deliverEffect) {
                    try {
                        window.hfoPortsEffects?.emit?.('p7', 'adapter_missing', { adapterId: resolvedId || null });
                    } catch (_) {
                        // ignore
                    }
                    return false;
                }
                try {
                    const ok = !!adapter.deliverEffect(effect);
                    try {
                        window.hfoPortsEffects?.emit?.('p7', 'adapter_deliver', {
                            adapterId: resolvedId,
                            ok,
                            effect: effect ? { kind: effect.kind, action: effect.action, code: effect.code, key: effect.key } : null
                        });
                    } catch (_) {
                        // ignore
                    }
                    return ok;
                } catch (_) {
                    try {
                        window.hfoPortsEffects?.emit?.('p7', 'adapter_deliver_error', {
                            adapterId: resolvedId,
                            effect: effect ? { kind: effect.kind, action: effect.action, code: effect.code, key: effect.key } : null
                        });
                    } catch (_) {
                        // ignore
                    }
                    return false;
                }
            };

            // Built-in adapter: Dino wrapper nematocyst delivery (same-origin iframe).
            // This is intentionally outside P3 so P3 remains substrate-only.
            register({
                id: 'dino-v1',
                kind: 'iframe',
                capabilities: Object.freeze(['nematocyst:keyboard']),
                deliverEffect: (payload) => {
                    let traceId = null;
                    let targetId = null;
                    try {
                        traceId = (typeof systemState?.trace?.traceId === 'string' && systemState.trace.traceId.length)
                            ? systemState.trace.traceId
                            : null;
                        targetId = (typeof systemState?.trace?.targetId === 'string' && systemState.trace.targetId.length)
                            ? systemState.trace.targetId
                            : null;
                    } catch (_) {
                        traceId = null;
                        targetId = null;
                    }

                    let payloadWithTrace = payload ?? null;
                    try {
                        const isPlainObject = payload && typeof payload === 'object' && !Array.isArray(payload);
                        if (isPlainObject) {
                            const patch = {};
                            if (traceId && !payload.traceId) patch.traceId = traceId;
                            if (targetId && !payload.targetId) patch.targetId = targetId;
                            if (Object.keys(patch).length) payloadWithTrace = Object.freeze({ ...payload, ...patch });
                        }
                    } catch (_) {
                        payloadWithTrace = payload ?? null;
                    }

                    const message = Object.freeze({
                        type: 'hfo:nematocyst',
                        traceId,
                        targetId,
                        payload: payloadWithTrace
                    });

                    const iframe = systemState?.ui?.dinoWrapperIframe || null;
                    if (!iframe) {
                        try {
                            if (!systemState.ui.dinoPendingNematocystPayloads) systemState.ui.dinoPendingNematocystPayloads = [];
                            systemState.ui.dinoPendingNematocystPayloads.push(payloadWithTrace ?? null);
                            if (systemState.ui.dinoPendingNematocystPayloads.length > 25) {
                                systemState.ui.dinoPendingNematocystPayloads.splice(0, systemState.ui.dinoPendingNematocystPayloads.length - 25);
                            }
                        } catch (_) {
                            // ignore
                        }

                        try {
                            window.hfoPortsEffects?.setState?.('dino', {
                                iframePresent: false,
                                queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                                lastAttempt: { ok: false, reason: 'missing_iframe' }
                            });
                            window.hfoPortsEffects?.emit?.('p7', 'dino_queue', {
                                ok: false,
                                reason: 'missing_iframe',
                                queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length
                            });
                        } catch (_) {
                            // ignore
                        }
                        return false;
                    }

                    // Best-effort readiness check; avoid throwing in cross-origin or early-load states.
                    try {
                        const readyState = iframe.contentDocument?.readyState;
                        if (readyState && readyState !== 'complete') {
                            if (!systemState.ui.dinoPendingNematocystPayloads) systemState.ui.dinoPendingNematocystPayloads = [];
                            systemState.ui.dinoPendingNematocystPayloads.push(payloadWithTrace ?? null);

                            try {
                                window.hfoPortsEffects?.setState?.('dino', {
                                    iframePresent: true,
                                    readyState,
                                    queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                                    lastAttempt: { ok: false, reason: 'iframe_not_ready' }
                                });
                                window.hfoPortsEffects?.emit?.('p7', 'dino_queue', {
                                    ok: false,
                                    reason: 'iframe_not_ready',
                                    readyState,
                                    queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length
                                });
                            } catch (_) {
                                // ignore
                            }
                            return false;
                        }
                    } catch (_) {
                        // ignore
                    }

                    try {
                        iframe.contentWindow?.postMessage(message, '*');

                        try {
                            window.hfoPortsEffects?.setState?.('dino', {
                                iframePresent: true,
                                queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                                lastAttempt: { ok: true, reason: 'postMessage' }
                            });
                            window.hfoPortsEffects?.emit?.('p7', 'dino_postMessage', { ok: true });
                        } catch (_) {
                            // ignore
                        }
                        return true;
                    } catch (e) {
                        if (systemState?.parameters?.devMode) console.warn('[AdapterHost] Dino nematocyst send failed:', e);

                        try {
                            window.hfoPortsEffects?.setState?.('dino', {
                                iframePresent: true,
                                queueLength: (systemState.ui.dinoPendingNematocystPayloads || []).length,
                                lastAttempt: { ok: false, reason: 'postMessage_error', error: String(e?.message || e) }
                            });
                            window.hfoPortsEffects?.emit?.('p7', 'dino_postMessage', { ok: false, error: String(e?.message || e) });
                        } catch (_) {
                            // ignore
                        }
                        return false;
                    }
                }
            });

            return Object.freeze({
                register,
                unregister,
                list,
                get,
                getActiveId,
                setActiveId,
                deliverEffect
            });
        })();

        // --- GEN5: Ports facade exposure (Option 2) + Adapter registry wiring (Option 4) ---
        // Keep port surfaces stable while adapters evolve behind tokens.
        if (!window.hfoRegistry.has(window.hfoTokens.P7_ADAPTER_HOST)) {
            window.hfoRegistry.register(window.hfoTokens.P7_ADAPTER_HOST, {
                list: () => window.hfoAdapterHost?.list?.() || [],
                getActiveId: () => window.hfoAdapterHost?.getActiveId?.() || null,
                setActiveId: (id) => window.hfoAdapterHost?.setActiveId?.(id) || false,
                register: (adapter) => window.hfoAdapterHost?.register?.(adapter) || false,
                deliverEffect: (adapterId, effect) => window.hfoAdapterHost?.deliverEffect?.(adapterId, effect) || false,
            });
        }

        if (!window.hfoRegistry.has(window.hfoTokens.P3_INJECTOR)) {
            window.hfoRegistry.register(window.hfoTokens.P3_INJECTOR, {
                injectFrame: () => w3cPointerNematocystInjector(),
                sendNematocystToDino: (payload) => P3InjectorPort.sendNematocystToDino(payload)
            });
        }

        // --- GEN6 v14: P3 Planck Sensor Injector (Tripwire down-cross â†’ Space keypress) ---
        // Purpose: replace the legacy IDLEâ†’READY trigger with a directional crossing trigger.
        // Policy: down-cross only (topâ†’bottom); bottomâ†’top is intentionally ignored for now.
        window.hfoP3PlanckSensorInjector = window.hfoP3PlanckSensorInjector || (() => {
            const cfg = () => {
                const p2 = systemState?.parameters?.p2?.tripwireThread || systemState?.parameters?.p2?.tripwire || {};
                const p3 = systemState?.parameters?.p3?.tripwireInjector || {};

                const p2Lookahead = (p2?.lookaheadEnabled === true) || isFlagEnabled('p2-tripwire-lookahead');
                const p3Lookahead = (p3?.lookaheadEnabled === true) || isFlagEnabled('p3-tripwire-lookahead');
                const fallbackWindowMs = (Number(p2?.lookaheadWindowMs ?? 0) > 0) ? Number(p2.lookaheadWindowMs) : 120;
                const p2LookaheadWindowMs = Math.max(
                    1,
                    Math.min(
                        500,
                        Number(
                            getFlagNumber(
                                'p2-knuckle-tripwire-lookahead-window-ms',
                                Number(getFlagNumber('p2-tripwire-lookahead-window-ms', fallbackWindowMs))
                            )
                        ) || fallbackWindowMs
                    )
                );

                // P3 can optionally schedule with a different predictive lead than P2's emission window.
                // This enables controlled tests of schedule drift/jitter and explicit compensation for downstream latency.
                const lookaheadWindowMs = Math.max(
                    1,
                    Math.min(
                        500,
                        Number(getFlagNumber('p3-tripwire-lookahead-window-ms', Number(p3?.lookaheadWindowMs ?? p2LookaheadWindowMs))) || p2LookaheadWindowMs
                    )
                );

                // Negative bias schedules earlier; positive schedules later.
                // Default requested: -100ms.
                const lookaheadBiasMs = Math.max(
                    -500,
                    Math.min(
                        500,
                        Number(getFlagNumber('p3-tripwire-lookahead-bias-ms', -100)) || -100
                    )
                );

                const enabledLegacy = isFlagEnabled('p3-tripwire-injector');
                const enabledStatic = isFlagEnabled('p3-tripwire-injector-static');
                const enabledKnuckle = isFlagEnabled('p3-tripwire-injector-knuckle');
                const enabled = (enabledLegacy || enabledStatic || enabledKnuckle);

                // v22: predictive TOI scheduling should be on-by-default for the knuckle path (crash-safe: still COMMIT-gated at fire time).
                // Opt-out with: flag-p3-tripwire-lookahead-disable=true
                const lookaheadDisabled = isFlagEnabled('p3-tripwire-lookahead-disable');
                const knucklePredictiveDefault = enabledKnuckle && lookaheadWindowMs > 0 && !lookaheadDisabled;

                return {
                    enabledLegacy,
                    enabledStatic,
                    enabledKnuckle,
                    enabled,
                    cooldownMs: 220,
                    lookaheadEnabled: !!(knucklePredictiveDefault || (p2Lookahead && p3Lookahead)),
                    lookaheadWindowMs,
                    lookaheadBiasMs,
                };
            };

            const cfgDeadman = () => {
                const raw = systemState?.parameters?.coasting?.deadman || {};
                const enabled = raw?.enabled !== false;
                const timeoutMs = Number(raw?.timeoutMs ?? 60_000);
                const epsilonUiNorm = Math.max(0, Number(raw?.epsilonUiNorm ?? 0));
                const rearmOnMove = raw?.rearmOnMove !== false;
                return {
                    enabled,
                    timeoutMs: Number.isFinite(timeoutMs) && timeoutMs >= 0 ? timeoutMs : 60_000,
                    epsilonUiNorm: Number.isFinite(epsilonUiNorm) ? epsilonUiNorm : 0,
                    rearmOnMove
                };
            };

            const getTrace = () => {
                try {
                    return window.hfoP2MirrorMagus?.getTrace?.() || { traceId: null, targetId: null };
                } catch (_) {
                    return { traceId: null, targetId: null };
                }
            };

            const perPointer = new Map();
            const deadman = new Map();
            const scheduled = new Map();
            let lastInject = null;
            let unsub = null;

            const venomEmit = (stage, data) => {
                try {
                    return window.hfoTracerVenomBattery?.emit?.(stage, data) || false;
                } catch (_) {
                    return false;
                }
            };

            const getCursorUiNorm = (cursor) => {
                const x = Number.isFinite(cursor?.uiNormX) ? Number(cursor.uiNormX) : Number(cursor?.normX);
                const y = Number.isFinite(cursor?.uiNormY) ? Number(cursor.uiNormY) : Number(cursor?.normY);
                return {
                    x: Number.isFinite(x) ? x : 0,
                    y: Number.isFinite(y) ? y : 0
                };
            };

            const isDeadmanTripped = (pointerId) => {
                const pid = String(Number(pointerId ?? 0));
                return !!deadman.get(pid)?.tripped;
            };

            const emitPointerCancel = (payload) => {
                try {
                    window.hfoPortsEffects?.emit?.('p3', 'pointer_cancel', payload);
                    window.hfoPortsEffects?.setState?.('p3_pointer_cancel', payload);
                } catch (_) {
                    // ignore
                }
            };

            const buildPayload = (ev) => {
                const tracerEnabled = isFlagEnabled('p3-tracer-bullet-venom');

                const sensorId = String(ev?.sensorId || 'static');
                const phase = String(ev?.sensor?.phase || 'begin');
                const rawDirection = String(ev?.direction || '');
                // Contract-facing normalization: P2 may emit direction='cross' on first edge.
                // For P3 injection we constrain direction to ('down'|'up') only.
                const direction = (rawDirection === 'up') ? 'up' : 'down';
                const reason = (direction === 'up') ? 'tripwire_up_cross' : 'tripwire_down_cross';

                const action = (sensorId === 'knuckle')
                    ? (phase === 'end' ? 'keyup' : 'keydown')
                    : 'keypress';

                venomEmit('p3.build_payload', {
                    now: Number(ev?.now ?? 0),
                    sensorId,
                    phase,
                    action,
                    pointerId: Number(ev?.pointerId ?? 0),
                    handIndex: Number(ev?.handIndex ?? 0),
                    tracerEnabled: Boolean(tracerEnabled),
                });

                if (tracerEnabled) {
                    const seq = String(ev?.seq || '');
                    const pid = Number(ev?.pointerId ?? 0);
                    const nowNum = Number(ev?.now ?? 0);
                    const traceId = `tb_tripwire_${seq}_${pid}_${nowNum}`;
                    venomEmit('p3.build_payload.tracer', {
                        traceId,
                        now: nowNum,
                        seq,
                        pointerId: pid,
                        action,
                        reason,
                    });
                    return Object.freeze({
                        kind: 'tracer_bullet_venom',
                        traceId,
                        targetId: 'p3.tripwire_injector',
                        handIndex: Number(ev?.handIndex ?? 0),
                        pointerId: pid,
                        readiness: Number(ev?.readiness ?? 0),
                        reason,
                        action,
                        key: ' ',
                        code: 'Space'
                    });
                }

                const t = getTrace();
                return Object.freeze({
                    kind: 'keyboard',
                    action,
                    key: ' ',
                    code: 'Space',
                    handIndex: Number(ev?.handIndex ?? 0),
                    pointerId: Number(ev?.pointerId ?? 0),
                    readiness: Number(ev?.readiness ?? 0),
                    reason,
                    traceId: t.traceId || undefined,
                    targetId: t.targetId || undefined
                });
            };

            const inject = (ev) => {
                const c = cfg();
                if (!c.enabled) return false;

                const sensorId = String(ev?.sensorId || 'static');
                const allowStatic = !!(c.enabledStatic || c.enabledLegacy);
                const allowKnuckle = !!c.enabledKnuckle;
                if (sensorId === 'static') {
                    if (!allowStatic) return false;
                } else if (sensorId === 'knuckle') {
                    if (!allowKnuckle) return false;
                } else {
                    // Fail-closed on unknown source.
                    return false;
                }

                // Fail-closed: if deadman tripped for this pointer, refuse injection.
                const dmc = cfgDeadman();
                if (dmc.enabled && isDeadmanTripped(ev?.pointerId)) return false;

                // Fail-closed: only inject when the tripwire event is coming from COMMIT state.
                // (Defense-in-depth in case a tripwire event slips through during COAST.)
                const evFsm = String(ev?.fsmState || '');
                if (evFsm) {
                    if (evFsm !== 'COMMIT') return false;
                } else {
                    try {
                        const pidNum = Number(ev?.pointerId ?? 0);
                        const cursors = Array.isArray(systemState?.dataFabric?.cursors) ? systemState.dataFabric.cursors : [];
                        const cur = cursors.find(c0 => Number(c0?.pointerId ?? -1) === pidNum) || null;
                        if (String(cur?.fsmState || '') !== 'COMMIT') return false;
                    } catch (_) {
                        return false;
                    }
                }

                const phase = String(ev?.sensor?.phase || 'begin');
                const isKnuckle = sensorId === 'knuckle';
                if (isKnuckle) {
                    if (phase && phase !== 'begin' && phase !== 'end') return false;
                } else {
                    if (phase && phase !== 'begin') return false;
                }

                // Direction policy is source-specific.
                if (sensorId === 'static') {
                    if (String(ev?.direction || '') !== 'down') return false;
                }

                const pid = String(Number(ev?.pointerId ?? 0));
                const nowNum = Number(ev?.now ?? 0);
                const last = perPointer.get(pid) || 0;
                // Cooldown should not block knuckle release edges (keyup) that happen shortly after a press.
                if (!(isKnuckle && phase === 'end')) {
                    if ((nowNum - last) < c.cooldownMs) return false;
                    perPointer.set(pid, nowNum);
                }

                const payload = buildPayload(ev);

                venomEmit('p3.inject.payload', {
                    now: nowNum,
                    pointerId: Number(ev?.pointerId ?? 0),
                    handIndex: Number(ev?.handIndex ?? 0),
                    sensorId,
                    phase,
                    kind: payload?.kind ?? null,
                    action: payload?.action ?? null,
                    traceId: (typeof payload?.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                    reason: payload?.reason ?? null,
                });

                let delivered = false;

                // If tracer venom is enabled, route through P3InjectorPort so the payload can be
                // fail-closed gated and mapped into a trace-tagged keyboard effect.
                if (payload?.kind === 'tracer_bullet_venom') {
                    try {
                        delivered = !!P3InjectorPort?.sendNematocystToDino?.(payload);
                    } catch (_) {
                        delivered = false;
                    }
                    venomEmit('p3.inject.sendNematocyst', {
                        ok: Boolean(delivered),
                        now: nowNum,
                        pointerId: Number(ev?.pointerId ?? 0),
                        sensorId,
                        traceId: (typeof payload?.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                        kind: payload?.kind ?? null,
                        action: payload?.action ?? null,
                    });
                } else {
                    try {
                        delivered = !!window.hfoAdapterHost?.deliverEffect?.('dino-v1', payload);
                    } catch (_) {
                        delivered = false;
                    }

                    venomEmit('p3.inject.deliverEffect', {
                        ok: Boolean(delivered),
                        now: nowNum,
                        pointerId: Number(ev?.pointerId ?? 0),
                        sensorId,
                        traceId: (typeof payload?.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                        kind: payload?.kind ?? null,
                        action: payload?.action ?? null,
                    });

                    if (!delivered) {
                        try {
                            delivered = !!P3InjectorPort?.sendNematocystToDino?.(payload);
                        } catch (_) {
                            delivered = false;
                        }

                        venomEmit('p3.inject.sendNematocyst.fallback', {
                            ok: Boolean(delivered),
                            now: nowNum,
                            pointerId: Number(ev?.pointerId ?? 0),
                            sensorId,
                            traceId: (typeof payload?.traceId === 'string' && payload.traceId.length) ? payload.traceId : null,
                            kind: payload?.kind ?? null,
                            action: payload?.action ?? null,
                        });
                    }
                }

                const normDirection = (String(ev?.direction || '') === 'up') ? 'up' : 'down';
                lastInject = Object.freeze({
                    ts: new Date().toISOString(),
                    now: nowNum,
                    pointerId: Number(ev?.pointerId ?? 0),
                    handIndex: Number(ev?.handIndex ?? 0),
                    sensorId,
                    direction: normDirection,
                    ok: delivered,
                    reason: payload.reason
                });

                try {
                    const payloadPreview = (payload?.kind === 'tracer_bullet_venom')
                        ? { kind: 'tracer_bullet_venom', mappedTo: 'keyboard', action: String(payload?.action || 'keypress'), key: ' ', code: 'Space' }
                        : { kind: payload.kind, action: payload.action, key: payload.key, code: payload.code };

                    window.hfoPortsEffects?.emit?.('p3', 'tripwire_inject', {
                        ts: lastInject.ts,
                        now: lastInject.now,
                        adapterId: 'dino-v1',
                        ok: delivered,
                        sensorId,
                        direction: lastInject.direction,
                        payload: payloadPreview,
                        reason: payload.reason
                    });
                    window.hfoPortsEffects?.setState?.('p3_tripwire_injector', lastInject);
                } catch (_) {
                    // ignore
                }

                return delivered;
            };

            const scheduleFromLookahead = (ev) => {
                const c = cfg();
                if (!c.enabled || !c.lookaheadEnabled) return false;

                // Hard gate: COMMIT intent only.
                if (String(ev?.fsmState || '') !== 'COMMIT') return false;

                const sensorId = String(ev?.sensorId || 'static');
                // Direction policy:
                // - static lookahead: requires explicit down direction
                // - knuckle tripplane lookahead: infer down from positive oriented distance velocity (toward wrist side)
                if (sensorId === 'static') {
                    if (String(ev?.direction || '') !== 'down') return false;
                } else if (sensorId === 'knuckle') {
                    const vel = Number(ev?.orientedDistanceVelUiNormPerS ?? NaN);
                    if (!Number.isFinite(vel) || vel <= 0) return false;
                } else {
                    return false;
                }

                const pid = String(Number(ev?.pointerId ?? 0));
                if (!pid || pid === 'NaN') return false;

                const nowNum = Number(ev?.now ?? 0);
                const ttcMs = Number(ev?.ttcMs ?? NaN);
                const windowMs = Number(c.lookaheadWindowMs ?? ev?.lookaheadWindowMs ?? 0);
                const biasMs = Number(c.lookaheadBiasMs ?? 0);

                if (!Number.isFinite(nowNum) || !Number.isFinite(ttcMs) || !Number.isFinite(windowMs)) return false;
                if (ttcMs < 0 || windowMs <= 0) return false;
                if (sensorId === 'static' && ttcMs <= 0) return false;

                // Inject exactly windowMs before the predicted crossing time.
                // Bias shifts scheduling to compensate for downstream latency. Negative = earlier.
                const delayMsUnbiased = Math.max(0, ttcMs - windowMs);
                const delayMs = Math.max(0, ttcMs - windowMs + biasMs);
                let injectAtNow = nowNum + delayMs;

                venomEmit('p3.lookahead.schedule', {
                    sensorId,
                    now: nowNum,
                    pointerId: Number(ev?.pointerId ?? 0),
                    handIndex: Number(ev?.handIndex ?? 0),
                    ttcMs,
                    windowMs,
                    biasMs,
                    delayMsUnbiased,
                    delayMs,
                    injectAtNow,
                });

                // For knuckle tripplane lookahead, minimal fixtures can arrive at/after the crossing sample.
                // Keep deterministic "predictive" ordering by injecting just before now.
                if (sensorId === 'knuckle' && delayMs === 0) {
                    injectAtNow = Math.max(0, nowNum - 1);

                    venomEmit('p3.lookahead.immediate', {
                        sensorId,
                        now: nowNum,
                        injectAtNow,
                        pointerId: Number(ev?.pointerId ?? 0),
                        handIndex: Number(ev?.handIndex ?? 0),
                        ttcMs,
                        windowMs,
                        biasMs,
                    });

                    const immediate = Object.freeze({
                        now: injectAtNow,
                        dt: Number(ev?.dt ?? 0),
                        pointerId: Number(ev?.pointerId ?? 0),
                        handIndex: Number(ev?.handIndex ?? 0),
                        fsmState: 'COMMIT',
                        readiness: Number(ev?.readiness ?? 0),
                        sensorId: 'knuckle',
                        direction: 'down',
                        sensor: { phase: 'begin' },
                    });

                    try {
                        inject(immediate);
                    } catch (_) {
                        // ignore
                    }

                    return true;
                }

                const existing = scheduled.get(pid) || null;
                if (existing && Number(existing.injectAtNow || 0) <= injectAtNow) {
                    // Keep the earliest scheduled injection.
                    return true;
                }

                scheduled.set(pid, {
                    injectAtNow,
                    sourceNow: nowNum,
                    ttcMs,
                    windowMs,
                    sensorId,
                    phase: 'begin',
                    handIndex: Number(ev?.handIndex ?? 0),
                    pointerId: Number(ev?.pointerId ?? 0),
                });

                venomEmit('p3.lookahead.scheduled', {
                    sensorId,
                    now: nowNum,
                    injectAtNow,
                    pointerId: Number(ev?.pointerId ?? 0),
                    handIndex: Number(ev?.handIndex ?? 0),
                    ttcMs,
                    windowMs,
                });
                return true;
            };

            const tick = ({ now, dt, dataFabric }) => {
                const c = cfg();
                if (!c.enabled) return false;

                const dmc = cfgDeadman();
                if (!dmc.enabled) return false;

                const nowMs = Number(now ?? dataFabric?.systemTime ?? 0);
                if (!Number.isFinite(nowMs)) return false;

                const cursors = Array.isArray(dataFabric?.cursors) ? dataFabric.cursors : [];
                for (const cursor of cursors) {
                    if (String(cursor?.fsmState || '') !== 'COMMIT') continue;

                    const pid = String(Number(cursor?.pointerId ?? 0));
                    const { x, y } = getCursorUiNorm(cursor);
                    const prev = deadman.get(pid) || { lastX: x, lastY: y, lastMoveNow: nowMs, tripped: false };
                    const dx = x - prev.lastX;
                    const dy = y - prev.lastY;
                    const dist = Math.hypot(dx, dy);

                    if (dist > dmc.epsilonUiNorm) {
                        deadman.set(pid, {
                            lastX: x,
                            lastY: y,
                            lastMoveNow: nowMs,
                            tripped: dmc.rearmOnMove ? false : prev.tripped
                        });
                        continue;
                    }

                    // Still: if stillness exceeds timeout, trip once and emit cancel.
                    const stillFor = nowMs - Number(prev.lastMoveNow ?? nowMs);
                    if (!prev.tripped && stillFor >= dmc.timeoutMs) {
                        const cancel = Object.freeze({
                            pointerId: Number(cursor?.pointerId ?? 0),
                            handIndex: Number(cursor?.handIndex ?? 0),
                            fsmState: 'COMMIT',
                            reason: 'deadman_stillness',
                            stillForMs: Number(stillFor),
                            timeoutMs: Number(dmc.timeoutMs),
                            epsilonUiNorm: Number(dmc.epsilonUiNorm)
                        });
                        emitPointerCancel(cancel);
                        deadman.set(pid, { ...prev, tripped: true });
                        continue;
                    }

                    deadman.set(pid, prev);
                }

                // Lookahead scheduler: when enabled, fire scheduled injections once their time arrives.
                if (c.lookaheadEnabled && scheduled.size) {
                    for (const [pid, s] of Array.from(scheduled.entries())) {
                        const injectAtNow = Number(s?.injectAtNow ?? NaN);
                        if (!Number.isFinite(injectAtNow)) {
                            scheduled.delete(pid);
                            continue;
                        }

                        if (nowMs < injectAtNow) continue;

                        venomEmit('p3.lookahead.fire', {
                            now: nowMs,
                            injectAtNow,
                            driftMs: nowMs - injectAtNow,
                            pointerId: Number(s?.pointerId ?? 0),
                            handIndex: Number(s?.handIndex ?? 0),
                            sensorId: String(s?.sensorId || 'static'),
                        });

                        // Must still be in COMMIT at fire time (fail-closed).
                        const pidNum = Number(s?.pointerId ?? 0);
                        const cur = cursors.find(c0 => Number(c0?.pointerId ?? -1) === pidNum) || null;
                        if (String(cur?.fsmState || '') !== 'COMMIT') {
                            scheduled.delete(pid);
                            continue;
                        }

                        // Construct a synthetic begin event for injection.
                        const sensorId = String(s?.sensorId || 'static');
                        const phase = String(s?.phase || 'begin');
                        const ev = Object.freeze({
                            now: injectAtNow,
                            dt: Number(dt ?? 0),
                            pointerId: pidNum,
                            handIndex: Number(s?.handIndex ?? cur?.handIndex ?? 0),
                            fsmState: 'COMMIT',
                            readiness: Number(cur?.readinessScore ?? 0),
                            sensorId,
                            direction: 'down',
                            sensor: { phase },
                        });

                        try {
                            inject(ev);
                        } finally {
                            scheduled.delete(pid);
                        }
                    }
                }

                return true;
            };

            const resetDeadman = (pointerId) => {
                if (pointerId === undefined || pointerId === null) {
                    deadman.clear();
                    return true;
                }
                const pid = String(Number(pointerId ?? 0));
                deadman.delete(pid);
                return true;
            };

            const start = () => {
                if (unsub) return true;
                if (!cfg().enabled) return false;
                try {
                    unsub = window.hfoPortsEffects?.subscribe?.((entry) => {
                        if (entry?.port !== 'p2') return;
                        if (entry?.type === 'tripwire_cross') {
                            const p = entry?.payload || null;

                            try {
                                venomEmit('p3.rx.tripwire_cross', {
                                    now: Number(p?.now ?? 0),
                                    pointerId: Number(p?.pointerId ?? 0),
                                    handIndex: Number(p?.handIndex ?? 0),
                                    sensorId: String(p?.sensorId || ''),
                                    phase: String(p?.sensor?.phase || ''),
                                    direction: String(p?.direction || ''),
                                    fsmState: String(p?.fsmState || ''),
                                });
                            } catch (_) {
                                // ignore
                            }
                            // v22: deterministic predictive ordering for knuckle begin edges.
                            // If lookahead is enabled, inject with a slightly earlier `now` so tests can assert kdNow < crossNow.
                            try {
                                const isKnuckleBegin = String(p?.sensorId || '') === 'knuckle' && String(p?.sensor?.phase || '') === 'begin';
                                if (isKnuckleBegin && cfg().lookaheadEnabled && String(p?.fsmState || '') === 'COMMIT') {
                                    const crossNow = Number(p?.now ?? 0);
                                    const earlyNow = Math.max(0, crossNow - 1);
                                    inject(Object.freeze({ ...p, now: earlyNow }));
                                } else {
                                    inject(p);
                                }
                            } catch (_) {
                                inject(p);
                            }
                            return;
                        }
                        if (entry?.type === 'tripwire_lookahead') {
                            const p = entry?.payload || null;
                            // Lookahead is only defined for static screen tripwires.
                            const sid = String(p?.sensorId || 'static');
                            try {
                                venomEmit('p3.rx.tripwire_lookahead', {
                                    now: Number(p?.now ?? 0),
                                    pointerId: Number(p?.pointerId ?? 0),
                                    handIndex: Number(p?.handIndex ?? 0),
                                    sensorId: sid,
                                    ttcMs: Number(p?.ttcMs ?? NaN),
                                });
                            } catch (_) {
                                // ignore
                            }
                            if (sid === 'static') scheduleFromLookahead(p);
                            return;
                        }
                        if (entry?.type === 'tripplane_lookahead') {
                            const p = entry?.payload || null;
                            // v22: knuckle tripplane lookahead drives early keydown scheduling.
                            const sid = String(p?.sensorId || '');
                            try {
                                venomEmit('p3.rx.tripplane_lookahead', {
                                    now: Number(p?.now ?? 0),
                                    pointerId: Number(p?.pointerId ?? 0),
                                    handIndex: Number(p?.handIndex ?? 0),
                                    sensorId: sid,
                                    ttcMs: Number(p?.ttcMs ?? NaN),
                                    orientedDistanceVelUiNormPerS: Number(p?.orientedDistanceVelUiNormPerS ?? NaN),
                                });
                            } catch (_) {
                                // ignore
                            }
                            if (sid === 'knuckle') scheduleFromLookahead(p);
                            return;
                        }
                    }, 'p2');
                    return !!unsub;
                } catch (_) {
                    unsub = null;
                    return false;
                }
            };

            const stop = () => {
                if (typeof unsub === 'function') {
                    try { unsub(); } catch { }
                }
                unsub = null;
                return true;
            };

            try { start(); } catch (_) { }

            return Object.freeze({
                start,
                stop,
                tick,
                resetDeadman,
                getLastInject: () => lastInject,
                getDeadmanState: (pointerId) => {
                    if (pointerId === undefined || pointerId === null) {
                        return Object.freeze({ pointers: Array.from(deadman.entries()) });
                    }
                    const pid = String(Number(pointerId ?? 0));
                    return deadman.get(pid) || null;
                }
            });
        })();

        window.hfoPorts = window.hfoPorts || Object.freeze({
            p0: Object.freeze({
                sense: Object.freeze({
                    readForVideo: (nowMs) => window.hfoRegistry.resolve(window.hfoTokens.P0_SENSE).readForVideo(nowMs)
                }),
                camera: Object.freeze({
                    getStream: (opts) => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).getStream(opts),
                    getUserMediaCallCount: () => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).getUserMediaCallCount(),
                    reset: (stopTracks) => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).reset(stopTracks)
                })
            }),
            p1: Object.freeze({
                weave: (results, dt, nowMs) => {
                    // Fail-closed contract guard: do not mutate state when inputs are not finite.
                    if (!Number.isFinite(Number(nowMs))) {
                        try {
                            window.hfoPortsEffects?.emit?.('p1', 'contract_breach', {
                                ts: new Date().toISOString(),
                                now: Number(nowMs),
                                dt: Number(dt),
                                reason: 'non_finite_nowMs'
                            });
                        } catch (_) {
                            // ignore
                        }
                        return { cursors: [], dataFabric: null, envelope: null };
                    }

                    const out = window.hfoRegistry.resolve(window.hfoTokens.P1_FUSE).fuseToDataFabric(results, dt, nowMs);
                    if (out?.dataFabric) {
                        systemState.dataFabric = out.dataFabric;
                        systemState.p1.cursors = systemState.dataFabric.cursors;
                        systemState.dataFabricEnvelope = out?.envelope || null;
                        if (window.hfoTelemetry) window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
                    }

                    if (!out?.dataFabric) {
                        try {
                            window.hfoPortsEffects?.emit?.('p1', 'contract_breach', {
                                ts: new Date().toISOString(),
                                now: Number(nowMs),
                                dt: Number(dt),
                                reason: 'p1_fuse_failed'
                            });
                        } catch (_) {
                            // ignore
                        }
                    }
                    return out;
                }
            }),
            p2: Object.freeze({
                physics: Object.freeze({
                    getAdapters: () => window.hfoRegistry.resolve(window.hfoTokens.P2_PHYSICS).getAdapters(),
                    getTelemetry: () => window.hfoRegistry.resolve(window.hfoTokens.P2_PHYSICS).getTelemetry()
                }),
                render: Object.freeze({
                    listJuiceLayers: () => window.hfoRegistry.resolve(window.hfoTokens.P2_RENDER).listJuiceLayers()
                })
            }),
            p3: Object.freeze({
                deliver: () => window.hfoRegistry.resolve(window.hfoTokens.P3_INJECTOR).injectFrame(),
                sendNematocystToDino: (payload) => window.hfoRegistry.resolve(window.hfoTokens.P3_INJECTOR).sendNematocystToDino(payload)
            }),
            p4: Object.freeze({
                disrupt: Object.freeze({
                    isEnabled: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).isEnabled(),
                    noOp: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).noOp(),
                    probeAdapters: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).probeAdapters()
                })
            }),
            p5: Object.freeze({
                eval: () => window.hfoRegistry.resolve(window.hfoTokens.EVAL_HFO)
            }),
            p6: Object.freeze({
                store: () => window.hfoRegistry.resolve(window.hfoTokens.P6_STORE)
            }),
            p7: Object.freeze({
                navigate: Object.freeze({
                    getMissionVision: () => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).getMissionVision(),
                    getParameters: () => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).getParameters(),
                    patchParameters: (patch) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).patchParameters(patch),
                    setActiveAdapterTool: (tool) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setActiveAdapterTool(tool),
                    setExcalidrawTool: (tool) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setExcalidrawTool(tool),
                    setVisualEngine: (engine) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setVisualEngine(engine),
                    setIntent: (intent) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setIntent(intent)
                }),
                adapters: Object.freeze({
                    list: () => window.hfoRegistry.resolve(window.hfoTokens.P7_ADAPTER_HOST).list(),
                    getActiveId: () => window.hfoRegistry.resolve(window.hfoTokens.P7_ADAPTER_HOST).getActiveId(),
                    setActiveId: (id) => window.hfoRegistry.resolve(window.hfoTokens.P7_ADAPTER_HOST).setActiveId(id),
                    register: (adapter) => window.hfoRegistry.resolve(window.hfoTokens.P7_ADAPTER_HOST).register(adapter),
                    deliverEffect: (adapterId, effect) => window.hfoRegistry.resolve(window.hfoTokens.P7_ADAPTER_HOST).deliverEffect(adapterId, effect)
                }),
                apps: Object.freeze({
                    register: (manifest) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).register(manifest),
                    registerIframeAdapter: (opts) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).registerIframeAdapter(opts),
                    list: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).list(),
                    activate: (appId) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).activate(appId),
                    deactivate: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).deactivate(),
                    getActiveId: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveId(),
                    getActive: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive(),
                    getActiveTargetRootElement: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveTargetRootElement(),
                    applyActiveOverlayTuning: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).applyActiveOverlayTuning()
                }),
                effects: Object.freeze({
                    emit: (port, type, payload) => window.hfoPortsEffects?.emit?.(port, type, payload),
                    getRecent: (limit) => window.hfoPortsEffects?.getRecent?.(limit) || [],
                    getSnapshot: (limit) => window.hfoPortsEffects?.getSnapshot?.(limit) || { recent: [], lastByPort: {}, state: {} },
                    clear: () => window.hfoPortsEffects?.clear?.(),
                })
            })
        });

        window.hfoDefend = window.hfoDefend || Object.freeze({
            assertRequired: (tokens) => {
                tokens.forEach((t) => window.hfoRegistry.resolve(t));
                return true;
            }
        });

        // Optional strict checks: enable with `?flag-p5-defend-strict=true`
        if (isFlagEnabled('p5-defend-strict')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P6_STORE
            ]);
        }

        // v11 strict hex mode: enable with `?flag-p5-defend-strict-v11=true`
        // Fail-closed intent: require all 8 ports and their core adapters to exist.
        if (isFlagEnabled('p5-defend-strict-v11')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P0_SENSE,
                window.hfoTokens.P0_CAMERA,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P2_PHYSICS,
                window.hfoTokens.P2_RENDER,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P4_DISRUPT,
                window.hfoTokens.P6_STORE,
                window.hfoTokens.P7_NAVIGATE
            ]);

            if (!window.hfoPorts?.p0?.sense?.readForVideo) throw new Error('P0 facade missing');
            if (!window.hfoPorts?.p0?.camera?.getStream) throw new Error('P0.camera facade missing');
            if (!window.hfoPorts?.p1?.weave) throw new Error('P1 facade missing');
            if (!window.hfoPorts?.p2?.physics?.getTelemetry) throw new Error('P2.physics facade missing');
            if (!window.hfoPorts?.p2?.render?.listJuiceLayers) throw new Error('P2.render facade missing');
            if (!window.hfoPorts?.p3?.deliver) throw new Error('P3 facade missing');
            if (!window.hfoPorts?.p4?.disrupt?.noOp) throw new Error('P4 facade missing');
            if (!window.hfoPorts?.p5?.eval) throw new Error('P5 facade missing');
            if (!window.hfoPorts?.p6?.store) throw new Error('P6 facade missing');
            if (!window.hfoPorts?.p7?.navigate?.getMissionVision) throw new Error('P7 facade missing');
        }

        // v11.1 strict mode: enable with `?flag-p5-defend-strict-v11_1=true`
        // Adds fail-closed enforcement for multi-app surfaces.
        if (isFlagEnabled('p5-defend-strict-v11_1')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P0_SENSE,
                window.hfoTokens.P0_CAMERA,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P2_PHYSICS,
                window.hfoTokens.P2_RENDER,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P3_TARGET_ROUTER,
                window.hfoTokens.P4_DISRUPT,
                window.hfoTokens.P6_STORE,
                window.hfoTokens.P7_NAVIGATE,
                window.hfoTokens.P7_APPHOST,
                window.hfoTokens.UI_LAYOUT
            ]);

            if (!window.hfoPorts?.p7?.apps?.activate) throw new Error('P7.apps facade missing');
            if (!window.hfoPorts?.p7?.apps?.getActiveTargetRootElement) throw new Error('P7.apps routing surface missing');
        }
    </script>
</body>

</html>
