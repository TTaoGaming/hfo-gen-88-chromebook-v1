<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO Omega V43: Hive Tree & Interaction Hardening</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Cinzel:wght@400;700&display=swap"
        rel="stylesheet">
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #000;
            color: #ff0000;
            font-family: 'Orbitron', sans-serif;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 10px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
            background-color: #0d0d0d;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='49' viewBox='0 0 28 49'%3E%3Cg fill-rule='evenodd'%3E%3Cg id='hexagons' fill='%23ff0000' fill-opacity='0.03' fill-rule='nonzero'%3E%3Cpath d='M13.99 9.25l13 7.5v15l-13 7.5L1 31.75v-15l12.99-7.5zM3 17.91v12.68l10.99 6.34 11-6.35V17.9l-11-6.34L3 17.91zM0 15l12.98-7.5V0h-2v6.35L0 12.69v2.3zm0 18.5L12.98 41v8h-2v-6.85L0 35.81v-2.3zM15 0v7.5L27.99 15H28v-2.31h-.01L17 6.35V0h-2zm0 49v-8l12.99-7.5H28v2.31h-.01L17 42.15V49h-2z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            color: #d1d1d1;
            border: 1px solid #1a0000;
            position: relative;
        }

        h2,
        h3 {
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .video-feed {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 2px;
            background: #000;
            filter: grayscale(1) contrast(1.2) brightness(0.6) sepia(100%) hue-rotate(-50deg);
            opacity: 0.5;
            transition: opacity 0.5s ease;
        }

        .video-feed:hover {
            opacity: 0.8;
        }

        .video-feed.mirrored {
            transform: scaleX(-1);
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .overlay-canvas.mirrored {
            transform: scaleX(-1);
        }

        .data-card {
            background: #120000;
            padding: 12px;
            border-radius: 4px;
            border-left: 4px solid #ff0000;
            border-right: 1px solid #330000;
            border-bottom: 1px solid #330000;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .data-card h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #ff0000;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            color: #ff4d4d;
        }

        #gesture-visualizer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .state-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 2px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 5px;
            border: 1px solid transparent;
        }

        .tag-idle {
            background: #1a1a1a;
            color: #555;
            border-color: #333;
        }

        .tag-arming {
            background: #4a0000;
            color: #ff4d4d;
            border-color: #7b0000;
        }

        .tag-armed {
            background: #7b0000;
            color: #fff;
            box-shadow: 0 0 5px #ff0000;
        }

        .tag-committing {
            background: #ff0000;
            color: #000;
        }

        .tag-committed {
            background: #ff0000;
            color: #000;
            box-shadow: 0 0 15px #ff0000;
        }

        .tag-releasing {
            background: #000;
            color: #ff0000;
            border-color: #ff0000;
        }

        .ghost-cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 1px solid #ff0000;
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            transition: transform 0.05s linear;
            display: none;
            background: rgba(255, 0, 0, 0.1);
        }

        .ghost-cursor.active {
            display: block;
        }

        .ghost-cursor.port-7-pointer-committed {
            background: rgba(255, 0, 0, 0.8);
            transform: scale(1.2);
            box-shadow: 0 0 30px #ff0000;
        }

        .ghost-cursor.port-0-pointer-ready {
            border-color: #ff4d4d;
            background: rgba(255, 77, 77, 0.2);
        }

        .ghost-cursor.idle {
            border-color: #330000;
            background: transparent;
        }

        .local-cursor {
            position: fixed;
            width: 8px;
            height: 8px;
            background: #ff0000;
            border-radius: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            pointer-events: none;
            z-index: 10000;
            display: none;
        }

        .local-cursor.port-7-pointer-committed {
            background: #ff0000;
            transform: scale(2.0);
            box-shadow: 0 0 10px #ff0000;
        }

        .local-cursor.port-0-pointer-ready {
            background: #7b0000;
        }

        .local-cursor.idle {
            background: #1a0000;
        }

        .camera-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .camera-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .camera-btn {
            padding: 10px 20px;
            font-size: 14px;
            font-family: 'Courier New', Courier, monospace;
            background: rgba(255, 0, 0, 0.1);
            color: #ff0000;
            border: 1px solid #7b0000;
            border-radius: 2px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }

        .camera-btn:hover {
            background: rgba(255, 0, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

        .camera-btn.danger {
            color: #ff4444;
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
        }

        .camera-btn.danger:hover {
            background: rgba(255, 68, 68, 0.4);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }

        .camera-btn.active {
            background: #00ff88;
            color: #000;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "https://cdn.jsdelivr.net/npm/matter-js@0.19.0/+esm",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸŒ‰ PORT 1: BRIDGE (Contracts)
        // Essence: Contract Enforcement & Logical Harmonization
        // Role: [B]ridging high-frequency streams against Zod 6.0 contracts.
        const Port1CursorBridgeSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
        const Port1HandBridgeSchema = z.object({
            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
            cursors: z.record(Port1CursorBridgeSchema),
            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() }),
            curls: z.object({ index: z.number(), middle: z.number(), ring: z.number(), pinky: z.number() }).optional(),
            palm: z.object({ normal: z.object({ x: z.number(), y: z.number(), z: z.number() }), facingCamera: z.boolean() }).optional()
        });
        const Port1CloudEventBridgeSchema = z.object({
            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(Port1HandBridgeSchema)
        });

        // ðŸ¤– V42: Hierarchical Anti-Midas FSM (Dwell + Palm Cone + Gesture)
        class GestureFSM {
            constructor() {
                this.state = 'IDLE';
                this.pointerEvent = 'none';
                this.dwellMs = 800;
                this.dwellAccumulator = 0;
                this.lastTimestamp = 0;
            }

            process(gesture, timestamp, score = 1.0, isPalmFacing = false, currentCurls = null) {
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
                this.lastTimestamp = timestamp;
                this.pointerEvent = 'none';
                const isConfident = score > 0.5;

                // ï¿½ Leaky Bucket for Palm Cone Dwell (Charge on Palm Facing)
                if (isPalmFacing) {
                    this.dwellAccumulator = Math.min(this.dwellAccumulator + dt, 1500);
                } else {
                    this.dwellAccumulator = Math.max(this.dwellAccumulator - dt * 2, 0);
                }

                // ðŸŒŒ HFO Hierarchical Cosmology 
                switch (this.state) {
                    case 'IDLE':
                        // 1. IDLE -> PORT_0_POINTER_READY: Face Palm towards camera + Leaky Bucket 
                        if (this.dwellAccumulator >= this.dwellMs) {
                            // ðŸ”­ State: PORT_0_POINTER_READY | Port: P0 (Observe)
                            // Perspective baseline for all gestures.
                            this.state = 'PORT_0_POINTER_READY';
                        }
                        break;

                    case 'PORT_0_POINTER_READY':
                        this.pointerEvent = 'pointermove';
                        // Baseline: Any gesture detected here is 'READY' presence except the commit trigger

                        // Exit on dwell exhaustion
                        if (this.dwellAccumulator <= 0) {
                            this.state = 'IDLE';
                        }

                        // 2. PORT_0_POINTER_READY -> PORT_7_POINTER_COMMITTED: Specific Pointing Trigger
                        if (currentGesture === 'POINTING_UP' && isConfident) {
                            // ðŸ§­ State: PORT_7_POINTER_COMMITTED | Port: P7 (Navigate)
                            // Transition: P0 -> P7 (HIVE/8 Initial Pairing)
                            this.state = 'PORT_7_POINTER_COMMITTED';
                            this.pointerEvent = 'pointerdown';
                        }
                        break;

                    case 'PORT_7_POINTER_COMMITTED':
                        this.pointerEvent = 'pointermove';

                        // Sticky Logic: Drag is maintained through NONE/LOST/Low-Confidence noise
                        const isPointing = (currentGesture === 'POINTING_UP' && isConfident);
                        const isNoneOrLost = (currentGesture === 'NONE' || currentGesture === 'LOST' || !isConfident);

                        if (!isPointing && !isNoneOrLost) {
                            // Detection of ANY other high-confidence gesture releases to READY
                            this.state = isPalmFacing ? 'PORT_0_POINTER_READY' : 'IDLE';
                            this.pointerEvent = 'pointerup';
                        }

                        // Exit on dwell exhaustion (the hard release gate)
                        if (this.dwellAccumulator <= 0) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointercancel';
                        }
                        break;
                }

                return { state: this.state, pointerEvent: this.pointerEvent };
            }
        }

        // ï¿½ Finger Logic Helpers
        const calculateCurl = (landmarks, indices) => {
            let totalAngle = 0;
            for (let i = 0; i < indices.length - 2; i++) {
                const a = landmarks[indices[i]];
                const b = landmarks[indices[i + 1]];
                const c = landmarks[indices[i + 2]];
                const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
            }
            return Math.min(1.0, totalAngle / Math.PI);
        };

        const getBoneRatios = (lm) => {
            const dist = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2 + (p1.z - p2.z) ** 2);
            return {
                index: dist(lm[5], lm[6]) / (dist(lm[6], lm[7]) || 1),
                middle: dist(lm[9], lm[10]) / (dist(lm[10], lm[11]) || 1)
            };
        };

        const getCurls = (lm) => ({
            index: calculateCurl(lm, [5, 6, 7, 8]),
            middle: calculateCurl(lm, [9, 10, 11, 12]),
            ring: calculateCurl(lm, [13, 14, 15, 16]),
            pinky: calculateCurl(lm, [17, 18, 19, 20])
        });

        // ï¿½ðŸ§  Multi-Resolution Filters (Smooth/Snappy Presets)
        class LowPassFilter { constructor(alpha) { this.alpha = alpha; this.s = null; } call(v) { if (this.s === null) this.s = v; else this.s = this.alpha * v + (1 - this.alpha) * this.s; return this.s; } }
        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
                this.xFilter = new LowPassFilter(this.alpha(minCutoff)); this.dxFilter = new LowPassFilter(this.alpha(dCutoff)); this.lastTime = null;
            }
            alpha(c) { const te = 1 / (this.freq || 60); const tau = 1 / (2 * Math.PI * (c || 1.0)); return 1 / (1 + tau / te); }
            call(x, t = null) {
                if (this.lastTime !== null && t !== null) {
                    const dt = (t - this.lastTime) / 1000;
                    if (dt > 0.001) this.freq = 1 / dt;
                }
                this.lastTime = t;
                const prevX = this.xFilter.s;
                const dx = prevX === null ? 0 : (x - prevX) * (this.freq || 60);
                const edx = this.dxFilter.call(dx);
                const c = this.minCutoff + this.beta * Math.abs(edx);
                this.xFilter.alpha = this.alpha(c);
                const result = this.xFilter.call(x);
                return isNaN(result) ? (x || 0) : result;
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: true,
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6, dwellMs: 1000 },
            physics: {
                stiffness: 0.2, stiffnessArmed: 0.6, damping: 0.1, lookAhead: 1.5,
                springSource: 'snappy', predSource: 'snappy',
                p3Source: 'spring', p3Mirror: true,
                p0Mirror: true,
                showGlobalCursor: false,
                remoteMode: true,
                purePointerMode: false,
                remoteTargetId: 'excalidraw-iframe',
                persistence: { snapDistance: 0.15, coastFrames: 60, repulsionDistance: 0.12, teleportLimit: 0.3 }
            },
            hands: {}, bridge: { lastEvent: null, errorCount: 0, status: 'IDLE', lastValidate: 0 }
        };

        // ðŸ›°ï¸ V37 System Singleton Guard
        const hfoSystem = window.hfoSystem = {
            initialized: false,
            initializing: false,
            video: null,
            canvas: null,
            ctx: null,
            recognizer: null,
            stream: null,
            loopActive: false,
            lastFrame: 0,
            heroReady: false
        };

        let telemetrySeq = 0;
        /**
         * ðŸ”­ PORT 0: OBSERVE (Sense)
         * Essence: Intelligence, Surveillance, Reconnaissance
         * Role: [O]bserving high-fidelity MediaPipe sensing and gesture extraction.
         */
        const port0Observe = (video, recognizer, now) => {
            if (!video || !recognizer || video.readyState < 2) return null;
            return recognizer.recognizeForVideo(video, now);
        };

        /**
         * ðŸŒ‰ PORT 1: BRIDGE (Fuse)
         * Essence: Contractual Integrity
         * Role: [B]ridging hand telemetry stream to Zod 6.0 contracts.
         */
        const port1Bridge = (hands) => {
            const now = performance.now();
            const shouldValidate = (now - hfoState.bridge.lastValidate) > 500;
            try {
                const telemetryData = {};
                for (const id in hands) {
                    const h = hands[id];
                    if (!h.active) continue;
                    telemetryData[id] = {
                        id: h.id, active: h.active, lastSeen: h.lastSeen, fsm: h.fsm.state,
                        cursors: {
                            raw: h.cursors.raw,
                            smooth: h.cursors.smooth,
                            snappy: h.cursors.snappy,
                            spring: h.cursors.spring,
                            pred: h.cursors.predictive
                        },
                        gestures: h.gestures, palm: h.palm, curls: h.curls
                    };
                }
                const event = {
                    specversion: "1.0", type: "hfo.omega.v43.hand_update", source: "hfo.port.0.sense",
                    id: `telemetry-${telemetrySeq++}`, time: new Date().toISOString(), data: telemetryData
                };
                if (shouldValidate) {
                    Port1CloudEventBridgeSchema.parse(event);
                    hfoState.bridge.lastValidate = now;
                }
                hfoState.bridge.lastEvent = event; hfoState.bridge.status = 'VALID';
            } catch (e) {
                if (hfoState.debug) console.error("Port 1 BRIDGE Breach:", e);
                hfoState.bridge.status = 'ERROR'; hfoState.bridge.errorCount++;
            }
        };

        /**
         * ðŸ“ PORT 2: SHAPE (Tree Manifold)
         * Essence: Digital Twin Transformation
         * Role: [Node 1] Raw -> [Node 2/3] Smooth/Snappy -> [Node 4] Spring -> [Node 5] Predictive
         */
        const port2Shape = (hand, now, lm) => {
            if (lm) {
                // ðŸŽ¯ Handedness-Agnostic Orientation
                const v1 = { x: lm[5].x - lm[0].x, y: lm[5].y - lm[0].y, z: lm[5].z - lm[0].z };
                const v2 = { x: lm[17].x - lm[0].x, y: lm[17].y - lm[0].y, z: lm[17].z - lm[0].z };

                const cross = {
                    x: (v1.y * v2.z - v1.z * v2.y) || 0,
                    y: (v1.z * v2.x - v1.x * v2.z) || 0,
                    z: (v1.x * v2.y - v1.y * v2.x) || 1
                };
                const mag = Math.sqrt(cross.x ** 2 + cross.y ** 2 + cross.z ** 2) || 1;
                const normal = { x: cross.x / mag, y: cross.y / mag, z: cross.z / mag };

                const isFacing = Math.abs(normal.z) > 0.5;
                hand.palm = { normal, facingCamera: isFacing };

                // ðŸ§¬ Internal Sharding: The Tree Starts Here
                // Node 1: Raw
                hand.cursors.raw.x = lm[8].x; hand.cursors.raw.y = lm[8].y;
                hand.lastSeen = now; hand.coastCount = 0; hand.active = true;

                // Node 2 & 3: Filtered Children of Raw
                hand.cursors.smooth.x = hand.filters.sx.call(hand.cursors.raw.x, now);
                hand.cursors.smooth.y = hand.filters.sy.call(hand.cursors.raw.y, now);
                hand.cursors.snappy.x = hand.filters.nx.call(hand.cursors.raw.x, now);
                hand.cursors.snappy.y = hand.filters.ny.call(hand.cursors.raw.y, now);
            }

            // ðŸš€ Physics Digital Twin (Matter.js Chain)
            if (engine && hand.active && hfoSystem.canvas) {
                const canvas = hfoSystem.canvas;
                const isEngaged = hand.fsm.state === 'PORT_0_POINTER_READY' || hand.fsm.state === 'PORT_7_POINTER_COMMITTED';
                hand.cursors.spring.constraint.stiffness = isEngaged ? hfoState.physics.stiffnessArmed : hfoState.physics.stiffness;

                // Node 4: Spring is driven by Snappy (Node 3)
                const anchorSource = hand.cursors.snappy;
                Matter.Body.setPosition(hand.cursors.spring.anchor, { x: anchorSource.x * canvas.width, y: anchorSource.y * canvas.height });

                // Node 5: Predictive is driven by Spring (Node 4) + Velocity projection
                const rawVel = hand.cursors.spring.body.velocity;
                const vel = {
                    x: hand.filters.vx.call(rawVel.x, now),
                    y: hand.filters.vy.call(rawVel.y, now)
                };
                
                const lead = { 
                    x: vel.x * hfoState.physics.lookAhead * 8, // Slightly reduced multiplier
                    y: vel.y * hfoState.physics.lookAhead * 8 
                };

                Matter.Body.setPosition(hand.cursors.predictive.body, {
                    x: (hand.cursors.spring.body.position.x) + lead.x,
                    y: (hand.cursors.spring.body.position.y) + lead.y
                });

                const SafeW = canvas.width || 1280;
                const SafeH = canvas.height || 720;
                hand.cursors.spring.x = hand.cursors.spring.body.position.x / SafeW;
                hand.cursors.spring.y = hand.cursors.spring.body.position.y / SafeH;
                hand.cursors.predictive.x = hand.cursors.predictive.body.position.x / SafeW;
                hand.cursors.predictive.y = hand.cursors.predictive.body.position.y / SafeH;
            }
            return hand.palm?.facingCamera || false;
        };

        // ðŸ—¡ï¸ PORT 3: INJECT (Deliver)
        // Essence: W3C Pointer Injection & Event Synthesis
        // Role: [I]njecting official W3C pointer events into the DOM.
        const port3Inject = window.port3Inject = window.p3InjectPointer = window.p3Inject = (hand) => {
            try {
                if (!hand.active) {
                    if (hand.ghost) hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    if (hand.capturedTarget && hand.capturedTarget.releasePointerCapture) {
                        try { hand.capturedTarget.releasePointerCapture(Number(hand.id) + 10); } catch (e) { }
                        hand.capturedTarget = null;
                    }
                    return;
                }

                if (!hand.ghost) {
                    hand.ghost = document.createElement('div');
                    hand.ghost.className = 'ghost-cursor';
                    document.body.appendChild(hand.ghost);
                }

                const types = { 'pointerdown': 'pointerdown', 'pointermove': 'pointermove', 'pointerup': 'pointerup', 'pointercancel': 'pointercancel' };
                const type = types[hand.fsm.pointerEvent];
                const activeType = type || (hand.fsm.state !== 'IDLE' ? 'pointermove' : null);

                if (!activeType || !hand.active) {
                    hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    return;
                }

                const cursor = hand.cursors[hfoState.physics.p3Source] || hand.cursors.predictive;
                let normX = cursor.x;
                if (hfoState.physics.p3Mirror) normX = 1 - normX;

                let x = normX * window.innerWidth;
                let y = cursor.y * window.innerHeight;

                // ðŸŽ¯ V40 EXEMPLAR: Robust Target Capture
                const pointerId = Number(hand.id) + 10;
                let target;

                if (hand.capturedTarget) {
                    target = hand.capturedTarget;
                } else {
                    target = document.elementFromPoint(x, y) || document.body;
                }

                // âš¡ Hardened Click Logic: If we are on a DOWN transition, ensure we trigger a real click
                if (activeType === 'pointerdown' && target && !hand.capturedTarget) {
                    // Inject hovering/focusing sequence for sensitive UIs (Excalidraw)
                    const overEvent = new PointerEvent('pointerover', { bubbles: true, cancelable: true, pointerId, x, y, clientX: x, clientY: y });
                    const enterEvent = new PointerEvent('pointerenter', { bubbles: true, cancelable: true, pointerId, x, y, clientX: x, clientY: y });
                    target.dispatchEvent(overEvent);
                    target.dispatchEvent(enterEvent);
                    
                    // Specific fix for Excalidraw buttons: If button is detected, call .click() directly on next tick
                    if (target.tagName === 'BUTTON' || target.closest('button')) {
                        const btn = target.tagName === 'BUTTON' ? target : target.closest('button');
                        requestAnimationFrame(() => {
                           if (btn) btn.click();
                        });
                    }
                }

                let finalX = x;
                let finalY = y;

                // ðŸŽ¯ V30: Robust Coordinate Mapping & Drill
                if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
                    const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
                    if (remoteEl) {
                        const rect = remoteEl.getBoundingClientRect();
                        finalX = normX * rect.width;
                        finalY = cursor.y * rect.height;

                        if (!hand.capturedTarget) target = remoteEl;

                        if (remoteEl.tagName === 'IFRAME') {
                            try {
                                const innerTarget = remoteEl.contentDocument.elementFromPoint(finalX, finalY);
                                if (innerTarget && !hand.capturedTarget) target = innerTarget;
                            } catch (e) {
                                finalX = rect.left + finalX;
                                finalY = rect.top + finalY;
                            }
                        } else {
                            finalX = rect.left + finalX;
                            finalY = rect.top + finalY;
                        }

                        if (!hand.localCursor) {
                            hand.localCursor = document.createElement('div');
                            hand.localCursor.className = 'local-cursor';
                            document.body.appendChild(hand.localCursor);
                        }
                        hand.localCursor.style.display = 'block';
                        hand.localCursor.style.left = `${rect.left + (normX * rect.width) - 5}px`;
                        hand.localCursor.style.top = `${rect.top + (cursor.y * rect.height) - 5}px`;
                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
                    }
                } else {
                    if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                        const rect = target.getBoundingClientRect();
                        finalX = x - rect.left;
                        finalY = y - rect.top;
                        if (target.tagName === 'IFRAME' && !hand.capturedTarget) {
                            try {
                                const inner = target.contentDocument.elementFromPoint(finalX, finalY);
                                if (inner) target = inner;
                                else { finalX = x; finalY = y; }
                            } catch (e) { finalX = x; finalY = y; }
                        }
                    } else { finalX = x; finalY = y; }

                    if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                        if (!hand.localCursor) {
                            hand.localCursor = document.createElement('div');
                            hand.localCursor.className = 'local-cursor';
                            document.body.appendChild(hand.localCursor);
                        }
                        hand.localCursor.style.display = 'block';
                        hand.localCursor.style.left = `${x - 5}px`;
                        hand.localCursor.style.top = `${y - 5}px`;
                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
                    } else if (hand.localCursor) hand.localCursor.style.display = 'none';
                }

                if (hfoState.physics.showGlobalCursor) {
                    hand.ghost.classList.add('active');
                    hand.ghost.style.left = `${x - 10}px`;
                    hand.ghost.style.top = `${y - 10}px`;
                    hand.ghost.className = `ghost-cursor active ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
                } else hand.ghost.classList.remove('active');

                // ðŸ§¬ BRIDGE INTERCEPTION: Sequence Hardening
                if (activeType === 'pointerdown') {
                    hand.lastTargetOnDown = target;
                    // Hover sequence
                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId, clientX: finalX, clientY: finalY }));
                    target.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, clientX: finalX, clientY: finalY }));

                    if (hfoState.physics.remoteTargetId === 'excalidraw-iframe') {
                        const btn = target.closest('button, .ToolIcon, label[title]');
                        if (btn) {
                            const label = (btn.getAttribute('aria-label') || btn.title || "").toLowerCase();
                            const tools = ['selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'freedraw', 'text', 'eraser'];
                            const match = tools.find(t => label.includes(t));
                            if (match) document.getElementById('excalidraw-iframe').contentWindow.postMessage({ type: 'SET_TOOL', data: { tool: match } }, '*');
                        }
                    }
                }

                // ðŸŽ¯ CAPTURE LOGIC
                if (activeType === 'pointerdown' && target.setPointerCapture) {
                    try {
                        target.setPointerCapture(pointerId);
                        hand.capturedTarget = target;
                    } catch (e) { console.warn("Pointer capture failed", e); }
                }

                if (hand.lastTarget && hand.lastTarget !== target && !hand.capturedTarget) {
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerout', { bubbles: true, pointerId: pointerId, clientX: x, clientY: y }));
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerleave', { bubbles: false, pointerId: pointerId, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId: pointerId, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerenter', { bubbles: false, pointerId: pointerId, clientX: x, clientY: y }));
                }

                const movementX = hand.lastX !== undefined ? x - hand.lastX : 0;
                const movementY = hand.lastY !== undefined ? y - hand.lastY : 0;
                hand.lastX = x; hand.lastY = y; hand.lastTarget = target;

                const isDown = (hand.fsm.state === 'PORT_7_POINTER_COMMITTED');
                
                // ðŸ§¬ Dynamic Primary Pointer: The lowest numeric ID that is active is primary
                const activeIds = Object.keys(hfoState.hands).filter(id => hfoState.hands[id].active).sort((a,b) => a-b);
                const isPrimary = activeIds.length > 0 && Number(hand.id) == Number(activeIds[0]);

                const ev = new PointerEvent(activeType, {
                    bubbles: true, cancelable: true, 
                    pointerType: 'touch', // ðŸ’  Set to touch for better gesture/multi-point harmony
                    view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                    pointerId: pointerId, clientX: finalX, clientY: finalY,
                    movementX: movementX, movementY: movementY,
                    width: 20, height: 20, // Simulate finger contact patch
                    pressure: isDown ? 0.9 : 0.0, 
                    buttons: isDown ? 1 : 0,
                    button: (activeType === 'pointerdown' || activeType === 'pointerup') ? 0 : -1,
                    isPrimary: isPrimary
                });
                target.dispatchEvent(ev);

                // ï¿½ï¸ Legacy Polyfill (Option C Standard): 
                // Only dispatch MouseEvents for Hand 0 (Primary) to maintain compatibility with 
                // legacy UI frameworks (Excalidraw buttons, etc.) without polluting 2-hand concurrency.
                // ðŸ›¡ï¸ V43 Hardening: Manual click dispatch
                if (!hfoState.physics.purePointerMode && isPrimary && (activeType === 'pointerdown' || activeType === 'pointerup')) {
                    const mouseType = activeType === 'pointerdown' ? 'mousedown' : 'mouseup';
                    target.dispatchEvent(new MouseEvent(mouseType, { bubbles: true, clientX: finalX, clientY: finalY, button: 0, buttons: isDown ? 1 : 0 }));
                    if (activeType === 'pointerup' && target === hand.lastTargetOnDown) {
                        target.dispatchEvent(new MouseEvent('click', { bubbles: true, clientX: finalX, clientY: finalY, button: 0 }));
                        const btn = target.tagName === 'BUTTON' ? target : target.closest('button');
                        if (btn) btn.click();
                    }
                }

                // ï¿½ðŸŽ¯ RELEASE LOGIC
                if ((activeType === 'pointerup' || activeType === 'pointercancel') && hand.capturedTarget) {
                    try { hand.capturedTarget.releasePointerCapture(pointerId); } catch (e) { }
                    hand.capturedTarget = null;
                }

            } catch (err) {
                if (hfoState.debug) console.error("W3C Injection Error:", err);
            }
        };

        /**
         * ðŸŒªï¸ PORT 4: DISRUPT (Supression)
         * Role: [D]isrupting noise and handle feedback suppression.
         */
        const port4Disrupt = (hand) => { /* Internal suppression logic */ };

        /**
         * ðŸ›¡ï¸ PORT 5: INTEGRITY (HardGate)
         * Essence: Defensive Shields
         * Role: [I]ntegrity gates to prevent FSM regression and invalid transitions.
         * V42.1: Sensor-Aware Coasting Audit.
         */
        const port5Integrity = (hand, nextState, confidence = 1.0) => {
            const prevState = hand.fsm.state;
            const isLowConfidence = confidence < 0.3;

            // ðŸ§¬ Kinetic Coasting Trigger
            if (isLowConfidence && hand.active) {
                if (hfoState.debug) console.warn(`ðŸ›¡ï¸ P5: Low confidence (${confidence.toFixed(2)}). Engaging Kinetic Coast.`);
                return 'COAST';
            }

            const validTransitions = {
                'IDLE': ['IDLE', 'PORT_0_POINTER_READY'],
                'PORT_0_POINTER_READY': ['IDLE', 'PORT_0_POINTER_READY', 'PORT_7_POINTER_COMMITTED'],
                'PORT_7_POINTER_COMMITTED': ['IDLE', 'PORT_0_POINTER_READY', 'PORT_7_POINTER_COMMITTED']
            };

            const allowed = validTransitions[prevState]?.includes(nextState) || false;
            if (!allowed && hfoState.debug) {
                console.warn(`ðŸ›¡ï¸ P5 HardGate BREACH: ${prevState} -> ${nextState} blocked.`);
            }
            return allowed ? 'ALLOW' : 'BLOCK';
        };

        /**
         * ðŸ“¦ PORT 6: ASSIMILATE (Store)
         * Essence: State Persistence & Assimilation
         * Role: [A]ssimilating gesture telemetry into the FSM store.
         */
        const port6Assimilate = (hand, gestureName, score, now, isFacing, confidence = 1.0) => {
            // Peek at next state logic (simplified mirror of FSM)
            let nextState = hand.fsm.state;
            const dt = hand.fsm.lastTimestamp ? (now - hand.fsm.lastTimestamp) : 0;
            const acc = isFacing ? Math.min(hand.fsm.dwellAccumulator + dt, 1500) : Math.max(hand.fsm.dwellAccumulator - dt * 2, 0);

            if (hand.fsm.state === 'IDLE' && acc >= hand.fsm.dwellMs) nextState = 'PORT_0_POINTER_READY';
            else if (hand.fsm.state === 'PORT_0_POINTER_READY') {
                if (acc <= 0) nextState = 'IDLE';
                else if (gestureName === 'POINTING_UP' && score > 0.5) nextState = 'PORT_7_POINTER_COMMITTED';
            } else if (hand.fsm.state === 'PORT_7_POINTER_COMMITTED') {
                if (acc <= 0) nextState = 'IDLE';
                else if (gestureName !== 'POINTING_UP' && gestureName !== 'NONE' && gestureName !== 'LOST' && score > 0.5) nextState = isFacing ? 'PORT_0_POINTER_READY' : 'IDLE';
            }

            // P5 HardGate Validation with Coasting Support
            const auditResult = port5Integrity(hand, nextState, confidence);

            if (auditResult === 'ALLOW') {
                return hand.fsm.process(gestureName, now, score, isFacing);
            } else if (auditResult === 'COAST') {
                // Engage Coast: Maintain FSM state but block event changes until confidence returns
                hand.fsm.lastTimestamp = now;
                hand.isCoasting = true;
                return { state: hand.fsm.state, pointerEvent: 'none' };
            } else {
                // Shield regression by maintaining previous state but updating time
                hand.fsm.lastTimestamp = now;
                return { state: hand.fsm.state, pointerEvent: 'none' };
            }
        };

        /**
         * ðŸ•¸ï¸ PORT 7: NAVIGATE (Plan)
         * Role: [N]avigating orchestration and BMC2 intent.
         */
        const port7Navigate = (intent) => { /* Strategic planning */ };

        const createCursorSet = (handId, hue) => {
            const h = {
                id: handId, lastSeen: 0, active: false, coastCount: 0, fsm: new GestureFSM(),
                cursors: {
                    raw: { x: 0.5, y: 0.5, color: `hsl(${hue}, 10%, 40%)`, label: `Node1 Raw` },
                    smooth: { x: 0.5, y: 0.5, color: `hsl(${hue}, 40%, 40%)`, label: `Node2 Smooth` },
                    snappy: { x: 0.5, y: 0.5, color: `hsl(${hue}, 70%, 40%)`, label: `Node3 Snappy` },
                    spring: { x: 0.5, y: 0.5, body: null, anchor: null, constraint: null, color: `hsl(${hue}, 90%, 50%)`, label: `Node4 Spring` },
                    predictive: { x: 0.5, y: 0.5, body: null, color: `hsl(${hue}, 100%, 50%)`, label: `Node5 Pred` }
                },
                filters: {
                    sx: new OneEuroFilter(30, 0.5, 0.001), sy: new OneEuroFilter(30, 0.5, 0.001),
                    nx: new OneEuroFilter(30, 2.0, 0.1), ny: new OneEuroFilter(30, 2.0, 0.1),
                    vx: new OneEuroFilter(30, 0.5, 0.01), vy: new OneEuroFilter(30, 0.5, 0.01) // Velocity Filters for Pred
                },
                gestures: { active: 'None', score: 0, isDown: false, pointerEvent: 'none' },
                lastTarget: null,
                lastTargetOnDown: null
            };
            if (engine) {
                const { Bodies, Composite, Constraint } = Matter;
                h.cursors.spring.anchor = Bodies.circle(0.5, 0.5, 1, { isStatic: true, isSensor: true });
                h.cursors.spring.body = Bodies.circle(0.5, 0.5, 10, { frictionAir: 0.1, label: `H${handId}-SpringB` });
                h.cursors.spring.constraint = Constraint.create({ bodyA: h.cursors.spring.anchor, bodyB: h.cursors.spring.body, stiffness: hfoState.physics.stiffness, damping: hfoState.physics.damping, length: 0 });
                h.cursors.predictive.body = Bodies.circle(0.5, 0.5, 10, { isStatic: true, label: `H${handId}-PredB` });
                Composite.add(engine.world, [h.cursors.spring.anchor, h.cursors.spring.body, h.cursors.spring.constraint, h.cursors.predictive.body]);
            }
            return h;
        };

        let engine, runner, gestureRecognizer;
        const initPhysics = window.initPhysics = () => {
            if (hfoSystem.initialized) return;
            engine = Matter.Engine.create(); engine.gravity.scale = 0;
            runner = Matter.Runner.create(); Matter.Runner.run(runner, engine);
            hfoState.hands[0] = createCursorSet(0, 0); hfoState.hands[1] = createCursorSet(1, 350);
            hfoSystem.initialized = true;
        };

        const initMediaPipe = async (container) => {
            // Ensure container is ready for absolute children and styled correctly
            container.style.position = 'relative';
            container.style.backgroundColor = '#000';
            container.classList.add('camera-container');

            // UI Controls
            if (!container.querySelector('.camera-controls')) {
                const controls = document.createElement('div');
                controls.className = 'camera-controls';

                const btnStart = document.createElement('button');
                btnStart.className = 'camera-btn start';
                btnStart.innerText = 'Start Video';

                const btnStop = document.createElement('button');
                btnStop.className = 'camera-btn stop';
                btnStop.innerText = 'Stop';
                btnStop.style.display = 'none';

                const btnFlip = document.createElement('button');
                btnFlip.className = 'camera-btn flip';
                btnFlip.innerText = 'Flip';

                controls.appendChild(btnStart);
                controls.appendChild(btnStop);
                controls.appendChild(btnFlip);
                container.appendChild(controls);

                const updateButtons = (active) => {
                    btnStart.style.display = active ? 'none' : 'block';
                    btnStop.style.display = active ? 'block' : 'none';
                };

                btnStart.onclick = async () => {
                    try {
                        hfoSystem.stream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 1280, height: 720, facingMode: "user" }
                        });
                        hfoSystem.video.srcObject = hfoSystem.stream;
                        hfoSystem.video.onloadedmetadata = () => {
                            hfoSystem.video.play();
                            hfoSystem.canvas.width = hfoSystem.video.videoWidth;
                            hfoSystem.canvas.height = hfoSystem.video.videoHeight;
                            hfoSystem.loopActive = true;
                            updateButtons(true);
                            if (!hfoSystem.initialized) initPhysics();
                        };
                    } catch (e) {
                        console.error("Camera access failed:", e);
                        alert("Camera access failed. Check permissions.");
                    }
                };

                btnStop.onclick = () => {
                    if (hfoSystem.stream) {
                        hfoSystem.stream.getTracks().forEach(t => t.stop());
                        hfoSystem.stream = null;
                        hfoSystem.video.srcObject = null;
                    }
                    hfoSystem.loopActive = false;
                    updateButtons(false);
                    if (hfoSystem.ctx) hfoSystem.ctx.clearRect(0, 0, hfoSystem.canvas.width, hfoSystem.canvas.height);
                };

                btnFlip.onclick = () => {
                    hfoState.physics.p0Mirror = !hfoState.physics.p0Mirror;
                    if (hfoState.physics.p0Mirror) {
                        hfoSystem.video.classList.add('mirrored');
                        hfoSystem.canvas.classList.add('mirrored');
                    } else {
                        hfoSystem.video.classList.remove('mirrored');
                        hfoSystem.canvas.classList.remove('mirrored');
                    }
                };
            }

            if (hfoSystem.initializing) {
                // Wait and re-mount if already initializing (don't return empty container)
                setTimeout(() => initMediaPipe(container), 200);
                return;
            }

            hfoSystem.initializing = true;
            try {
                if (!hfoSystem.video) {
                    hfoSystem.video = document.createElement('video');
                    hfoSystem.video.autoplay = true;
                    hfoSystem.video.playsinline = true;
                    hfoSystem.video.className = 'video-feed mirrored';
                }
                if (!hfoSystem.canvas) {
                    hfoSystem.canvas = document.createElement('canvas');
                    hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
                    hfoSystem.canvas.className = 'overlay-canvas mirrored';
                }

                // Force mount to current container (singleton moves)
                // Dedup check: only append if not already child
                if (hfoSystem.video.parentElement !== container) {
                    container.appendChild(hfoSystem.video);
                }
                if (hfoSystem.canvas.parentElement !== container) {
                    container.appendChild(hfoSystem.canvas);
                }

                if (hfoSystem.recognizer) {
                    hfoSystem.initializing = false;
                    return;
                }

                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                    runningMode: "VIDEO", ...hfoState.mpOptions
                });
                hfoSystem.recognizer = gestureRecognizer;

                const render = () => {
                    const loop = () => {
                        const now = hfoSystem.lastFrame = performance.now();
                        if (hfoState.active && hfoSystem.loopActive) {
                            try {
                                const res = port0Observe(hfoSystem.video, hfoSystem.recognizer, now);
                                if (res) {
                                    const ctx = hfoSystem.ctx;
                                    const canvas = hfoSystem.canvas;
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    const dw = new DrawingUtils(ctx);

                                    const landmarks = res.landmarks || [];
                                    const landmarkCurls = landmarks.map(lm => getCurls(lm));
                                    const landmarkRatios = landmarks.map(lm => getBoneRatios(lm));

                                    const handIds = Object.keys(hfoState.hands);
                                    const assignedLandmarks = new Set();
                                    const currentAssignments = {};

                                    // PASS 1: Sticky Tracking (Kinetic Snaplock)
                                    handIds.filter(id => hfoState.hands[id].active).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minCost = hfoState.physics.persistence.teleportLimit;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.spring.x) ** 2 + (lm[8].y - h.cursors.spring.y) ** 2);
                                            if (d < minCost) { minCost = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // PASS 2: Discovery
                                    handIds.filter(id => !currentAssignments.hasOwnProperty(id)).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minD = hfoState.physics.persistence.snapDistance;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                            if (d < minD) { minD = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // APPLY
                                    handIds.forEach(id => {
                                        const h = hfoState.hands[id];
                                        if (currentAssignments.hasOwnProperty(id)) {
                                            const lIdx = currentAssignments[id];
                                            const lm = landmarks[lIdx];

                                            h.curls = landmarkCurls[lIdx];
                                            h.ratios = landmarkRatios[lIdx];
                                            const isFacing = port2Shape(h, now, lm);
                                            h.isCoasting = false;

                                            if (res.gestures?.[lIdx]) {
                                                const g = res.gestures[lIdx][0];
                                                const fsmRes = port6Assimilate(h, g.categoryName, g.score, now, isFacing, g.score);
                                                h.gestures = { active: g.categoryName, score: g.score, isDown: (h.fsm.state === 'PORT_7_POINTER_COMMITTED'), pointerEvent: fsmRes.pointerEvent };
                                            }
                                        } else {
                                            h.palm = { normal: { x: 0, y: 0, z: 0 }, facingCamera: false };
                                            h.coastCount++;
                                            const fsmRes = port6Assimilate(h, 'LOST', 0, now, false, 0);
                                            h.gestures.isDown = (h.fsm.state === 'PORT_7_POINTER_COMMITTED');
                                            h.gestures.pointerEvent = fsmRes.pointerEvent;
                                            if (h.coastCount > hfoState.physics.persistence.coastFrames) h.active = false;
                                            port2Shape(h, now, null);
                                        }

                                        if (h.active) {
                                            if (hfoState.debug && currentAssignments.hasOwnProperty(id)) {
                                                dw.drawConnectors(landmarks[currentAssignments[id]], HandLandmarker.HAND_CONNECTIONS, { color: "#cc0000", lineWidth: 5 });
                                            }

                                            [h.cursors.raw, h.cursors.smooth, h.cursors.snappy, h.cursors.spring, h.cursors.predictive].forEach(c => {
                                                const isHero = c.label.includes('Pred');
                                                if (!hfoState.debug && !isHero) return;

                                                const size = isHero ? 16 : 4;
                                                ctx.beginPath();
                                                if (isHero) {
                                                    // ðŸ’  Hexagonal Hero Cursor
                                                    for (let i = 0; i < 6; i++) {
                                                        const angle = (i * Math.PI) / 3;
                                                        const hx = c.x * canvas.width + size * Math.cos(angle);
                                                        const hy = c.y * canvas.height + size * Math.sin(angle);
                                                        if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
                                                    }
                                                    ctx.closePath();
                                                } else {
                                                    ctx.arc(c.x * canvas.width, c.y * canvas.height, size, 0, 2 * Math.PI);
                                                }

                                                ctx.fillStyle = c.color;
                                                ctx.globalAlpha = isHero ? 1.0 : 0.3;
                                                ctx.fill();

                                                if (isHero) {
                                                    ctx.strokeStyle = (h.fsm.state === 'PORT_7_POINTER_COMMITTED') ? '#ff0000' : (h.fsm.state === 'PORT_0_POINTER_READY' ? '#7b0000' : 'transparent');
                                                    ctx.lineWidth = 2;
                                                    ctx.stroke();
                                                    // ðŸŽ‡ Glow
                                                    if (h.fsm.state === 'PORT_7_POINTER_COMMITTED') {
                                                        ctx.shadowBlur = 15;
                                                        ctx.shadowColor = '#ff0000';
                                                    }
                                                }

                                                ctx.shadowBlur = 0;
                                                ctx.globalAlpha = 1.0;
                                                if (hfoState.debug) {
                                                    ctx.fillStyle = '#fff'; ctx.font = '8px Courier';
                                                    ctx.fillText(c.label.split(' ')[1], c.x * canvas.width + size + 5, c.y * canvas.height + 3);
                                                }
                                            });

                                            // ðŸ§¬ Identity HUD
                                            if (hfoState.debug) {
                                                const tx = h.cursors.raw.x * canvas.width + 15;
                                                const ty = h.cursors.raw.y * canvas.height + 25;
                                                ctx.fillStyle = '#ff4d4d';
                                                ctx.font = '10px Courier';
                                                const curlStr = `I:${h.curls.index.toFixed(2)} M:${h.curls.middle.toFixed(2)} R:${h.curls.ring.toFixed(2)} P:${h.curls.pinky.toFixed(2)}`;
                                                ctx.fillText(curlStr, tx, ty);
                                                ctx.fillText(`Facing: ${h.palm.facingCamera}`, tx, ty + 12);
                                            }
                                            port3Inject(h);
                                        }
                                    });
                                } else {
                                    // ðŸš€ Synthetic Support
                                    Object.values(hfoState.hands).filter(h => h.active).forEach(h => {
                                        port2Shape(h, now, null);
                                        port3Inject(h);
                                    });
                                }
                                port1Bridge(hfoState.hands);
                            } catch (loopErr) {
                                console.error("Loop Error Cycle:", loopErr);
                            }
                        }
                        requestAnimationFrame(loop);
                    };
                    loop();
                };

                render();
            } catch (err) {
                console.error("Critical MediaPipe Failure:", err);
            } finally {
                hfoSystem.initializing = false;
            }
        };

        const initPhysicsPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-section'; s.id = `section-h${id}`;
                            s.innerHTML = `<h2 style="font-size: 11px; color: #ff0000; margin: 10px 0 5px 0;">HAND ID: ${id}</h2>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                                    <div class="data-card" style="border-left-color: #666; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Raw</h3><code class="val-raw" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #990000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Smooth</h3><code class="val-smooth" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #cc0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Snappy</h3><code class="val-snappy" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Spring</h3><code class="val-spring" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff4d4d; padding: 4px; border-radius: 4px; grid-column: span 2;"><h3 style="font-size:9px;">Pred</h3><code class="val-pred" style="font-size:9px;">...</code></div>
                                </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#section-h${id}`);
                        if (s) {
                            s.querySelector('.val-raw').innerText = `X:${h.cursors.raw.x.toFixed(3)}`;
                            s.querySelector('.val-smooth').innerText = `X:${h.cursors.smooth.x.toFixed(3)}`;
                            s.querySelector('.val-snappy').innerText = `X:${h.cursors.snappy.x.toFixed(3)}`;
                            s.querySelector('.val-spring').innerText = `X:${h.cursors.spring.x.toFixed(3)}`;
                            s.querySelector('.val-pred').innerText = `X:${h.cursors.pred.x.toFixed(3)}, Y:${h.cursors.pred.y.toFixed(3)}`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initGesturesPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-gesture-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-gesture-section'; s.id = `gesture-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #cc00ff; padding: 10px; margin-bottom:10px;">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <h3 style="margin:0; font-size:12px;">HAND ${id}</h3>
                                    <span class="val-tag state-tag tag-idle">IDLE</span>
                                </div>
                                <h1 class="val-gesture" style="font-size: 24px; margin: 10px 0;">NONE</h1>
                                <div style="display:flex; gap: 5px; align-items:center;">
                                    <div class="val-event" style="background:#000; padding: 2px 5px; border-radius:3px; color:#00ff88; font-size:10px; font-family:monospace;">none</div>
                                    <div class="val-score" style="color: #666; font-size: 10px;">Conf: 0%</div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#gesture-section-h${id}`);
                        if (s) {
                            const tag = s.querySelector('.val-tag');
                            tag.innerText = h.fsm;
                            tag.className = `val-tag state-tag tag-${h.fsm.toLowerCase().split('_')[0]}`;
                            s.querySelector('.val-gesture').innerText = h.gestures.active;
                            s.querySelector('.val-event').innerText = h.gestures.pointerEvent;
                            s.querySelector('.val-score').innerText = `Conf: ${(h.gestures.score * 100).toFixed(1)}%`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initPalmConePanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting for Palm Data...</div>';
                else {
                    if (div.querySelectorAll('.hand-palm-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-palm-section'; s.id = `palm-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #ffaa00; padding: 10px; margin-bottom:10px;">
                                <h3 style="margin:0; font-size:12px;">PALM ${id}</h3>
                                <div style="display:flex; align-items:center; gap: 20px; margin-top:10px;">
                                    <div class="palm-visual" style="width:60px; height:60px; background:#000; border:2px solid #555; position:relative; border-radius:50%; overflow:hidden;">
                                        <div class="palm-dot" style="width:10px; height:10px; background:#ffaa00; position:absolute; top:50%; left:50%; border-radius:50%; transform:translate(-50%, -50%);"></div>
                                    </div>
                                    <div>
                                        <div class="val-facing" style="font-size:14px; font-weight:bold; color:#ffaa00;">FACING: NO</div>
                                        <code class="val-norm" style="font-size:10px; color:#888;">Z: 0.00</code>
                                    </div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#palm-section-h${id}`);
                        if (s && h.palm) {
                            const visual = s.querySelector('.palm-visual');
                            const dot = s.querySelector('.palm-dot');
                            const facing = s.querySelector('.val-facing');
                            const norm = s.querySelector('.val-norm');

                            facing.innerText = `FACING: ${h.palm.facingCamera ? 'YES' : 'NO'}`;
                            facing.style.color = h.palm.facingCamera ? '#00ff88' : '#ff4444';
                            norm.innerText = `X:${h.palm.normal.x.toFixed(2)} Y:${h.palm.normal.y.toFixed(2)} Z:${h.palm.normal.z.toFixed(2)}`;

                            // Visual hint: move dot based on X/Y normal
                            dot.style.left = `${50 + h.palm.normal.x * 40}%`;
                            dot.style.top = `${50 + h.palm.normal.y * 40}%`;
                            visual.style.borderColor = h.palm.facingCamera ? '#00ff88' : '#555';
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initInteractionTest = (container) => {
            const div = document.createElement('div'); div.className = 'component-container';
            div.innerHTML = `
                <div class="data-card" style="border-left-color: #ff0055;">
                    <h3>P3 Injection Target</h3>
                    <button id="test-btn" style="width:100%; height:80px; background:#333; color:#fff; border:2px solid #ff0055; border-radius:8px; font-size:18px; cursor:pointer;">CLICK ME</button>
                    <div id="click-status" style="margin-top:10px; font-family:monospace; font-size:12px; color:#aaa;">Last Action: None</div>
                </div>
                <div class="data-card" style="border-left-color: #00ff88;">
                    <h3>Slider Test</h3>
                    <input type="range" id="test-slider" style="width:100%;">
                </div>
            `;
            container.appendChild(div);
            const btn = div.querySelector('#test-btn');
            const status = div.querySelector('#click-status');
            btn.addEventListener('pointerdown', () => {
                btn.style.background = '#ff0055';
                status.innerText = 'Last Action: pointerdown';
            });
            btn.addEventListener('pointerup', () => {
                btn.style.background = '#333';
                status.innerText = 'Last Action: pointerup';
            });
            btn.addEventListener('click', () => {
                status.innerText = 'Last Action: click! ðŸš€';
                setTimeout(() => { if (status.innerText.includes('click')) status.innerText = 'Last Action: waiting...'; }, 2000);
            });
        };

        const initExcalidraw = (container) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-gate';
            wrapper.style.width = '100%';
            wrapper.style.height = '100%';
            wrapper.style.position = 'relative';
            wrapper.style.background = '#0d0d0d'; // Matched to Red/Black Theme

            const iframe = document.createElement('iframe');
            iframe.src = './excalidraw_v31_wrapper.html';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.id = 'excalidraw-iframe';
            wrapper.appendChild(iframe);

            container.appendChild(wrapper);
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });
            const phys = gui.addFolder('V25 Dynamics');
            phys.add(hfoState.physics, 'springSource', ['snappy', 'smooth', 'raw']).name('Anchor');
            phys.add(hfoState.physics, 'stiffness', 0, 1).name('Stiffness');
            phys.add(hfoState.physics, 'stiffnessArmed', 0, 1).name('Armed Stiffness');
            phys.add(hfoState.physics, 'lookAhead', 0, 10).name('Pred Time');
            phys.open();

            const p3 = gui.addFolder('P3 Injection');
            p3.add(hfoState.physics, 'p3Source', ['raw', 'smooth', 'snappy', 'spring', 'predictive']).name('Inject Source');
            p3.add(hfoState.physics, 'p3Mirror').name('Mirror X Coordinates');
            p3.open();

            const mp = gui.addFolder('MediaPipe');
            mp.add(hfoState, 'debug').name('Show Connections');
            mp.add(hfoState.physics, 'showGlobalCursor').name('Global Cursor');
            mp.open();
            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    {
                        type: 'component',
                        componentType: 'Excalidraw',
                        title: 'OMEGA: EXCALIDRAW',
                        width: 70
                    },
                    {
                        type: 'column',
                        width: 30,
                        content: [
                            {
                                type: 'stack',
                                height: 50,
                                content: [
                                    { type: 'component', componentType: 'PalmCone', title: 'P0: ORIENTATION' },
                                    { type: 'component', componentType: 'Gestures', title: 'P3: FSM' },
                                    { type: 'component', componentType: 'Physics', title: 'P2: SHAPE' },
                                    { type: 'component', componentType: 'Settings', title: 'P7: NAVIGATE' },
                                    { type: 'component', componentType: 'Interaction', title: 'P3: TEST' }
                                ]
                            },
                            {
                                type: 'component',
                                componentType: 'MediaPipe',
                                title: 'P0: SENSE',
                                height: 50
                            }
                        ]
                    }
                ]
            }
        };
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.registerComponentFactoryFunction('Physics', c => initPhysicsPanel(c.element));
        layout.registerComponentFactoryFunction('Gestures', c => initGesturesPanel(c.element));
        layout.registerComponentFactoryFunction('PalmCone', c => initPalmConePanel(c.element));
        layout.registerComponentFactoryFunction('Interaction', c => initInteractionTest(c.element));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.loadLayout(config); window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>