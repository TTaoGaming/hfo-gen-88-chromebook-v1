<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO Omega V39: Symbiotic Canalization</title>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: sans-serif;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 10px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
            background: #1a1a1a;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            border-radius: 8px;
            background: #000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            pointer-events: none;
        }

        .data-card {
            background: #222;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #00ccff;
            margin-bottom: 15px;
        }

        .data-card h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #888;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            color: #00ff88;
        }

        #gesture-visualizer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .state-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 5px;
        }

        .tag-idle {
            background: #444;
            color: #aaa;
        }

        .tag-arming {
            background: #ffaa00;
            color: #000;
        }

        .tag-armed {
            background: #0088ff;
            color: #fff;
        }

        .tag-committing {
            background: #ffcc00;
            color: #000;
        }

        .tag-committed {
            background: #00ff88;
            color: #000;
        }

        .tag-releasing {
            background: #ff00ff;
            color: #fff;
        }

        .ghost-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s linear, background 0.1s;
            display: none;
        }

        .ghost-cursor.active {
            display: block;
        }

        .ghost-cursor.committed {
            background: rgba(0, 255, 136, 0.6);
            border-color: #00ff88;
            transform: scale(0.8);
        }

        .ghost-cursor.armed {
            border-color: #0088ff;
            background: rgba(0, 136, 255, 0.3);
        }

        .local-cursor {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff0055;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 5px rgba(255, 0, 85, 0.8);
        }

        .local-cursor.committed {
            background: #00ff88;
            transform: scale(1.5);
            box-shadow: 0 0 10px rgba(0, 255, 136, 1);
        }

        .local-cursor.armed {
            background: #0088ff;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "https://cdn.jsdelivr.net/npm/matter-js@0.19.0/+esm",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸ›¡ï¸ Contracts
        const CursorSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
        const HandSchema = z.object({
            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
            cursors: z.record(CursorSchema),
            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() }),
            curls: z.object({ index: z.number(), middle: z.number(), ring: z.number(), pinky: z.number() }).optional(),
            palm: z.object({ normal: z.object({ x: z.number(), y: z.number(), z: z.number() }), facingCamera: z.boolean() }).optional()
        });
        const CloudEventSchema = z.object({
            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(HandSchema)
        });

        // ðŸ¤– V38: Palm-Oriented "Predict then Confirm" FSM
        class GestureFSM {
            constructor() {
                this.state = 'IDLE';
                this.progress = 0;
                this.departureStartTime = 0;
                this.coastStartTime = 0;
                this.dwellStartTime = 0;
                this.pointerEvent = 'none';
                this.ARMING_THRESHOLD = 300;
                this.RECOVERY_TIMEOUT = 1000;
                this.RELEASE_TIMEOUT = 500;   // Increased for stability
                this.CANCEL_DWELL = 800; // V38.1.1 Stickier palm identity
                this.COMMIT_TIMEOUT = 1500; // More forgiving prediction
                this.lastTimestamp = 0;
            }

            process(gesture, timestamp, score = 1.0, isPalmFacing = false) {
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const dt = this.lastTimestamp ? timestamp - this.lastTimestamp : 0;
                this.lastTimestamp = timestamp;
                this.pointerEvent = 'none';
                const isConfident = score > 0.5;

                // ðŸ›¡ï¸ Global Departure Logic: Stickier Palm Recovery
                if (!isPalmFacing && this.state !== 'IDLE') {
                    if (!this.departureStartTime) this.departureStartTime = timestamp;
                    if (timestamp - this.departureStartTime > this.CANCEL_DWELL) {
                        const oldState = this.state;
                        this.state = 'IDLE';
                        this.pointerEvent = (oldState === 'COMMITTED' || oldState === 'RELEASING') ? 'pointercancel' : 'none';
                        this.departureStartTime = 0;
                        return { state: this.state, pointerEvent: this.pointerEvent };
                    }
                    // ðŸ”’ LOCK: No internal transitions while departure in progress
                    return { state: this.state, pointerEvent: this.pointerEvent };
                } else if (isPalmFacing) {
                    this.departureStartTime = 0;
                }

                switch (this.state) {
                    case 'IDLE':
                        if (isPalmFacing) {
                            this.state = 'ARMING';
                            this.progress = 0;
                        }
                        break;

                    case 'ARMING':
                        this.progress += dt;
                        if (this.progress >= this.ARMING_THRESHOLD) {
                            this.state = 'ARMED';
                            this.progress = 0;
                        } else if (!isConfident && currentGesture !== 'NONE') {
                            this.state = 'IDLE';
                        }
                        break;

                    case 'ARMED':
                        this.pointerEvent = 'pointermove';
                        // ðŸŽ¯ V38.1.1: Responsive Threshold Tuning
                        if (currentGesture === 'POINTING_UP' && score > 0.8 && isPalmFacing) {
                            this.state = 'COMMITTING'; // Transition through state for consistency
                            this.coastStartTime = timestamp;
                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'COMMITTING';
                            this.coastStartTime = timestamp;
                        } else if ((currentGesture === 'NONE' || currentGesture === 'LOST') && isPalmFacing) {
                            this.state = 'COMMITTING';
                            this.coastStartTime = timestamp;
                        }
                        break;

                    case 'COMMITTING':
                        this.pointerEvent = 'pointermove';
                        // ðŸš€ Faster Commitment
                        if (currentGesture === 'POINTING_UP' && (score > 0.7 || timestamp - this.coastStartTime > 150)) {
                            this.state = 'COMMITTED';
                            this.pointerEvent = 'pointerdown';
                        } else if (currentGesture !== 'NONE' && currentGesture !== 'LOST' && currentGesture !== 'POINTING_UP' && isConfident) {
                            this.state = 'ARMED'; // Returned to regular tracking
                        } else if (timestamp - this.coastStartTime > this.COMMIT_TIMEOUT) {
                            this.state = 'ARMED'; // Prediction timed out, no click
                        }
                        break;

                    case 'COMMITTED':
                        this.pointerEvent = 'pointermove';
                        if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.coastStartTime = 0;
                        } else if (currentGesture === 'NONE' || currentGesture === 'LOST') {
                            this.state = 'RELEASING';
                            this.coastStartTime = timestamp;
                        } else {
                            if (!this.coastStartTime) this.coastStartTime = timestamp;
                            if (timestamp - this.coastStartTime > this.RECOVERY_TIMEOUT) {
                                this.state = 'RELEASING';
                                this.coastStartTime = timestamp;
                            }
                        }
                        break;

                    case 'RELEASING':
                        this.pointerEvent = 'pointermove';
                        if (currentGesture === 'OPEN_PALM' && isConfident) {
                            this.state = 'ARMED';
                            this.pointerEvent = 'pointerup';
                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'COMMITTED';
                        } else if (timestamp - this.coastStartTime > this.RELEASE_TIMEOUT) {
                            // If stuck in RELEASING/NONE for too long, finalize release
                            this.state = 'ARMED';
                            this.pointerEvent = 'pointerup';
                        }
                        break;
                }
                return { state: this.state, pointerEvent: this.pointerEvent };
            }
        }

        // ðŸ§  Multi-Resolution Filters (Smooth/Snappy Presets)
        class LowPassFilter { constructor(alpha) { this.alpha = alpha; this.s = null; } call(v) { if (this.s === null) this.s = v; else this.s = this.alpha * v + (1 - this.alpha) * this.s; return this.s; } }
        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
                this.xFilter = new LowPassFilter(this.alpha(minCutoff)); this.dxFilter = new LowPassFilter(this.alpha(dCutoff)); this.lastTime = null;
            }
            alpha(c) { const te = 1 / (this.freq || 60); const tau = 1 / (2 * Math.PI * (c || 1.0)); return 1 / (1 + tau / te); }
            call(x, t = null) {
                if (this.lastTime !== null && t !== null) {
                    const dt = (t - this.lastTime) / 1000;
                    if (dt > 0.001) this.freq = 1 / dt;
                }
                this.lastTime = t;
                const prevX = this.xFilter.s;
                const dx = prevX === null ? 0 : (x - prevX) * (this.freq || 60);
                const edx = this.dxFilter.call(dx);
                const c = this.minCutoff + this.beta * Math.abs(edx);
                this.xFilter.alpha = this.alpha(c);
                const result = this.xFilter.call(x);
                return isNaN(result) ? (x || 0) : result;
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: true,
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6, dwellMs: 1000 },
            physics: {
                stiffness: 0.2, stiffnessArmed: 0.6, damping: 0.1, lookAhead: 1.5,
                springSource: 'snappy', predSource: 'snappy',
                p3Source: 'predictive', p3Mirror: true,
                showGlobalCursor: false,
                remoteMode: true,
                remoteTargetId: 'excalidraw-iframe',
                persistence: { snapDistance: 0.15, coastFrames: 60, repulsionDistance: 0.12, teleportLimit: 0.3 }
            },
            hands: {}, bridge: { lastEvent: null, errorCount: 0, status: 'IDLE', lastValidate: 0 }
        };

        // ðŸ›°ï¸ V37 System Singleton Guard
        const hfoSystem = window.hfoSystem = {
            initialized: false,
            initializing: false,
            video: null,
            canvas: null,
            ctx: null,
            recognizer: null,
            stream: null,
            loopActive: false,
            lastFrame: 0
        };

        let telemetrySeq = 0;
        const port1Bridge = (hands) => {
            const now = performance.now();
            const shouldValidate = (now - hfoState.bridge.lastValidate) > 500;
            try {
                const telemetryData = {};
                for (const id in hands) {
                    const h = hands[id];
                    if (!h.active) continue;
                    telemetryData[id] = {
                        id: h.id, active: h.active, lastSeen: h.lastSeen, fsm: h.fsm.state,
                        cursors: {
                            raw: h.cursors.raw,
                            smooth: h.cursors.smooth,
                            snappy: h.cursors.snappy,
                            spring: h.cursors.spring,
                            pred: h.cursors.predictive
                        },
                        gestures: h.gestures, palm: h.palm, curls: h.curls
                    };
                }
                const event = {
                    specversion: "1.0", type: "hfo.omega.v25.hand_update", source: "hfo.port.0.sense",
                    id: `telemetry-${telemetrySeq++}`, time: new Date().toISOString(), data: telemetryData
                };
                if (shouldValidate) {
                    CloudEventSchema.parse(event);
                    hfoState.bridge.lastValidate = now;
                }
                hfoState.bridge.lastEvent = event; hfoState.bridge.status = 'VALID';
            } catch (e) {
                hfoState.bridge.status = 'ERROR'; hfoState.bridge.errorCount++;
            }
        };

        const p3InjectPointer = window.p3InjectPointer = (hand) => {
            try {
                if (!hand.active) {
                    if (hand.ghost) hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    return;
                }

                if (!hand.ghost) {
                    hand.ghost = document.createElement('div');
                    hand.ghost.className = 'ghost-cursor';
                    document.body.appendChild(hand.ghost);
                }

                const types = { 'pointerdown': 'pointerdown', 'pointermove': 'pointermove', 'pointerup': 'pointerup', 'pointercancel': 'pointercancel' };
                const type = types[hand.fsm.pointerEvent];
                const activeType = type || (hand.fsm.state !== 'IDLE' ? 'pointermove' : null);

                if (!activeType || !hand.active) {
                    hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    return;
                }

                const cursor = hand.cursors[hfoState.physics.p3Source] || hand.cursors.predictive;
                let normX = cursor.x;
                if (hfoState.physics.p3Mirror) normX = 1 - normX;

                let x = normX * window.innerWidth;
                let y = cursor.y * window.innerHeight;

                // Optimization: Skip DOM traversal if same point and no change (Optional, but elementFromPoint is heavy)
                let target = document.elementFromPoint(x, y) || document.body;
                let finalX = x;
                let finalY = y;

                // ðŸŽ¯ V30: Robust Coordinate Mapping & Drill
                if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
                    const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
                    if (remoteEl) {
                        const rect = remoteEl.getBoundingClientRect();
                        finalX = normX * rect.width;
                        finalY = cursor.y * rect.height;
                        target = remoteEl;

                        if (remoteEl.tagName === 'IFRAME') {
                            try {
                                const innerTarget = remoteEl.contentDocument.elementFromPoint(finalX, finalY);
                                if (innerTarget) target = innerTarget;
                            } catch (e) {
                                finalX = rect.left + finalX;
                                finalY = rect.top + finalY;
                            }
                        } else {
                            finalX = rect.left + finalX;
                            finalY = rect.top + finalY;
                        }

                        if (!hand.localCursor) {
                            hand.localCursor = document.createElement('div');
                            hand.localCursor.className = 'local-cursor';
                            document.body.appendChild(hand.localCursor);
                        }
                        hand.localCursor.style.display = 'block';
                        hand.localCursor.style.left = `${rect.left + (normX * rect.width) - 5}px`;
                        hand.localCursor.style.top = `${rect.top + (cursor.y * rect.height) - 5}px`;
                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase()}`;
                    }
                } else {
                    if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                        const rect = target.getBoundingClientRect();
                        finalX = x - rect.left;
                        finalY = y - rect.top;
                        if (target.tagName === 'IFRAME') {
                            try {
                                const inner = target.contentDocument.elementFromPoint(finalX, finalY);
                                if (inner) target = inner;
                                else { finalX = x; finalY = y; }
                            } catch (e) { finalX = x; finalY = y; }
                        }
                    } else { finalX = x; finalY = y; }

                    if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                        if (!hand.localCursor) {
                            hand.localCursor = document.createElement('div');
                            hand.localCursor.className = 'local-cursor';
                            document.body.appendChild(hand.localCursor);
                        }
                        hand.localCursor.style.display = 'block';
                        hand.localCursor.style.left = `${x - 5}px`;
                        hand.localCursor.style.top = `${y - 5}px`;
                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase()}`;
                    } else if (hand.localCursor) hand.localCursor.style.display = 'none';
                }

                if (hfoState.physics.showGlobalCursor) {
                    hand.ghost.classList.add('active');
                    hand.ghost.style.left = `${x - 10}px`;
                    hand.ghost.style.top = `${y - 10}px`;
                } else hand.ghost.classList.remove('active');

                hand.ghost.classList.toggle('committed', hand.fsm.state === 'COMMITTED');
                hand.ghost.classList.toggle('armed', hand.fsm.state === 'ARMED' || hand.fsm.state === 'COMMITTING');

                if (hand.lastTarget && hand.lastTarget !== target) {
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerout', { bubbles: true, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerleave', { bubbles: false, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerenter', { bubbles: false, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                }

                const movementX = hand.lastX !== undefined ? x - hand.lastX : 0;
                const movementY = hand.lastY !== undefined ? y - hand.lastY : 0;
                hand.lastX = x; hand.lastY = y; hand.lastTarget = target;

                const isDown = (hand.fsm.state === 'COMMITTED');
                const isPrimary = Number(hand.id) === 0;
                const ev = new PointerEvent(activeType, {
                    bubbles: true, cancelable: true, pointerType: 'mouse',
                    view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                    pointerId: Number(hand.id) + 10, clientX: finalX, clientY: finalY,
                    movementX: movementX, movementY: movementY,
                    pressure: isDown ? 0.9 : 0.0, buttons: isDown ? 1 : 0,
                    button: (activeType === 'pointerdown' || activeType === 'pointerup') ? 0 : -1,
                    isPrimary: isPrimary
                });
                target.dispatchEvent(ev);

                if (isPrimary && (activeType === 'pointerdown' || activeType === 'pointerup')) {
                    const mouseType = activeType === 'pointerdown' ? 'mousedown' : 'mouseup';
                    target.dispatchEvent(new MouseEvent(mouseType, {
                        bubbles: true, cancelable: true, view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                        clientX: finalX, clientY: finalY, button: 0, buttons: isDown ? 1 : 0
                    }));
                }

                if (isPrimary && activeType === 'pointerup' && hand.fsm.state === 'ARMED') {
                    target.dispatchEvent(new MouseEvent('click', {
                        bubbles: true, cancelable: true, view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                        clientX: finalX, clientY: finalY, button: 0
                    }));
                }
            } catch (err) {
                if (hfoState.debug) console.error("P3 Injection Error:", err);
            }
        };

        const createCursorSet = (handId, hue) => {
            const h = {
                id: handId, lastSeen: 0, active: false, coastCount: 0, fsm: new GestureFSM(),
                cursors: {
                    raw: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 100%)`, label: `H${handId} Raw` },
                    smooth: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 70%)`, label: `H${handId} Smooth` },
                    snappy: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 50%)`, label: `H${handId} Snappy` },
                    spring: { x: 0.5, y: 0.5, body: null, anchor: null, constraint: null, color: `hsl(${hue}, 100%, 40%)`, label: `H${handId} Spring` },
                    predictive: { x: 0.5, y: 0.5, body: null, color: `hsl(${hue}, 100%, 30%)`, label: `H${handId} Pred` }
                },
                filters: { sx: new OneEuroFilter(30, 0.5, 0.001), sy: new OneEuroFilter(30, 0.5, 0.001), nx: new OneEuroFilter(30, 2.0, 0.1), ny: new OneEuroFilter(30, 2.0, 0.1) },
                gestures: { active: 'None', score: 0, isDown: false, pointerEvent: 'none' },
                lastTarget: null
            };
            if (engine) {
                const { Bodies, Composite, Constraint } = Matter;
                h.cursors.spring.anchor = Bodies.circle(0.5, 0.5, 1, { isStatic: true, isSensor: true });
                h.cursors.spring.body = Bodies.circle(0.5, 0.5, 10, { frictionAir: 0.1, label: `H${handId}-SpringB` });
                h.cursors.spring.constraint = Constraint.create({ bodyA: h.cursors.spring.anchor, bodyB: h.cursors.spring.body, stiffness: hfoState.physics.stiffness, damping: hfoState.physics.damping, length: 0 });
                h.cursors.predictive.body = Bodies.circle(0.5, 0.5, 10, { isStatic: true, label: `H${handId}-PredB` });
                Composite.add(engine.world, [h.cursors.spring.anchor, h.cursors.spring.body, h.cursors.spring.constraint, h.cursors.predictive.body]);
            }
            return h;
        };

        let engine, runner, gestureRecognizer;
        const initPhysics = window.initPhysics = () => {
            if (hfoSystem.initialized) return;
            engine = Matter.Engine.create(); engine.gravity.scale = 0;
            runner = Matter.Runner.create(); Matter.Runner.run(runner, engine);
            hfoState.hands[0] = createCursorSet(0, 200); hfoState.hands[1] = createCursorSet(1, 30);
            hfoSystem.initialized = true;
        };

        const initMediaPipe = async (container) => {
            if (hfoSystem.loopActive || hfoSystem.initializing) return;
            hfoSystem.initializing = true;
            try {
                // Re-use or Create Singleton Elements
                if (!hfoSystem.video) {
                    hfoSystem.video = document.createElement('video');
                    hfoSystem.video.autoplay = true;
                    hfoSystem.video.playsinline = true;
                    hfoSystem.video.style.opacity = '0.3';
                }
                if (!hfoSystem.canvas) {
                    hfoSystem.canvas = document.createElement('canvas');
                    hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
                }

                // Attach to current container
                container.appendChild(hfoSystem.video);
                container.appendChild(hfoSystem.canvas);

                if (hfoSystem.loopActive) {
                    // Resize if needed
                    hfoSystem.canvas.width = hfoSystem.video.videoWidth || 1280;
                    hfoSystem.canvas.height = hfoSystem.video.videoHeight || 720;
                    hfoSystem.initializing = false;
                    return;
                }

                const video = hfoSystem.video;
                const canvas = hfoSystem.canvas;
                const ctx = hfoSystem.ctx;
                const dw = new DrawingUtils(ctx);
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                    runningMode: "VIDEO", ...hfoState.mpOptions
                });
                hfoSystem.recognizer = gestureRecognizer;

                const render = () => {
                    hfoSystem.initializing = false;
                    if (hfoSystem.loopActive) return;
                    hfoSystem.loopActive = true;

                    // ðŸ§¬ Identity: Finger Curl Calculation
                    const calculateCurl = (landmarks, indices) => {
                        let totalAngle = 0;
                        for (let i = 0; i < indices.length - 2; i++) {
                            const a = landmarks[indices[i]];
                            const b = landmarks[indices[i + 1]];
                            const c = landmarks[indices[i + 2]];
                            const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 }; // Flatten Z influence
                            const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                            const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                            totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                        }
                        // Normalize: 0 (flat) to ~1.0 (curled)
                        return Math.min(1.0, totalAngle / Math.PI);
                    };

                    const loop = () => {
                        const now = hfoSystem.lastFrame = performance.now();
                        if (hfoState.active) {
                            try {
                                if (video.readyState >= 2 && gestureRecognizer) {
                                    const res = gestureRecognizer.recognizeForVideo(video, now);
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    const landmarks = res.landmarks || [];
                                    const handIds = Object.keys(hfoState.hands);
                                    const assignedLandmarks = new Set();
                                    const currentAssignments = {};

                                    // PASS 1: Sticky Tracking
                                    handIds.filter(id => hfoState.hands[id].active).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minD = hfoState.physics.persistence.teleportLimit;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                            if (d < minD) { minD = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // PASS 2: Discovery
                                    handIds.filter(id => !currentAssignments.hasOwnProperty(id)).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minD = hfoState.physics.persistence.snapDistance;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                            if (d < minD) { minD = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // APPLY
                                    handIds.forEach(id => {
                                        const h = hfoState.hands[id];
                                        if (currentAssignments.hasOwnProperty(id)) {
                                            const lIdx = currentAssignments[id];
                                            const lm = landmarks[lIdx];

                                            // ðŸŽ¯ V39.1: Handedness-Agnostic Orientation (Palm or Back)
                                            const v1 = { x: lm[5].x - lm[0].x, y: lm[5].y - lm[0].y, z: lm[5].z - lm[0].z };
                                            const v2 = { x: lm[17].x - lm[0].x, y: lm[17].y - lm[0].y, z: lm[17].z - lm[0].z };

                                            const cross = {
                                                x: (v1.y * v2.z - v1.z * v2.y) || 0,
                                                y: (v1.z * v2.x - v1.x * v2.z) || 0,
                                                z: (v1.x * v2.y - v1.y * v2.x) || 0
                                            };
                                            const mag = Math.sqrt(cross.x ** 2 + cross.y ** 2 + cross.z ** 2) || 1;
                                            const normal = { x: cross.x / mag, y: cross.y / mag, z: cross.z / mag };

                                            // Tighter Cone: Accept either side of flat hand (|Z| > 0.5)
                                            const isFacing = Math.abs(normal.z) > 0.5;
                                            h.palm = { normal, facingCamera: isFacing };

                                            // ðŸ§¬ Finger Identity
                                            h.curls = {
                                                index: calculateCurl(lm, [5, 6, 7, 8]),
                                                middle: calculateCurl(lm, [9, 10, 11, 12]),
                                                ring: calculateCurl(lm, [13, 14, 15, 16]),
                                                pinky: calculateCurl(lm, [17, 18, 19, 20])
                                            };

                                            h.cursors.raw.x = lm[8].x; h.cursors.raw.y = lm[8].y; h.lastSeen = now; h.coastCount = 0; h.active = true;
                                            h.cursors.smooth.x = h.filters.sx.call(lm[8].x, now); h.cursors.smooth.y = h.filters.sy.call(lm[8].y, now);
                                            h.cursors.snappy.x = h.filters.nx.call(lm[8].x, now); h.cursors.snappy.y = h.filters.ny.call(lm[8].y, now);

                                            if (res.gestures?.[lIdx]) {
                                                const g = res.gestures[lIdx][0];
                                                const fsmRes = h.fsm.process(g.categoryName, now, g.score, isFacing);
                                                h.gestures = { active: g.categoryName, score: g.score, isDown: (h.fsm.state === 'COMMITTED'), pointerEvent: fsmRes.pointerEvent };
                                            }
                                        } else {
                                            h.palm = { normal: { x: 0, y: 0, z: 0 }, facingCamera: false };
                                            h.coastCount++;
                                            const fsmRes = h.fsm.process('LOST', now, 0, false);
                                            h.gestures.isDown = (h.fsm.state === 'COMMITTED');
                                            h.gestures.pointerEvent = fsmRes.pointerEvent;
                                            if (h.coastCount > hfoState.physics.persistence.coastFrames) h.active = false;
                                        }

                                        if (h.active) {
                                            if (hfoState.debug && currentAssignments.hasOwnProperty(id)) {
                                                dw.drawConnectors(landmarks[currentAssignments[id]], HandLandmarker.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
                                            }
                                            if (engine) {
                                                const isEngaged = h.fsm.state === 'ARMED' || h.fsm.state === 'COMMITTED';
                                                h.cursors.spring.constraint.stiffness = isEngaged ? hfoState.physics.stiffnessArmed : hfoState.physics.stiffness;
                                                // ðŸš€ Fix: Ensure cursors reference is robust
                                                const source = h.cursors[hfoState.physics.springSource] || h.cursors.raw;
                                                Matter.Body.setPosition(h.cursors.spring.anchor, { x: source.x * canvas.width, y: source.y * canvas.height });
                                                const lead = { x: (h.cursors.snappy.x - h.cursors.smooth.x) * hfoState.physics.lookAhead, y: (h.cursors.snappy.y - h.cursors.smooth.y) * hfoState.physics.lookAhead };
                                                const predSource = h.cursors[hfoState.physics.predSource] || h.cursors.snappy;
                                                Matter.Body.setPosition(h.cursors.predictive.body, { x: (predSource.x + lead.x) * canvas.width, y: (predSource.y + lead.y) * canvas.height });
                                                h.cursors.spring.x = h.cursors.spring.body.position.x / canvas.width; h.cursors.spring.y = h.cursors.spring.body.position.y / canvas.height;
                                                h.cursors.predictive.x = h.cursors.predictive.body.position.x / canvas.width; h.cursors.predictive.y = h.cursors.predictive.body.position.y / canvas.height;
                                            }

                                            [h.cursors.raw, h.cursors.smooth, h.cursors.snappy, h.cursors.spring, h.cursors.predictive].forEach(c => {
                                                ctx.beginPath(); ctx.arc(c.x * canvas.width, c.y * canvas.height, 12, 0, 2 * Math.PI);
                                                ctx.fillStyle = c.color; ctx.globalAlpha = 1.0; ctx.fill();
                                                ctx.strokeStyle = (h.fsm.state === 'COMMITTED') ? '#00ff88' : (h.fsm.state === 'ARMED' ? '#0088ff' : 'transparent');
                                                ctx.lineWidth = 4; ctx.stroke();
                                                ctx.globalAlpha = 1.0; ctx.fillStyle = '#fff'; ctx.font = '10px Courier'; ctx.fillText(c.label, c.x * canvas.width + 15, c.y * canvas.height + 5);
                                            });

                                            // ðŸ§¬ Identity HUD
                                            if (hfoState.debug) {
                                                const tx = h.cursors.raw.x * canvas.width + 15;
                                                const ty = h.cursors.raw.y * canvas.height + 25;
                                                ctx.fillStyle = '#00ff88';
                                                ctx.font = '10px Courier';
                                                const curlStr = `I:${h.curls.index.toFixed(2)} M:${h.curls.middle.toFixed(2)} R:${h.curls.ring.toFixed(2)} P:${h.curls.pinky.toFixed(2)}`;
                                                ctx.fillText(curlStr, tx, ty);
                                                ctx.fillText(`Facing: ${h.palm.facingCamera}`, tx, ty + 12);
                                            }
                                            p3InjectPointer(h);
                                        }
                                    });
                                } else {
                                    // ðŸš€ Synthetic Support: Process physics even if video is off
                                    Object.values(hfoState.hands).filter(h => h.active).forEach(h => {
                                        if (engine) {
                                            const source = h.cursors[hfoState.physics.springSource] || h.cursors.raw;
                                            Matter.Body.setPosition(h.cursors.spring.anchor, { x: source.x * canvas.width, y: source.y * canvas.height });
                                            h.cursors.spring.x = h.cursors.spring.body.position.x / canvas.width; h.cursors.spring.y = h.cursors.spring.body.position.y / canvas.height;
                                        }
                                        p3InjectPointer(h);
                                    });
                                }
                                port1Bridge(hfoState.hands);
                            } catch (loopErr) {
                                console.error("Loop Error Cycle:", loopErr);
                            }
                        }
                        requestAnimationFrame(loop);
                    };
                    loop();
                };

                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    initPhysics();
                    render();
                };

                try {
                    if (!hfoSystem.stream) {
                        hfoSystem.stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                        video.srcObject = hfoSystem.stream;
                    } else {
                        video.srcObject = hfoSystem.stream;
                        if (video.readyState >= 2) {
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            initPhysics();
                            render();
                        }
                    }
                } catch (mediaErr) {
                    console.warn("Media Access Error: Entering Synthetic Baseline.", mediaErr);
                    initPhysics();
                    render();
                }
            } catch (err) {
                console.error("Critical MediaPipe Failure:", err);
            } finally {
                hfoSystem.initializing = false;
            }
        };

        const initPhysicsPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-section'; s.id = `section-h${id}`;
                            s.innerHTML = `<h2 style="font-size: 11px; color: #888; margin: 10px 0 5px 0;">HAND ID: ${id}</h2>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                                    <div class="data-card" style="border-left-color: #ffffff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Raw</h3><code class="val-raw" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #00ccff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Smooth</h3><code class="val-smooth" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ffcc00; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Snappy</h3><code class="val-snappy" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff00ff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Spring</h3><code class="val-spring" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #00ff00; padding: 4px; border-radius: 4px; grid-column: span 2;"><h3 style="font-size:9px;">Pred</h3><code class="val-pred" style="font-size:9px;">...</code></div>
                                </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#section-h${id}`);
                        if (s) {
                            s.querySelector('.val-raw').innerText = `X:${h.cursors.raw.x.toFixed(3)}`;
                            s.querySelector('.val-smooth').innerText = `X:${h.cursors.smooth.x.toFixed(3)}`;
                            s.querySelector('.val-snappy').innerText = `X:${h.cursors.snappy.x.toFixed(3)}`;
                            s.querySelector('.val-spring').innerText = `X:${h.cursors.spring.x.toFixed(3)}`;
                            s.querySelector('.val-pred').innerText = `X:${h.cursors.pred.x.toFixed(3)}, Y:${h.cursors.pred.y.toFixed(3)}`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initGesturesPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-gesture-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-gesture-section'; s.id = `gesture-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #cc00ff; padding: 10px; margin-bottom:10px;">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <h3 style="margin:0; font-size:12px;">HAND ${id}</h3>
                                    <span class="val-tag state-tag tag-idle">IDLE</span>
                                </div>
                                <h1 class="val-gesture" style="font-size: 24px; margin: 10px 0;">NONE</h1>
                                <div style="display:flex; gap: 5px; align-items:center;">
                                    <div class="val-event" style="background:#000; padding: 2px 5px; border-radius:3px; color:#00ff88; font-size:10px; font-family:monospace;">none</div>
                                    <div class="val-score" style="color: #666; font-size: 10px;">Conf: 0%</div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#gesture-section-h${id}`);
                        if (s) {
                            const tag = s.querySelector('.val-tag');
                            tag.innerText = h.fsm;
                            tag.className = `val-tag state-tag tag-${h.fsm.toLowerCase().split('_')[0]}`;
                            s.querySelector('.val-gesture').innerText = h.gestures.active;
                            s.querySelector('.val-event').innerText = h.gestures.pointerEvent;
                            s.querySelector('.val-score').innerText = `Conf: ${(h.gestures.score * 100).toFixed(1)}%`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initPalmConePanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting for Palm Data...</div>';
                else {
                    if (div.querySelectorAll('.hand-palm-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-palm-section'; s.id = `palm-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #ffaa00; padding: 10px; margin-bottom:10px;">
                                <h3 style="margin:0; font-size:12px;">PALM ${id}</h3>
                                <div style="display:flex; align-items:center; gap: 20px; margin-top:10px;">
                                    <div class="palm-visual" style="width:60px; height:60px; background:#000; border:2px solid #555; position:relative; border-radius:50%; overflow:hidden;">
                                        <div class="palm-dot" style="width:10px; height:10px; background:#ffaa00; position:absolute; top:50%; left:50%; border-radius:50%; transform:translate(-50%, -50%);"></div>
                                    </div>
                                    <div>
                                        <div class="val-facing" style="font-size:14px; font-weight:bold; color:#ffaa00;">FACING: NO</div>
                                        <code class="val-norm" style="font-size:10px; color:#888;">Z: 0.00</code>
                                    </div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#palm-section-h${id}`);
                        if (s && h.palm) {
                            const visual = s.querySelector('.palm-visual');
                            const dot = s.querySelector('.palm-dot');
                            const facing = s.querySelector('.val-facing');
                            const norm = s.querySelector('.val-norm');

                            facing.innerText = `FACING: ${h.palm.facingCamera ? 'YES' : 'NO'}`;
                            facing.style.color = h.palm.facingCamera ? '#00ff88' : '#ff4444';
                            norm.innerText = `X:${h.palm.normal.x.toFixed(2)} Y:${h.palm.normal.y.toFixed(2)} Z:${h.palm.normal.z.toFixed(2)}`;

                            // Visual hint: move dot based on X/Y normal
                            dot.style.left = `${50 + h.palm.normal.x * 40}%`;
                            dot.style.top = `${50 + h.palm.normal.y * 40}%`;
                            visual.style.borderColor = h.palm.facingCamera ? '#00ff88' : '#555';
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initInteractionTest = (container) => {
            const div = document.createElement('div'); div.className = 'component-container';
            div.innerHTML = `
                <div class="data-card" style="border-left-color: #ff0055;">
                    <h3>P3 Injection Target</h3>
                    <button id="test-btn" style="width:100%; height:80px; background:#333; color:#fff; border:2px solid #ff0055; border-radius:8px; font-size:18px; cursor:pointer;">CLICK ME</button>
                    <div id="click-status" style="margin-top:10px; font-family:monospace; font-size:12px; color:#aaa;">Last Action: None</div>
                </div>
                <div class="data-card" style="border-left-color: #00ff88;">
                    <h3>Slider Test</h3>
                    <input type="range" id="test-slider" style="width:100%;">
                </div>
            `;
            container.appendChild(div);
            const btn = div.querySelector('#test-btn');
            const status = div.querySelector('#click-status');
            btn.addEventListener('pointerdown', () => {
                btn.style.background = '#ff0055';
                status.innerText = 'Last Action: pointerdown';
            });
            btn.addEventListener('pointerup', () => {
                btn.style.background = '#333';
                status.innerText = 'Last Action: pointerup';
            });
            btn.addEventListener('click', () => {
                status.innerText = 'Last Action: click! ðŸš€';
                setTimeout(() => { if (status.innerText.includes('click')) status.innerText = 'Last Action: waiting...'; }, 2000);
            });
        };

        const initExcalidraw = (container) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-gate';
            wrapper.style.width = '100%';
            wrapper.style.height = '100%';
            wrapper.style.position = 'relative';
            wrapper.style.background = '#fff';

            const iframe = document.createElement('iframe');
            iframe.src = './excalidraw_v30_wrapper.html';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.id = 'excalidraw-iframe';
            wrapper.appendChild(iframe);

            container.appendChild(wrapper);
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });
            const phys = gui.addFolder('V25 Dynamics');
            phys.add(hfoState.physics, 'springSource', ['snappy', 'smooth', 'raw']).name('Anchor');
            phys.add(hfoState.physics, 'stiffness', 0, 1).name('Stiffness');
            phys.add(hfoState.physics, 'stiffnessArmed', 0, 1).name('Armed Stiffness');
            phys.add(hfoState.physics, 'lookAhead', 0, 10).name('Pred Time');
            phys.open();

            const p3 = gui.addFolder('P3 Injection');
            p3.add(hfoState.physics, 'p3Source', ['raw', 'smooth', 'snappy', 'spring', 'predictive']).name('Inject Source');
            p3.add(hfoState.physics, 'p3Mirror').name('Mirror X Coordinates');
            p3.open();

            const mp = gui.addFolder('MediaPipe');
            mp.add(hfoState, 'debug').name('Show Connections');
            mp.add(hfoState.physics, 'showGlobalCursor').name('Global Cursor');
            mp.open();
            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    {
                        type: 'component',
                        componentType: 'Excalidraw',
                        title: 'OMEGA: EXCALIDRAW',
                        width: 70
                    },
                    {
                        type: 'column',
                        width: 30,
                        content: [
                            {
                                type: 'stack',
                                height: 50,
                                content: [
                                    { type: 'component', componentType: 'PalmCone', title: 'P0: ORIENTATION' },
                                    { type: 'component', componentType: 'Gestures', title: 'P3: FSM' },
                                    { type: 'component', componentType: 'Physics', title: 'P2: SHAPE' },
                                    { type: 'component', componentType: 'Settings', title: 'P7: NAVIGATE' },
                                    { type: 'component', componentType: 'Interaction', title: 'P3: TEST' }
                                ]
                            },
                            {
                                type: 'component',
                                componentType: 'MediaPipe',
                                title: 'P0: SENSE',
                                height: 50
                            }
                        ]
                    }
                ]
            }
        };
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.registerComponentFactoryFunction('Physics', c => initPhysicsPanel(c.element));
        layout.registerComponentFactoryFunction('Gestures', c => initGesturesPanel(c.element));
        layout.registerComponentFactoryFunction('PalmCone', c => initPalmConePanel(c.element));
        layout.registerComponentFactoryFunction('Interaction', c => initInteractionTest(c.element));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.loadLayout(config); window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>