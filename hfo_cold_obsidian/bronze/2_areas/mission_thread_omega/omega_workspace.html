<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO Omega: Physics Cursor Workspace V12</title>

    <!-- Medallion: Bronze | Mutation: 0% | HIVE: E -->
    <!-- üèóÔ∏è Styles -->
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: sans-serif;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 10px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
        }

        video {
            width: 100%;
            border-radius: 8px;
            transform: scaleX(-1);
            background: #000;
        }

        canvas {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            transform: scaleX(-1);
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>

    <!-- üì¶ Dependencies -->
    <!-- üß™ MediaPipe Tasks API (Official Gesture Implementation) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>

    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout, LayoutConfig } from 'golden-layout';
        import GUI from 'lil-gui';

        // üß™ Official MediaPipe Tasks (extracted from global bundle)
        const GestureRecognizer = window.GestureRecognizer || (window.gesture && window.gesture.GestureRecognizer);
        const FilesetResolver = window.FilesetResolver || (window.gesture && window.gesture.FilesetResolver);
        const { drawConnectors, drawLandmarks } = window;

        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
        ];

        // ÔøΩüß† One Euro Filter Implementation
        class LowPassFilter {
            constructor(alpha) {
                this.alpha = alpha;
                this.s = null;
            }
            call(value) {
                if (this.s === null) {
                    this.s = value;
                } else {
                    this.s = this.alpha * value + (1.0 - this.alpha) * this.s;
                }
                return this.s;
            }
        }

        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
                this.freq = freq;
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.dCutoff = dCutoff;
                this.xFilter = new LowPassFilter(this.alpha(minCutoff));
                this.dxFilter = new LowPassFilter(this.alpha(dCutoff));
                this.lastTime = null;
            }

            alpha(cutoff) {
                const te = 1.0 / this.freq;
                const tau = 1.0 / (2 * Math.PI * cutoff);
                return 1.0 / (1.0 + tau / te);
            }

            call(x, timestamp = null) {
                if (this.lastTime !== null && timestamp !== null) {
                    this.freq = 1.0 / ((timestamp - this.lastTime) / 1000);
                }
                this.lastTime = timestamp;

                const prevX = this.xFilter.s;
                const dx = prevX === null ? 0.0 : (x - prevX) * this.freq;
                const edx = this.dxFilter.call(dx);

                const cutoff = this.minCutoff + this.beta * Math.abs(edx);
                this.xFilter.alpha = this.alpha(cutoff);
                return this.xFilter.call(x);
            }
        }

        let gestureRecognizer = null;

        // üé• MediaPipe State
        const state = {
            active: true,
            smoothing: 0.5,
            debug: true,
            stats: { fps: 0 },
            mpOptions: {
                maxNumHands: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            },
            cursors: {
                smooth: { x: 0.5, y: 0.5, filterX: null, filterY: null, color: '#00ccff', label: 'Smooth Cursor' },
                snappy: { x: 0.5, y: 0.5, filterX: null, filterY: null, color: '#ffcc00', label: 'Snappy Cursor' }
            },
            gestures: {
                active: 'None',
                score: 0,
                pinchDistance: 0,
                pinchThreshold: 0.05,
                isPinching: false,
                isFist: false,
                isOpen: false,
                wasDown: false
            }
        };

        // ü§è Gesture Logic (Now with Official Categories)
        const detectGestures = (landmarks, mpGestures) => {
            // Reset official booleans
            state.gestures.isFist = false;
            state.gestures.isOpen = false;

            // Priority 1: Official Classifier
            if (mpGestures && mpGestures.length > 0) {
                const topGesture = mpGestures[0].categoryName;
                const score = mpGestures[0].score;

                if (score > 0.5) {
                    state.gestures.active = topGesture;
                    state.gestures.score = score;
                    // Map official to internal booleans for physics integration
                    state.gestures.isFist = topGesture === 'Closed_Fist';
                    state.gestures.isOpen = topGesture === 'Open_Palm';
                }
            }

            // Priority 2: HFO Heuristics (for Pinch mapping)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const dx = thumbTip.x - indexTip.x;
            const dy = thumbTip.y - indexTip.y;
            const dz = thumbTip.z - indexTip.z;
            state.gestures.pinchDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            state.gestures.isPinching = state.gestures.pinchDistance < state.gestures.pinchThreshold;

            if (state.gestures.isPinching) {
                state.gestures.active = 'PINCH';
            }
        };

        // Initialize Filters
        state.cursors.smooth.filterX = new OneEuroFilter(30, 0.5, 0.001);
        state.cursors.smooth.filterY = new OneEuroFilter(30, 0.5, 0.001);
        state.cursors.snappy.filterX = new OneEuroFilter(30, 2.0, 0.1);
        state.cursors.snappy.filterY = new OneEuroFilter(30, 2.0, 0.1);

        // üõ†Ô∏è GUI Logic
        const initGUI = (container) => {
            const gui = new GUI({ container, autoPlace: false });

            const mpFolder = gui.addFolder('P0: SENSOR (MediaPipe)');
            mpFolder.add(state.mpOptions, 'maxNumHands', 1, 4, 1).name('Max Hands').onChange(updateMP);
            mpFolder.add(state.mpOptions, 'modelComplexity', { 'Lite (0)': 0, 'Full (1)': 1 }).name('Complexity').onChange(updateMP);
            mpFolder.add(state.mpOptions, 'minDetectionConfidence', 0, 1).name('Detection Thresh').onChange(updateMP);
            mpFolder.add(state.mpOptions, 'minTrackingConfidence', 0, 1).name('Tracking Thresh').onChange(updateMP);
            mpFolder.open();

            const cursorsFolder = gui.addFolder('P2: SHAPE (One Euro Filters)');
            const sFolder = cursorsFolder.addFolder('Smooth Preset');
            sFolder.add(state.cursors.smooth.filterX, 'minCutoff', 0.1, 10).name('Min Cutoff').onChange(v => state.cursors.smooth.filterY.minCutoff = v);
            sFolder.add(state.cursors.smooth.filterX, 'beta', 0, 1).name('Beta').onChange(v => state.cursors.smooth.filterY.beta = v);

            const snFolder = cursorsFolder.addFolder('Snappy Preset');
            snFolder.add(state.cursors.snappy.filterX, 'minCutoff', 0.1, 10).name('Min Cutoff').onChange(v => state.cursors.snappy.filterY.minCutoff = v);
            snFolder.add(state.cursors.snappy.filterX, 'beta', 0, 1).name('Beta').onChange(v => state.cursors.snappy.filterY.beta = v);
            cursorsFolder.open();

            const gestFolder = gui.addFolder('P3: DELIVER (Gestures)');
            gestFolder.add(state.gestures, 'pinchThreshold', 0.01, 0.2).name('Pinch Thresh');
            gestFolder.add(state.gestures, 'active').name('Current Gesture').listen();
            gestFolder.open();

            const vizFolder = gui.addFolder('Visualization');
            vizFolder.add(state, 'active').name('Sensing Active');
            vizFolder.add(state, 'debug').name('Show Skeleton');
            vizFolder.add(state, 'smoothing', 0, 1).name('Global Smoothing');
            vizFolder.add(state.stats, 'fps').name('MP FPS').listen();
            vizFolder.open();

            container.appendChild(gui.domElement);
        };

        const updateMP = () => {
            if (gestureRecognizer) {
                gestureRecognizer.setOptions({
                    numHands: state.mpOptions.maxNumHands,
                    minHandDetectionConfidence: state.mpOptions.minDetectionConfidence,
                    minHandPresenceConfidence: state.mpOptions.minTrackingConfidence,
                    minTrackingConfidence: state.mpOptions.minTrackingConfidence
                });
                console.log('GestureRecognizer Options Updated:', state.mpOptions);
            }
        };

        // üìΩÔ∏è MediaPipe Logic (Official Tasks API)
        const initMediaPipe = async (container) => {
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.style.display = 'none';
            container.appendChild(video);

            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: state.mpOptions.maxNumHands,
                minHandDetectionConfidence: state.mpOptions.minDetectionConfidence,
                minHandPresenceConfidence: state.mpOptions.minTrackingConfidence,
                minTrackingConfidence: state.mpOptions.minTrackingConfidence
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;

            let lastTime = 0;
            const render = () => {
                const now = performance.now();
                state.stats.fps = lastTime ? Math.round(1000 / (now - lastTime)) : 0;

                if (state.active && video.readyState >= 2) {
                    const results = gestureRecognizer.recognizeVideo(video, now);

                    ctx.save();
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Note: Results in Tasks API are different from Solution API
                    if (results.landmarks && results.landmarks.length > 0) {
                        results.landmarks.forEach((landmarks, index) => {
                            if (state.debug) {
                                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF0033', lineWidth: 2 });
                                drawLandmarks(ctx, landmarks, { color: '#FF000033', lineWidth: 1, radius: 2 });
                            }

                            const tip = landmarks[8];
                            const gest = results.gestures[index];

                            // ü§è Detect Gestures
                            detectGestures(landmarks, gest);

                            // Apply Filters
                            state.cursors.smooth.x = state.cursors.smooth.filterX.call(tip.x, now);
                            state.cursors.smooth.y = state.cursors.smooth.filterY.call(tip.y, now);
                            state.cursors.snappy.x = state.cursors.snappy.filterX.call(tip.x, now);
                            state.cursors.snappy.y = state.cursors.snappy.filterY.call(tip.y, now);

                            // üì° Bridge P3: DELIVER (Pointer Dispatch)
                            const emitX = (1 - state.cursors.smooth.x) * window.innerWidth; // Mirroring check
                            const emitY = state.cursors.smooth.y * window.innerHeight;
                            const isDown = state.gestures.isPinching || state.gestures.isFist;

                            let eventType = 'pointermove';
                            if (isDown && !state.gestures.wasDown) eventType = 'pointerdown';
                            if (!isDown && state.gestures.wasDown) eventType = 'pointerup';
                            state.gestures.wasDown = isDown;

                            const pointerEvent = new PointerEvent(eventType, {
                                bubbles: true,
                                cancelable: true,
                                pointerType: 'touch',
                                clientX: emitX,
                                clientY: emitY,
                                pressure: isDown ? 1.0 : 0.0
                            });
                            document.elementFromPoint(emitX, emitY)?.dispatchEvent(pointerEvent);

                            // Render Cursors
                            [state.cursors.smooth, state.cursors.snappy].forEach(cursor => {
                                ctx.beginPath();
                                ctx.arc(cursor.x * canvas.width, cursor.y * canvas.height, 10, 0, 2 * Math.PI);
                                ctx.fillStyle = cursor.color;
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                // Label
                                ctx.fillStyle = '#fff';
                                ctx.font = '12px Courier New';
                                ctx.fillText(cursor.label, cursor.x * canvas.width + 15, cursor.y * canvas.height + 5);
                            });
                        });
                    }
                    ctx.restore();
                }
                lastTime = now;
                requestAnimationFrame(render);
            };

            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                render();
            };
        };

        const initPhysicsPanel = (container) => {
            const div = document.createElement('div');
            div.className = 'component-container';
            div.innerHTML = `
                <div style="background: #222; padding: 15px; border-radius: 8px; border-left: 4px solid #00ccff; margin-bottom: 10px;">
                    <h3 style="margin-top:0">üîµ Smooth Cursor</h3>
                    <code id="smooth-data">X: 0.000, Y: 0.000</code>
                </div>
                <div style="background: #222; padding: 15px; border-radius: 8px; border-left: 4px solid #ffcc00;">
                    <h3 style="margin-top:0">üü° Snappy Cursor</h3>
                    <code id="snappy-data">X: 0.000, Y: 0.000</code>
                </div>
            `;
            container.appendChild(div);

            const smoothEl = div.querySelector('#smooth-data');
            const snappyEl = div.querySelector('#snappy-data');

            const update = () => {
                smoothEl.innerText = `X: ${state.cursors.smooth.x.toFixed(4)}, Y: ${state.cursors.smooth.y.toFixed(4)}`;
                snappyEl.innerText = `X: ${state.cursors.snappy.x.toFixed(4)}, Y: ${state.cursors.snappy.y.toFixed(4)}`;
                requestAnimationFrame(update);
            };
            update();
        };

        const initGesturesPanel = (container) => {
            const div = document.createElement('div');
            div.className = 'component-container';
            div.innerHTML = `
                <div style="background: #222; padding: 15px; border-radius: 8px; border-left: 4px solid #cc00ff; margin-bottom: 10px;">
                    <h3 style="margin-top:0">ü§è Gesture Intent</h3>
                    <div id="gesture-active" style="font-size: 24px; font-weight: bold; color: #cc00ff;">NONE</div>
                    <div id="gesture-score" style="font-size: 13px; color: #888; margin-top: 5px;">Score: 0.00</div>
                    <div style="margin-top: 10px;">
                        Pinch Distance: <progress id="pinch-progress" value="0.1" max="0.2" style="width: 100%;"></progress>
                    </div>
                </div>
                <div id="gesture-visualizer" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 20px;">
                    <div id="icon-PINCH" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">PINCH</div>
                    <div id="icon-Closed_Fist" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">FIST</div>
                    <div id="icon-Open_Palm" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">OPEN</div>
                    <div id="icon-Pointing_Up" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">POINT</div>
                    <div id="icon-Thumb_Up" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">THUMBS‚Üë</div>
                    <div id="icon-Victory" style="opacity: 0.2; background: #cc00ff; padding: 10px; border-radius: 4px; text-align:center;">VICTORY</div>
                </div>
            `;
            container.appendChild(div);

            const activeEl = div.querySelector('#gesture-active');
            const scoreEl = div.querySelector('#gesture-score');
            const pinchEl = div.querySelector('#pinch-progress');
            const iconIds = ['PINCH', 'Closed_Fist', 'Open_Palm', 'Pointing_Up', 'Thumb_Up', 'Victory'];
            const icons = {};
            iconIds.forEach(id => icons[id] = div.querySelector(`#icon-${id}`));

            const update = () => {
                activeEl.innerText = state.gestures.active;
                scoreEl.innerText = `Confidence: ${(state.gestures.score * 100).toFixed(1)}%`;
                pinchEl.value = state.gestures.pinchDistance;

                Object.keys(icons).forEach(key => {
                    icons[key].style.opacity = (state.gestures.active === key) ? '1.0' : '0.2';
                    icons[key].style.boxShadow = (state.gestures.active === key) ? '0 0 10px #cc00ff' : 'none';
                });

                requestAnimationFrame(update);
            };
            update();
        };

        // üèóÔ∏è Layout Config
        const config = {
            root: {
                type: 'column',
                content: [
                    {
                        type: 'row',
                        height: 70,
                        content: [
                            {
                                type: 'component',
                                componentType: 'MediaPipe',
                                title: 'P0: SENSE (MediaPipe)',
                                width: 50
                            },
                            {
                                type: 'component',
                                componentType: 'Physics',
                                title: 'P2: SHAPE (Physics Data)',
                                width: 25
                            },
                            {
                                type: 'component',
                                componentType: 'Gestures',
                                title: 'P3: DELIVER (Gesture Intent)',
                                width: 25
                            }
                        ]
                    },
                    {
                        type: 'component',
                        componentType: 'Settings',
                        title: 'P7: NAVIGATE (System Control)',
                        height: 30
                    }
                ]
            }
        };

        const layout = new GoldenLayout(document.getElementById('layout-container'));

        layout.registerComponentFactoryFunction('MediaPipe', (container) => {
            initMediaPipe(container.element);
        });

        layout.registerComponentFactoryFunction('Physics', (container) => {
            initPhysicsPanel(container.element);
        });

        layout.registerComponentFactoryFunction('Gestures', (container) => {
            initGesturesPanel(container.element);
        });

        layout.registerComponentFactoryFunction('Settings', (container) => {
            initGUI(container.element);
        });

        layout.loadLayout(config);

        window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>