--- /home/tommytai3/active/hfo_gen_88_chromebook_v_1/hfo_hot_obsidian/bronze/2_areas/mission_thread_omega_gen_4/omega_gen4_v31_3.html	2026-01-16 12:54:46.045459276 -0700
+++ /home/tommytai3/active/hfo_gen_88_chromebook_v_1/hfo_hot_obsidian/bronze/2_areas/mission_thread_omega_gen_4/omega_gen4_v33.html	2026-01-16 14:15:02.147705443 -0700
@@ -1,14 +1,14 @@
 <!-- Medallion: Bronze | Mutation: 0% | HIVE: E -->
-<!-- OMEGA GEN 4 V31.3 HEADER EVOLUTION -->
-<!-- Mission: Standardize Tutorial Headers (READY - COMMIT - RELEASE - SETTINGS) -->
-<!-- Intent: Evolve tutorial headers to match request while maintaining V31 forensic triplets. -->
+<!-- OMEGA GEN 4 V33 RESPONSIVE COMPONENT HARDENING -->
+<!-- Mission: Implement Component-Relative Interaction (Option 1) and Hardened Containment (Option 4). -->
+<!-- Intent: Resolve fullscreen sync-loss while maintaining tunable overscan beautiful-mode. -->
 <!DOCTYPE html>
 <html lang="en">
 
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>HFO OMEGA GEN 4 | V31.3 Evolution</title>
+    <title>HFO OMEGA GEN 4 | V33 Responsive Lab</title>
 
     <!-- CSS Dependencies -->
     <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-base.css" />
@@ -36,6 +36,10 @@
             --m3-radius: 12px;
         }
 
+        * {
+            box-sizing: border-box;
+        }
+
         body,
         html {
             margin: 0;
@@ -62,7 +66,7 @@
             font-size: 10px;
             border-top: 1px solid var(--md-sys-color-outline);
             text-transform: uppercase;
-            z-index: 1000;
+            z-index: 2000; /* V32: Elevate above GL components */
         }
 
         .component-container {
@@ -580,7 +584,7 @@
                 gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                 palm: { enterThreshold: 0.80, exitThreshold: 0.64 },
                 fsm: {
-                    hysteresisHigh: 80,
+                    hysteresisHigh: 88,
                     hysteresisLow: 64,
                     chargeTimeMs: 200,
                     releaseTimeMs: 200,
@@ -671,14 +675,15 @@
                 toBufferX: (nx) => nx * (systemState.p0.canvas?.width || 1280),
                 toBufferY: (ny) => ny * (systemState.p0.canvas?.height || 720),
                 toViewportX: (nx) => {
-                    const b = systemState.ui.viewBounds || { width: 1280, offsetX: 0 };
-                    const r = systemState.p0.video?.parentElement?.getBoundingClientRect() || { left: 0 };
-                    return r.left + b.offsetX + (nx * b.width);
+                    const b = systemState.ui.viewBounds || { width: 1280, offsetX: 0, containerRect: { left: 0 } };
+                    // V33: Use cached containerRect for Option 1 performance stability
+                    const left = b.containerRect?.left || 0;
+                    return left + b.offsetX + (nx * b.width);
                 },
                 toViewportY: (ny) => {
-                    const b = systemState.ui.viewBounds || { height: 720, offsetY: 0 };
-                    const r = systemState.p0.video?.parentElement?.getBoundingClientRect() || { top: 0 };
-                    return r.top + b.offsetY + (ny * b.height);
+                    const b = systemState.ui.viewBounds || { height: 720, offsetY: 0, containerRect: { top: 0 } };
+                    const top = b.containerRect?.top || 0;
+                    return top + b.offsetY + (ny * b.height);
                 }
             },
             ui: {
@@ -688,7 +693,7 @@
                 fsm: null,
                 fsmCtx: null,
                 juiceLayers: [],
-                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0 }
+                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0, containerRect: { left: 0, top: 0, width: 0, height: 0 } }
             },
             dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
         };
@@ -1378,9 +1383,9 @@
                             }
 
                             // Palm Facing Hysteresis (80 Enter, 64 Exit)
+                            // V33: Omni-Gating (Accept Front or Back for READY)
                             let isPalmFacing = systemState.p1.palmFacingStates[i];
                             if (!isPalmFacing) {
-                                // Omni-Hand Tracking: Still support both for basic awareness
                                 if (normalZ > systemState.parameters.palm.enterThreshold) isPalmFacing = true;
                             } else {
                                 if (normalZ < systemState.parameters.palm.exitThreshold) isPalmFacing = false;
@@ -1422,10 +1427,11 @@
                             const primary = systemState.fsm.primaryHandIndex;
                             const isSeatAvailable = (primary === null || primary === i);
 
+                            // V33: Bidirectional Palm Gating (Gate only on Angle/Readiness)
                             if (fsmState === 'IDLE') {
-                                if (readiness >= systemState.parameters.fsm.hysteresisHigh && isPalmVisible) fsmStateNew = 'READY';
+                                if (readiness >= systemState.parameters.fsm.hysteresisHigh) fsmStateNew = 'READY';
                             } else if (fsmState === 'READY') {
-                                if (readiness <= systemState.parameters.fsm.hysteresisLow || isBackVisible) {
+                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                     fsmStateNew = 'IDLE';
                                     if (primary === i) systemState.fsm.primaryHandIndex = null;
                                 } else if (!hasConfidence) fsmStateNew = 'COAST';
@@ -1435,12 +1441,12 @@
                                     systemState.fsm.primaryHandIndex = i;
                                 }
                             } else if (fsmState === 'COMMIT') {
-                                if (readiness <= systemState.parameters.fsm.hysteresisLow || isBackVisible) {
+                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                     fsmStateNew = 'IDLE';
                                     if (primary === i) systemState.fsm.primaryHandIndex = null;
                                 } else if (!hasConfidence) fsmStateNew = 'COAST';
                             } else if (fsmState === 'COAST') {
-                                if (readiness <= systemState.parameters.fsm.hysteresisLow || isBackVisible) {
+                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                     fsmStateNew = 'IDLE';
                                     if (primary === i) systemState.fsm.primaryHandIndex = null;
                                 } else if (hasConfidence && isPalmFacing) {
@@ -1647,8 +1653,8 @@
                 this.completedPhases = new Set();
                 this.steps = {
                     'READY': {
-                        header: 'Phase 1: READY üñêÔ∏è ‚û° üî•',
-                        body: 'Welcome Initiate! Show your <span class="tutorial-highlight">Palm Towards</span> the camera to ignite the <span class="tutorial-highlight">READY - Amber Phoenix Core</span>.'
+                        header: 'Phase 1: READY üñêÔ∏è/ü§ö ‚û° üî•',
+                        body: 'Welcome Initiate! Show your <span class="tutorial-highlight">Palm or Back of Hand</span> to the camera to charge your <span class="tutorial-highlight">Readiness</span>. Reach 88% to ignite the <span class="tutorial-highlight">Amber Phoenix Core</span>.'
                     },
                     'COMMIT': {
                         header: 'Phase 2: COMMIT ‚òùÔ∏è ‚û° ‚òÑÔ∏è',
@@ -1708,10 +1714,12 @@
 
                 // Strictly sequential stateId (one-way progression)
                 let stateId = this.lastActiveStepId || 'READY';
+                let readinessToDisplay = 0;
 
                 if (cursors.length > 0) {
                     const primary = cursors[0];
                     const fsm = primary.fsmState;
+                    readinessToDisplay = primary.readinessScore || 0;
                     
                     // Progression triggers
                     if (stateId === 'READY' && fsm === 'READY') {
@@ -1730,6 +1738,7 @@
                     }
                 }
 
+                // V33: READINESS Bar for first 3 phases, Timer for last phase
                 if (stateId === 'SETTINGS') {
                     if (this.settingsStart) {
                         const elapsed = now - this.settingsStart;
@@ -1738,6 +1747,7 @@
                         
                         systemState.ui.tutProgress.style.display = 'block';
                         systemState.ui.tutProgressBar.style.width = `${progress}%`;
+                        systemState.ui.tutProgressBar.style.background = 'var(--md-sys-color-primary)';
 
                         if (elapsed >= duration && !this.isCompleted) {
                             this.isCompleted = true;
@@ -1745,6 +1755,16 @@
                             logMission("Tutorial Sequence Complete.");
                         }
                     }
+                } else {
+                    // Show Readiness Score (Leaky Bucket)
+                    if (readinessToDisplay > 0) {
+                        systemState.ui.tutProgress.style.display = 'block';
+                        systemState.ui.tutProgressBar.style.width = `${readinessToDisplay}%`;
+                        // Color based on readiness: Amber if low, Cyan if high (READY)
+                        systemState.ui.tutProgressBar.style.background = readinessToDisplay >= systemState.parameters.fsm.hysteresisHigh ? '#00FFFF' : '#FFD700';
+                    } else {
+                        systemState.ui.tutProgress.style.display = 'none';
+                    }
                 }
 
                 if (stateId !== this.lastActiveStepId) {
@@ -1910,25 +1930,54 @@
                 let finalX = viewX;
                 let finalY = viewY;
 
+                // V33: OVERSCAN INTERACTION HARDENING (Option 1)
+                // Clamp coordinates to the physical browser viewport for initial document search
+                // while preserving the raw coordinates for internal iframe injection.
+                const clampedX = Math.max(0, Math.min(window.innerWidth - 1, viewX));
+                const clampedY = Math.max(0, Math.min(window.innerHeight - 1, viewY));
+
                 if (!target) {
-                    let probe = document.elementFromPoint(viewX, viewY) || document.body;
-                    if (probe && probe.tagName === 'IFRAME') {
-                        try {
-                            const iframeRect = probe.getBoundingClientRect();
-                            const subX = viewX - iframeRect.left;
-                            const subY = viewY - iframeRect.top;
-                            const inner = probe.contentDocument.elementFromPoint(subX, subY);
-                            if (inner) {
-                                probe = inner;
-                                finalX = subX;
-                                finalY = subY;
-                            }
-                        } catch (e) { 
-                            // Cross-origin or hidden iframe access failure is expected but logged in dev
-                            if (systemState.parameters.devMode) console.warn("[P3] Deep Target Search Failure:", e);
+                    // Try to find the Excalidraw overlay first if we have a direct handle
+                    const overlay = systemState.ui.excalidrawOverlay;
+                    if (overlay && overlay.style.display !== 'none') {
+                        const oRect = overlay.getBoundingClientRect();
+                        // If coordinates fall within the physical container rect, probe the iframe directly
+                        if (viewX >= oRect.left && viewX <= oRect.right && viewY >= oRect.top && viewY <= oRect.bottom) {
+                            try {
+                                const subX = viewX - oRect.left;
+                                const subY = viewY - oRect.top;
+                                const inner = systemState.ui.excalidrawIframe?.contentDocument.elementFromPoint(subX, subY);
+                                if (inner) {
+                                    target = inner;
+                                    finalX = subX;
+                                    finalY = subY;
+                                }
+                            } catch (e) {
+                                // Shadow DOM access failure expected on some nodes
+                            }
                         }
                     }
-                    target = probe;
+
+                    if (!target) {
+                        let probe = document.elementFromPoint(clampedX, clampedY) || document.body;
+                        if (probe && probe.tagName === 'IFRAME') {
+                            try {
+                                const iframeRect = probe.getBoundingClientRect();
+                                const subX = viewX - iframeRect.left;
+                                const subY = viewY - iframeRect.top;
+                                const inner = probe.contentDocument.elementFromPoint(subX, subY);
+                                if (inner) {
+                                    probe = inner;
+                                    finalX = subX;
+                                    finalY = subY;
+                                }
+                            } catch (e) { 
+                                // Cross-origin or hidden iframe access failure is expected but logged in dev
+                                if (systemState.parameters.devMode) console.warn("[P3] Deep Target Search Failure:", e);
+                            }
+                        }
+                        target = probe;
+                    }
                 } else {
                     if (target.ownerDocument !== document) {
                         const iframe = Array.from(document.querySelectorAll('iframe')).find(f => f.contentDocument === target.ownerDocument);
@@ -3037,11 +3086,20 @@
 
             const parent = video.parentElement;
             if (!parent) return;
+
+            // V32: SAFESTEP DIMENSIONS (Avoid GL Transition Flicker)
             const pRect = parent.getBoundingClientRect();
+            let parentWidth = pRect.width;
+            let parentHeight = pRect.height;
 
-            // Handle 0 dimensions in headless
-            const parentWidth = pRect.width || vw;
-            const parentHeight = pRect.height || vh;
+            // If dimensions are zero, retry in 100ms
+            if (parentWidth <= 0 || parentHeight <= 0) {
+                if (!window._resizeRetry) {
+                    window._resizeRetry = true;
+                    setTimeout(() => { window._resizeRetry = false; resizeCanvas(); }, 150);
+                }
+                return;
+            }
 
             const vRatio = vw / vh;
 
@@ -3078,7 +3136,8 @@
                 width: drawW,
                 height: drawH,
                 offsetX: offsetX,
-                offsetY: offsetY
+                offsetY: offsetY,
+                containerRect: pRect // V33: Store physical bounds for Option 1 mapping
             };
 
             // Sync all canvas elements (Overlay, Babylon)
@@ -3153,7 +3212,8 @@
                     
                     <!-- EXCALIDRAW OVERLAY LAYER [V20.1: Dark Mode Hardening] -->
                     ${isFlagEnabled('ui-excalidraw') ? `
-                    <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8; display:none;">
+                    <!-- V32: RESTORED INTERACTION (GLASS WALL MANAGED VIA Z-INDEX) -->
+                    <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8; display:none; pointer-events: auto;">
                         <iframe 
                             id="excalidraw-iframe"
                             src="excalidraw_v20_wrapper.html" 
@@ -3181,6 +3241,15 @@
                 </div>
             `;
             container.getElement().appendChild(wrap);
+
+            // V32: COMPONENT-LEVEL RESIZE OBSERVER (Fullscreen Stability Hardening)
+            const heroObserver = new ResizeObserver(() => {
+                if (systemState.parameters.p0Active) {
+                    resizeCanvas();
+                }
+            });
+            heroObserver.observe(wrap);
+
             systemState.p0.video = wrap.querySelector('#video-feed');
             systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
             systemState.p0.ctx = systemState.p0.canvas.getContext('2d');
@@ -3373,11 +3442,17 @@
                 type: 'row', content: [
                     {
                         type: 'stack', width: 60, content: [
-                            { type: 'component', componentType: 'hero', title: 'Tactical Workspace' }
+                            { 
+                                type: 'component', 
+                                componentType: 'hero', 
+                                title: 'Tactical Workspace',
+                                minWidth: 400,
+                                minHeight: 300
+                            }
                         ]
                     },
                     {
-                        type: 'column', width: 40, content: [
+                        type: 'column', width: 40, minWidth: 300, content: [
                             {
                                 type: 'row', height: 40, content: [
                                     { type: 'component', componentType: 'gestures', title: 'P1: Gestures' },
