<!-- Medallion: Bronze | Mutation: 0% | HIVE: V -->
<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!-- OMEGA GEN5 v11 (v10.2 clone; strict hex modular monolith + port doctrine blurbs) -->
<!-- OMEGA V39: UI POLISH & PROGRESSIVE DISCLOSURE (KIOSK MODE) -->
<!-- Goal: Implement Essentials/Developer toggle for progressive disclosure.
     Simplify default Golden Layout for a clean Kiosk experience. -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN5 | v11 (v10.2 clone)</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-dark-theme.css" />

    <!-- Babylon.js Dependencies -->
    <script src="./lib/js/babylon.js"></script>
    <script src="./lib/js/babylon.loaders.min.js"></script>

    <!-- OpenFeature SDK -->
    <script src="./lib/js/web-sdk.min.js"></script>

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 2000;
            /* V32: Elevate above GL components */
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        /* ðŸ“œ SECURED SCROLLING PANEL */
        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            /* Above Pixi Juice (10) */
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        /* ï¿½ BABYLON/PIXI OVERLAY CONTAINERS */
        .visual-substrate {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ï¿½ðŸ’Ž M3 INTEGRATION */
        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }

        /* ðŸ“– TUTORIAL OVERLAY [V30] */
        .tutorial-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--md-sys-color-primary);
            border-radius: var(--m3-radius);
            padding: 16px;
            z-index: 100;
            pointer-events: none;
            display: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .tutorial-step-active {
            animation: tutorial-pulse 2s infinite;
        }

        @keyframes tutorial-pulse {
            0% {
                border-color: var(--md-sys-color-primary);
            }

            50% {
                border-color: #fff;
            }

            100% {
                border-color: var(--md-sys-color-primary);
            }
        }

        .tutorial-step {
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
        }

        /* ðŸŽ¥ GEN5: CLIP REPLAY OVERLAY */
        #hfo-clip-replay {
            position: absolute;
            right: 12px;
            bottom: 44px;
            width: 320px;
            max-width: 45vw;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--m3-radius);
            padding: 8px;
            z-index: 2001;
            display: none;
        }

        #hfo-clip-replay video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
        }

        .tutorial-highlight {
            color: var(--md-sys-color-primary);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA V30.1 - RECONSTRUCTION ACTIVE]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./lib/js/golden-layout.esm.js",
            "lil-gui": "./lib/js/lil-gui.esm.js",
            "@mediapipe/tasks-vision": "./lib/js/vision_bundle.js",
            "zod": "./lib/js/zod.esm.js",
            "planck": "./lib/js/planck.esm.js"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';

        // --- ðŸš© OPENFEATURE CONFIGURATION (V24.2 Evolution) ---
        const urlParams = new URLSearchParams(window.location.search);

        const featureConfig = {
            'phoenix-core': true,
            'engine-babylon': true,
            'engine-pixi': false,
            'engine-canvas': false,
            'physics-planck': true,
            'ui-golden-layout': true,
            'ui-excalidraw': true,
            'ui-lil-gui': true,
            'p3-injector': true,
            'p3-legacy-click': true,
            'p3-adapter-standard': false,
            'data-fabric': true,

            // --- GEN5 v11.1: multi-app (opt-in; default off) ---
            'ui-multiapp': false,

            // --- GEN5 v11.2: multiview (single-camera shared substrate; default off) ---
            'ui-multiview': false,

            // --- GEN5 v11.3: touch games (same-origin iframes; default off) ---
            'ui-games': false,
            // --- GEN5 v12: intent injection panel (default off) ---
            'ui-intent': false,
            'p3-target-active-app': false,
            'p5-defend-strict-v11_1': false
        };

        const HFOFeatureProvider = {
            metadata: { name: 'HFODefaultProvider' },
            resolveBooleanEvaluation(flagKey, defaultValue) {
                // Priority: URL Param > Config Map > Default
                let val = featureConfig[flagKey] ?? defaultValue;
                if (urlParams.has(`flag-${flagKey}`)) {
                    val = urlParams.get(`flag-${flagKey}`) === 'true';
                }
                return { value: val };
            }
        };

        // ðŸ›¡ï¸ [HFO] Initialize OpenFeature (Local UMD Bridge)
        const OF_ROOT = window.OpenFeature || {};
        const api = OF_ROOT.OpenFeature || OF_ROOT.default || OF_ROOT;

        if (typeof api.setProvider === 'function') {
            api.setProvider(HFOFeatureProvider);
            console.log("ðŸš€ [HFO] OpenFeature Hardened (Offline Ready)");
        } else {
            console.warn("âš ï¸ [HFO] OpenFeature API not found in expected UMD location.");
        }

        const featureClient = typeof api.getClient === 'function' ? api.getClient() : {
            getBooleanValue: (key, def) => {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has(`flag-${key}`)) return urlParams.get(`flag-${key}`) === 'true';
                return featureConfig[key] ?? def;
            }
        };

        const isFlagEnabled = (key) => featureClient.getBooleanValue(key, false);

        // --- MEDALLION LIFECYCLE: Resource Zero-Trust [V24.5] ---
        class LifecycleManager {
            constructor() {
                this.disposables = new Set();
                this.engines = new Map(); // Track singleton engines
            }
            register(id, obj) {
                if (obj && typeof obj.dispose === 'function') {
                    this.disposables.add(obj);
                    if (id) this.engines.set(id, obj);
                }
                return obj;
            }
            unregister(obj) {
                this.disposables.delete(obj);
            }
            dispose(id) {
                if (id) {
                    const obj = this.engines.get(id);
                    if (obj) {
                        try { obj.dispose(); } catch (e) { console.error(`[LIFECYCLE] Error disposing ${id}:`, e); }
                        this.disposables.delete(obj);
                        this.engines.delete(id);
                        console.log(`[LIFECYCLE] Disposed engine: ${id}`);
                    }
                }
            }
            disposeAll() {
                this.disposables.forEach(obj => {
                    try {
                        obj.dispose();
                    } catch (e) {
                        console.error("[LIFECYCLE] Purge Error:", e);
                    }
                });
                this.disposables.clear();
                this.engines.clear();
                console.log("[LIFECYCLE] All resources purged.");
            }
        }
        window.hfoLifecycle = new LifecycleManager();

        // --- TELEMETRY: Deterministic Replay Substrate [V24.5] ---
        class TelemetryRecorder {
            constructor() {
                this.buffer = [];
                this.isRecording = false;
                this.maxEntries = 10000;
            }
            start() {
                this.buffer = [];
                this.isRecording = true;
                console.log("âºï¸ [TELEMETRY] Recording started.");
            }
            stop() {
                this.isRecording = false;
                console.log("â¹ï¸ [TELEMETRY] Recording stopped. Entries:", this.buffer.length);
            }
            record(phase, data) {
                if (!this.isRecording || window.hfoPlayer.isPlaying) return;
                this.buffer.push({
                    timestamp: performance.now(),
                    phase: phase,
                    data: JSON.parse(JSON.stringify(data)) // Deep clone
                });
                if (this.buffer.length > this.maxEntries) this.buffer.shift();
            }
            exportJSONL() {
                const content = this.buffer.map(e => JSON.stringify(e)).join('\n');
                const blob = new Blob([content], { type: 'application/x-jsonlines' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hfo_telemetry_${new Date().toISOString()}.jsonl`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        window.hfoTelemetry = new TelemetryRecorder();

        // --- TELEMETRY PLAYER: Golden Master Replay [V24.6] ---
        class TelemetryPlayer {
            constructor() {
                this.sequence = [];
                this.index = 0;
                this.isPlaying = false;
                this.loop = false;
            }
            async load(file) {
                const text = await file.text();
                this.sequence = text.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
                this.index = 0;
                console.log("ðŸŽžï¸ [TELEMETRY] Sequence loaded. Entries:", this.sequence.length);
            }
            start() {
                if (this.sequence.length === 0) return console.warn("P6: No sequence loaded.");
                this.index = 0;
                this.isPlaying = true;
                systemState.parameters.p0Active = true; // Force loop
                console.log("â–¶ï¸ [TELEMETRY] Playback started.");
            }
            stop() {
                this.isPlaying = false;
                console.log("â¹ï¸ [TELEMETRY] Playback stopped.");
            }
            pause() {
                this.isPlaying = false;
                console.log("â¸ï¸ [TELEMETRY] Playback paused.");
            }
            getNextFrame() {
                if (!this.isPlaying || this.sequence.length === 0) return null;
                const frame = this.sequence[this.index];
                this.index++;
                if (this.index >= this.sequence.length) {
                    if (this.loop) this.index = 0;
                    else this.stop();
                }
                return frame;
            }
        }
        window.hfoPlayer = new TelemetryPlayer();

        // --- REPLAY LOADER: JSONL TEXT INJECTION (Golden Master Harness) ---
        window.hfoLoadReplayFromText = (text) => {
            try {
                const seq = text
                    .split('\n')
                    .filter(l => l.trim())
                    .map(l => JSON.parse(l));
                window.hfoPlayer.sequence = seq;
                window.hfoPlayer.index = 0;
                window.hfoPlayer.isPlaying = false;
                console.log("ðŸ§ª [TELEMETRY] Replay loaded from text. Entries:", seq.length);
                return seq.length;
            } catch (e) {
                console.error("[TELEMETRY] Failed to load replay from text:", e);
                return 0;
            }
        };

        // --- VIDEO CLIP HARNESS: Record live video/canvas to WEBM ---
        window.hfoClipRecorder = (() => {
            let recorder = null;
            let chunks = [];

            const getStream = () => {
                if (systemState?.p0?.video && systemState.p0.video.srcObject) {
                    return systemState.p0.video.srcObject;
                }
                if (systemState?.p0?.canvas?.captureStream) {
                    return systemState.p0.canvas.captureStream(30);
                }
                return null;
            };

            const start = () => {
                const stream = getStream();
                if (!stream) {
                    console.warn("[CLIP] No stream available (video or canvas). Ignite first.");
                    return false;
                }
                chunks = [];
                recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hfo_clip_${new Date().toISOString()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
                recorder.start();
                console.log("ðŸŽ¥ [CLIP] Recording started.");
                return true;
            };

            const stop = () => {
                if (recorder && recorder.state !== 'inactive') {
                    recorder.stop();
                    console.log("ðŸŽ¥ [CLIP] Recording stopped.");
                    return true;
                }
                return false;
            };

            return { start, stop };
        })();

        // --- GEN5: CLIP REPLAY HARNESS ---
        window.hfoClipPlayer = (() => {
            let container = null;
            let video = null;

            const ensure = () => {
                if (container && video) return;
                container = document.getElementById('hfo-clip-replay');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'hfo-clip-replay';
                    container.innerHTML = `
                        <div class="m3-label" style="margin-bottom:6px;">GEN5 CLIP REPLAY</div>
                        <video controls></video>
                    `;
                    document.body.appendChild(container);
                }
                video = container.querySelector('video');
            };

            const open = () => {
                ensure();
                const inp = document.createElement('input');
                inp.type = 'file';
                inp.accept = 'video/webm,video/mp4';
                inp.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (file) loadFile(file);
                };
                inp.click();
            };

            const loadFile = (file) => {
                ensure();
                const url = URL.createObjectURL(file);
                video.src = url;
                container.style.display = 'block';
                video.play().catch(() => { });
                console.log("ðŸŽžï¸ [CLIP] Replay loaded:", file.name);
            };

            const hide = () => {
                if (container) container.style.display = 'none';
            };

            return { open, loadFile, hide };
        })();

        // --- GEN5: MOCK RESULTS REPLAY (JSONL) ---
        window.hfoMockPlayer = (() => {
            let sequence = [];
            let index = 0;
            let isPlaying = false;

            const loadFromText = (text) => {
                try {
                    sequence = text
                        .split('\n')
                        .filter(l => l.trim())
                        .map(l => JSON.parse(l));
                    index = 0;
                    isPlaying = false;
                    console.log("ðŸ§ª [MOCK] Loaded JSONL entries:", sequence.length);
                    return sequence.length;
                } catch (e) {
                    console.error("[MOCK] Failed to parse JSONL:", e);
                    sequence = [];
                    index = 0;
                    isPlaying = false;
                    return 0;
                }
            };

            const open = () => {
                const inp = document.createElement('input');
                inp.type = 'file';
                inp.accept = '.jsonl';
                inp.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    file.text().then(loadFromText);
                };
                inp.click();
            };

            const start = () => {
                if (!sequence.length) return false;
                index = 0;
                isPlaying = true;
                systemState.parameters.p0Active = true;
                return true;
            };

            const stop = () => {
                isPlaying = false;
            };

            const nextResults = () => {
                if (!isPlaying || index >= sequence.length) {
                    isPlaying = false;
                    return null;
                }
                const frame = sequence[index++];
                return frame?.results || null;
            };

            return { loadFromText, open, start, stop, nextResults, get isPlaying() { return isPlaying; } };
        })();

        // --- GEN5: MOCK RESULTS REPLAY (MediaPipe JSONL) ---
        window.hfoLoadMockResultsFromText = (text) => {
            try {
                const lines = text.split('\n').filter(l => l.trim());
                let fps = 30;
                const frames = [];
                for (const line of lines) {
                    const obj = JSON.parse(line);
                    if (obj.type === 'meta' && obj.fps) fps = obj.fps;
                    if (obj.type === 'frame' && obj.results) frames.push(obj);
                }
                window.__hfoMockFrames = frames;
                window.__hfoMockFps = fps;
                console.log("ðŸ§ª [MOCK] Loaded frames:", frames.length, "fps:", fps);
                return { frames: frames.length, fps };
            } catch (e) {
                console.error("[MOCK] Failed to load mock results:", e);
                return { frames: 0, fps: 0 };
            }
        };

        window.hfoMockResultsPlayer = (() => {
            let timer = null;
            let index = 0;

            const start = () => {
                const frames = window.__hfoMockFrames || [];
                const fps = window.__hfoMockFps || 30;
                if (!frames.length) {
                    console.warn("[MOCK] No frames loaded.");
                    return false;
                }
                index = 0;
                const interval = Math.max(1, Math.floor(1000 / fps));
                timer = setInterval(() => {
                    const frame = frames[index];
                    if (!frame) {
                        stop();
                        return;
                    }
                    window.hfoMockResults = frame.results;
                    index += 1;
                }, interval);
                console.log("â–¶ï¸ [MOCK] Playback started.");
                return true;
            };

            const stop = () => {
                if (timer) {
                    clearInterval(timer);
                    timer = null;
                }
                window.hfoMockResults = null;
                console.log("â¹ï¸ [MOCK] Playback stopped.");
            };

            return { start, stop };
        })();

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            ui: z.object({
                showTutorial: z.boolean().default(true)
            }).optional(),
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                minPresenceConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            palm: z.object({
                enterThreshold: z.number().min(0).max(1),
                exitThreshold: z.number().min(0).max(1)
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(1),
                hysteresisLow: z.number().min(0).max(1),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1), // Added for V16
                tensionMs: z.number().min(0)
            }),
            coasting: z.object({
                timeoutMs: z.number().min(0),
                confidenceThreshold: z.number().min(0).max(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(), // V20.6: User Requested Feature Flag
                directProjectionOffset: z.number().min(0), // V20.6: Tuning for LI/Direct stability
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']), // V20.4: HFO Trigram Bagua
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                oneEuroRodMinCutoff: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                fireScale: z.number().min(0.1).default(1.0),
                fireIntensity: z.number().min(0.1).default(1.0),
                palmRodMultiplier: z.number().min(0.5).max(10), // V18: Palm-width based scaling
                showLaserBeam: z.boolean(),
                predictiveLookahead: z.number().min(0)
            }),
            anatomy: z.object({
                palmWidthCm: z.number().min(3).max(15),
                rodExtensionMultiplier: z.number().min(0.1).max(10)
            }),
            visuals: z.object({
                engine: z.literal('BABYLON'),
                variant: z.string()
            }).optional(),
            canvasCursors: z.object({
                radiusBase: z.number().default(40).optional(),
                gageHeight: z.number().default(80).optional(),
                readinessGaugeHeight: z.number().default(80).optional(),
                gageOffset: z.number().default(20).optional()
            }).optional()
        });

        // ðŸ—ï¸ PORT 1: FUSION CONTRACTS
        const FusionSchema = z.object({
            screenX: z.number(),
            screenY: z.number(),
            normX: z.number(),
            normY: z.number(),
            uiNormX: z.number().optional(), // V28.5: UPE Parity Hardening
            uiNormY: z.number().optional(), // V28.5: UPE Parity Hardening
            normZ: z.number(), // V24.21: Depth Parity
            rawX: z.number(), // V18: Required for laser origin
            rawY: z.number(), // V18: Required for laser origin
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(),
            confidence: z.number(),
            isPalmFacing: z.boolean(),
            normalZ: z.number(),
            palmConeAngle: z.number(), // V20.3: Anatomical Stability Factor
            palmNormal: z.object({
                x: z.number(),
                y: z.number(),
                z: z.number()
            }),
            readinessScore: z.number().min(0).max(1),
            skeletonAlpha: z.number().default(1.0), // V24.22: Fading on tracking loss
            handIndex: z.number(),
            pointerId: z.number(), // V24.4: Stable ABI ID
            curls: z.object({
                index: z.number(),
                middle: z.number(),
                ring: z.number(),
                pinky: z.number()
            }),
            landmarks: z.array(z.object({ x: z.number(), y: z.number(), z: z.number() })).optional(), // V24.17: Skeletal Fabric
            timestamp: z.number().optional()
        });

        const LandmarkSchema = z.object({ x: z.number(), y: z.number(), z: z.number() });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        // P1 Universal Fabric Envelope (CloudEvents-inspired, but local-only for v10.1)
        // Non-breaking: existing consumers keep using systemState.dataFabric.
        const FabricEnvelopeSchema = z.object({
            specversion: z.string(),
            id: z.string(),
            type: z.string(),
            source: z.string(),
            subject: z.string().optional(),
            time: z.string(),
            datacontenttype: z.string().optional(),
            monotonicMs: z.number().optional(),
            dt: z.number().optional(),
            data: DataFabricSchema
        });

        // --- P1: v11.1 Multi-App Contracts (SSOT) ---
        // Invariant: schemas live only here (P1 authority).
        window.Contracts = window.Contracts || (() => {
            const TargetPolicySchema = z.enum(['ACTIVE_APP_ONLY', 'ACTIVE_APP_OR_FALLBACK', 'GLOBAL']);

            // NOTE: This is an additive contract used by P7 AppHost; runtime fields are passthrough.
            const AppManifestSchema = z.object({
                appId: z.string().min(1),
                title: z.string().min(1),
                kind: z.enum(['iframe', 'overlay']).default('iframe'),
                entrypoint: z.string().optional(),
                tags: z.array(z.string()).optional(),
                targetPolicy: TargetPolicySchema.optional()
            }).passthrough();

            const IntentManifestSchema = z.object({
                id: z.string().min(1),
                type: z.string().min(1),
                ts: z.string().min(1),
                data: z.any(),
                subject: z.string().optional(),
                source: z.string().optional()
            }).passthrough();

            return Object.freeze({ TargetPolicySchema, AppManifestSchema, IntentManifestSchema });
        })();

        const CoordinateSchema = FusionSchema;

        // --- PRODUCTION STATE ---
        const systemState = {
            parameters: {
                ui: { showTutorial: true },
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                p3: {
                    // Adapter selection can be forced via URL flag: ?flag-p3-adapter-standard=true
                    adapter: isFlagEnabled('p3-adapter-standard') ? 'standard' : 'auto',
                    // Click synthesis is controlled by the existing legacy flag (can be disabled via URL)
                    enableClickSynthesis: isFlagEnabled('p3-legacy-click'),
                    tapMoveThresholdPx: 6
                },
                landmarks: {
                    minConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    minPresenceConfidence: 0.5,
                    numHands: 2,
                    showSkeleton: true,
                    skeletonFadeTimeMs: 400, // V26: Time to fade out
                    skeletonInactivityTimeoutMs: 1500 // V26: Time before pruning stale skeleton
                },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.70, exitThreshold: 0.55 },
                fsm: {
                    hysteresisHigh: 0.88,
                    hysteresisLow: 0.64,
                    chargeTimeMs: 200,
                    releaseTimeMs: 200,
                    coastDrainTimeMs: 1200, // Slower drain for Inertia [V16]
                    tensionMs: 100
                },
                readiness: {
                    fillMultiplier: 1.0,
                    drainMultiplier: 1.0,
                    coastDrainMultiplier: 1.25 // COAST drains faster by default
                },
                coasting: { timeoutMs: 150, confidenceThreshold: 0.4 },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true, // V20.6 Feature Flag (Default ON)
                    directProjectionOffset: 0.04, // V20.6 Custom Offset for Direct projection
                    cursorTheme: 'LI', // V20.5 stable evolution
                    oneEuroMinCutoff: 0.85,
                    oneEuroBeta: 0.02,
                    oneEuroRodMinCutoff: 0.8,
                    planckStiffness: 4.5,
                    planckDamping: 1.2,
                    palmRodMultiplier: 0.64,
                    showLaserBeam: true,
                    showTrailMesh: false, // V24.17: Off by default
                    showHFOClaw: false, // V24.18: Off by default
                    predictiveLookahead: 0.5,
                    fireScale: 2.0, // V24.11 Default
                    fireIntensity: 2.0 // V24.11 Default
                },
                anatomy: {
                    palmWidthCm: 8,
                    rodExtensionMultiplier: 0.125
                },
                excalidraw: {
                    opacity: 0.8,
                    enabled: true,
                    activeTool: 'freedraw',
                    zoomFactor: 1.2, // V37: Applied 20% Safety Margin to bring bottom UI into safe reach zone
                },
                apps: {
                    overlay: {
                        opacity: 1.0,
                        zoom: 1.0,
                        rememberPerApp: true
                    },
                    perApp: {}
                },
                visuals: {
                    engine: 'BABYLON',
                    variant: 'PHOENIX_CORE'
                },
                ports: {
                    p0_recognizer: 'MEDIAPIPE_HANDS',
                    p1_fusion: 'UNIVERSAL_PROJECTION_V28',
                    p2_fsm: 'SOVEREIGN_4_STATE',
                    p3_injector: 'HYDRA_ADAPTER_PULSE',
                },
                canvasCursors: {
                    radiusBase: 40,
                    gageHeight: 80,
                    readinessGaugeHeight: 80,
                    gageOffset: 20
                },
                p0Active: false,
                devMode: false,
                essentialsMode: true // V39: Kiosk-first progressive disclosure
            },
            fsm: {
                currentState: 'IDLE',
                lastState: 'IDLE',
                lastCommitTime: 0,
                commitExitStartTime: 0,
                primaryHandIndex: null,
                nematocystTargetLock: null,
                lastTarget: null,
                activePointers: {} // V24.4: Tracks down status per pointerId
            },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [],
                readinessScores: [0, 0, 0, 0], // Per-hand leaky buckets
                fsmStates: ['IDLE', 'IDLE', 'IDLE', 'IDLE'], // Per-hand FSM states [V15]
                palmFacingStates: [false, false, false, false], // Hysteresis state
                lastPalmFacingTimes: [0, 0, 0, 0], // Tension/Coyote timers
                lastData: [null, null, null, null], // Per-hand coasting data
                lastTrackingTimes: [0, 0, 0, 0], // V26: Tracking heartbeats
                lastMovementTimes: [0, 0, 0, 0], // V26: Inactivity detection
                lastLandmarks: [null, null, null, null], // V26: Ghost landmarks for fading
                coastStartTimes: [0, 0, 0, 0], // Per-hand coast timers
                filters: [null, null, null, null], // OneEuroFilters
                rodFilters: [null, null, null, null], // V19.2: Stabilize rod length
                anchorFilters: [null, null, null, null], // V19.2: Stabilize anchor point
                directionFilters: [null, null, null, null], // V19.2: Stabilize rod direction
                physicsState: [null, null, null, null], // Mass-Spring state

                // ðŸŽ¯ V28.0 UNIVERSAL PROJECTION ENGINE (UPE)
                // Centralized parity logic for all coordinate substrates
                // V28.0 FIX: Internal drawing (Fire/Skeleton) MUST use buffer space.
                // Interaction (PointerEvents) MUST use viewport space.
                toBufferX: (nx) => nx * (systemState.p0.canvas?.width || 1280),
                toBufferY: (ny) => ny * (systemState.p0.canvas?.height || 720),
                toViewportX: (nx) => {
                    const b = systemState.ui.viewBounds || { width: 1280, offsetX: 0, containerRect: { left: 0 } };
                    // V33: Use cached containerRect for Option 1 performance stability
                    const left = b.containerRect?.left || 0;
                    return left + b.offsetX + (nx * b.width);
                },
                toViewportY: (ny) => {
                    const b = systemState.ui.viewBounds || { height: 720, offsetY: 0, containerRect: { top: 0 } };
                    const top = b.containerRect?.top || 0;
                    return top + b.offsetY + (ny * b.height);
                }
            },
            ui: {
                gestures: null,
                palm: null,
                palmCtx: null,
                fsm: null,
                fsmCtx: null,
                juiceLayers: [],
                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0, containerRect: { left: 0, top: 0, width: 0, height: 0 } }
            },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
            ,
            // Optional: canonical envelope shaped by P1 (kept separate for back-compat)
            dataFabricEnvelope: null
        };

        // --- P4: VISUAL JUICE (BabylonJS Substrate) ---
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // thumb
            [0, 5], [5, 6], [6, 7], [7, 8], // index
            [0, 9], [9, 10], [10, 11], [11, 12], // middle
            [0, 13], [13, 14], [14, 15], [15, 16], // ring
            [0, 17], [17, 18], [18, 19], [19, 20], // pinky
            [5, 9], [9, 13], [13, 17] // palm
        ];

        class BabylonJuiceSubstrate {
            constructor(container) {
                // V24.4: Hard Enforcement of Single-Engine Invariant
                window.hfoLifecycle.dispose('BABYLON_ENGINE');

                this.canvas = document.createElement('canvas');
                this.canvas.id = 'babylon-canvas';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '0';
                this.canvas.style.top = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.zIndex = '9';
                this.canvas.style.display = 'none'; // Hidden by default
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                this.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -10), this.scene);
                this.camera.setTarget(BABYLON.Vector3.Zero());

                this.light = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 0, -5), this.scene);
                this.light.intensity = 0.8;
                this.light.diffuse = new BABYLON.Color3(1, 0.4, 0.1);

                this.emitterRoots = [];
                this.particleSystems = [];
                this.trails = []; // V24.16: Hybrid Geometric Core
                this.skeletons = []; // V24.17: Skeletal Data Fabric
                this.idleIndicators = []; // V38: Leaky Bucket Visualization
                this.lastPositions = [];
                this.perfMultiplier = 1.0; // Math.max(0.2, Math.min(this.perfMultiplier, 1.5));

                this.engine.runRenderLoop(() => {
                    if (this.canvas && this.canvas.style.display !== 'none') {
                        this.scene.render();

                        // V24.15: 30FPS Mobile Optimization Target
                        const fps = this.engine.getFps();
                        if (fps > 0) {
                            const target = 30; // 30Hz Baseline for Midrange Mobile
                            const factor = fps / target;
                            this.perfMultiplier = this.perfMultiplier * 0.95 + factor * 0.05;
                            this.perfMultiplier = Math.max(0.2, Math.min(this.perfMultiplier, 1.5));
                        }
                    }
                });

                window.hfoLifecycle.register('BABYLON_ENGINE', this);
            }

            dispose() {
                if (this.engine) {
                    // Loop through all hand-specific resources
                    this.emitterRoots.forEach((root, i) => {
                        this.particleSystems[i]?.forEach(s => s.dispose());
                        this.trails[i]?.dispose();
                        this.skeletons[i]?.root.dispose();
                        root?.dispose();
                    });

                    this.idleIndicators.forEach(ind => ind?.group?.dispose());

                    this.engine.dispose();
                    this.engine = null;
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                console.log("[BABYLON] Engine and all associated trails/emitters disposed via Lifecycle hook.");
            }

            update(cursors) {
                const width = this.engine.getRenderWidth();
                const height = this.engine.getRenderHeight();

                const activeIndices = new Set();

                cursors.forEach((c) => {
                    const i = c.handIndex;
                    activeIndices.add(i);

                    if (!this.emitterRoots[i]) this.createEffect(i);
                    const root = this.emitterRoots[i];
                    const systems = this.particleSystems[i];
                    const trail = this.trails[i];
                    const skeleton = this.skeletons[i];

                    const isActive = (c.fsmState !== 'IDLE');
                    const isCoast = (c.fsmState === 'COAST');
                    const showSkeleton = systemState.parameters.landmarks.showSkeleton;
                    const hasLandmarks = !!(c.landmarks && c.landmarks.length > 0);

                    // V24.18: Sovereign Skeleton Visibility (IDLE, READY, COMMIT)
                    // V24.22: Fading logic for Tracking Loss / COAST
                    if (skeleton) {
                        const shouldShowSkeleton = showSkeleton && hasLandmarks;
                        skeleton.root.setEnabled(shouldShowSkeleton);

                        if (shouldShowSkeleton) {
                            const fadeAlpha = c.skeletonAlpha !== undefined ? c.skeletonAlpha : 1.0;
                            // Apply fading to children
                            skeleton.root.getChildMeshes().forEach(m => {
                                m.visibility = fadeAlpha;
                            });

                            // Update 21 landmark spheres
                            c.landmarks.forEach((lm, lIndex) => {
                                // V24.18 Perspective Alignment:
                                // projectToWorld correctly handles the perspective shift for depth.
                                // V28.5 HARDENED: Use landmarks directly (already mirrored/scaled in Fabric)
                                const targetZ = lm.z * 1.5;
                                const lmPos = this.projectToWorld(lm.x, lm.y, width, height, targetZ);
                                skeleton.spheres[lIndex].position.copyFrom(lmPos);
                            });

                            // Update Index Claw (Link from Tip 8 to pointer root)
                            const showClaw = systemState.parameters.physics.showHFOClaw || false;
                            skeleton.claw.setEnabled(showClaw && isActive); // Only show claw if in an active pointing state

                            if (showClaw && isActive) {
                                const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height);
                                const tipPos = skeleton.spheres[8].position;
                                const clawPoints = [tipPos, targetPos];
                                skeleton.claw = BABYLON.MeshBuilder.CreateLines("claw" + i, { points: clawPoints, instance: skeleton.claw }, this.scene);

                                // Set Claw Color based on state
                                const isCommit = (c.fsmState === 'COMMIT');
                                skeleton.claw.color = isCommit ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0.4, 0);
                            }

                            // Update wire skeleton bones
                            HAND_CONNECTIONS.forEach((conn, bIndex) => {
                                const p1 = skeleton.spheres[conn[0]].position;
                                const p2 = skeleton.spheres[conn[1]].position;
                                const bonePoints = [p1, p2];
                                skeleton.bones[bIndex] = BABYLON.MeshBuilder.CreateLines("bone" + i + "_" + bIndex, { points: bonePoints, instance: skeleton.bones[bIndex] }, this.scene);
                            });
                        }
                    }

                    if (isActive) {
                        if (this.idleIndicators[i]) this.idleIndicators[i].group.setEnabled(false);
                        systems.forEach(s => { if (!s.isStarted()) s.start(); });

                        // V24.17: Toggleable TrailMesh (Off by default)
                        if (trail) {
                            trail.isVisible = systemState.parameters.physics.showTrailMesh || false;
                        }

                        // Pixel to World Projection for the pointer root
                        // V28.5: Use unified uiNorm coordinates to bypass Zod Scythe and parity drift
                        const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height, (c.normZ || 0) * 1.5);

                        let motionVector = BABYLON.Vector3.Zero();
                        if (this.lastPositions[i]) {
                            motionVector = targetPos.subtract(this.lastPositions[i]);
                        }
                        this.lastPositions[i] = targetPos.clone();
                        root.position.copyFrom(targetPos);

                        // V24.10: Plasma Needle Scion (Fire Lab V3 Aesthetics)
                        const scale = systemState.parameters.physics.fireScale || 1.0;
                        const intensity = systemState.parameters.physics.fireIntensity || 1.0;

                        if (c.fsmState === 'COMMIT') {
                            if (trail) {
                                trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1);
                                trail.material.alpha = 0.3;
                            }
                            systems.forEach(s => {
                                s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                this.tuneFireSystem(s, motionVector, scale, intensity, true);
                            });
                        } else {
                            // READY, COAST, etc.
                            const isCyan = (c.fsmState === 'COAST'); // Coast maintains visual of last state (often COMMIT)
                            if (isCyan) {
                                // COAST keeps Cyan if it was COMMIT-ing
                                if (trail) { trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1); }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                    s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                });
                            } else {
                                if (trail) {
                                    trail.material.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
                                    trail.material.alpha = 0.2;
                                }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 0.5);
                                    s.color2 = new BABYLON.Color4(1, 0.2, 0, 0.2);
                                    this.tuneFireSystem(s, motionVector, scale, intensity, false);
                                });
                            }
                        }
                    } else {
                        systems.forEach(s => s.stop());
                        if (trail) trail.isVisible = false;
                        this.lastPositions[i] = null;

                        // V40: Update Idle Cursor / Leaky Bucket Visuals (Fixed Fading)
                        if (this.idleIndicators[i]) {
                            const ind = this.idleIndicators[i];
                            const fadeAlpha = c.skeletonAlpha !== undefined ? c.skeletonAlpha : 1.0;
                            const showIdle = hasLandmarks && fadeAlpha > 0.01;
                            ind.group.setEnabled(showIdle);

                            if (showIdle) {
                                const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height, (c.normZ || 0) * 1.5);
                                ind.group.position.copyFrom(targetPos);

                                const readiness = systemState.p1.readinessScores[i] || 0;
                                const dwellRatio = readiness;
                                ind.fill.scaling = new BABYLON.Vector3(dwellRatio, dwellRatio, 1);

                                // V40: Sync Alpha with Skeleton fading
                                if (ind.fill.material) ind.fill.material.alpha = 0.5 * fadeAlpha;
                                if (ind.ring.material) ind.ring.material.alpha = 0.4 * fadeAlpha;
                                if (ind.marker && ind.marker.material) ind.marker.material.alpha = 0.2 * fadeAlpha;

                                // Fire color shift
                                if (readiness >= systemState.parameters.fsm.hysteresisHigh) {
                                    ind.fill.material.emissiveColor = new BABYLON.Color3(1, 1, 0.4); // Ignite Yellow
                                } else {
                                    ind.fill.material.emissiveColor = new BABYLON.Color3(1, 0.4, 0.1); // Amber
                                }
                            }
                        }
                    }
                });

                // V24.16: Production Hardening (Prune Lost Emitters)
                // Hide or Dispose emitters for hands not present in cursors
                this.emitterRoots.forEach((root, i) => {
                    if (!activeIndices.has(i)) {
                        this.particleSystems[i]?.forEach(s => s.stop());
                        if (this.trails[i]) this.trails[i].isVisible = false;
                        if (this.skeletons[i]) this.skeletons[i].root.setEnabled(false);
                        if (this.idleIndicators[i]) this.idleIndicators[i].group.setEnabled(false); // V40: Fixed ghost dots on track loss

                        // If tracking is lost entirely (no bucket level), dispose of resources
                        const readiness = systemState.p1.readinessScores[i] || 0;
                        if (readiness <= 0 && this.emitterRoots[i]) {
                            console.log(`[BABYLON] Pruning stale emitter for Hand ${i}`);
                            this.particleSystems[i]?.forEach(s => s.dispose());
                            this.trails[i]?.dispose();
                            this.skeletons[i]?.root.dispose();
                            this.idleIndicators[i]?.group.dispose();
                            this.emitterRoots[i]?.dispose();

                            delete this.particleSystems[i];
                            delete this.trails[i];
                            delete this.skeletons[i];
                            delete this.idleIndicators[i];
                            delete this.emitterRoots[i];
                            this.lastPositions[i] = null;
                        }
                    }
                });
            }

            projectToWorld(nx, ny, width, height, targetZ = 0) {
                const vectorNear = new BABYLON.Vector3(nx * width, ny * height, 0);
                const worldCoordNear = BABYLON.Vector3.Unproject(
                    vectorNear, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const vectorFar = new BABYLON.Vector3(nx * width, ny * height, 1);
                const worldCoordFar = BABYLON.Vector3.Unproject(
                    vectorFar, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const direction = worldCoordFar.subtract(worldCoordNear).normalize();
                if (Math.abs(direction.z) > 0.0001) {
                    const distance = (targetZ - worldCoordNear.z) / direction.z;
                    return worldCoordNear.add(direction.scale(distance));
                }
                return worldCoordNear;
            }

            tuneFireSystem(s, motionVector, scale, intensity, isHigh) {
                const speed = motionVector.length();
                const densityMultiplier = 1.0 + Math.min(speed * (isHigh ? 20 : 10), isHigh ? 2.5 : 2.0);
                const baseRate = (isHigh ? 600 : 250) * scale;
                s.emitRate = baseRate * densityMultiplier * this.perfMultiplier;

                const jitter = (isHigh ? 0.03 * (1.0 + speed) : 0.06);
                s.minEmitBox = motionVector.scale(isHigh ? -1.0 : -0.8).add(new BABYLON.Vector3(-jitter, isHigh ? -0.02 : -jitter, -jitter));
                s.maxEmitBox = new BABYLON.Vector3(jitter, isHigh ? 0.02 : jitter, jitter);

                s.minSize = (isHigh ? 0.06 : 0.1) * scale;
                s.maxSize = (isHigh ? 0.24 : 0.3) * scale;
                s.minLifeTime = isHigh ? 0.25 : 0.4;
                s.maxLifeTime = isHigh ? 0.5 : 0.8;
                s.gravity = new BABYLON.Vector3(0, (isHigh ? 4 : 2) * intensity, 0);
            }

            createSkeleton(index) {
                const root = new BABYLON.TransformNode("skeleton" + index, this.scene);
                const spheres = [];
                const bones = [];

                const mat = new BABYLON.StandardMaterial("skeletonMat" + index, this.scene);
                mat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Bone White
                mat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                mat.alpha = 0.12; // V24.18: Transparent Bone
                mat.disableLighting = true;

                for (let i = 0; i < 21; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere("tm_" + index + "_" + i, { diameter: 0.12 }, this.scene);
                    sphere.material = mat;
                    sphere.parent = root;
                    spheres.push(sphere);
                }

                // Initial claw line
                const claw = BABYLON.MeshBuilder.CreateLines("claw" + index, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                claw.color = new BABYLON.Color3(0.9, 0.9, 1.0); // Bright Bone Claw
                claw.parent = root;
                claw.alpha = 0.2;

                // Wire skeleton bones
                HAND_CONNECTIONS.forEach((_, bIndex) => {
                    const bone = BABYLON.MeshBuilder.CreateLines("bone" + index + "_" + bIndex, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                    bone.color = new BABYLON.Color3(0.8, 0.8, 0.8);
                    bone.alpha = 0.08; // Delicate Bone Structure
                    bone.parent = root;
                    bones.push(bone);
                });

                return { root, spheres, bones, claw };
            }

            createIdleIndicator(index) {
                const group = new BABYLON.TransformNode("idleGroup" + index, this.scene);

                // V38: Hollow Ring (Background)
                const ring = BABYLON.MeshBuilder.CreateTorus("idleRing" + index, {
                    diameter: 0.22,
                    thickness: 0.015,
                    tessellation: 64
                }, this.scene);
                ring.rotation.x = Math.PI / 2;
                const ringMat = new BABYLON.StandardMaterial("idleRingMat" + index, this.scene);
                ringMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                ringMat.alpha = 0.4;
                ringMat.disableLighting = true;
                ring.material = ringMat;
                ring.parent = group;

                // V38: Readiness Fill (Progress Disc)
                const fill = BABYLON.MeshBuilder.CreateDisc("idleFill" + index, { radius: 0.1, tessellation: 64 }, this.scene);
                const fillMat = new BABYLON.StandardMaterial("idleFillMat" + index, this.scene);
                fillMat.emissiveColor = new BABYLON.Color3(1, 0.4, 0.1); // Amber Fire
                fillMat.alpha = 0.5;
                fillMat.disableLighting = true;
                fill.material = fillMat;
                fill.parent = group;
                fill.scaling = BABYLON.Vector3.Zero();

                // V38: Threshold Marker (High Hysteresis)
                const highThreshold = systemState.parameters.fsm.hysteresisHigh || 0.88;
                const marker = BABYLON.MeshBuilder.CreateTorus("idleMarker" + index, {
                    diameter: 0.22 * highThreshold,
                    thickness: 0.005,
                    tessellation: 64
                }, this.scene);
                marker.rotation.x = Math.PI / 2;
                const markerMat = new BABYLON.StandardMaterial("markerMat" + index, this.scene);
                markerMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                markerMat.alpha = 0.2;
                markerMat.disableLighting = true;
                marker.material = markerMat;
                marker.parent = group;

                group.setEnabled(false);
                return { group, ring, fill, marker };
            }

            createEffect(index) {
                const root = BABYLON.MeshBuilder.CreateSphere("emitter" + index, { diameter: 0.05 }, this.scene);
                root.isVisible = false;
                this.emitterRoots[index] = root;

                // Initialize Skeleton
                this.skeletons[index] = this.createSkeleton(index);

                // Initialize Idle Indicator [V38]
                this.idleIndicators[index] = this.createIdleIndicator(index);

                // V24.16: Hybrid Geometric Core (Exemplar TrailMesh)
                // Diameter 0.08, Length 30, Auto-shrink enabled.
                const trail = new BABYLON.TrailMesh("trail" + index, root, this.scene, 0.08, 30, true);
                const trailMat = new BABYLON.StandardMaterial("trailMat" + index, this.scene);
                trailMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1);
                trailMat.alpha = 0.4;
                trailMat.disableLighting = true;
                trail.material = trailMat;
                trail.isVisible = false;
                this.trails[index] = trail;

                const defaultTexture = "./lib/models/flare.png";

                // PHOENIX CORE EFFECT
                const fire = new BABYLON.ParticleSystem("fire", 2000, this.scene);
                fire.particleTexture = new BABYLON.Texture(defaultTexture, this.scene);
                fire.emitter = root;
                fire.minEmitBox = new BABYLON.Vector3(-0.05, 0, -0.05);
                fire.maxEmitBox = new BABYLON.Vector3(0.05, 0, 0.05);
                fire.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 1.0);
                fire.color2 = new BABYLON.Color4(1, 0.2, 0, 0.5);
                fire.colorDead = new BABYLON.Color4(0, 0, 0, 0);
                fire.minLifeTime = 0.1; fire.maxLifeTime = 0.3;
                fire.emitRate = 400;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(0, 2, 0);
                this.particleSystems[index] = [fire];
            }

            resize() { this.engine.resize(); }
        }

        window.hfoState = systemState;

        // --- P2: AGNOSTIC PHYSICS MANIFOLD ---
        /**
         * IPhysicsAdapter: Interface for vendor-agnostic physics steering.
         * Decouples the FSM and Pointer logic from specific engines (Planck, Matter, Rapier).
         */
        class IPhysicsAdapter {
            update(targetX, targetY, dt) { throw new Error("Not implemented"); }
            setParams(params) { throw new Error("Not implemented"); }
            reset(x, y) { throw new Error("Not implemented"); }
            setBallistic(enabled) { throw new Error("Not implemented"); }
            getTelemetry() { return {}; }
        }

        /**
         * PlanckPhysicsAdapter: High-fidelity deterministic Box2D (Planck.js) implementation.
         * Uses MKS scaling (1 meter = 100 pixels) for numerical stability.
         */
        class PlanckPhysicsAdapter extends IPhysicsAdapter {
            constructor(stiffness = 5.0, damping = 0.7) {
                super();
                this.SCALE = 100.0; // 100px = 1m
                this.world = planck.World({ gravity: planck.Vec2(0, 0) });
                this.stiffness = stiffness;
                this.damping = damping;
                this.isBallistic = false;

                // Cursor Body (Dynamic)
                this.cursor = this.world.createBody({
                    type: 'dynamic',
                    position: planck.Vec2(0, 0),
                    linearDamping: 2.0, // Reduced for smoother glide
                    angularDamping: 5.0
                });
                this.cursor.createFixture(planck.Circle(0.1), { density: 1.0, friction: 0.3 });

                // Target Body (Kinematic)
                this.target = this.world.createBody({ type: 'kinematic', position: planck.Vec2(0, 0) });

                // Constant Distance Joint (Rod) or Spring (DistanceJoint with frequency)
                this.joint = this.world.createJoint(planck.DistanceJoint({
                    bodyA: this.target,
                    bodyB: this.cursor,
                    anchorA: planck.Vec2(0, 0),
                    anchorB: planck.Vec2(0, 0),
                    frequencyHz: stiffness, // Stiffness as frequency
                    dampingRatio: damping,    // Damping
                    length: 0
                }));

                this.lastPos = { x: 0, y: 0 };
            }

            setBallistic(enabled) {
                this.isBallistic = enabled;
                if (enabled) {
                    this.joint.setFrequency(0); // Effectively detach
                } else {
                    this.joint.setFrequency(this.stiffness);
                }
            }

            update(targetX, targetY, dt) {
                if (!this.isBallistic) {
                    const tx = targetX / this.SCALE;
                    const ty = targetY / this.SCALE;
                    this.target.setPosition(planck.Vec2(tx, ty));
                }

                // Step world
                this.world.step(Math.min(dt / 1000, 0.033));

                const pos = this.cursor.getPosition();
                this.lastPos = { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
                return this.lastPos;
            }

            setParams(params) {
                this.stiffness = params.stiffness || 5.0;
                this.damping = params.dampingRatio || 0.7;
                if (!this.isBallistic) {
                    this.joint.setFrequency(this.stiffness);
                }
                this.joint.setDampingRatio(this.damping);
            }

            reset(x, y) {
                const px = x / this.SCALE;
                const py = y / this.SCALE;
                this.cursor.setPosition(planck.Vec2(px, py));
                this.target.setPosition(planck.Vec2(px, py));
                this.cursor.setLinearVelocity(planck.Vec2(0, 0));
            }

            getTelemetry() {
                const vel = this.cursor.getLinearVelocity();
                return {
                    velocity: { x: vel.x * this.SCALE, y: vel.y * this.SCALE },
                    speed: vel.length() * this.SCALE,
                    position: { ...this.lastPos }
                };
            }
        }

        // --- COORDINATE SUBSTRATE: 1EURO ---
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.0) {
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.xPrev = null;
                this.dxPrev = 0;
            }

            filter(x, rate = 30) {
                if (this.xPrev === null) {
                    this.xPrev = x;
                    return x;
                }
                const dx = (x - this.xPrev) * rate;
                const edx = this.alpha(rate, 1.0); // Simple smoothing for derivative
                const dxHat = edx * dx + (1 - edx) * this.dxPrev;
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(rate, cutoff);
                const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat;
                this.dxPrev = dxHat;
                return xHat;
            }

            alpha(rate, cutoff) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                const te = 1.0 / rate;
                return 1.0 / (1.0 + tau / te);
            }
        }

        class MassSpringDampener {
            constructor(stiffness = 0.15, damping = 0.05) {
                this.pos = null;
                this.vel = { x: 0, y: 0 };
                this.stiffness = stiffness;
                this.damping = damping;
            }

            update(targetX, targetY) {
                if (this.pos === null) {
                    this.pos = { x: targetX, y: targetY };
                    return this.pos;
                }
                const forceX = (targetX - this.pos.x) * this.stiffness;
                const forceY = (targetY - this.pos.y) * this.stiffness;

                this.vel.x = this.vel.x * (1 - this.damping) + forceX;
                this.vel.y = this.vel.y * (1 - this.damping) + forceY;

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                return this.pos;
            }
        }

        // --- P1 BRIDGER: CONTRACT ENFORCEMENT ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]];
                    const b = landmarks[indices[i + 1]];
                    const c = landmarks[indices[i + 2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                    const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static validateConfig(config) {
                try {
                    return ConfigSchema.parse(config);
                } catch (e) {
                    console.error("ðŸš¨ P1_CONFIG_CONTRACT_BREACH:", e.errors);
                    return null;
                }
            }

            static fuse(results, dt) {
                const cursors = [];
                const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;

                for (let i = 0; i < numHands; i++) {
                    const landmarks = results.landmarks?.[i];
                    const bestGesture = results.gestures?.[i]?.[0];
                    let cursorData = null;

                    // V26: Tracking Heartbeat
                    if (landmarks) systemState.p1.lastTrackingTimes[i] = now;
                    const tTracking = now - (systemState.p1.lastTrackingTimes[i] || 0);
                    const isTrackingLost = !landmarks;

                    if (landmarks) {
                        try {
                            const validatedLandmarks = landmarks.map(l => LandmarkSchema.parse(l));
                            const { width, height } = systemState.p0.videoBounds || { width: 0, height: 0 };
                            const lm = validatedLandmarks;

                            // V26: Inactivity Detection (Skeleton Dormancy)
                            const lastLms = systemState.p1.lastData[i]?.landmarks;
                            if (lastLms && lastLms[8]) {
                                const dx = lm[8].x - lastLms[8].x;
                                const dy = lm[8].y - lastLms[8].y;
                                if (Math.sqrt(dx * dx + dy * dy) > 0.005) systemState.p1.lastMovementTimes[i] = now;
                            } else {
                                systemState.p1.lastMovementTimes[i] = now;
                            }
                            const tMovement = now - (systemState.p1.lastMovementTimes[i] || now);
                            const dormancyAlpha = tMovement < 3000 ? 1.0 : Math.max(0, 1.0 - (tMovement - 3000) / 1000);

                            // V20.3: ANATOMICAL STABILITY (Hardened Rod)
                            const p5 = lm[5];
                            const p17 = lm[17];
                            const p0_palm = lm[0];

                            // Observed 3D Palm Span (Index MCP to Pinky MCP) - Absolute Measure
                            const observedPalmSpan = Math.sqrt(
                                (p5.x - p17.x) ** 2 +
                                (p5.y - p17.y) ** 2 +
                                (p5.z - p17.z) ** 2
                            ) || 1e-6;

                            // V20.3: Calculate Palm Orientation / normalZ Early for stabilization
                            const v1_palm = { x: p5.x - p0_palm.x, y: p5.y - p0_palm.y, z: p5.z - p0_palm.z };
                            const v2_palm = { x: p17.x - p0_palm.x, y: p17.y - p0_palm.y, z: p17.z - p0_palm.z };
                            const cross_palm = {
                                x: (v1_palm.y * v2_palm.z - v1_palm.z * v2_palm.y) || 0,
                                y: (v1_palm.z * v2_palm.x - v1_palm.x * v2_palm.z) || 0,
                                z: (v1_palm.x * v2_palm.y - v1_palm.y * v2_palm.x) || 1
                            };
                            const mag_palm = Math.sqrt(cross_palm.x ** 2 + cross_palm.y ** 2 + cross_palm.z ** 2) || 1;
                            const nz = cross_palm.z / mag_palm;
                            const normalZ = Math.abs(nz);
                            const palmConeAngle = Math.acos(Math.min(1.0, normalZ));

                            // V20.3: Harden Rod length with Palm Cone Angle damping to stop longitudinal bouncing
                            if (!systemState.p1.rodFilters[i]) {
                                systemState.p1.rodFilters[i] = new OneEuroFilter(systemState.parameters.physics.oneEuroRodMinCutoff, systemState.parameters.physics.oneEuroBeta);
                            }
                            // Adaptive cutoff: smoother if tilting away (noisy Z)
                            systemState.p1.rodFilters[i].minCutoff = normalZ > 0.7 ?
                                systemState.parameters.physics.oneEuroRodMinCutoff :
                                systemState.parameters.physics.oneEuroRodMinCutoff * 0.5;

                            let baseRodLength;
                            const theme = systemState.parameters.physics.cursorTheme;
                            if (theme === 'LI') {
                                // V20.6: User Tunable Fixed Standoff for Fire (Li) stability
                                baseRodLength = systemState.parameters.physics.directProjectionOffset;
                            } else {
                                baseRodLength = observedPalmSpan * systemState.parameters.anatomy.rodExtensionMultiplier;
                            }
                            const rodLength = systemState.p1.rodFilters[i].filter(baseRodLength);

                            // V19.1: Anchor at Index Tip (8), Project further based on Palm Span
                            const mcp = lm[5];
                            const tipRaw = lm[8];
                            const dx_dir = tipRaw.x - mcp.x;
                            const dy_dir = tipRaw.y - mcp.y;
                            const dz_dir = tipRaw.z - mcp.z;
                            const mag_dir = Math.sqrt(dx_dir ** 2 + dy_dir ** 2 + dz_dir ** 2) || 1e-6;

                            // Projected point starts at Tip (8) and extends rodLength
                            const projectedPoint = {
                                x: tipRaw.x + (dx_dir / mag_dir) * rodLength,
                                y: tipRaw.y + (dy_dir / mag_dir) * rodLength,
                                z: tipRaw.z + (dz_dir / mag_dir) * rodLength
                            };

                            // V19.4: MIRROR AWARENESS (Global Port 1 Flip)
                            const isMirror = systemState.parameters.camera.mirror;

                            // V24.17 Fix: Mirror individual landmarks for shared data fabric parity
                            const mirroredLandmarks = lm.map(l => ({
                                x: isMirror ? (1.0 - l.x) : l.x,
                                y: l.y,
                                z: l.z
                            }));

                            const finalProjX = isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x;
                            const finalTipX = isMirror ? (1.0 - tipRaw.x) : tipRaw.x;

                            // V28: OVERSCAN PROJECTION (UPE Enforced - ALL DRAWING IS BUFFER-RELATIVE)
                            const screenX = systemState.p1.toBufferX(finalProjX);
                            const screenY = systemState.p1.toBufferY(projectedPoint.y);

                            // V18: Standardized cursor raw origin for laser beam/firebase
                            const rawX = systemState.p1.toBufferX(finalTipX);
                            const rawY = systemState.p1.toBufferY(tipRaw.y);

                            // V24.17 Fix: Also mirror the raw anchor point and projected point in 3D
                            const mirroredProjected3D = {
                                x: isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x,
                                y: projectedPoint.y,
                                z: projectedPoint.z
                            };

                            // V19.2: Apply Smoothing to Anchor Point (Tip) to stop jitter
                            if (!systemState.p1.anchorFilters[i]) {
                                systemState.p1.anchorFilters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const anchorX = systemState.p1.anchorFilters[i].x.filter(systemState.p1.toBufferX(finalTipX));
                            const anchorY = systemState.p1.anchorFilters[i].y.filter(systemState.p1.toBufferY(tipRaw.y));

                            // Palm Orientation (Calculated bridger_nx, bridger_ny for telemetry/mirroring)
                            let bridger_nx = cross_palm.x / mag_palm;
                            let bridger_ny = cross_palm.y / mag_palm;

                            // V31.1: Distinct Palm vs Back Detection
                            const isPalmVisible = nz < -systemState.parameters.palm.enterThreshold;
                            const isBackVisible = nz > systemState.parameters.palm.enterThreshold;

                            // V19.5: Mirror the normal X-component to match mirrored coordinate space
                            if (isMirror) {
                                bridger_nx = -bridger_nx;
                            }

                            // Palm Facing Hysteresis (80 Enter, 64 Exit)
                            let isPalmFacing = systemState.p1.palmFacingStates[i];
                            if (!isPalmFacing) {
                                // Omni-Hand Tracking: Still support both for basic awareness
                                if (normalZ > systemState.parameters.palm.enterThreshold) isPalmFacing = true;
                            } else {
                                if (normalZ < systemState.parameters.palm.exitThreshold) isPalmFacing = false;
                            }
                            systemState.p1.palmFacingStates[i] = isPalmFacing;

                            const category = bestGesture?.categoryName || 'None';
                            const confidence = bestGesture?.score || 0;

                            // Apply 1EuroFilter (Always applied for landmark jitter)
                            if (!systemState.p1.filters[i]) {
                                systemState.p1.filters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const smoothedX = systemState.p1.filters[i].x.filter(screenX);
                            const smoothedY = systemState.p1.filters[i].y.filter(screenY);

                            // V31.1: FSM Triggers using Emoji Language Logic
                            const fsmState = systemState.p1.fsmStates[i];
                            const isPointing = (category === 'Pointing_Up' && confidence > systemState.parameters.gestures.minGestureConfidence);
                            const hasConfidence = (confidence > systemState.parameters.coasting.confidenceThreshold);

                            const isFacingCamera = isPalmVisible || isBackVisible;
                            if (isFacingCamera) systemState.p1.lastPalmFacingTimes[i] = now;
                            const isCharging = isFacingCamera || (now - systemState.p1.lastPalmFacingTimes[i] < systemState.parameters.fsm.tensionMs);
                            const isCoasting = (fsmState === 'COAST');
                            const shouldFill = isCharging && hasConfidence;

                            // Readiness Energy: intent pre-arm for gestures/effects.
                            // Fill when palm/back faces camera, drain when faced away or in COAST.
                            if (shouldFill) {
                                const fillAmount = (1 / systemState.parameters.fsm.chargeTimeMs) * dt;
                                const fillScaled = fillAmount * systemState.parameters.readiness.fillMultiplier;
                                systemState.p1.readinessScores[i] = Math.min(1, systemState.p1.readinessScores[i] + fillScaled);
                            } else {
                                const drainTime = isCoasting
                                    ? systemState.parameters.fsm.coastDrainTimeMs
                                    : systemState.parameters.fsm.releaseTimeMs;
                                const drainAmount = (1 / drainTime) * dt;
                                const coastScale = isCoasting
                                    ? systemState.parameters.readiness.coastDrainMultiplier
                                    : 1.0;
                                const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * coastScale;
                                systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainScaled);
                            }

                            let fsmStateNew = fsmState;
                            const readiness = systemState.p1.readinessScores[i];
                            const primary = systemState.fsm.primaryHandIndex;
                            const isSeatAvailable = (primary === null || primary === i);

                            // V39.5: Hardened Sovereign FSM (Relaxed READY visual ignition / 1 COMMIT MAX)
                            if (fsmState === 'IDLE') {
                                if (readiness >= systemState.parameters.fsm.hysteresisHigh && (isFacingCamera || isCharging)) fsmStateNew = 'READY';
                            } else if (fsmState === 'READY') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (!hasConfidence) fsmStateNew = 'COAST';
                                // Gated COMMIT: Only 1 hand can interact. Visuals match state.
                                else if (isPointing && isSeatAvailable) {
                                    fsmStateNew = 'COMMIT';
                                    systemState.fsm.primaryHandIndex = i;
                                }
                            } else if (fsmState === 'COMMIT') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (!hasConfidence) fsmStateNew = 'COAST';
                            } else if (fsmState === 'COAST') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (hasConfidence && isFacingCamera) {
                                    // V39.5 REVERT: COAST is no longer terminal to ensure parity with v24.23
                                    fsmStateNew = isPointing ? 'COMMIT' : 'READY';
                                }
                            }
                            systemState.p1.fsmStates[i] = fsmStateNew;

                            let finalX, finalY;
                            const forceDirect = systemState.parameters.physics.useDirectProjection;

                            if (systemState.parameters.physics.mode === 'STATIC_ROD' || forceDirect) {
                                finalX = smoothedX;
                                finalY = smoothedY;
                            } else {
                                // PLANCK_SPRING Mode
                                if (isFlagEnabled('physics-planck') && !(systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter)) {
                                    systemState.p1.physicsState[i] = new PlanckPhysicsAdapter(
                                        systemState.parameters.physics.planckStiffness,
                                        systemState.parameters.physics.planckDamping
                                    );
                                    systemState.p1.physicsState[i].reset(smoothedX, smoothedY);
                                }

                                let physicsPos = { x: smoothedX, y: smoothedY };
                                if (systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter) {
                                    systemState.p1.physicsState[i].setBallistic(fsmStateNew === 'COAST');
                                    systemState.p1.physicsState[i].setParams({
                                        stiffness: systemState.parameters.physics.planckStiffness,
                                        dampingRatio: systemState.parameters.physics.planckDamping
                                    });
                                    physicsPos = systemState.p1.physicsState[i].update(smoothedX, smoothedY, dt);
                                }

                                // V19.2: CLAW RIGID PROJECTION
                                const dx = smoothedX - anchorX;
                                const dy = smoothedY - anchorY;
                                const mag = Math.sqrt(dx * dx + dy * dy) || 1e-6;
                                let ux = dx / mag;
                                let uy = dy / mag;

                                if (!systemState.p1.directionFilters[i]) {
                                    systemState.p1.directionFilters[i] = {
                                        x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                        y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                    };
                                }
                                ux = systemState.p1.directionFilters[i].x.filter(ux);
                                uy = systemState.p1.directionFilters[i].y.filter(uy);
                                const mag_filtered = Math.sqrt(ux * ux + uy * uy) || 1e-6;
                                ux /= mag_filtered; uy /= mag_filtered;

                                const vx = physicsPos.x - anchorX;
                                const vy = physicsPos.y - anchorY;
                                const d_proj = vx * ux + vy * uy;

                                finalX = anchorX + ux * d_proj;
                                finalY = anchorY + uy * d_proj;
                            }

                            const curls = {
                                index: this.calculateCurl(lm, [5, 6, 7, 8]),
                                middle: this.calculateCurl(lm, [9, 10, 11, 12]),
                                ring: this.calculateCurl(lm, [13, 14, 15, 16]),
                                pinky: this.calculateCurl(lm, [17, 18, 19, 20])
                            };

                            const rawCursorData = {
                                screenX: finalX, screenY: finalY,
                                normX: finalX / width, normY: finalY / height,
                                uiNormX: finalX / width, // V28.5: Hardened 1:1 Parity
                                uiNormY: finalY / height, // V28.5: Hardened 1:1 Parity
                                normZ: projectedPoint.z,
                                fsmState: fsmStateNew, gesture: category,
                                confidence, isPalmFacing, readinessScore: readiness,
                                skeletonAlpha: dormancyAlpha, // V26: Fades on stillness
                                handIndex: i, pointerId: 10 + i, // V24.4: Stable Hand ID
                                curls,
                                landmarks: mirroredLandmarks, // Fixed: Mirrored landmarks
                                rawX: anchorX, rawY: anchorY,
                                normalZ: normalZ,
                                palmConeAngle: palmConeAngle,
                                palmNormal: { x: bridger_nx, y: bridger_ny, z: nz },
                                timestamp: now
                            };

                            cursorData = FusionSchema.parse(rawCursorData);
                            systemState.p1.lastData[i] = cursorData;
                        } catch (e) {
                            console.error("ðŸš¨ P1_FUSE_CONTRACT_BREACH:", e);
                        }
                    } else {
                        // Coasting Logic for missing landmarks (V24.3: Ballistic Inertia)
                        const last = systemState.p1.lastData[i];
                        const fsmState = systemState.p1.fsmStates[i];
                        const fadeTime = systemState.parameters.landmarks.skeletonFadeTimeMs || 400;

                        if (last && fsmState !== 'IDLE') {
                            const isCoasting = (fsmState === 'COAST' || fsmState === 'COMMIT');
                            const drainTime = systemState.parameters.fsm.coastDrainTimeMs;
                            const drainAmount = (1 / drainTime) * dt;
                            const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * systemState.parameters.readiness.coastDrainMultiplier;
                            systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainScaled);

                            const readiness = systemState.p1.readinessScores[i];
                            const tTrackingLost = now - (systemState.p1.lastTrackingTimes[i] || now);

                            if (readiness > systemState.parameters.fsm.hysteresisLow) {
                                // Update Physics in Ballistic mode to get inertial position
                                let coastPos = { x: last.screenX, y: last.screenY };
                                const adapter = systemState.p1.physicsState[i];
                                if (adapter instanceof PlanckPhysicsAdapter) {
                                    adapter.setBallistic(true);
                                    coastPos = adapter.update(last.screenX, last.screenY, dt);
                                }

                                cursorData = FusionSchema.parse({
                                    ...last,
                                    screenX: coastPos.x,
                                    screenY: coastPos.y,
                                    uiNormX: coastPos.x / (systemState.p0.videoBounds?.width || 1280), // V28.5 Recalculate UI Norms
                                    uiNormY: coastPos.y / (systemState.p0.videoBounds?.height || 720), // V28.5 Recalculate UI Norms
                                    fsmState: 'COAST',
                                    readinessScore: readiness,
                                    skeletonAlpha: Math.max(0, 1.0 - (tTrackingLost / fadeTime)), // V26: Dedicated tracking loss fade
                                    handIndex: i,
                                    landmarks: last.landmarks || [], // V24.22: Keep landmarks for fading
                                    timestamp: now
                                });
                                systemState.p1.fsmStates[i] = 'COAST';
                            } else {
                                // Terminal Drain reached: emit one IDLE frame to ensure pointerup before drop
                                cursorData = FusionSchema.parse({
                                    ...last,
                                    fsmState: 'IDLE',
                                    readinessScore: readiness,
                                    skeletonAlpha: 0,
                                    handIndex: i,
                                    landmarks: last.landmarks || [],
                                    timestamp: now,
                                    uiNormX: last.screenX / (systemState.p0.videoBounds?.width || 1280),
                                    uiNormY: last.screenY / (systemState.p0.videoBounds?.height || 720)
                                });
                                systemState.p1.lastData[i] = null;
                                systemState.p1.fsmStates[i] = 'IDLE';
                                if (systemState.fsm.primaryHandIndex === i) systemState.fsm.primaryHandIndex = null;
                            }
                        }
                    }

                    if (cursorData) {
                        const validated = FusionSchema.parse({ ...cursorData, timestamp: now });
                        cursors.push(validated);
                    }
                }

                // V24.7: MULTI-READY / SINGLE-COMMIT (HOT SEAT V2)
                // Return ALL active cursors for visual feedback.
                const primary = systemState.fsm.primaryHandIndex;
                const primaryHand = cursors.find(c => c.handIndex === primary);

                if (primaryHand) {
                    systemState.fsm.currentState = primaryHand.fsmState;
                } else if (cursors.length > 0) {
                    const states = cursors.map(c => c.fsmState);
                    if (states.includes('COMMIT')) systemState.fsm.currentState = 'COMMIT';
                    else if (states.includes('COAST')) systemState.fsm.currentState = 'COAST';
                    else if (states.includes('READY')) systemState.fsm.currentState = 'READY';
                    else systemState.fsm.currentState = 'IDLE';
                } else {
                    systemState.fsm.currentState = 'IDLE';
                }

                // ðŸŒ UPDATE DATA FABRIC
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });

                return cursors;
            }
        }

        // Expose to window for hardened testing [V24.3]
        window.systemState = systemState;
        window.PlanckPhysicsAdapter = PlanckPhysicsAdapter;
        window.P1Bridger = P1Bridger;
        window.drawResults = drawResults;

        // --- P0: SENSE ---
        async function initP0() {
            logMission("P0: Initializing V7 Laser Cluster...");
            const vision = await FilesetResolver.forVisionTasks("./lib/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "./lib/models/gesture_recognizer.task",
                    delegate: 'GPU'
                },
                runningMode: "VIDEO",
                numHands: systemState.parameters.landmarks.numHands
            });
            logMission("âœ… P0: Sensing Cluster Online");
        }

        /**
         * ðŸ“– V30 TACTICAL TUTORIAL SYSTEM
         * Enforces User flow: IDLE -> READY (Palm) -> COMMIT (Gesture) -> IDLE
         */
        class TutorialSystem {
            constructor() {
                this.isCompleted = false;
                this.completionTimer = null;
                this.stepTimer = null;
                this.lastActiveStepId = null;
                this.completedPhases = new Set();
                this.steps = {
                    'READY': {
                        header: 'Phase 1: READY ðŸ–ï¸ âž¡ ðŸ”¥',
                        body: 'Welcome Initiate! Show your <span class="tutorial-highlight">Palm Towards</span> the camera to ignite the <span class="tutorial-highlight">READY - Amber Phoenix Core</span>.'
                    },
                    'COMMIT': {
                        header: 'Phase 2: COMMIT â˜ï¸ âž¡ â˜„ï¸',
                        body: 'Excellent! Now <span class="tutorial-highlight">Point your Index Finger Up</span> to focus the core into the <span class="tutorial-highlight">COMMIT - Cyan Phoenix Core</span>.'
                    },
                    'RELEASE_IDLE': {
                        header: 'Phase 3: RELEASE ðŸ«· âž¡ ðŸš«',
                        body: 'Safety first. Turn your hand away (<span class="tutorial-highlight">Side Profile</span>) to extinguish the flame.'
                    },
                    'SETTINGS': {
                        header: 'Phase 4: SETTINGS âš™ï¸ âž¡ ðŸ“ˆ',
                        body: 'Navigator access granted. <span class="tutorial-highlight">Release to interact</span> with the UI, then use the panels to tune parameters. This tutorial will self-destruct in 8s.'
                    }
                };
                this.isVisible = false;
                this.settingsStart = null;
            }

            reset() {
                this.isCompleted = false;
                this.lastActiveStepId = null;
                this.completedPhases.clear();
                this.settingsStart = null;
                if (this.completionTimer) clearTimeout(this.completionTimer);
                if (this.stepTimer) clearTimeout(this.stepTimer);

                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.opacity = '1';
                    systemState.ui.tutorial.style.display = 'block';
                    systemState.ui.tutProgress.style.display = 'none';
                }
                this.isVisible = true;
                logMission("Tutorial Reset.");
            }

            show() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'block';
                    this.isVisible = true;
                }
            }

            hide() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'none';
                    this.isVisible = false;
                }
            }

            update(cursors) {
                if (!systemState.parameters.ui.showTutorial || this.isCompleted) {
                    if (this.isVisible) this.hide();
                    return;
                }

                const now = performance.now();

                // Strictly sequential stateId (one-way progression)
                let stateId = this.lastActiveStepId || 'READY';

                if (cursors.length > 0) {
                    const primary = cursors[0];
                    const fsm = primary.fsmState;

                    // Progression triggers
                    if (stateId === 'READY' && fsm === 'READY') {
                        stateId = 'COMMIT';
                        this.completedPhases.add('READY');
                    }
                    else if (stateId === 'COMMIT' && fsm === 'COMMIT') {
                        stateId = 'RELEASE_IDLE';
                        this.completedPhases.add('COMMIT');
                    }
                    else if (stateId === 'RELEASE_IDLE' && (fsm === 'IDLE' || fsm === 'COAST')) {
                        // RELEASE phase triggers when user drops to IDLE or COAST from COMMIT
                        stateId = 'SETTINGS';
                        this.completedPhases.add('RELEASE_IDLE');
                        this.settingsStart = now;
                    }
                }

                if (stateId === 'SETTINGS') {
                    if (this.settingsStart) {
                        const elapsed = now - this.settingsStart;
                        const duration = 8000;
                        const progress = Math.min(100, (elapsed / duration) * 100);

                        systemState.ui.tutProgress.style.display = 'block';
                        systemState.ui.tutProgressBar.style.width = `${progress}%`;

                        if (elapsed >= duration && !this.isCompleted) {
                            this.isCompleted = true;
                            this.hide();
                            logMission("Tutorial Sequence Complete.");
                        }
                    }
                }

                if (stateId !== this.lastActiveStepId) {
                    this.lastActiveStepId = stateId;
                    const step = this.steps[stateId];

                    if (step) {
                        systemState.ui.tutHeader.innerText = step.header;
                        systemState.ui.tutBody.innerHTML = step.body;

                        this.show();
                        systemState.ui.tutorial.style.opacity = '1';

                        systemState.ui.tutorial.classList.remove('tutorial-step-active');
                        void systemState.ui.tutorial.offsetWidth;
                        systemState.ui.tutorial.classList.add('tutorial-step-active');

                        if (this.stepTimer) clearTimeout(this.stepTimer);
                        this.stepTimer = setTimeout(() => {
                            if (this.lastActiveStepId === stateId && stateId !== 'SETTINGS') {
                                systemState.ui.tutorial.style.opacity = '0.4';
                            }
                        }, 5000);
                    }
                }
            }
        }
        window.hfoTutorial = new TutorialSystem();

        let lastFrameTime = performance.now();
        function predictLoop() {
            if (!systemState.parameters.p0Active) return;
            const now = performance.now();
            let dt = now - lastFrameTime;
            lastFrameTime = now;

            // V40.1: Clamp dt to prevent physical "time jumps" from bypassing Leaky Bucket logic
            dt = Math.max(0, Math.min(100, dt));

            let results = null; // HOISTED: Ensure results exists in all branches

            // V24.6: Telemetry Replay Logic (Golden Master)
            if (window.hfoPlayer.isPlaying) {
                const frame = window.hfoPlayer.getNextFrame();
                if (frame && frame.phase === 'P1_FUSE') {
                    try {
                        systemState.dataFabric = DataFabricSchema.parse(frame.data);
                        systemState.p1.cursors = systemState.dataFabric.cursors;
                    } catch (e) {
                        console.error("REPLAY CONTRACT BREACH:", e);
                    }
                    // Continue to rendering/tutorial/injection
                }
            } else {
                // ðŸ’‰ P4: INJECTION HOOK (For E2E/Stress Testing)
                if (window.hfoMockPlayer && window.hfoMockPlayer.isPlaying) {
                    results = window.hfoMockPlayer.nextResults();
                }
                if (!results && window.hfoMockResults) {
                    results = window.hfoMockResults;
                }
                if (!results) {
                    if (systemState.p0.recognizer && systemState.p0.video) {
                        results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
                    } else {
                        requestAnimationFrame(predictLoop);
                        return;
                    }
                }

                // P1 BRIDGE: Fusing sensing to coordinates under contract
                // Optional hex path: allow the Port Facade to own the fabric shape.
                if (isFlagEnabled('p1-ports') && window.hfoPorts?.p1?.weave) {
                    window.hfoPorts.p1.weave(results, dt, now);
                } else {
                    const cursors = P1Bridger.fuse(results, dt);

                    // V19.4: VALIDATED SHARED DATA FABRIC ENFORCEMENT
                    try {
                        systemState.dataFabric = DataFabricSchema.parse({
                            cursors: cursors,
                            systemTime: now,
                            frameId: (systemState.dataFabric.frameId || 0) + 1
                        });
                        // Maintain legacy pointer for back-compat with existing FSM logic
                        systemState.p1.cursors = systemState.dataFabric.cursors;

                        // V24.5 Telemetry Recording
                        window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
                    } catch (e) {
                        console.error("PORT 1 CONTRACT BREACH:", e);
                        // Fail-safe to last known good or empty
                    }
                }
            }

            // ðŸ“Š P5: State Transparency (For E2E Testing)
            window.hfoState = {
                hands: systemState.dataFabric.cursors,
                parameters: systemState.parameters,
                fsm: systemState.fsm,
                lineage: 'SHARED_DATA_FABRIC_V19.5'
            };

            // V19.5: Unified Draw Call (Only skeleton receives raw results for ISR overlay)
            // V24.10: Substrate Gating (Prevent visual muddiness when Babylon is active)
            if (isFlagEnabled('engine-canvas')) {
                drawResults(results, systemState.dataFabric);
            }

            if (isFlagEnabled('ui-lil-gui')) {
                updateVisualPanels(results);
            }

            if (isFlagEnabled('p3-injector')) {
                w3cPointerNematocystInjector(); // V20.1: Rebranded Hydra Port
            }

            // ðŸ“– V30 Tutorial Update
            window.hfoTutorial.update(systemState.dataFabric.cursors);

            // BABYLON ENGINE (Standardized V28+)
            systemState.ui.juiceLayers.forEach(layer => {
                if (layer instanceof BabylonJuiceSubstrate) {
                    layer.canvas.style.display = 'block';
                    layer.update(systemState.dataFabric.cursors);
                }
            });

            requestAnimationFrame(predictLoop);
        }

        // --- GEN5: Mock replay start (no camera required) ---
        window.hfoStartMockReplay = () => {
            systemState.parameters.p0Active = true;
            if (!systemState.p0.videoBounds || !systemState.p0.videoBounds.width) {
                systemState.p0.videoBounds = { width: 1280, height: 720 };
            }
            lastFrameTime = performance.now();
            predictLoop();
        };

        // --- GEN5: Eval harness helpers (readiness drain / diagnostics) ---
        window.hfoEval = {
            getReadinessScores: () => [...systemState.p1.readinessScores],
            setReadinessScore: (handIndex, value) => {
                systemState.p1.readinessScores[handIndex] = Math.max(0, Math.min(1, value));
                return systemState.p1.readinessScores[handIndex];
            },
            setReadinessParams: (params) => {
                systemState.parameters.readiness = { ...systemState.parameters.readiness, ...params };
                return { ...systemState.parameters.readiness };
            },
            fillReadiness: (handIndex, dt) => {
                const fillAmount = (1 / systemState.parameters.fsm.chargeTimeMs) * dt;
                const fillScaled = fillAmount * systemState.parameters.readiness.fillMultiplier;
                systemState.p1.readinessScores[handIndex] = Math.min(1, systemState.p1.readinessScores[handIndex] + fillScaled);
                return systemState.p1.readinessScores[handIndex];
            },
            drainReadiness: (handIndex, dt, useCoast = true) => {
                const drainTime = useCoast
                    ? systemState.parameters.fsm.coastDrainTimeMs
                    : systemState.parameters.fsm.releaseTimeMs;
                const drainAmount = (1 / drainTime) * dt;
                const coastScale = useCoast ? systemState.parameters.readiness.coastDrainMultiplier : 1.0;
                const drainScaled = drainAmount * systemState.parameters.readiness.drainMultiplier * coastScale;
                systemState.p1.readinessScores[handIndex] = Math.max(0, systemState.p1.readinessScores[handIndex] - drainScaled);
                return systemState.p1.readinessScores[handIndex];
            }
        };

        // --- GEN5: Hexagonal Modular Monolith Scaffolding (Option 2 + Option 4) ---
        // Goal: stay single-HTML while enforcing (a) Port Facades and (b) Adapter Registry.
        // This scaffold is intentionally minimal and non-invasive for v10.1 boot safety.

        // --- HFO: Legendary Commanders / Domains / Authority (8 Ports) ---
        // Grounded sources:
        // - hfo_hot_obsidian/bronze/3_resources/mtg_slivers/16_SLIVER_SYNERGY_MANIFOLD.md
        // - hfo_hot_obsidian/bronze/4_archive/*/HFO_LEGENDARY_COMMANDERS_V1.md
        // Notes:
        // - Verb aliases across sources are expected (e.g., BRIDGE/ROUTE/FUSE).
        // - P3 has a known alias discrepancy in deeper notes (Spore Storm vs Harmonic Hydra).
        //
        // P0 SENSE/OBSERVE â€” Commander: Lidless Legion â€” Domain: ISR â€” Authority: sensing/recognition ingest.
        // P1 FUSE/BRIDGE/ROUTE â€” Commander: Web Weaver â€” Domain: Data Fabric â€” Authority: contracts + fusion (canonical fabric).
        // P2 SHAPE â€” Commander: Mirror Magus â€” Domain: Digital Twin â€” Authority: physics/render substrate shaping.
        // P3 INJECT/MODEL/DELIVER â€” Commander: Spore Storm (aka Harmonic Hydra) â€” Domain: Effect Delivery â€” Authority: W3C event injection.
        // P4 DISRUPT â€” Commander: Red Regnant â€” Domain: Coevolving Red Team â€” Authority: fault injection/chaos probes (opt-in).
        // P5 IMMUNIZE/AUDIT/DEFEND â€” Commander: Pyre Praetorian â€” Domain: Force Protection â€” Authority: audits + fail-closed integrity.
        // P6 ASSIMILATE/PERSIST/STORE â€” Commander: Kraken Keeper â€” Domain: AAR â€” Authority: persistence + consolidation.
        // P7 NAVIGATE/PLAN â€” Commander: Spider Sovereign â€” Domain: BMC2 â€” Authority: orchestration + total tool virtualization.

        // --- GEN5 v11: Port Doctrine (blurbs + keyword tags + synergy map) ---
        // Purpose: give agents a scan-friendly, canonical description of each hex port.
        // Invariant: this metadata must not mutate runtime behavior.
        window.hfoPortMeta = window.hfoPortMeta || Object.freeze({
            p0: Object.freeze({
                name: 'SENSE',
                commander: 'Lidless Legion',
                role: 'Observer',
                purpose: 'Convert raw world input (video) into first-pass perception results (MediaPipe hands + gestures).',
                keywords: Object.freeze(['P0', 'OBSERVE', 'ISR', 'mediapipe', 'hands', 'gestures', 'perception', 'frame_time']),
                inputs: Object.freeze(['HTMLVideoElement', 'monotonicMs']),
                outputs: Object.freeze(['recognition results (landmarks/gestures)']),
                synergy: Object.freeze({
                    upstream: Object.freeze([]),
                    downstream: Object.freeze(['p1.fuse'])
                })
            }),
            p1: Object.freeze({
                name: 'FUSE',
                commander: 'Web Weaver',
                role: 'Bridger / Data Fabric Authority',
                purpose: 'Fuse recognition into the canonical DataFabric, enforce Zod contracts, and emit a stable envelope for cross-port transport.',
                keywords: Object.freeze(['P1', 'BRIDGE', 'ROUTE', 'FUSE', 'data_fabric', 'zod', 'contracts', 'envelope', 'schema']),
                inputs: Object.freeze(['recognition results', 'dt', 'monotonicMs']),
                outputs: Object.freeze(['DataFabric', 'FabricEnvelope']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p0.sense']),
                    downstream: Object.freeze(['p2.shape', 'p3.deliver', 'p6.store'])
                })
            }),
            p2: Object.freeze({
                name: 'SHAPE',
                commander: 'Mirror Magus',
                role: 'Shaper / Digital Twin',
                purpose: 'Consume DataFabric and create shape state: physics, visuals, and interaction affordances (without directly injecting app events).',
                keywords: Object.freeze(['P2', 'SHAPE', 'digital_twin', 'physics', 'visuals', 'interaction', 'substrate']),
                inputs: Object.freeze(['DataFabric']),
                outputs: Object.freeze(['physics adapters telemetry', 'render layers']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse']),
                    downstream: Object.freeze(['p3.deliver'])
                })
            }),
            p3: Object.freeze({
                name: 'DELIVER',
                commander: 'Spore Storm (aka Harmonic Hydra)',
                role: 'Injector / Effect Delivery',
                purpose: 'Transform DataFabric into W3C-ish PointerEvents and inject into the target app (including Excalidraw overlay).',
                keywords: Object.freeze(['P3', 'INJECT', 'DELIVER', 'pointerevents', 'w3c', 'nematocyst', 'excalidraw', 'golden_layout']),
                inputs: Object.freeze(['DataFabric', 'target DOM']),
                outputs: Object.freeze(['PointerEvents dispatched into app']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse', 'p2.shape']),
                    downstream: Object.freeze(['p5.defend', 'p6.store'])
                })
            }),
            p4: Object.freeze({
                name: 'DISRUPT',
                commander: 'Red Regnant',
                role: 'Red Team / Chaos Probe',
                purpose: 'Opt-in disruption hooks: feedback loops, suppression heuristics, and bounded chaos probes that stress the other ports without corrupting state.',
                keywords: Object.freeze(['P4', 'DISRUPT', 'red_team', 'chaos', 'fault_injection', 'suppression', 'stability']),
                inputs: Object.freeze(['ports', 'contracts', 'flags']),
                outputs: Object.freeze(['diagnostics', 'bounded perturbations (opt-in)']),
                synergy: Object.freeze({
                    upstream: Object.freeze([]),
                    downstream: Object.freeze(['p5.immunize', 'p7.navigate'])
                })
            }),
            p5: Object.freeze({
                name: 'DEFEND',
                commander: 'Pyre Praetorian',
                role: 'Blue Team / Immunizer',
                purpose: 'Fail-closed integrity: assert required adapters/ports exist, guard contracts, and expose stable evaluation surfaces.',
                keywords: Object.freeze(['P5', 'IMMUNIZE', 'DEFEND', 'audit', 'integrity', 'fail_closed', 'eval_harness']),
                inputs: Object.freeze(['registry', 'tokens', 'contracts']),
                outputs: Object.freeze(['assertions', 'audit signals']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p4.disrupt (opt-in)']),
                    downstream: Object.freeze(['p7.navigate'])
                })
            }),
            p6: Object.freeze({
                name: 'STORE',
                commander: 'Kraken Keeper',
                role: 'Assimilator / AAR',
                purpose: 'Persist telemetry (fabric frames, readiness, injected events) for replay, audit, and long-term learning loops.',
                keywords: Object.freeze(['P6', 'ASSIMILATE', 'STORE', 'telemetry', 'jsonl', 'replay', 'aar']),
                inputs: Object.freeze(['DataFabric', 'events']),
                outputs: Object.freeze(['JSONL telemetry exports']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p1.fuse', 'p3.deliver']),
                    downstream: Object.freeze(['p7.navigate'])
                })
            }),
            p7: Object.freeze({
                name: 'NAVIGATE',
                commander: 'Spider Sovereign',
                role: 'Orchestrator / BMC2',
                purpose: 'Compose tools over time: parameters, modes, and intent manifests (Mission Thread OMEGA: Total Tool Virtualization).',
                keywords: Object.freeze(['P7', 'NAVIGATE', 'plan', 'orchestrate', 'intent', 'tool_virtualization', 'governance']),
                inputs: Object.freeze(['user intent', 'port surfaces', 'telemetry']),
                outputs: Object.freeze(['parameter patches', 'intent manifests', 'tool selection']),
                synergy: Object.freeze({
                    upstream: Object.freeze(['p5.defend', 'p6.store']),
                    downstream: Object.freeze([])
                })
            }),
            synergy_chain: Object.freeze([
                'P0 OBSERVE: MediaPipe hands/gestures',
                'â†’ P1 BRIDGE: Zod-enforced DataFabric + envelope',
                'â†’ P2 SHAPE: physics/visuals/interaction affordances',
                'â†’ P3 INJECT: PointerEvents into app',
                'â†’ Golden layout: Excalidraw overlay ready + stable tool semantics'
            ])
        });

        window.hfoTokens = window.hfoTokens || Object.freeze({
            P0_SENSE: 'p0.sense',
            P0_CAMERA: 'p0.camera',
            P1_FUSE: 'p1.fuse',
            P2_PHYSICS: 'p2.physics',
            P2_RENDER: 'p2.render',
            P3_INJECTOR: 'p3.injector',
            P3_TARGET_ROUTER: 'p3.target_router',
            P4_DISRUPT: 'p4.disrupt',
            P6_STORE: 'p6.store',
            P7_NAVIGATE: 'p7.navigate',
            P7_APPHOST: 'p7.apphost',
            UI_LAYOUT: 'ui.layout',
            EVAL_HFO: 'eval.hfo'
        });

        window.hfoRegistry = window.hfoRegistry || (() => {
            const map = new Map();
            return {
                register(token, impl) {
                    if (map.has(token)) throw new Error(`Adapter already registered: ${token}`);
                    map.set(token, impl);
                },
                resolve(token) {
                    const impl = map.get(token);
                    if (!impl) throw new Error(`Missing adapter: ${token}`);
                    return impl;
                },
                has(token) {
                    return map.has(token);
                }
            };
        })();

        // Register adapters we can safely wrap today.
        if (!window.hfoRegistry.has(window.hfoTokens.EVAL_HFO)) {
            window.hfoRegistry.register(window.hfoTokens.EVAL_HFO, window.hfoEval);
        }

        // P1 is the "Web Weaver": the single authority that shapes the universal DataFabric.
        // It owns (a) fusion, (b) contract validation, and (c) the canonical fabric envelope.
        if (!window.hfoRegistry.has(window.hfoTokens.P1_FUSE)) {
            window.hfoRegistry.register(window.hfoTokens.P1_FUSE, {
                fuseToDataFabric: (results, dt, nowMs) => {
                    const cursors = P1Bridger.fuse(results, dt);
                    try {
                        const next = DataFabricSchema.parse({
                            cursors,
                            systemTime: nowMs,
                            frameId: (systemState.dataFabric.frameId || 0) + 1
                        });

                        const wallTimeMs = Date.now();
                        const candidateEnvelope = {
                            specversion: '0.1',
                            id: `hfo-gen5-${wallTimeMs}-${next.frameId}`,
                            type: 'hfo.gen5.p1.fuse',
                            source: window.location?.pathname || 'unknown',
                            subject: 'p1.fuse',
                            time: new Date(wallTimeMs).toISOString(),
                            datacontenttype: 'application/json',
                            monotonicMs: nowMs,
                            dt,
                            data: next
                        };
                        const envelopeParsed = FabricEnvelopeSchema.safeParse(candidateEnvelope);

                        return { cursors, dataFabric: next, envelope: envelopeParsed.success ? envelopeParsed.data : null };
                    } catch (e) {
                        console.error("PORT 1 CONTRACT BREACH:", e);
                        return { cursors: [], dataFabric: null, envelope: null };
                    }
                }
            });
        }

        if (window.hfoTelemetry && !window.hfoRegistry.has(window.hfoTokens.P6_STORE)) {
            window.hfoRegistry.register(window.hfoTokens.P6_STORE, {
                record: (...args) => window.hfoTelemetry.record(...args),
                start: () => window.hfoTelemetry.start(),
                stop: () => window.hfoTelemetry.stop(),
                exportJSONL: () => window.hfoTelemetry.exportJSONL()
            });
        }

        if (!window.hfoRegistry.has(window.hfoTokens.P0_SENSE)) {
            window.hfoRegistry.register(window.hfoTokens.P0_SENSE, {
                readForVideo: (nowMs) => {
                    const recognizer = systemState?.p0?.recognizer;
                    const video = systemState?.p0?.video;
                    if (!recognizer || !video) return null;
                    return recognizer.recognizeForVideo(video, nowMs);
                }
            });
        }

        // P0 v11.2: shared camera substrate (single getUserMedia stream cached across views).
        // Default-inert: no side-effects unless `getStream()` is called.
        if (!window.hfoRegistry.has(window.hfoTokens.P0_CAMERA)) {
            const cameraAdapter = (() => {
                let stream = null;
                let streamPromise = null;
                let gumCalls = 0;

                const parseResolution = () => {
                    try {
                        const r = String(systemState?.parameters?.camera?.resolution || '1280x720');
                        const [w, h] = r.split('x');
                        return { width: parseInt(w, 10) || 1280, height: parseInt(h, 10) || 720 };
                    } catch {
                        return { width: 1280, height: 720 };
                    }
                };

                const getStream = async (opts = {}) => {
                    if (stream) return stream;
                    if (streamPromise) return streamPromise;

                    const mediaDevices = navigator?.mediaDevices;
                    if (!mediaDevices || typeof mediaDevices.getUserMedia !== 'function') {
                        throw new Error('navigator.mediaDevices.getUserMedia unavailable');
                    }

                    const { width, height } = parseResolution();
                    const requested = {
                        width: typeof opts?.width === 'number' ? opts.width : width,
                        height: typeof opts?.height === 'number' ? opts.height : height
                    };

                    gumCalls += 1;
                    streamPromise = mediaDevices.getUserMedia({
                        video: { width: requested.width, height: requested.height }
                    }).then((s) => {
                        stream = s;
                        return stream;
                    }).catch((e) => {
                        streamPromise = null;
                        throw e;
                    });

                    return streamPromise;
                };

                const getUserMediaCallCount = () => gumCalls;

                const reset = (stopTracks = true) => {
                    try {
                        if (stopTracks && stream && typeof stream.getTracks === 'function') {
                            stream.getTracks().forEach((t) => {
                                try { t.stop(); } catch { }
                            });
                        }
                    } catch { }
                    stream = null;
                    streamPromise = null;
                    gumCalls = 0;
                    return true;
                };

                return Object.freeze({ getStream, getUserMediaCallCount, reset });
            })();

            window.hfoRegistry.register(window.hfoTokens.P0_CAMERA, cameraAdapter);
        }

        if (!window.hfoRegistry.has(window.hfoTokens.P2_PHYSICS)) {
            window.hfoRegistry.register(window.hfoTokens.P2_PHYSICS, {
                getAdapters: () => (systemState?.p1?.physicsState ? [...systemState.p1.physicsState] : []),
                getTelemetry: () => {
                    const adapters = systemState?.p1?.physicsState || [];
                    return adapters.map((a) => (typeof a?.getTelemetry === 'function' ? a.getTelemetry() : {}));
                }
            });
        }

        // Render adapter is intentionally side-effect-free in v10.1 scaffolding.
        if (!window.hfoRegistry.has(window.hfoTokens.P2_RENDER)) {
            window.hfoRegistry.register(window.hfoTokens.P2_RENDER, {
                listJuiceLayers: () => (systemState?.ui?.juiceLayers ? [...systemState.ui.juiceLayers] : [])
            });
        }

        // P7 is NAVIGATE: long-horizon orchestration and total tool virtualization intent.
        // Non-breaking v10.1: exposes safe parameter patching + a mission vision object.
        if (!window.hfoRegistry.has(window.hfoTokens.P7_NAVIGATE)) {
            const deepMerge = (target, patch) => {
                if (!patch || typeof patch !== 'object') return target;
                Object.keys(patch).forEach((k) => {
                    const pv = patch[k];
                    if (pv && typeof pv === 'object' && !Array.isArray(pv)) {
                        if (!target[k] || typeof target[k] !== 'object') target[k] = {};
                        deepMerge(target[k], pv);
                    } else {
                        target[k] = pv;
                    }
                });
                return target;
            };

            const navigateAdapter = {
                currentIntent: null,
                postMessageToActiveAdapter: (message) => {
                    try {
                        const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                        const iframeEl = host?.getActiveTargetRootElement?.();
                        const win = iframeEl?.contentWindow;
                        if (!win || typeof win.postMessage !== 'function') return false;
                        win.postMessage(message, '*');
                        return true;
                    } catch (_) {
                        return false;
                    }
                },
                getMissionVision: () => {
                    return {
                        mission_thread: 'OMEGA',
                        title: 'Total Tool Virtualization',
                        north_star: 'Gesture + multimodal intent manifests virtual tools with evaluation harness feedback.',
                        capabilities: {
                            current_slice: ['Excalidraw overlay', 'parameter hot-swap via Navigator', 'P1 DataFabric + envelope', 'P3 pointer injection'],
                            near_term: ['rapid gesture/visual/app swapping', 'passive props + tool presets', 'multi-user primacy/hot-seat'],
                            long_term: ['any tool on demand (e.g., phoenix fireball, scalpel trainer, cockpit controls)', 'multi-sensor inputs (e.g., thermal camera)', 'archive-backed curricula from beginnerâ†’master', 'AI-assisted evaluation + coaching']
                        }
                    };
                },
                getParameters: () => systemState.parameters,
                patchParameters: (patch) => {
                    deepMerge(systemState.parameters, patch);
                    return systemState.parameters;
                },
                setActiveAdapterTool: (tool) => {
                    const activeId = window.hfoPorts?.p7?.apps?.getActiveId?.() || null;
                    if (activeId === 'excalidraw') {
                        systemState.parameters.excalidraw.activeTool = tool;
                    } else {
                        systemState.parameters.apps = systemState.parameters.apps || {};
                        systemState.parameters.apps.activeTool = tool;
                    }
                    navigateAdapter.postMessageToActiveAdapter({
                        type: 'SET_TOOL',
                        data: { tool }
                    });
                    return tool;
                },
                setExcalidrawTool: (tool) => {
                    // Backward-compatible shim: Excalidraw is just one adapter.
                    return navigateAdapter.setActiveAdapterTool(tool);
                },
                setVisualEngine: (engine) => {
                    systemState.parameters.visuals.engine = engine;
                    return systemState.parameters.visuals.engine;
                },
                setIntent: (intent) => {
                    const wallTimeMs = Date.now();
                    navigateAdapter.currentIntent = {
                        ts: new Date(wallTimeMs).toISOString(),
                        intent
                    };
                    return navigateAdapter.currentIntent;
                }
            };

            window.hfoRegistry.register(window.hfoTokens.P7_NAVIGATE, navigateAdapter);
        }

        // P7 v11.1: APPHOST (Multi-app runtime)
        // Default-inert: only affects DOM visibility when `?flag-ui-multiapp=true`.
        if (!window.hfoRegistry.has(window.hfoTokens.P7_APPHOST)) {
            const validateAppManifest = (candidate) => {
                if (window.Contracts?.AppManifestSchema?.parse) {
                    return window.Contracts.AppManifestSchema.parse(candidate);
                }
                return candidate;
            };

            const appHostAdapter = (() => {
                const apps = new Map();
                let activeAppId = null;

                const register = (manifest) => {
                    const parsed = validateAppManifest(manifest);
                    if (!parsed?.appId) throw new Error('AppManifest missing appId');
                    apps.set(parsed.appId, parsed);
                    return parsed;
                };

                // Register default demo apps (same-origin iframes).
                register({
                    appId: 'excalidraw',
                    title: 'Excalidraw',
                    kind: 'iframe',
                    entrypoint: 'excalidraw_v20_wrapper.html',
                    tags: ['demo', 'whiteboard'],
                    pointerAdapter: 'excalidraw',
                    targetPolicy: 'ACTIVE_APP_OR_FALLBACK',
                    runtime: { overlayKey: 'excalidrawOverlay', iframeKey: 'excalidrawIframe' }
                });
                register({
                    appId: 'sandbox',
                    title: 'Sandbox Canvas',
                    kind: 'iframe',
                    entrypoint: 'sandbox_canvas_app.html',
                    tags: ['demo', 'canvas'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'sandboxOverlay', iframeKey: 'sandboxIframe' }
                });

                // GEN5 v12: Pointer Lab (same-origin; touch + stylus validation surface).
                register({
                    appId: 'pointer-lab',
                    title: 'Pointer Lab',
                    kind: 'iframe',
                    entrypoint: 'pointer_lab_app.html',
                    tags: ['demo', 'touch', 'pointer'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'pointerLabOverlay', iframeKey: 'pointerLabIframe' }
                });

                // OFFICIAL adapter: MDN Breakout workshop (vendored, same-origin).
                register({
                    appId: 'breakout-mdn',
                    title: 'Breakout (MDN Workshop)',
                    kind: 'iframe',
                    entrypoint: 'official_adapters/mdn_breakout_end3r/index.html',
                    tags: ['official', 'breakout', 'canvas'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'breakoutOverlay', iframeKey: 'breakoutIframe' }
                });

                // OFFICIAL adapter: Dino Runner (v1) (vendored, same-origin).
                // NOTE: This variant (v12.1_dino_v1) treats Dino as the primary hero adapter for COMMITâ†’keypress experiments.
                register({
                    appId: 'dino-v1',
                    title: 'Dino Runner (v1)',
                    kind: 'iframe',
                    entrypoint: 'dino_v1_wrapper.html',
                    tags: ['official', 'dino', 'runner', 'keyboard'],
                    pointerAdapter: 'standard',
                    targetPolicy: 'ACTIVE_APP_ONLY',
                    runtime: { overlayKey: 'dinoOverlay', iframeKey: 'dinoIframe' }
                });

                // NOTE: Bespoke Gen5 game demos were removed. Only vendor "official" upstream demos into the repo.

                const getActiveId = () => activeAppId;
                const getActive = () => (activeAppId ? apps.get(activeAppId) || null : null);

                const getRuntimeEl = (key) => {
                    const ui = systemState?.ui || {};
                    return ui?.[key] || null;
                };

                const getOverlayTuningForApp = (appId) => {
                    const p = systemState?.parameters?.apps;
                    if (!p) return { opacity: 1.0, zoom: 1.0 };
                    if (p?.overlay?.rememberPerApp && appId && p?.perApp?.[appId]) {
                        const o = p.perApp[appId] || {};
                        return {
                            opacity: typeof o.opacity === 'number' ? o.opacity : (p.overlay.opacity ?? 1.0),
                            zoom: typeof o.zoom === 'number' ? o.zoom : (p.overlay.zoom ?? 1.0)
                        };
                    }
                    return {
                        opacity: typeof p?.overlay?.opacity === 'number' ? p.overlay.opacity : 1.0,
                        zoom: typeof p?.overlay?.zoom === 'number' ? p.overlay.zoom : 1.0
                    };
                };

                const applyOverlayTuningToManifest = (manifest) => {
                    const overlayKey = manifest?.runtime?.overlayKey;
                    const iframeKey = manifest?.runtime?.iframeKey;
                    if (!overlayKey || !iframeKey) return false;

                    const overlay = getRuntimeEl(overlayKey);
                    const iframe = getRuntimeEl(iframeKey);
                    if (!overlay || !iframe) return false;

                    const { opacity, zoom } = getOverlayTuningForApp(manifest?.appId);

                    overlay.style.opacity = String(Math.max(0, Math.min(1, Number(opacity) || 0)));

                    const z = Math.max(1.0, Math.min(2.0, Number(zoom) || 1.0));
                    overlay.style.width = `${z * 100}%`;
                    overlay.style.height = `${z * 100}%`;
                    overlay.style.left = `${(1 - z) * 50}%`;
                    overlay.style.top = `${(1 - z) * 50}%`;
                    overlay.style.position = 'absolute';

                    // Ensure iframe remains a full-bleed surface inside the tuned overlay box.
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';

                    return true;
                };

                const setOverlayVisible = (manifest, visible) => {
                    const overlayKey = manifest?.runtime?.overlayKey;
                    if (!overlayKey) return;
                    const overlay = getRuntimeEl(overlayKey);
                    if (!overlay) return;
                    overlay.style.display = visible ? 'block' : 'none';
                    if (visible) applyOverlayTuningToManifest(manifest);
                };

                const hideAllOverlays = () => {
                    for (const m of apps.values()) setOverlayVisible(m, false);
                };

                const emit = (type, detail) => {
                    try {
                        window.hfoStigmergy?.emit?.(type, detail);
                    } catch (_) {
                        // ignore
                    }
                };

                const activate = (appId) => {
                    if (!apps.has(appId)) throw new Error(`Unknown appId: ${appId}`);
                    activeAppId = appId;
                    // v12.1: Always attempt to toggle overlays when activating apps.
                    // This is fail-soft: if overlays/iframes were not mounted, getRuntimeEl() returns null.
                    hideAllOverlays();
                    setOverlayVisible(apps.get(appId), true);
                    emit('apphost.activate', { appId, ts: new Date().toISOString() });
                    return getActive();
                };

                const deactivate = () => {
                    const prev = activeAppId;
                    activeAppId = null;
                    hideAllOverlays();
                    emit('apphost.deactivate', { prevAppId: prev, ts: new Date().toISOString() });
                    return true;
                };

                const getActiveTargetRootElement = () => {
                    const active = getActive();
                    if (!active) return null;
                    if (active.kind !== 'iframe') return null;
                    const iframeKey = active?.runtime?.iframeKey;
                    if (!iframeKey) return null;
                    return getRuntimeEl(iframeKey);
                };

                const applyActiveOverlayTuning = () => {
                    const active = getActive();
                    if (!active || active.kind !== 'iframe') return false;

                    const p = systemState?.parameters?.apps;
                    if (p?.overlay?.rememberPerApp && active?.appId && p?.perApp?.[active.appId]) {
                        const stored = p.perApp[active.appId] || {};
                        if (typeof stored.opacity === 'number') p.overlay.opacity = stored.opacity;
                        if (typeof stored.zoom === 'number') p.overlay.zoom = stored.zoom;
                    }

                    return applyOverlayTuningToManifest(active);
                };

                return Object.freeze({
                    register,
                    registerIframeAdapter: ({
                        appId,
                        title,
                        entrypoint,
                        overlayKey,
                        iframeKey,
                        tags = [],
                        targetPolicy = 'ACTIVE_APP_ONLY',
                        pointerAdapter = 'standard'
                    }) => {
                        return register({
                            appId,
                            title,
                            kind: 'iframe',
                            entrypoint,
                            tags,
                            pointerAdapter,
                            targetPolicy,
                            runtime: { overlayKey, iframeKey }
                        });
                    },
                    list: () => Array.from(apps.values()),
                    activate,
                    deactivate,
                    getActiveId,
                    getActive,
                    getActiveTargetRootElement,
                    applyActiveOverlayTuning
                });
            })();

            window.hfoRegistry.register(window.hfoTokens.P7_APPHOST, appHostAdapter);
        }

        // UI layout adapter (placeholder surface for v11.1 integration; does not mutate state).
        if (!window.hfoRegistry.has(window.hfoTokens.UI_LAYOUT)) {
            window.hfoRegistry.register(window.hfoTokens.UI_LAYOUT, {
                getActiveAppId: () => {
                    try {
                        return window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveId();
                    } catch (_) {
                        return null;
                    }
                }
            });
        }

        // P3 v11.1: Target router. When enabled, constrains pointer hit-testing to the active app.
        if (!window.hfoRegistry.has(window.hfoTokens.P3_TARGET_ROUTER)) {
            const safeElementFromPointInIframe = (iframeEl, x, y) => {
                if (!iframeEl) return null;
                try {
                    const doc = iframeEl.contentDocument;
                    if (!doc || typeof doc.elementFromPoint !== 'function') return null;
                    return doc.elementFromPoint(x, y);
                } catch (_) {
                    return null;
                }
            };

            window.hfoRegistry.register(window.hfoTokens.P3_TARGET_ROUTER, {
                getActivePolicy: () => {
                    try {
                        const active = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive();
                        return active?.targetPolicy || 'ACTIVE_APP_OR_FALLBACK';
                    } catch (_) {
                        return 'ACTIVE_APP_OR_FALLBACK';
                    }
                },
                isTargetAllowed: (target) => {
                    try {
                        const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                        const active = host.getActive();
                        if (!active) return true;
                        if (active.kind === 'iframe') {
                            const iframeEl = host.getActiveTargetRootElement();
                            const doc = iframeEl?.contentDocument;
                            return !!(target && doc && target.ownerDocument === doc);
                        }
                        return target?.ownerDocument === document;
                    } catch (_) {
                        return true;
                    }
                },
                resolveTargetAt: (viewX, viewY) => {
                    const host = window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST);
                    const active = host.getActive();
                    if (!active) return null;
                    if (active.kind !== 'iframe') return null;

                    const iframeEl = host.getActiveTargetRootElement();
                    if (!iframeEl) return null;

                    // Prefer overlay rect if present (overlays are positioned absolute to the hero container).
                    const overlayKey = active?.runtime?.overlayKey;
                    const overlay = overlayKey ? (systemState?.ui?.[overlayKey] || null) : null;
                    const rect = (overlay && overlay.style.display !== 'none') ? overlay.getBoundingClientRect() : iframeEl.getBoundingClientRect();

                    if (viewX < rect.left || viewX > rect.right || viewY < rect.top || viewY > rect.bottom) return null;

                    const subX = viewX - rect.left;
                    const subY = viewY - rect.top;
                    const inner = safeElementFromPointInIframe(iframeEl, subX, subY);
                    if (!inner) return null;
                    return { target: inner, clientX: subX, clientY: subY };
                }
            });
        }

        // P4 is DISRUPT: red-team coevolution. Must be explicitly enabled; otherwise it is inert.
        // Critical invariant: no side-effects unless a caller invokes the adapter.
        if (!window.hfoRegistry.has(window.hfoTokens.P4_DISRUPT)) {
            window.hfoRegistry.register(window.hfoTokens.P4_DISRUPT, {
                isEnabled: () => isFlagEnabled('p4-disrupt'),
                noOp: () => {
                    const wallTimeMs = Date.now();
                    return {
                        ok: true,
                        enabled: isFlagEnabled('p4-disrupt'),
                        ts: new Date(wallTimeMs).toISOString(),
                        note: 'P4 DISRUPT is inert unless you call it.'
                    };
                },
                probeAdapters: () => {
                    return {
                        p0: window.hfoRegistry.has(window.hfoTokens.P0_SENSE),
                        p1: window.hfoRegistry.has(window.hfoTokens.P1_FUSE),
                        p2_physics: window.hfoRegistry.has(window.hfoTokens.P2_PHYSICS),
                        p2_render: window.hfoRegistry.has(window.hfoTokens.P2_RENDER),
                        p3: window.hfoRegistry.has(window.hfoTokens.P3_INJECTOR),
                        p5_eval: window.hfoRegistry.has(window.hfoTokens.EVAL_HFO),
                        p6: window.hfoRegistry.has(window.hfoTokens.P6_STORE),
                        p7: window.hfoRegistry.has(window.hfoTokens.P7_NAVIGATE)
                    };
                }
            });
        }

        /**
         * ðŸ”± PORT 3: POINTER INJECTION (Polymorphic Hexagonal Adapter)
         *
         * Goal:
         * - Standard W3C PointerEvents pipeline as the default substrate.
         * - Optional UI adapter behavior (Excalidraw) without polluting the core.
         */
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            const video = systemState.p0.video;
            if (!video) return;

            const videoWidth = video.videoWidth || parseInt(systemState.parameters.camera.resolution.split('x')[0]) || 1280;
            const videoHeight = video.videoHeight || parseInt(systemState.parameters.camera.resolution.split('x')[1]) || 720;
            const rect = video.getBoundingClientRect();
            const rectWidth = rect.width || videoWidth;
            const rectHeight = rect.height || videoHeight;
            const rectLeft = rect.left || 0;
            const rectTop = rect.top || 0;

            const currentIds = new Set();

            cursors.forEach(cursor => {
                const pid = cursor.pointerId;

                // V24.7: Hot Seat V2 Interaction Gating
                // Ensures only ONE hand can interact with the system at a time.
                // READY hands provide multiple visual fireballs, but only the primary hand injects events.
                const isPrimary = (systemState.fsm.primaryHandIndex === cursor.handIndex);
                let pState = systemState.fsm.activePointers[pid];

                // If not primary, only allow processing if it was previously active (to cleanup)
                if (!isPrimary && (!pState || !pState.wasDown)) return;

                currentIds.add(pid);

                // V28.0: UNIVERSAL PROJECTION ENGINE (UPE) ENFORCEMENT
                // V28.5 HARDENED: Use pre-calculated uiNorms for cross-substrate parity
                const viewX = systemState.p1.toViewportX(cursor.uiNormX || cursor.normX);
                const viewY = systemState.p1.toViewportY(cursor.uiNormY || cursor.normY);

                // V39.3: HARDENED INTERACTION GATE
                // "there is no injection layer EXCEPT for COMMIT"
                const isDown = (cursor.fsmState === 'COMMIT');
                const pressure = isDown ? 1.0 : 0.0;

                if (!pState) {
                    systemState.fsm.activePointers[pid] = {
                        lastTarget: null,
                        lock: null,
                        wasDown: false,
                        downClientX: null,
                        downClientY: null,
                        downTarget: null,
                        downControl: null,
                        downDoc: null,
                        moved: false
                    };
                    pState = systemState.fsm.activePointers[pid];
                }

                let target = pState.lock;
                let finalX = viewX;
                let finalY = viewY;

                const targetRoutingEnabled = isFlagEnabled('p3-target-active-app');
                let targetRouter = null;
                let targetPolicy = 'ACTIVE_APP_OR_FALLBACK';
                if (targetRoutingEnabled) {
                    try {
                        targetRouter = window.hfoRegistry.resolve(window.hfoTokens.P3_TARGET_ROUTER);
                        targetPolicy = targetRouter?.getActivePolicy?.() || 'ACTIVE_APP_OR_FALLBACK';
                    } catch (_) {
                        targetRouter = null;
                    }
                }

                // If a lock exists but is no longer allowed under active-app routing, clear it.
                if (target && targetRouter && !targetRouter.isTargetAllowed(target)) {
                    pState.lock = null;
                    target = null;
                }

                if (!target) {
                    // v11.1: active-app routing (same-origin iframe probing) before legacy global hit-test.
                    if (targetRouter) {
                        const routed = targetRouter.resolveTargetAt?.(viewX, viewY);
                        if (routed?.target) {
                            target = routed.target;
                            finalX = routed.clientX;
                            finalY = routed.clientY;
                        } else if (targetPolicy === 'ACTIVE_APP_ONLY') {
                            return;
                        }
                    }

                    if (!target) {
                        let probe = document.elementFromPoint(viewX, viewY) || document.body;
                        if (probe && probe.tagName === 'IFRAME') {
                            try {
                                const iframeRect = probe.getBoundingClientRect();
                                const subX = viewX - iframeRect.left;
                                const subY = viewY - iframeRect.top;
                                const inner = probe.contentDocument.elementFromPoint(subX, subY);
                                if (inner) {
                                    probe = inner;
                                    finalX = subX;
                                    finalY = subY;
                                }
                            } catch (e) {
                                // Cross-origin or hidden iframe access failure is expected but logged in dev
                                if (systemState.parameters.devMode) console.warn("[P3] Deep Target Search Failure:", e);
                            }
                        }
                        target = probe;
                    }
                } else {
                    if (target.ownerDocument !== document) {
                        const iframe = Array.from(document.querySelectorAll('iframe')).find(f => f.contentDocument === target.ownerDocument);
                        if (iframe) {
                            const r = iframe.getBoundingClientRect();
                            finalX = viewX - r.left;
                            finalY = viewY - r.top;
                        }
                    }
                }

                const eventInit = {
                    bubbles: true, cancelable: true, pointerId: pid, pointerType: 'mouse',
                    clientX: finalX, clientY: finalY, screenX: viewX, screenY: viewY,
                    pressure: pressure, buttons: isDown ? 1 : 0, button: isDown ? 0 : -1,
                    width: 1, height: 1, isPrimary: pid === 10
                };

                if (target !== pState.lastTarget) {
                    if (pState.lastTarget) {
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerout', eventInit), pState);
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerleave', eventInit), pState);
                    }
                    if (target) {
                        dispatchToHydraHydrant(target, new PointerEvent('pointerover', eventInit), pState);
                        dispatchToHydraHydrant(target, new PointerEvent('pointerenter', eventInit), pState);
                    }
                    pState.lastTarget = target;
                }

                if (isDown && !pState.wasDown) {
                    pState.lock = target;
                    pState.downClientX = finalX;
                    pState.downClientY = finalY;
                    pState.downTarget = target;
                    pState.downDoc = target?.ownerDocument || document;
                    // Prefer resolving a UI control, even when elementFromPoint returns a wrapper node.
                    pState.downControl = P3InjectorPort.findControl(target);
                    if (!pState.downControl) {
                        try {
                            const probe = (pState.downDoc || document).elementFromPoint?.(finalX, finalY);
                            pState.downControl = P3InjectorPort.findControl(probe);
                        } catch (e) {
                            // ignore
                        }
                    }
                    pState.moved = false;
                    if (target.setPointerCapture) {
                        try {
                            target.setPointerCapture(pid);
                        } catch (e) {
                            if (systemState.parameters.devMode) console.warn("[P3] SetPointerCapture failed:", e);
                        }
                    }
                    dispatchToHydraHydrant(target, new PointerEvent('pointerdown', eventInit), pState);

                    // GEN5 v12.1 (Dino v1): COMMIT edge â†’ synthesize a Space keypress into the active iframe.
                    // Rationale: Dino runner is keyboard-driven; this ties the HFO COMMIT FSM to a deterministic action.
                    try {
                        const host = window.hfoRegistry?.resolve?.(window.hfoTokens?.P7_APPHOST);
                        const activeId = host?.getActiveId?.() || '';
                        if (activeId === 'dino-v1') {
                            const iframeEl = systemState?.ui?.dinoIframe || host?.getActiveTargetRootElement?.();
                            const doc = iframeEl?.contentDocument || null;
                            const win = iframeEl?.contentWindow || doc?.defaultView || null;
                            if (win && typeof win.focus === 'function') win.focus();
                            const targetEl = doc?.activeElement || doc?.body || null;
                            if (targetEl && doc) {
                                const down = new KeyboardEvent('keydown', { key: ' ', code: 'Space', bubbles: true, cancelable: true });
                                const up = new KeyboardEvent('keyup', { key: ' ', code: 'Space', bubbles: true, cancelable: true });
                                targetEl.dispatchEvent(down);
                                targetEl.dispatchEvent(up);
                            }
                        }
                    } catch (_) {
                        // ignore
                    }
                }

                // Track movement while down to avoid false "release-click" on drags.
                if (isDown && pState.downClientX != null && pState.downClientY != null) {
                    const cfg = P3InjectorPort.getConfig();
                    const dx = finalX - pState.downClientX;
                    const dy = finalY - pState.downClientY;
                    if (!pState.moved && Math.hypot(dx, dy) > cfg.tapMoveThresholdPx) {
                        pState.moved = true;
                    }
                }

                dispatchToHydraHydrant(target, new PointerEvent('pointermove', eventInit), pState);

                if (!isDown && pState.wasDown) {
                    dispatchToHydraHydrant(target, new PointerEvent('pointerup', { ...eventInit, pressure: 0.0, buttons: 0, button: 0 }), pState);
                    if (target.releasePointerCapture) {
                        try {
                            target.releasePointerCapture(pid);
                        } catch (e) {
                            if (systemState.parameters.devMode) console.warn("[P3] ReleasePointerCapture failed:", e);
                        }
                    }
                    pState.lock = null;
                    pState.downClientX = null;
                    pState.downClientY = null;
                    pState.downTarget = null;
                    pState.downControl = null;
                    pState.downDoc = null;
                    pState.moved = false;
                }

                pState.wasDown = isDown;
            });

            // V24.4: Real pointercancel path for lost tracking
            Object.keys(systemState.fsm.activePointers).forEach(pidStr => {
                const pid = parseInt(pidStr);
                if (!currentIds.has(pid)) {
                    const pState = systemState.fsm.activePointers[pid];
                    if (pState.wasDown && pState.lock) {
                        dispatchToHydraHydrant(pState.lock, new PointerEvent('pointercancel', {
                            pointerId: pid, bubbles: true, pointerType: 'mouse'
                        }), pState);
                        if (pState.lock.releasePointerCapture) {
                            try {
                                pState.lock.releasePointerCapture(pid);
                            } catch (e) {
                                if (systemState.parameters.devMode) console.warn("[P3] Cancel: ReleasePointerCapture failed:", e);
                            }
                        }
                        if (systemState.parameters.devMode) console.log(`[P3] Handled pointer-loss cancel for id: ${pid}`);
                    }
                    delete systemState.fsm.activePointers[pid];
                }
            });
        }

        // --- TEST HARNESS: Expose injector for Playwright guards ---
        if (!window.hfoTestHarness) window.hfoTestHarness = {};
        window.hfoTestHarness.injectPointers = () => {
            try {
                w3cPointerNematocystInjector();
            } catch (e) {
                if (systemState.parameters.devMode) console.warn('[P3] Test harness inject failed:', e);
            }
        };

        /**
         * ðŸ”± HYDRA HYDRANT: Payload Delivery Mechanism (W3C PointerEvents)
         * Optimized for React/Excalidraw and universal target discovery.
         */
        // --- P3: Injector Port (Adapter Boundary) ---
        const P3InjectorPort = (() => {
            const DEFAULTS = {
                // 'standard' = pure PointerEvents; 'excalidraw' = allows guarded click synthesis for UI controls
                adapter: 'auto',
                enableClickSynthesis: true,
                tapMoveThresholdPx: 6,
                // 'down' = switch tools on COMMIT (pointerdown). 'up' = legacy click-on-release.
                clickSynthesisPhase: 'down'
            };

            const getActiveManifest = () => {
                try {
                    return window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive?.() || null;
                } catch (_) {
                    return null;
                }
            };

            const getEffectiveAdapterKind = (cfg) => {
                const forced = cfg?.adapter;
                if (forced === 'standard' || forced === 'excalidraw') return forced;

                const active = getActiveManifest();
                const byManifest = active?.pointerAdapter;
                if (byManifest === 'excalidraw' || byManifest === 'standard') return byManifest;
                if (active?.appId === 'excalidraw') return 'excalidraw';
                return 'standard';
            };

            const getConfig = () => {
                if (!systemState.parameters) systemState.parameters = {};
                if (!systemState.parameters.p3) systemState.parameters.p3 = {};
                return { ...DEFAULTS, ...systemState.parameters.p3 };
            };

            const isInteractive = (el) => {
                if (!el) return false;
                const tag = el.tagName ? el.tagName.toLowerCase() : '';
                const role = el.getAttribute ? el.getAttribute('role') : null;
                return (
                    tag === 'button' || tag === 'a' || tag === 'input' || tag === 'select' ||
                    role === 'button' || role === 'link' || role === 'checkbox' ||
                    el.classList?.contains('ToolIcon') || !!el.onclick
                );
            };

            // Find nearest interactive ancestor; returns null if none.
            // Excalidraw UI DOM can be deep; keep this generous but bounded.
            const findControl = (el) => {
                let curr = el;
                for (let i = 0; i < 25 && curr; i++) {
                    if (isInteractive(curr)) return curr;
                    if (curr === curr.ownerDocument?.body || curr === curr.ownerDocument?.documentElement) break;
                    curr = curr.parentElement;
                }
                return null;
            };

            const focusPriming = (target) => {
                const control = findControl(target);
                if (control?.focus) control.focus();
            };

            const resolveSynthesizedClickControl = (target, e, pState, phase) => {
                const cfg = getConfig();
                const effective = getEffectiveAdapterKind(cfg);
                if (effective !== 'excalidraw') return null;
                if (!cfg.enableClickSynthesis) return null;
                if (!pState) return null;
                if (pState.moved) return null;

                // Only synthesize clicks for real UI controls (not canvas / background)
                let downControl = pState.downControl;
                if (!downControl && pState.downTarget) downControl = findControl(pState.downTarget);

                // Avoid cross-document / cross-iframe mismatches
                const upDoc = target?.ownerDocument || document;
                if (pState.downDoc && upDoc !== pState.downDoc) return null;

                const isBlockedClickTarget = (el) => {
                    if (!el || !el.tagName) return true;
                    const tag = el.tagName.toLowerCase();
                    return tag === 'canvas' || tag === 'html' || tag === 'body' || tag === 'svg';
                };

                // Require release on the same control to avoid "wrong tool" clicks
                if (phase === 'down') {
                    const candidate = downControl || findControl(target);
                    if (!candidate || !isInteractive(candidate) || isBlockedClickTarget(candidate)) return null;

                    // During pointerdown (COMMIT), we expect a left-button style press.
                    if (e.buttons !== 1) return null;

                    return candidate;
                }

                // phase === 'up'
                let upControl = findControl(target);
                if (!upControl) {
                    try {
                        const probe = upDoc.elementFromPoint?.(e.clientX, e.clientY);
                        upControl = findControl(probe);
                    } catch (err) {
                        // ignore
                    }
                }

                // Only when the pointerup is a left-button-style release
                if (e.buttons !== 0) return null;

                // Prefer strict same-control semantics when possible.
                if (downControl && upControl) {
                    if (downControl !== upControl) return null;
                    if (!isInteractive(downControl) || isBlockedClickTarget(downControl)) return null;
                    return downControl;
                }

                // Fallback: if one side couldn't resolve a control, still allow a click
                // when the other side resolves a real UI control (prevents dead taps on wrappers).
                const candidate = downControl || upControl;
                if (!candidate || !isInteractive(candidate) || isBlockedClickTarget(candidate)) return null;

                return candidate;
            };

            const synthesizeClick = (control, e) => {
                const clickEv = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    view: control.ownerDocument?.defaultView || window
                });
                control.dispatchEvent(clickEv);
            };

            const dispatch = (target, e, pState) => {
                if (!target) return;
                target.dispatchEvent(e);

                if (e.type === 'pointerdown') {
                    focusPriming(target);

                    const cfg = getConfig();
                    if (cfg.clickSynthesisPhase === 'down') {
                        const control = resolveSynthesizedClickControl(target, e, pState, 'down');
                        if (control) synthesizeClick(control, e);
                    }
                }

                if (e.type === 'pointerup') {
                    // Click the control that was pressed, not the current hover target.
                    const cfg = getConfig();
                    if (cfg.clickSynthesisPhase !== 'down') {
                        const control = resolveSynthesizedClickControl(target, e, pState, 'up');
                        if (control) synthesizeClick(control, e);
                    }
                }
            };

            return { getConfig, getEffectiveAdapterKind, findControl, dispatch };
        })();

        function dispatchToHydraHydrant(t, e, pState) {
            P3InjectorPort.dispatch(t, e, pState);
        }

        // --- SPARKLINE HELPER ---
        function drawSparkline(ctx, x, y, w, h, data, color, markers = []) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            const step = w / 64;
            data.forEach((val, i) => {
                const px = x + i * step;
                const py = y + h - (val * h);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Draw Markers
            markers.forEach(m => {
                const my = y + h - (m.val * h);
                ctx.strokeStyle = m.color;
                ctx.setLineDash([2, 1]);
                ctx.beginPath(); ctx.moveTo(x, my); ctx.lineTo(x + w, my); ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        // --- ðŸŒ  ELEMENTAL JUICE HELPERS ---
        function drawFireball(ctx, x, y, size, intensity, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 236, 61, 0.9)', 'rgba(255, 77, 79, 0.8)', 'rgba(255, 30, 0, 0)'],
                'READY': ['rgba(255, 255, 255, 0.8)', 'rgba(255, 251, 143, 0.7)', 'rgba(255, 169, 64, 0.6)', 'rgba(255, 169, 64, 0)'],
                'COAST': ['rgba(255, 255, 255, 0.4)', 'rgba(145, 213, 255, 0.3)', 'rgba(9, 109, 217, 0.2)', 'rgba(9, 109, 217, 0)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Outer Gloom/Heat Distortion
            const bloomSize = size * (4 + Math.sin(time / 150) * 0.5);
            const bloomGrad = ctx.createRadialGradient(x, y, 0, x, y, bloomSize);
            bloomGrad.addColorStop(0, c[2]);
            bloomGrad.addColorStop(0.4, c[3]);
            ctx.fillStyle = bloomGrad;
            ctx.beginPath(); ctx.arc(x, y, bloomSize, 0, Math.PI * 2); ctx.fill();

            // Core Plasma
            const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
            coreGrad.addColorStop(0, c[0]);
            coreGrad.addColorStop(0.3, c[1]);
            coreGrad.addColorStop(0.7, c[2]);
            coreGrad.addColorStop(1, c[3]);

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Pulsing spikes/tendrils
            if (state === 'COMMIT') {
                ctx.strokeStyle = c[1];
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (time / 200) + (i * Math.PI / 4);
                    const length = size * (2.5 + Math.sin(time / 50 + i) * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- ðŸŒŠ WATER ELEMENT CURSOR (V20.4) ---
        function drawWaterCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(0, 191, 255, 0.8)', 'rgba(0, 123, 255, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(173, 216, 230, 0.5)', 'rgba(0, 191, 255, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(224, 247, 250, 0.2)', 'rgba(178, 235, 242, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Fluid Laser / Beam Path
            if (systemState.parameters.physics.showLaserBeam) {
                const dist = Math.sqrt((x - rawX) ** 2 + (y - rawY) ** 2);
                const steps = 10;
                ctx.lineWidth = state === 'COMMIT' ? 8 : 4;
                ctx.strokeStyle = c[1];
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);

                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    // Sine wave distortion for water feel
                    const wave = Math.sin(time / 200 + ratio * 10) * 5 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();

                // Inner white fluid core
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    const wave = Math.sin(time / 200 + ratio * 10) * 2 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();
            }

            // 2. Ripple Effect at Tip
            const rippleSize = (state === 'COMMIT' ? 20 : 12) + Math.sin(time / 300) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, rippleSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.5, c[1]);
            grad.addColorStop(1, 'rgba(0, 123, 255, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, rippleSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Bubbles/Droplets if committed
            if (state === 'COMMIT') {
                for (let i = 0; i < 3; i++) {
                    const bTime = (time + i * 1000) % 2000;
                    const bScale = bTime / 2000;
                    const bx = x + Math.cos(i * 2 + time / 500) * 20 * bScale;
                    const by = y - 30 * bScale; // Rise up
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - bScale) + ')';
                    ctx.beginPath(); ctx.arc(bx, by, 2 * (1 - bScale), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        // --- ðŸ”¥ FIRE ELEMENT CURSOR (V20.4) ---
        function drawFireCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 69, 0, 0.8)', 'rgba(255, 140, 0, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(255, 195, 0, 0.5)', 'rgba(255, 69, 0, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(255, 140, 0, 0.2)', 'rgba(128, 0, 0, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Heat Distortion Beam
            if (systemState.parameters.physics.showLaserBeam) {
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = c[1];
                ctx.lineWidth = state === 'COMMIT' ? 12 : 6;
                ctx.lineCap = 'round';
                ctx.globalAlpha = 0.6;
                ctx.stroke();

                // Subtler Flicker Core (V20.5: Reduced magnitude to stop "perceived" oscillation)
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x + (Math.random() - 0.5) * 3, y + (Math.random() - 0.5) * 3);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.2;
                ctx.stroke();
            }

            // 2. Rising Fireball at Tip (V20.5: Slower pulse)
            const fireSize = (state === 'COMMIT' ? 25 : 15) + Math.sin(time / 250) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, fireSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.4, c[1]);
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, fireSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Emitted Sparks
            if (state === 'COMMIT' || state === 'READY') {
                for (let i = 0; i < (state === 'COMMIT' ? 5 : 2); i++) {
                    const sparkTime = (time + i * 500) % 1000;
                    const sRatio = sparkTime / 1000;
                    const angle = (i * Math.PI * 2 / 5) + time / 1000;
                    const sx = x + Math.cos(angle) * 30 * sRatio;
                    // Rise up in screen space
                    const sy = y + Math.sin(angle) * 10 * sRatio - 60 * sRatio;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = 1 - sRatio;
                    ctx.beginPath(); ctx.arc(sx, sy, 2 * (1 - sRatio), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawElementalJuice(ctx, landmarks, readinessScore, canvasWidth, canvasHeight) {
            if (readinessScore <= 0.05) return;
            const intensity = readinessScore;
            const time = Date.now();

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Scale points based on intensity (0=wrist, 20=tips)
            const targetPoints = [0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 16, 17, 20];
            const activeCount = Math.floor(targetPoints.length * intensity);

            for (let i = 0; i < activeCount; i++) {
                const lm = landmarks[targetPoints[i]];
                const x = lm.x * canvasWidth;
                const y = lm.y * canvasHeight;

                const size = (15 + Math.sin(time / 100 + i) * 5) * intensity;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(0, `rgba(255, ${100 + Math.random() * 50}, 50, ${0.6 * intensity})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();

                // Upward Ash/Sparks
                if (Math.random() > 0.7) {
                    const sx = x + (Math.random() - 0.5) * 20;
                    const sy = y - (time % 1000 / 1000) * 40 * intensity;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = Math.random() * intensity;
                    ctx.beginPath(); ctx.arc(sx, sy, 1.5, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }

        // --- GEN5: Mirror-aware Handedness ---
        function getMirrorAwareHandedness(results, handIndex) {
            const name = results?.handedness?.[handIndex]?.[0]?.categoryName || 'Unknown';
            if (!systemState.parameters.camera.mirror) return name;
            if (name === 'Left') return 'Right';
            if (name === 'Right') return 'Left';
            return name;
        }

        function updateVisualPanels(results) {
            // Update Gestures Panel
            if (systemState.ui.gestures) {
                let html = '<div class="scrollable-panel">';
                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((cursor, i) => {
                        const hIdx = cursor.handIndex;
                        const gesture = cursor.gesture;
                        const score = cursor.confidence;
                        // Handedness still comes from raw results for now
                        const handedness = getMirrorAwareHandedness(results, hIdx);

                        const isCoasting = cursor.fsmState === 'COAST';
                        const stateColor = cursor.fsmState === 'COMMIT' ? 'var(--hfo-red)' : (isCoasting ? '#FFA500' : 'var(--md-sys-color-primary)');

                        // Deep Debug Data
                        const phys = systemState.p1.physicsState[hIdx];
                        const telemetry = phys && phys.getTelemetry ? phys.getTelemetry() : { speed: 0 };
                        const speed = telemetry.speed.toFixed(2);

                        const isPrimary = systemState.fsm.primaryHandIndex === hIdx;
                        const labelPrefix = isPrimary ? 'ðŸŽ–ï¸ [PRIMARY] ' : '';

                        html += `
                            <div class="m3-card" style="border-left: 4px solid ${stateColor}">
                                <div class="m3-label">${labelPrefix}Hand ${hIdx} | ${handedness}</div>
                                <div class="m3-stat">
                                    <span>Gesture | Confidence</span>
                                    <span style="font-weight:bold">${gesture} | ${(score * 100).toFixed(0)}%</span>
                                </div>
                                <div class="m3-stat" style="margin-top:8px">
                                    <span>Planck Speed (px/s)</span>
                                    <span style="color:var(--hfo-gold)">${speed}</span>
                                </div>
                                <div class="m3-stat">
                                    <span>Readiness Score</span>
                                    <span>${((cursor.readinessScore || 0) * 100).toFixed(1)}%</span>
                                </div>
                                <div class="m3-progress-container">
                                    <div class="m3-progress-bar" style="width: ${(cursor.readinessScore || 0) * 100}%; background: ${stateColor}"></div>
                                </div>
                                <div class="m3-stat">
                                    <span>Rod Sync (Projected)</span>
                                    <span style="font-family:monospace">${cursor.screenX.toFixed(0)}/${cursor.screenY.toFixed(0)}</span>
                                </div>
                                <div class="m3-stat" style="margin-top:4px; font-size:10px; opacity:0.7">
                                    <span>FSM State</span>
                                    <span>${cursor.fsmState || 'IDLE'}</span>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += '<div style="color:var(--md-sys-color-outline); text-align:center; margin-top:40px;">No hands detected</div>';
                }
                html += '</div>';
                systemState.ui.gestures.innerHTML = html;
            }

            // Update Palm Panel
            if (systemState.ui.palmCtx) {
                const ctx = systemState.ui.palmCtx;
                const canvas = systemState.ui.palm;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((c, i) => {
                        const x = (i === 0 ? canvas.width * 0.25 : canvas.width * 0.75);
                        const y = canvas.height * 0.5;
                        const radius = 40;

                        // ðŸŸ¢ Palm Orientation Sphere (Enhanced V14)
                        const enterT = systemState.parameters.palm.enterThreshold;
                        const exitT = systemState.parameters.palm.exitThreshold;

                        // Background Sphere
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = c.isPalmFacing ? 'rgba(0, 255, 65, 0.05)' : 'rgba(255, 65, 54, 0.05)';
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Hysteresis Rings (Target Zones)
                        ctx.setLineDash([2, 4]);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath(); ctx.arc(x, y, radius * enterT, 0, Math.PI * 2); ctx.stroke(); // Enter Ring
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.beginPath(); ctx.arc(x, y, radius * exitT, 0, Math.PI * 2); ctx.stroke();  // Exit Ring
                        ctx.setLineDash([]);

                        // Face Dot & Normal (Fabric Driven)
                        const nx = c.palmNormal.x;
                        const ny = c.palmNormal.y;
                        const nz = c.normalZ;

                        if (c.palmNormal) { // Fabric always has normal data if cursor exists
                            // ðŸ“Š UPDATE SPARKLINE BUFFERS
                            if (!systemState.ui.history) systemState.ui.history = [];
                            if (!systemState.ui.history[i]) systemState.ui.history[i] = { zNorm: [], readiness: [] };

                            systemState.ui.history[i].zNorm.push(nz);
                            systemState.ui.history[i].readiness.push(c.readinessScore);
                            if (systemState.ui.history[i].zNorm.length > 88) { // Pareto-length history
                                systemState.ui.history[i].zNorm.shift();
                                systemState.ui.history[i].readiness.shift();
                            }

                            // Dynamic Color based on facing status
                            const stateColor = c.isPalmFacing ? '#00FF41' : '#FF4136';

                            // Depth Progress Ring (Fidelity Visualization)
                            ctx.beginPath();
                            ctx.arc(x, y, radius * nz, 0, Math.PI * 2);
                            ctx.strokeStyle = stateColor;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;

                            // Draw Normal Vector Shadow/Pointer
                            const dotX = x + nx * radius;
                            const dotY = y + ny * radius;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(dotX, dotY);
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.stroke();

                            // Facing Dot (Orientation Feedback)
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 6, 0, Math.PI * 2);
                            ctx.fillStyle = stateColor;
                            ctx.shadowBlur = c.isPalmFacing ? 15 : 0;
                            ctx.shadowColor = stateColor;
                            ctx.fill();
                            ctx.shadowBlur = 0;

                            // Crosshair if inside "Goldilocks" area (approx)
                            if (nz > 0.88) {
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(dotX - 10, dotY); ctx.lineTo(dotX + 10, dotY); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(dotX, dotY - 10); ctx.lineTo(dotX, dotY + 10); ctx.stroke();
                            }

                            // ðŸ“Š Z-NORM Hysteresis Gauge
                            const gageW = 8, gageH = 80;
                            const gageX = x + radius + 15, gageY = y - gageH / 2;

                            // Track
                            ctx.fillStyle = '#111';
                            ctx.fillRect(gageX, gageY, gageW, gageH);

                            // ðŸ“Š SPARKLINE: Z-NORM HISTORY
                            const zHistory = systemState.ui.history[i].zNorm;
                            drawSparkline(ctx, gageX - 5, gageY, gageW + 10, gageH, zHistory, '#00FF4144');

                            // Thresholds (0.80 & 0.64) & Goldilocks (0.88)
                            const enterY = gageY + gageH * (1 - systemState.parameters.palm.enterThreshold);
                            const exitY = gageY + gageH * (1 - systemState.parameters.palm.exitThreshold);
                            const goldY = gageY + gageH * (1 - 0.88); // 88% Pareto Target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(gageX - 5, enterY); ctx.lineTo(gageX + gageW + 5, enterY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(gageX - 5, exitY); ctx.lineTo(gageX + gageW + 5, exitY); ctx.stroke();

                            // 88% Goldilocks Marker
                            ctx.strokeStyle = '#FFD700'; // Gold
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(gageX - 8, goldY); ctx.lineTo(gageX + gageW + 8, goldY); ctx.stroke();
                            ctx.setLineDash([]);

                            // Fill
                            const normFill = gageH * Math.max(0, Math.min(1, nz));
                            ctx.fillStyle = c.isPalmFacing ? '#00FF41' : '#444';
                            ctx.fillRect(gageX, gageY + gageH - normFill, gageW, normFill);

                            // âš–ï¸ Readiness Hysteresis Visualizer
                            const rgW = 12, rgH = 80;
                            const rgX = x - radius - 27, rgY = y - rgH / 2;
                            const readinessScore = systemState.p1.readinessScores[i] || 0;

                            ctx.fillStyle = '#111';
                            ctx.fillRect(rgX, rgY, rgW, rgH);

                            // ðŸ“Š SPARKLINE: READINESS HISTORY
                            const bHistory = systemState.ui.history[i].readiness;
                            drawSparkline(ctx, rgX - 5, rgY, rgW + 10, rgH, bHistory, '#D0BCFF44');

                            const highY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisHigh);
                            const lowY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisLow);
                            const targetY = rgY + rgH * (1 - 0.88); // 88% HIVE target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(rgX - 2, highY); ctx.lineTo(rgX + rgW + 2, highY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(rgX - 2, lowY); ctx.lineTo(rgX + rgW + 2, lowY); ctx.stroke();

                            // 88% Target Marker
                            ctx.strokeStyle = '#D0BCFF';
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(rgX - 5, targetY); ctx.lineTo(rgX + rgW + 5, targetY); ctx.stroke();
                            ctx.setLineDash([]);

                            const fillH = rgH * readinessScore;
                            ctx.fillStyle = c.fsmState === 'READY' ? '#FFD700' : (c.fsmState === 'COMMIT' ? '#FF4136' : '#D0BCFF');
                            ctx.fillRect(rgX, rgY + rgH - fillH, rgW, fillH);

                            // Textual readout
                            ctx.fillStyle = '#AAA';
                            ctx.font = '9px Roboto';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${(systemState.parameters.fsm.hysteresisHigh * 100).toFixed(0)}/${(systemState.parameters.fsm.hysteresisLow * 100).toFixed(0)} Z`, gageX + gageW / 2, gageY - 5);
                            ctx.fillText(`88% HFO`, rgX + rgW / 2, rgY - 5);
                            ctx.fillText(`Z: ${nz.toFixed(2)}`, gageX + gageW / 2, gageY + gageH + 12);
                            ctx.fillText(`READINESS: ${(readinessScore * 100).toFixed(0)}%`, rgX + rgW / 2, rgY + rgH + 12);
                            ctx.fillText(`FSM: ${c.fsmState}`, x, y + radius + 35);
                        }
                    });
                }
            }

            // --- V18: TACTICAL VIEW (P3 GHOST CURSOR) ---
            if (systemState.ui.tacticalCtx) {
                const ctx = systemState.ui.tacticalCtx;
                const canvas = systemState.ui.tactical;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Grid lines for tactical feel
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const gx = (i / 10) * canvas.width;
                    const gy = (i / 10) * canvas.height;
                    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
                }

                if (systemState.p1.cursors.length > 0) {
                    systemState.p1.cursors.forEach((c) => {
                        const tx = (c.screenX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ty = (c.screenY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        // Origin Pointer (Raw Sensing)
                        const rx = (c.rawX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ry = (c.rawY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        ctx.beginPath();
                        ctx.moveTo(rx, ry);
                        ctx.lineTo(tx, ty);
                        ctx.strokeStyle = '#555';
                        ctx.setLineDash([1, 1]);
                        ctx.stroke();

                        // Ghost Cursor (Tactical UI)
                        ctx.beginPath();
                        ctx.arc(tx, ty, 6, 0, Math.PI * 2);
                        ctx.strokeStyle = c.fsmState === 'COMMIT' ? '#FF4136' : '#FFD700';
                        ctx.setLineDash([]);
                        ctx.stroke();

                        // Pressure Indicator
                        if (c.fsmState === 'COMMIT') {
                            ctx.beginPath();
                            ctx.arc(tx, ty, 10 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 65, 54, 0.2)';
                            ctx.fill();
                        }

                        // Identifier
                        ctx.fillStyle = '#888';
                        ctx.font = '9px monospace';
                        ctx.fillText(`H${c.handIndex}:${c.fsmState}`, tx + 10, ty - 10);
                    });
                }
            }

            // Update FSM Visualization Panel
            if (systemState.ui.fsmCtx) {
                const ctx = systemState.ui.fsmCtx;
                const canvas = systemState.ui.fsm;
                if (canvas.width === 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const nodes = [
                    { id: 'IDLE', x: 0.15, y: 0.5 },
                    { id: 'READY', x: 0.4, y: 0.5 },
                    { id: 'COMMIT', x: 0.65, y: 0.5 },
                    { id: 'COAST', x: 0.9, y: 0.5 }
                ];

                const nodeWidth = 70, nodeHeight = 35;
                const current = systemState.fsm.currentState;

                // Draw Transitions
                ctx.strokeStyle = '#333';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                // IDLE -> READY
                ctx.moveTo(canvas.width * 0.15 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.4 - nodeWidth / 2, canvas.height * 0.5);
                // READY -> COMMIT
                ctx.moveTo(canvas.width * 0.4 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.65 - nodeWidth / 2, canvas.height * 0.5);
                // COMMIT -> COAST
                ctx.moveTo(canvas.width * 0.65 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.9 - nodeWidth / 2, canvas.height * 0.5);
                // Transitions back and to IDLE omitted for clarity in simple viz
                ctx.stroke();
                ctx.setLineDash([]);

                nodes.forEach(node => {
                    const nx = canvas.width * node.x;
                    const ny = canvas.height * node.y;
                    const isActive = node.id === current;

                    // Glow for active node
                    if (isActive) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF')));
                    }

                    ctx.fillStyle = isActive ? '#000' : '#111';
                    ctx.strokeStyle = isActive ? (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF'))) : '#444';
                    ctx.beginPath();
                    ctx.roundRect(nx - nodeWidth / 2, ny - nodeHeight / 2, nodeWidth, nodeHeight, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = isActive ? '#FFF' : '#888';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.id, nx, ny + 5);

                    // Draw Readiness Gauge for active state
                    if (isActive && node.id !== 'IDLE') {
                        const pIdx = systemState.fsm.primaryHandIndex !== null ? systemState.fsm.primaryHandIndex : 0;
                        const charge = systemState.p1.readinessScores[pIdx] || 0;
                        const high = systemState.parameters.fsm.hysteresisHigh;
                        const low = systemState.parameters.fsm.hysteresisLow;

                        ctx.fillStyle = '#222';
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth, 6);

                        // Fill
                        ctx.fillStyle = (node.id === 'COAST' ? '#FFA500' : '#FFD700');
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth * charge, 6);

                        // HFO Threshold Markers (80/64)
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * high, ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * high, ny + 30);
                        ctx.stroke();

                        ctx.strokeStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * low, ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * low, ny + 30);
                        ctx.stroke();
                    }
                });
            }
        }

        function updateFSM(state) {
            if (systemState.fsm.currentState !== state) {
                systemState.fsm.currentState = state;
                const status = document.getElementById('state-indicator');
                status.innerText = `P1: CONTRACTS ACTIVE | FSM: ${state}`;
            }
        }

        function drawResults(rawResults, fabric) {
            const { ctx, canvas } = systemState.p0;
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cursors = fabric.cursors;
            const isMirror = systemState.parameters.camera.mirror;

            // --- V19.6: INTEGRATED TACTICAL GRID ---
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const gx = (i / 10) * canvas.width;
                const gy = (i / 10) * canvas.height;
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }
            ctx.restore();

            // --- P0 ISR SKELETON (Restricted Bypass) ---
            // V24.18: Consolidated skeleton drawing to Port 1 Fabric loop below for state-awareness.

            // --- PORT 1 FABRIC VISUALS (Enforced) ---
            cursors.forEach((c, i) => {
                const { screenX, screenY, fsmState, rawX, rawY, landmarks } = c;

                // V24.19 Parity Fix: landmarks are already mirrored/processed by P1Bridger.
                // Do NOT re-mirror them here.
                if ((fsmState === 'IDLE' || fsmState === 'READY' || fsmState === 'COMMIT') && landmarks && landmarks.length > 0 && systemState.parameters.landmarks.showSkeleton) {
                    const utils = new DrawingUtils(ctx);

                    // V28.0: UPE-AWARE SKELETON
                    // We must project landmarks into buffer space using UPE to maintain parity
                    const bufferLandmarks = landmarks.map(l => ({
                        x: systemState.p1.toBufferX(l.x) / canvas.width,
                        y: systemState.p1.toBufferY(l.y) / canvas.height,
                        z: l.z
                    }));

                    utils.drawConnectors(bufferLandmarks, GestureRecognizer.HAND_CONNECTIONS, { color: 'rgba(255, 255, 255, 0.15)', lineWidth: 1.2 });
                    utils.drawLandmarks(bufferLandmarks, { color: 'rgba(255, 255, 255, 0.2)', radius: 1 });
                }

                // V28.5: DIAGNOSTIC CROSSHAIRS (Red Truth Calibration)
                if (isFlagEnabled('dev-mode') && fsmState !== 'IDLE') {
                    ctx.save();
                    ctx.strokeStyle = (fsmState === 'COMMIT') ? '#00ffff' : '#ff9900';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 20, screenY); ctx.lineTo(screenX + 20, screenY);
                    ctx.moveTo(screenX, screenY - 20); ctx.lineTo(screenX, screenY + 20);
                    ctx.stroke();
                    ctx.restore();
                }

                if (fsmState === 'IDLE') return;

                const theme = systemState.parameters.physics.cursorTheme;

                if (theme === 'LI') {
                    drawFireCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'DUI') {
                    drawWaterCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'QIAN') {
                    // Legacy Rigid Rod Logic (Metal/Heaven)
                    const color = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                    if (systemState.parameters.physics.showLaserBeam) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = fsmState === 'COMMIT' ? 10 : 6;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = fsmState === 'COMMIT' ? 0.9 : 0.6;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = fsmState === 'COMMIT' ? 3 : 2;
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 8 : 5, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Placeholder for other 5 elements (ZHEN, XUN, KAN, GEN, KUN)
                    const themeColors = {
                        'ZHEN': '#9400D3', 'XUN': '#00FF00', 'KAN': '#00008B',
                        'GEN': '#8B4513', 'KUN': '#A52A2A'
                    };
                    const color = themeColors[theme] || '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 10 : 6, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }

                // --- V19.6: INTEGRATED GHOST CURSOR (Tactical Layer) ---
                const ghostColor = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                ctx.save();
                ctx.beginPath();
                ctx.arc(screenX, screenY, 12, 0, Math.PI * 2);
                ctx.strokeStyle = ghostColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.restore();

                // Focal Crosshair (Goldilocks Zone)
                if (fsmState === 'COMMIT') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 10, screenY); ctx.lineTo(screenX + 10, screenY);
                    ctx.moveTo(screenX, screenY - 10); ctx.lineTo(screenX, screenY + 10);
                    ctx.stroke();
                }
            });
        }

        // --- P7: NAVIGATOR (Settings Shell) ---
        class P7Navigator {
            static applyTooltip(control, text) {
                if (!control || !text) return;
                const el = control.domElement || control?.$?.container || control?.$?.root;
                if (el) el.title = text;
            }

            static init(container) {
                const div = document.createElement('div');
                div.className = 'scrollable-panel';
                container.appendChild(div);

                const gui = new GUI({ container: div, title: 'ðŸ›°ï¸ NAVIGATOR CONFIG', autoPlace: false });
                gui._hfoFolders = {}; // V39: Custom registry to avoid lil-gui namespace collision

                // V39: ESSENTIALS / DEVELOPER TOGGLE (PROGRESSIVE DISCLOSURE)
                gui.add(systemState.parameters, 'essentialsMode')
                    .name('ESSENTIALS (KIOSK)')
                    .onChange(val => {
                        logMission(`UX Mode: ${val ? 'ESSENTIALS' : 'DEVELOPER'}`);
                        initLayout(val);
                        // Refresh GUI visibility (though the rebuild will recreate it)
                        P7Navigator.applyVisibility(gui, val);
                    });

                const fTelem = gui.addFolder('P6: Telemetry & Replay [V24.6]');
                gui._hfoFolders.fTelem = fTelem;
                fTelem.add(window.hfoTelemetry, 'isRecording').name('RECORDING ACTIVE').listen();
                fTelem.add({ start: () => window.hfoTelemetry.start() }, 'start').name('Start Recording');
                fTelem.add({ stop: () => window.hfoTelemetry.stop() }, 'stop').name('Stop Recording');
                fTelem.add({ export: () => window.hfoTelemetry.exportJSONL() }, 'export').name('Export .jsonl');

                // Replay Controls (Golden Master)
                fTelem.add(window.hfoPlayer, 'isPlaying').name('REPLAY ACTIVE').listen();
                fTelem.add(window.hfoPlayer, 'loop').name('Loop Replay');
                fTelem.add({
                    load: () => {
                        const inp = document.createElement('input');
                        inp.type = 'file';
                        inp.accept = '.jsonl';
                        inp.onchange = (e) => {
                            const file = e.target.files[0];
                            if (file) window.hfoPlayer.load(file);
                        };
                        inp.click();
                    }
                }, 'load').name('Load JSONL Replay');
                fTelem.add({ start: () => window.hfoPlayer.start() }, 'start').name('â–¶ Start Replay');
                fTelem.add({ stop: () => window.hfoPlayer.stop() }, 'stop').name('â¹ Stop Replay');
                fTelem.add({ pause: () => window.hfoPlayer.pause() }, 'pause').name('â¸ Pause Replay');

                // ðŸ’  HEXAGONAL PORTS (MOSA ALIGNMENT)
                const fPorts = gui.addFolder('ðŸ’  JADC2 MOSAIC PORTS');
                gui._hfoFolders.fPorts = fPorts;
                fPorts.add(systemState.parameters.apps.overlay, 'zoom', 0.5, 2.0, 0.01).name('Overscan Zoom').onChange(() => {
                    try {
                        window.hfoPorts?.p7?.apps?.applyActiveOverlayTuning?.();
                    } catch (_) {
                        // ignore
                    }
                });
                fPorts.add(systemState.parameters.ports, 'p0_recognizer', ['MEDIAPIPE_HANDS', 'TENSORFLOW_JS', 'OPENCV_STUB']).name('P0: Sensing Shard').onChange(val => {
                    logMission(`P0 Shard Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p1_fusion', ['UNIVERSAL_PROJECTION_V28', 'LEGACY_PIXI_MAP']).name('P1: Fusion Bridge').onChange(val => {
                    logMission(`P1 Bridge Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p2_fsm', ['SOVEREIGN_4_STATE', 'LEGACY_3_STATE', 'BFT_CONSENSUS']).name('P2: FSM Controller').onChange(val => {
                    logMission(`P2 Controller Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p3_injector', ['HYDRA_ADAPTER_PULSE', 'DIRECT_DOM_CLICK']).name('P3: Effect Injector').onChange(val => {
                    logMission(`P3 Injector Swapped: ${val}`);
                });

                const fP3 = gui.addFolder('P3: Pointer Injector (Adapter)');
                gui._hfoFolders.fP3 = fP3;
                fP3.add(systemState.parameters.p3, 'adapter', ['auto', 'excalidraw', 'standard']).name('Adapter').onChange(val => {
                    logMission(`P3 Adapter: ${val}`);
                });
                fP3.add(systemState.parameters.p3, 'enableClickSynthesis').name('Click Synthesis (Legacy)').onChange(val => {
                    logMission(`P3 Click Synthesis: ${val ? 'ENABLED' : 'DISABLED'}`);
                });
                fP3.add(systemState.parameters.p3, 'tapMoveThresholdPx', 0, 20, 1).name('Tap Threshold (px)').onChange(val => {
                    logMission(`P3 Tap Threshold: ${val}px`);
                });

                fPorts.add(systemState.parameters.visuals, 'engine', ['BABYLON', 'PIXI', 'CANVAS']).name('P4: Visual Substrate').onChange(val => {
                    logMission(`Port 4: Visual Engine Swapping to ${val}...`);
                    if (val === 'BABYLON') {
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'block';
                        }
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    } else if (val === 'CANVAS') {
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'block';
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'none';
                        }
                    } else if (val === 'PIXI') {
                        logMission("âš ï¸ PIXI Engine selected. Stub mode active.", "#FFA500");
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    }
                });

                const fVisuals = gui.addFolder('ðŸš€ P4: Visual Engines');
                gui._hfoFolders.fVisuals = fVisuals;
                fVisuals.add(systemState.parameters.visuals, 'variant').disable().name('Active: PHOENIX_CORE (BabylonJS)');
                fVisuals.add(systemState.parameters.physics, 'showTrailMesh').name('Show Trail Ribbon (Legacy)');
                fVisuals.add(systemState.parameters.physics, 'showHFOClaw').name('Show HFO Pointer Claw');

                const fCam = gui.addFolder('P0: Camera Range');
                gui._hfoFolders.fCam = fCam;
                fCam.add(systemState.parameters.camera, 'resolution', ['640x480', '1280x720', '1920x1080']).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'fpsTarget', 15, 60, 1).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'mirror').onChange(syncConfig);

                const fLand = gui.addFolder('P0: Neural Shards');
                gui._hfoFolders.fLand = fLand;
                fLand.add(systemState.parameters.landmarks, 'minConfidence', 0.1, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'numHands', 1, 4, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'showSkeleton');
                fLand.add(systemState.parameters.landmarks, 'skeletonFadeTimeMs', 100, 2000, 10).name('Skeleton Fade (ms)');
                fLand.add(systemState.parameters.landmarks, 'skeletonInactivityTimeoutMs', 500, 5000, 10).name('Dormancy Timeout (ms)');

                const fGest = gui.addFolder('P1: Gesture Confidence');
                gui._hfoFolders.fGest = fGest;
                fGest.add(systemState.parameters.gestures, 'minGestureConfidence', 0, 1).name('Confidence Threshold');
                fGest.add(systemState.parameters.gestures, 'preferredHand', ['Any', 'Left', 'Right']);

                const fPalm = gui.addFolder('P1: Palm Cone Orientation');
                gui._hfoFolders.fPalm = fPalm;
                fPalm.add(systemState.parameters.palm, 'enterThreshold', 0, 1).name('Enter Threshold (80)');
                fPalm.add(systemState.parameters.palm, 'exitThreshold', 0, 1).name('Exit Threshold (64)');

                const fFSM = gui.addFolder('P2: Sharding & Hysteresis (Dev)');
                gui._hfoFolders.fFSM = fFSM;
                fFSM.add(systemState.parameters.fsm, 'hysteresisHigh', 0, 1, 0.01).name('Ready Threshold (0-1)');
                fFSM.add(systemState.parameters.fsm, 'hysteresisLow', 0, 1, 0.01).name('Idle Threshold (0-1)');
                const ctrlCharge = fFSM.add(systemState.parameters.fsm, 'chargeTimeMs', 10, 1000).name('Charge Time (ms)');
                const ctrlRelease = fFSM.add(systemState.parameters.fsm, 'releaseTimeMs', 10, 1000).name('Release Time (ms)');
                const ctrlCoastDrain = fFSM.add(systemState.parameters.fsm, 'coastDrainTimeMs', 10, 3000).name('Coast Drain (ms)');
                P7Navigator.applyTooltip(ctrlCharge, 'Readiness energy fill time. Lower = faster arm.');
                P7Navigator.applyTooltip(ctrlRelease, 'Readiness energy drain time when facing away.');
                P7Navigator.applyTooltip(ctrlCoastDrain, 'Readiness drain time during COAST/tracking loss.');
                fFSM.add(systemState.parameters.fsm, 'tensionMs', 0, 500).name('Tension/Coyote (ms)');

                const fReadiness = gui.addFolder('P2: Readiness Energy');
                gui._hfoFolders.fReadiness = fReadiness;
                const ctrlFill = fReadiness.add(systemState.parameters.readiness, 'fillMultiplier', 0.1, 3.0).name('Fill Ratio');
                const ctrlDrain = fReadiness.add(systemState.parameters.readiness, 'drainMultiplier', 0.1, 3.0).name('Drain Ratio');
                const ctrlCoastMult = fReadiness.add(systemState.parameters.readiness, 'coastDrainMultiplier', 0.1, 3.0).name('Coast Drain Ratio');
                P7Navigator.applyTooltip(ctrlFill, 'Multiplier for readiness fill when palm/back faces camera.');
                P7Navigator.applyTooltip(ctrlDrain, 'Multiplier for readiness drain when facing away.');
                P7Navigator.applyTooltip(ctrlCoastMult, 'Extra drain multiplier during COAST/tracking loss.');

                const fCoast = gui.addFolder('P4: Coasting Control');
                gui._hfoFolders.fCoast = fCoast;
                const ctrlCoastTimeout = fCoast.add(systemState.parameters.coasting, 'timeoutMs', 0, 1000).name('Coast Timeout (ms)');
                const ctrlCoastConf = fCoast.add(systemState.parameters.coasting, 'confidenceThreshold', 0, 1).name('Min Signal Confidence');
                P7Navigator.applyTooltip(ctrlCoastTimeout, 'How long to coast on tracking loss before decay to IDLE.');
                P7Navigator.applyTooltip(ctrlCoastConf, 'Minimum confidence required to avoid COAST.');

                const fPhys = gui.addFolder('P2: Coordinate Substrate');
                gui._hfoFolders.fPhys = fPhys;
                fPhys.add(systemState.parameters.physics, 'mode', ['STATIC_ROD', 'PLANCK_SPRING']).name('Physics Mode').onChange(syncConfig);
                fPhys.add(systemState.parameters.physics, 'useDirectProjection').name('Direct Projection Flag');
                fPhys.add(systemState.parameters.physics, 'directProjectionOffset', 0, 0.5, 0.01).name('Direct Offset (LI)');
                fPhys.add(systemState.parameters.physics, 'cursorTheme', ['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']).name('HFO Element (Trigram)');
                fPhys.add(systemState.parameters.physics, 'oneEuroMinCutoff', 0.1, 5).name('Smoothing MinCutoff');
                fPhys.add(systemState.parameters.physics, 'oneEuroBeta', 0, 0.5).name('Smoothing Beta');
                fPhys.add(systemState.parameters.physics, 'planckStiffness', 0.1, 20).name('Planck Stiffness (Hz)');
                fPhys.add(systemState.parameters.physics, 'planckDamping', 0.0, 1.0).name('Planck Damping Ratio');
                fPhys.add(systemState.parameters.physics, 'palmRodMultiplier', 0.5, 10.0).step(0.1).name('Rod Length Factor');
                fPhys.add(systemState.parameters.physics, 'showLaserBeam').name('Show Beam Path');
                fPhys.add(systemState.parameters.physics, 'predictiveLookahead', 0, 5).name('Lookahead Factor');

                // v11.4: Active App overlay tuning (opacity + overscan zoom).
                const fAppsOverlay = gui.addFolder('P7: Active App Overlay');
                gui._hfoFolders.fAppsOverlay = fAppsOverlay;

                const applyActiveOverlay = () => {
                    const activeId = window.hfoPorts?.p7?.apps?.getActiveId?.();
                    const p = systemState?.parameters?.apps;
                    if (p?.overlay?.rememberPerApp && activeId) {
                        p.perApp = p.perApp || {};
                        p.perApp[activeId] = {
                            opacity: p.overlay.opacity,
                            zoom: p.overlay.zoom
                        };
                    }
                    try {
                        window.hfoPorts?.p7?.apps?.applyActiveOverlayTuning?.();
                    } catch (_) {
                        // ignore
                    }
                };

                fAppsOverlay.add(systemState.parameters.apps.overlay, 'opacity', 0, 1, 0.01).name('Opacity').listen().onChange(applyActiveOverlay);
                fAppsOverlay.add(systemState.parameters.apps.overlay, 'zoom', 1.0, 2.0, 0.01).name('Overscan Zoom').listen().onChange(applyActiveOverlay);
                fAppsOverlay.add(systemState.parameters.apps.overlay, 'rememberPerApp').name('Remember Per App');

                const fTools = gui.addFolder('P7: Adapter Tools (Message)');
                gui._hfoFolders.fTools = fTools;
                fTools.add(systemState.parameters.excalidraw, 'activeTool', [
                    'selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'freedraw', 'text', 'eraser'
                ]).name('Active Tool').onChange(val => {
                    try {
                        window.hfoPorts?.p7?.navigate?.setActiveAdapterTool?.(val);
                    } catch (_) {
                        // ignore
                    }
                });

                const fAnat = gui.addFolder('P1: Anatomical Constraints');
                gui._hfoFolders.fAnat = fAnat;
                fAnat.add(systemState.parameters.anatomy, 'palmWidthCm', 4, 12, 0.1).name('Palm Width (cm)').onChange(syncConfig);
                fAnat.add(systemState.parameters.anatomy, 'rodExtensionMultiplier', 0.1, 5, 0.1).name('Rod Extension Factor').onChange(syncConfig);

                const fSystem = gui.addFolder('ðŸ›°ï¸ P7: SYSTEM & ONBOARDING');
                gui._hfoFolders.fSystem = fSystem;
                fSystem.add(systemState.parameters.ui, 'showTutorial').name('ONBOARDING ACTIVE').listen();
                fSystem.add({ reset: () => { window.hfoTutorial.reset(); } }, 'reset').name('Reset Tutorial');

                const fDebug = gui.addFolder('P5: Deep Visual Debugging');
                gui._hfoFolders.fDebug = fDebug;
                fDebug.add(systemState.parameters, 'devMode').name('Enable Full Telemetry').onChange(syncConfig);
                fDebug.add(systemState.parameters.landmarks, 'showSkeleton').name('Draw Skeleton');

                function syncConfig() {
                    const valid = P1Bridger.validateConfig(systemState.parameters);
                    if (valid && systemState.p0.recognizer) {
                        systemState.p0.recognizer.setOptions({
                            numHands: valid.landmarks.numHands,
                            minHandDetectionConfidence: valid.landmarks.minConfidence
                        });
                        logMission("P7: Configuration Synchronized & Validated");
                    }
                }

                // V39: Apply initial visibility
                P7Navigator.applyVisibility(gui, systemState.parameters.essentialsMode);
            }

            // V39: Gating Visibility Logic for Progressive Disclosure
            static applyVisibility(gui, isEssentials) {
                console.log(`[P7] applyVisibility called: isEssentials=${isEssentials}`);
                const folders = gui._hfoFolders;
                if (!folders) {
                    console.log("[P7] No folders found in registry!");
                    return;
                }

                // Folders to Keep in Essentials/Kiosk Mode
                const whitelist = ['fExcal', 'fPorts', 'fTelem', 'fTools', 'fSystem', 'fP3', 'fAppsOverlay'];

                Object.keys(folders).forEach(key => {
                    const folder = folders[key];
                    if (isEssentials && !whitelist.includes(key)) {
                        console.log(`[P7] Hiding folder: ${key}`);
                        folder.hide();
                    } else {
                        console.log(`[P7] Showing folder: ${key}`);
                        folder.show();
                    }
                });
            }
        }

        function resizeCanvas() {
            const { video, canvas } = systemState.p0;
            if (!video || !canvas) return;

            // V28: Fallback resolution for headless/mock testing
            const [w_param, h_param] = systemState.parameters.camera.resolution.split('x').map(Number);
            const vw = video.videoWidth || w_param || 1280;
            const vh = video.videoHeight || h_param || 720;

            systemState.p0.videoBounds = { width: vw, height: vh };

            const parent = video.parentElement;
            if (!parent) return;

            // V32: SAFESTEP DIMENSIONS (Avoid GL Transition Flicker)
            const pRect = parent.getBoundingClientRect();
            let parentWidth = pRect.width;
            let parentHeight = pRect.height;

            // If dimensions are zero, retry in 100ms
            if (parentWidth <= 0 || parentHeight <= 0) {
                if (!window._resizeRetry) {
                    window._resizeRetry = true;
                    setTimeout(() => { window._resizeRetry = false; resizeCanvas(); }, 150);
                }
                return;
            }

            const vRatio = vw / vh;

            let drawW_base = parentWidth, drawH_base = parentWidth / vRatio;
            if (drawH_base > parentHeight) { drawH_base = parentHeight; drawW_base = drawH_base * vRatio; }

            // V36: ADAPTIVE OVERSCAN (Automated Cover Baseline)
            // Ensures no black bars (Pillar/Letterbox) regardless of panel aspect ratio.
            const coverZoom = Math.max(parentWidth / drawW_base, parentHeight / drawH_base);
            const userZoom = systemState.parameters.excalidraw.zoomFactor || 1.0;
            const zoom = coverZoom * userZoom;

            const drawW = drawW_base * zoom;
            const drawH = drawH_base * zoom;

            // V24.19: Substrate Parity Alignment
            // Center zoomed substrates (offsetX/Y will be negative if zoom > 1.0)
            const offsetX = (parentWidth - drawW) / 2;
            const offsetY = (parentHeight - drawH) / 2;

            // V28.5: Hardened Video Alignment (Fix for Visual Drift)
            video.style.objectFit = 'fill';
            video.style.width = `${drawW}px`;
            video.style.height = `${drawH}px`;
            video.style.left = `${offsetX}px`;
            video.style.top = `${offsetY}px`;
            video.style.position = 'absolute';
            // V28.5: Standard Mirroring Logic
            const isMirror = systemState.parameters.camera.mirror;
            video.style.transform = isMirror ? 'scaleX(-1)' : 'none';

            // Set buffer size to match video source (High-fidelity sensing baseline)
            canvas.width = vw;
            canvas.height = vh;

            // V24.20: Store view bounds for coordinate transformation parity
            systemState.ui.viewBounds = {
                width: drawW,
                height: drawH,
                offsetX: offsetX,
                offsetY: offsetY,
                containerRect: pRect // V33: Store physical bounds for Option 1 mapping
            };

            // Sync Substrates (Decoupled Architecture)
            // V36: Shared Data Fabric Parity
            // Video and Babylon represent the 'Physical' substrate (Zoomable/Overscan)
            // Excalidraw represents the 'Interface' substrate (Always 100% of panel)

            const physicalSubstrates = [
                canvas,
                ...systemState.ui.juiceLayers.map(l => l.canvas)
            ];

            physicalSubstrates.forEach(el => {
                if (el) {
                    el.style.position = 'absolute';
                    el.style.left = `${offsetX}px`;
                    el.style.top = `${offsetY}px`;
                    el.style.width = `${drawW}px`;
                    el.style.height = `${drawH}px`;
                }
            });

            // V36: DECOUPLE EXCALIDRAW (NO CLIPPING)
            if (systemState.ui.excalidrawOverlay) {
                const el = systemState.ui.excalidrawOverlay;
                el.style.position = 'absolute';
                el.style.left = '0px';
                el.style.top = '0px';
                el.style.width = '100%';
                el.style.height = '100%';
                // The iframe inside already has width/height 100%
            }

            // V28.5: Calibration Markers (UPE Parity Verification)
            let calWrap = document.getElementById('upe-calibration-overlay');
            if (isFlagEnabled('dev-mode')) {
                if (!calWrap) {
                    calWrap = document.createElement('div');
                    calWrap.id = 'upe-calibration-overlay';
                    calWrap.style.position = 'absolute';
                    calWrap.style.pointerEvents = 'none';
                    calWrap.style.zIndex = '1000';
                    parent.appendChild(calWrap);
                }
                calWrap.style.left = `${offsetX}px`;
                calWrap.style.top = `${offsetY}px`;
                calWrap.style.width = `${drawW}px`;
                calWrap.style.height = `${drawH}px`;
                calWrap.innerHTML = `
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:red; font-size:10px; font-weight:bold;">UPE PARITY BOX</div>
                `;
            } else if (calWrap) {
                calWrap.remove();
            }

            // Trigger engine resizes to match the new CSS bounds
            systemState.ui.juiceLayers.forEach(l => {
                if (l.resize) l.resize(drawW, drawH);
            });
        }

        function logMission(msg, color = '#00ff41') {
            const logs = document.getElementById('mission-logs');
            if (!logs) return;
            const entry = document.createElement('div');
            entry.style.color = color;
            entry.innerText = `[${new Date().toLocaleTimeString('en-GB')}] ${msg}`;
            logs.prepend(entry);
        }

        // --- LAYOUT ENGINE ---
        const container = document.getElementById('layout-container');
        let layout = new GoldenLayout(container);

        function initLayout(isEssentials = true) {
            // V39: CLEAR PREVIOUS LAYOUT IF IT EXISTS
            if (layout) {
                try {
                    layout.destroy();
                } catch (e) { console.warn("Layout Destroy Error:", e); }
            }
            layout = new GoldenLayout(container);

            // Register components (Must re-register after destroy/init in GL v2)
            registerAllComponents(layout);

            const isMultiApp = isFlagEnabled('ui-multiapp');
            const isMultiView = isFlagEnabled('ui-multiview');

            const gameSelectorTabs = [];

            const appSelectorStack = {
                type: 'stack',
                height: 10,
                content: [
                    { type: 'component', componentType: 'app-excalidraw', title: 'App: Excalidraw' },
                    { type: 'component', componentType: 'app-sandbox', title: 'App: Sandbox' },
                    { type: 'component', componentType: 'app-pointer-lab', title: 'App: Pointer Lab' },
                    ...gameSelectorTabs
                ]
            };

            const heroComponent = {
                type: 'component',
                componentType: 'hero',
                title: 'Tactical Workspace',
                minWidth: 400,
                minHeight: 300
            };

            const mirrorComponent = {
                type: 'component',
                componentType: 'camera-mirror',
                title: 'Camera Mirror',
                minWidth: 240,
                minHeight: 180
            };

            const heroArea = isMultiView
                ? { type: 'row', height: 90, content: [heroComponent, mirrorComponent] }
                : { type: 'stack', height: 90, content: [heroComponent] };

            const leftPane = isMultiApp
                ? { type: 'column', width: 75, content: [appSelectorStack, heroArea] }
                : (isMultiView
                    ? { type: 'row', width: 75, content: [heroComponent, mirrorComponent] }
                    : { type: 'stack', width: 75, content: [heroComponent] }
                );

            const kioskPlan = {
                root: {
                    type: 'row', content: [
                        leftPane,
                        {
                            type: 'column', width: 25, content: [
                                { type: 'component', componentType: 'navigator', title: 'Port 7: Navigator', height: isFlagEnabled('ui-intent') ? 60 : 80 },
                                ...(isFlagEnabled('ui-intent')
                                    ? [{ type: 'component', componentType: 'intent', title: 'Intent Injector', height: 20 }]
                                    : []),
                                { type: 'component', componentType: 'logs', title: 'System Telemetry', height: 20 }
                            ]
                        }
                    ]
                }
            };

            const devPlan = {
                root: {
                    type: 'row', content: [
                        (isMultiApp
                            ? { type: 'column', width: 60, content: [appSelectorStack, heroArea] }
                            : (isMultiView
                                ? { type: 'row', width: 60, content: [heroComponent, mirrorComponent] }
                                : { type: 'stack', width: 60, content: [heroComponent] }
                            )
                        ),
                        {
                            type: 'column', width: 40, minWidth: 300, content: [
                                {
                                    type: 'row', height: 40, content: [
                                        { type: 'component', componentType: 'gestures', title: 'P1: Gestures' },
                                        { type: 'component', componentType: 'palm', title: 'P1: Palm Orientation' },
                                        { type: 'component', componentType: 'tactical', title: 'P3: Integrated Tactical' }
                                    ]
                                },
                                { type: 'component', componentType: 'fsm-viz', title: 'Tactical FSM Visualization', height: 15 },
                                { type: 'component', componentType: 'navigator', title: 'Port 7: Navigator', height: isFlagEnabled('ui-intent') ? 15 : 20 },
                                ...(isFlagEnabled('ui-intent')
                                    ? [{ type: 'component', componentType: 'intent', title: 'Intent Injector', height: 10 }]
                                    : []),
                                { type: 'component', componentType: 'logs', title: 'System Telemetry', height: 5 }
                            ]
                        }
                    ]
                }
            };

            layout.loadLayout(isEssentials ? kioskPlan : devPlan);

            // GEN5 v11.1: Wire GoldenLayout tab activation â†’ P7 AppHost activation.
            // Invariant: no behavior change unless `?flag-ui-multiapp=true`.
            if (isFlagEnabled('ui-multiapp')) {
                const safeActivate = (appId) => {
                    try {
                        window.hfoPorts?.p7?.apps?.activate?.(appId);
                    } catch (e) {
                        console.warn('[v11.1] AppHost activate failed:', e);
                    }
                };

                const resolveAppIdFromComponentType = (componentType) => {
                    if (!componentType || typeof componentType !== 'string') return null;
                    if (componentType === 'app-excalidraw') return 'excalidraw';
                    if (componentType === 'app-sandbox') return 'sandbox';
                    if (componentType === 'app-pointer-lab') return 'pointer-lab';
                    if (componentType === 'app-game-tap') return 'game-tap';
                    if (componentType === 'app-game-paddle') return 'game-paddle';
                    if (componentType === 'app-game-runner') return 'game-runner';
                    if (componentType === 'app-game-bricks') return 'game-bricks';
                    return null;
                };

                const onActiveChanged = (contentItem) => {
                    const componentType =
                        contentItem?.componentType ||
                        contentItem?.config?.componentType ||
                        contentItem?.componentItemConfig?.componentType ||
                        null;
                    const appId = resolveAppIdFromComponentType(componentType);
                    if (appId) {
                        safeActivate(appId);
                        try {
                            window.hfoUI?.setActiveAppDropdown?.(appId);
                        } catch (_) {
                            // ignore
                        }
                    }
                };

                try {
                    layout.on?.('activeContentItemChanged', onActiveChanged);
                } catch (e) {
                    console.warn('[v11.1] Failed to wire activeContentItemChanged:', e);
                }

                // Default active app (best-effort) so routing gates have a deterministic baseline.
                setTimeout(() => {
                    try {
                        const apps = window.hfoPorts?.p7?.apps;
                        if (!apps?.getActiveId?.()) {
                            const list = apps?.list?.() || [];
                            const hasPointerLab = !!list.find(m => m?.appId === 'pointer-lab');
                            safeActivate(hasPointerLab ? 'pointer-lab' : 'excalidraw');
                        }
                    } catch (_) {
                        // ignore
                    }
                }, 0);
            }

            window.addEventListener('resize', () => {
                layout.updateSize();
                resizeCanvas();
            });
        }

        function registerAllComponents(layout) {
            layout.registerComponentFactoryFunction('hero', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.innerHTML = `
                    <div class="hero-view-container">
                        <video id="video-feed" autoplay playsinline></video>

                        <!-- EXCALIDRAW OVERLAY LAYER [V20.1: Dark Mode Hardening] -->
                        ${(isFlagEnabled('ui-excalidraw') || isFlagEnabled('ui-multiapp')) ? `
                        <!-- V32: RESTORED INTERACTION (GLASS WALL MANAGED VIA Z-INDEX) -->
                        <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8; display:none; pointer-events: auto;">
                            <iframe
                                id="excalidraw-iframe"
                                src="excalidraw_v20_wrapper.html"
                                style="width:100%; height:100%; border:none; filter: contrast(1.1) brightness(0.9); background: transparent;"
                                allow="clipboard-read; clipboard-write; display-capture">
                            </iframe>
                        </div>
                        ` : ''}


                        <!-- GEN5 v11.1: Same-origin sandbox app overlay (for multi-app routing gates) -->
                        <div id="sandbox-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:5; opacity: 0.95; display:none; pointer-events: auto;">
                            <iframe
                                id="sandbox-iframe"
                                src="sandbox_canvas_app.html"
                                style="width:100%; height:100%; border:none; background: #000;"
                                allow="clipboard-read; clipboard-write; display-capture">
                            </iframe>
                        </div>

                        <!-- GEN5 v12: Pointer Lab overlay (same-origin; touch/stylus validation) -->
                        <div id="pointer-lab-overlay" style="position:absolute; width:100%; height:100%; z-index:6; opacity: 1.0; display:none; pointer-events: auto;">
                            <iframe
                                id="pointer-lab-iframe"
                                src="pointer_lab_app.html"
                                style="width:100%; height:100%; border:none; background: #000;"
                                allow="clipboard-read; clipboard-write">
                            </iframe>
                        </div>

                        <!-- OFFICIAL: MDN Breakout workshop (vendored; same-origin) -->
                        <div id="breakout-overlay" style="position:absolute; width:100%; height:100%; z-index:6; opacity: 1.0; display:none; pointer-events: auto;">
                            <iframe
                                id="breakout-iframe"
                                src="official_adapters/mdn_breakout_end3r/index.html"
                                style="width:100%; height:100%; border:none; background: #000;"
                                allow="clipboard-read; clipboard-write">
                            </iframe>
                        </div>

                        <!-- OFFICIAL: Dino Runner (v1) (vendored; same-origin) -->
                        <div id="dino-overlay" style="position:absolute; width:100%; height:100%; z-index:6; opacity: 1.0; display:none; pointer-events: auto;">
                            <iframe
                                id="dino-iframe"
                                src="dino_v1_wrapper.html"
                                style="width:100%; height:100%; border:none; background: #000;"
                                allow="clipboard-read; clipboard-write">
                            </iframe>
                        </div>


                        <!-- NOTE: Bespoke Gen5 game overlays removed (official vendoring only). -->

                        <div id="babylon-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:9;"></div>
                        <canvas id="overlay-canvas" style="z-index:11;"></canvas>

                        <!-- ðŸ“– V30 TACTICAL TUTORIAL -->
                        <div id="hfo-tutorial" class="tutorial-overlay">
                            <div class="m3-label" id="tut-header">Tactical Instruction</div>
                            <div class="tutorial-step" id="tut-body">
                                Initializing Mission Profile...
                            </div>
                            <div id="tut-progress-container" class="m3-progress-container" style="display:none; margin-top: 12px; height: 2px;">
                                <div id="tut-progress-bar" class="m3-progress-bar" style="width: 0%; background: var(--md-sys-color-primary);"></div>
                            </div>
                        </div>

                        <button id="btn-ignite" class="hfo-btn" style="position:absolute; bottom:30px; z-index:20;">IGNITE OMEGA</button>
                    </div>
                `;
                container.getElement().appendChild(wrap);

                // V34: RE-IMPLEMENTED RESIZE OBSERVER (Fixed Layout Clipping)
                // Ensures UPE Parity Box is recalculated whenever the GL panel resizes
                const heroObserver = new ResizeObserver(() => {
                    resizeCanvas();
                });
                heroObserver.observe(wrap);

                systemState.p0.video = wrap.querySelector('#video-feed');
                systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
                systemState.p0.ctx = systemState.p0.canvas.getContext('2d');

                // Reference for tutorial
                systemState.ui.tutorial = wrap.querySelector('#hfo-tutorial');
                systemState.ui.tutHeader = wrap.querySelector('#tut-header');
                systemState.ui.tutBody = wrap.querySelector('#tut-body');
                systemState.ui.tutProgress = wrap.querySelector('#tut-progress-container');
                systemState.ui.tutProgressBar = wrap.querySelector('#tut-progress-bar');

                // Reference for opacity control
                systemState.ui.excalidrawOverlay = wrap.querySelector('#excalidraw-hero-overlay');
                systemState.ui.excalidrawIframe = wrap.querySelector('#excalidraw-iframe');

                systemState.ui.sandboxOverlay = wrap.querySelector('#sandbox-hero-overlay');
                systemState.ui.sandboxIframe = wrap.querySelector('#sandbox-iframe');

                systemState.ui.pointerLabOverlay = wrap.querySelector('#pointer-lab-overlay');
                systemState.ui.pointerLabIframe = wrap.querySelector('#pointer-lab-iframe');

                systemState.ui.breakoutOverlay = wrap.querySelector('#breakout-overlay');
                systemState.ui.breakoutIframe = wrap.querySelector('#breakout-iframe');

                systemState.ui.dinoOverlay = wrap.querySelector('#dino-overlay');
                systemState.ui.dinoIframe = wrap.querySelector('#dino-iframe');

                // NOTE: App switching UI lives in the Navigator panel (Essentials), not the hero.

                // V23: Initialize Hybrid Substrates (Gated by V24.1 OpenFeature)
                const babylonWrap = wrap.querySelector('#babylon-juice-overlay');
                let babylonJuice = null;

                if (isFlagEnabled('engine-babylon') && babylonWrap) {
                    babylonJuice = new BabylonJuiceSubstrate(babylonWrap);
                }

                systemState.ui.juiceLayers = [babylonJuice].filter(l => l !== null);

                wrap.querySelector('#btn-ignite').onclick = async (e) => {
                    e.target.style.display = 'none';

                    // V24.1: Ensure only enabled engines are displayed
                    if (babylonJuice) babylonJuice.canvas.style.display = 'block';

                    // ðŸŽ¨ V26.1: Show Excalidraw overlay on Ignite if enabled
                    if (systemState.ui.excalidrawOverlay && systemState.parameters.excalidraw.enabled) {
                        systemState.ui.excalidrawOverlay.style.display = 'block';
                    }

                    // ðŸ“– V30: Start Tutorial
                    window.hfoTutorial.show();

                    const disableCamera = isFlagEnabled('disable-camera');
                    if (!disableCamera) {
                        await initP0();
                    }

                    const [w, h] = systemState.parameters.camera.resolution.split('x');
                    if (disableCamera) {
                        systemState.parameters.p0Active = true;
                        resizeCanvas();
                        predictLoop();
                    } else {
                        try {
                            const camera = window.hfoRegistry?.resolve?.(window.hfoTokens.P0_CAMERA) || null;
                            const stream = camera
                                ? await camera.getStream({ width: parseInt(w), height: parseInt(h) })
                                : await navigator.mediaDevices.getUserMedia({ video: { width: parseInt(w), height: parseInt(h) } });
                            systemState.p0.video.srcObject = stream;
                            systemState.p0.video.onloadeddata = () => {
                                systemState.parameters.p0Active = true;
                                resizeCanvas(); predictLoop();
                            };
                        } catch (err) {
                            console.warn("P0 Camera Error:", err);
                            // Playwright Fallback: Ensure the loop starts for mock-based testing
                            systemState.parameters.p0Active = true;
                            resizeCanvas();
                            predictLoop();
                        }
                    }
                };

                // Responsiveness: Hub Listener
                container.on('resize', () => {
                    resizeCanvas();
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        if (babylonJuice) babylonJuice.resize();
                    }
                });

                // V24.5: Component Teardown Integration
                container.on('destroy', () => {
                    console.log("[LIFECYCLE] Destroying Hero Component...");
                    if (babylonJuice) window.hfoLifecycle.unregister(babylonJuice);
                    systemState.p0.video = null;
                    systemState.p0.canvas = null;
                    systemState.ui.juiceLayers = [];
                });
            });

            // GEN5 v11.2: multiview mirror (shares stream via P0_CAMERA).
            layout.registerComponentFactoryFunction('camera-mirror', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.innerHTML = `
                    <div class="hero-view-container" style="background:#000;">
                        <video class="video-mirror" autoplay playsinline muted style="width:100%; height:100%; object-fit:cover;"></video>
                        <div style="position:absolute; top:8px; left:8px; z-index:20; color:#7CFC90; font-family:monospace; font-size:11px; opacity:0.9;">MULTIVIEW MIRROR</div>
                    </div>
                `;
                container.getElement().appendChild(wrap);

                const video = wrap.querySelector('video');
                const attach = async () => {
                    if (!video) return;
                    try {
                        const camera = window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA);
                        const stream = await camera.getStream();
                        video.srcObject = stream;
                    } catch (e) {
                        console.warn('[v11.2] camera-mirror attach failed:', e);
                    }
                };

                if (isFlagEnabled('ui-multiview')) {
                    // Best-effort attach immediately; shared adapter ensures only one getUserMedia call.
                    attach();
                }

                container.on('destroy', () => {
                    try {
                        if (video) video.srcObject = null;
                    } catch { }
                });
            });

            // GEN5 v11.1: App selector components (tabs live in GoldenLayout; AppHost controls overlay visibility).
            // These components intentionally have no side-effects; activation is wired at the layout level.
            layout.registerComponentFactoryFunction('app-excalidraw', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Excalidraw';
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('app-sandbox', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Sandbox';
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('app-pointer-lab', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                wrap.style.color = '#7CFC90';
                wrap.style.fontFamily = 'monospace';
                wrap.style.fontSize = '12px';
                wrap.innerText = 'Select Pointer Lab';
                container.getElement().appendChild(wrap);
            });

            // NOTE: Bespoke Gen5 game component factories removed (official vendoring only).

            layout.registerComponentFactoryFunction('navigator', (container) => {
                const root = container.getElement();

                // Essentials header + app hot-swap (kept out of HERO for clarity).
                const essentials = document.createElement('div');
                essentials.style.display = 'flex';
                essentials.style.flexDirection = 'column';
                essentials.style.gap = '8px';
                essentials.style.padding = '10px 10px 0 10px';
                essentials.style.background = '#000';
                essentials.style.borderBottom = '1px solid rgba(124,252,144,0.12)';

                const title = document.createElement('div');
                title.textContent = 'Essentials';
                title.style.fontFamily = 'monospace';
                title.style.fontSize = '12px';
                title.style.color = '#7CFC90';
                title.style.opacity = '0.9';

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '8px';

                const label = document.createElement('div');
                label.textContent = 'App';
                label.style.fontFamily = 'monospace';
                label.style.fontSize = '12px';
                label.style.color = '#7CFC90';
                label.style.opacity = '0.9';

                const select = document.createElement('select');
                select.id = 'hfo-app-dropdown';
                select.style.background = '#050a05';
                select.style.color = '#7CFC90';
                select.style.border = '1px solid rgba(124,252,144,0.25)';
                select.style.borderRadius = '10px';
                select.style.padding = '6px 8px';
                select.style.fontFamily = 'monospace';
                select.style.fontSize = '12px';

                row.appendChild(label);
                row.appendChild(select);
                essentials.appendChild(title);
                essentials.appendChild(row);
                root.appendChild(essentials);

                const guiHost = document.createElement('div');
                guiHost.style.padding = '10px';
                guiHost.style.boxSizing = 'border-box';
                guiHost.style.background = '#000';
                root.appendChild(guiHost);

                // Wire dropdown â†’ AppHost activation (and keep it in sync).
                window.hfoUI = window.hfoUI || {};
                const refreshAppDropdown = () => {
                    if (!select) return false;
                    let list = [];
                    try {
                        const host = window.hfoRegistry?.resolve?.(window.hfoTokens?.P7_APPHOST);
                        list = host?.list?.() || window.hfoPorts?.p7?.apps?.list?.() || [];
                    } catch (_) {
                        list = [];
                    }

                    const activeId = (() => {
                        try {
                            const host = window.hfoRegistry?.resolve?.(window.hfoTokens?.P7_APPHOST);
                            return host?.getActiveId?.() || window.hfoPorts?.p7?.apps?.getActiveId?.() || '';
                        } catch (_) {
                            return '';
                        }
                    })();

                    const prev = select.value;
                    select.innerHTML = '';

                    for (const m of list) {
                        if (!m?.appId) continue;
                        const opt = document.createElement('option');
                        opt.value = m.appId;
                        opt.textContent = m.title ? `${m.title}` : m.appId;
                        select.appendChild(opt);
                    }

                    const next = activeId || prev;
                    if (next) select.value = next;
                    return true;
                };

                window.hfoUI.refreshAppDropdown = refreshAppDropdown;
                window.hfoUI.setActiveAppDropdown = (appId) => {
                    if (!select) return false;
                    select.value = String(appId || '');
                    return true;
                };

                select.onchange = () => {
                    const appId = select.value;
                    try {
                        const host = window.hfoRegistry?.resolve?.(window.hfoTokens?.P7_APPHOST);
                        if (host?.activate) host.activate(appId);
                        else window.hfoPorts?.p7?.apps?.activate?.(appId);
                    } catch (e) {
                        console.warn('[v12.1] App dropdown activation failed:', e);
                    }
                };

                refreshAppDropdown();
                setTimeout(refreshAppDropdown, 0);
                setTimeout(refreshAppDropdown, 250);

                // v12.1 Dino: default active app if none is selected yet.
                try {
                    const host = window.hfoRegistry?.resolve?.(window.hfoTokens?.P7_APPHOST);
                    const active = host?.getActiveId?.() || '';
                    if (!active) host?.activate?.('dino-v1');
                } catch (_) {
                    // ignore
                }

                P7Navigator.init(guiHost);
            });

            layout.registerComponentFactoryFunction('logs', (container) => {
                const div = document.createElement('div');
                div.id = 'mission-logs';
                div.className = 'scrollable-panel';
                div.style.background = '#000'; div.style.fontSize = '10px'; div.style.fontFamily = 'monospace';
                container.getElement().appendChild(div);
                logMission("SYSTEM_LOGS: READY");
            });

            layout.registerComponentFactoryFunction('intent', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.gap = '8px';
                wrap.style.padding = '10px';
                wrap.style.boxSizing = 'border-box';

                const title = document.createElement('div');
                title.textContent = 'Intent Injector (P7)';
                title.style.fontFamily = 'monospace';
                title.style.fontSize = '12px';
                title.style.color = '#7CFC90';
                title.style.opacity = '0.9';

                const textarea = document.createElement('textarea');
                textarea.spellcheck = false;
                textarea.style.width = '100%';
                textarea.style.flex = '1 1 auto';
                textarea.style.minHeight = '80px';
                textarea.style.resize = 'vertical';
                textarea.style.background = '#050a05';
                textarea.style.color = '#7CFC90';
                textarea.style.border = '1px solid rgba(124,252,144,0.25)';
                textarea.style.borderRadius = '10px';
                textarea.style.padding = '10px';
                textarea.style.fontFamily = 'monospace';
                textarea.style.fontSize = '12px';
                textarea.value = JSON.stringify({
                    goal: 'touch validation',
                    app: 'pointer-lab',
                    notes: 'set ACTIVE_APP_ONLY routing; verify stylus + multi-touch'
                }, null, 2);

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.alignItems = 'center';

                const btnApply = document.createElement('button');
                btnApply.textContent = 'Apply Intent';
                btnApply.style.background = 'rgba(124,252,144,0.12)';
                btnApply.style.color = '#7CFC90';
                btnApply.style.border = '1px solid rgba(124,252,144,0.25)';
                btnApply.style.borderRadius = '10px';
                btnApply.style.padding = '8px 10px';
                btnApply.style.cursor = 'pointer';
                btnApply.style.fontFamily = 'monospace';
                btnApply.style.fontSize = '12px';

                const btnEmit = document.createElement('button');
                btnEmit.textContent = 'Emit Stigmergy';
                btnEmit.style.background = 'rgba(0,255,255,0.10)';
                btnEmit.style.color = '#7CFC90';
                btnEmit.style.border = '1px solid rgba(124,252,144,0.25)';
                btnEmit.style.borderRadius = '10px';
                btnEmit.style.padding = '8px 10px';
                btnEmit.style.cursor = 'pointer';
                btnEmit.style.fontFamily = 'monospace';
                btnEmit.style.fontSize = '12px';

                const status = document.createElement('div');
                status.style.fontFamily = 'monospace';
                status.style.fontSize = '11px';
                status.style.opacity = '0.8';
                status.style.color = '#7CFC90';
                status.textContent = 'Ready.';

                const parseIntent = () => {
                    const raw = String(textarea.value || '').trim();
                    if (!raw) return null;
                    return JSON.parse(raw);
                };

                const apply = () => {
                    try {
                        const intent = parseIntent();
                        const out = window.hfoPorts?.p7?.navigate?.setIntent?.(intent);
                        status.textContent = out?.ts ? `Applied @ ${out.ts}` : 'Applied.';
                    } catch (e) {
                        status.textContent = `ERROR: ${String(e?.message || e)}`;
                    }
                };

                const emit = () => {
                    try {
                        const intent = parseIntent();
                        const entry = window.hfoStigmergy?.emit?.('intent.set', {
                            intent,
                            ts: new Date().toISOString()
                        });
                        status.textContent = entry?.ts ? `Emitted intent.set @ ${entry.ts}` : 'Emitted.';
                    } catch (e) {
                        status.textContent = `ERROR: ${String(e?.message || e)}`;
                    }
                };

                btnApply.addEventListener('click', apply);
                btnEmit.addEventListener('click', emit);

                row.appendChild(btnApply);
                row.appendChild(btnEmit);
                wrap.appendChild(title);
                wrap.appendChild(textarea);
                wrap.appendChild(row);
                wrap.appendChild(status);
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('excalidraw', (container) => {
                if (!isFlagEnabled('ui-excalidraw')) {
                    container.getElement().innerHTML = '<div style="color:red; padding:20px;">EXCALIDRAW_DISABLED</div>';
                    return;
                }
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.background = '#000';
                wrap.innerHTML = `
                    <iframe
                        src="./excalidraw_v20_wrapper.html"
                        style="width:100%; height:100%; border:none; opacity: 0.8; filter: contrast(1.2) brightness(0.8);">
                    </iframe>
                    <div style="position:absolute; top:10px; right:10px; color:#555; font-size:9px; pointer-events:none;">OBSIDIAN MIRROR V9.0</div>
                `;
                container.getElement().appendChild(wrap);
            });

            layout.registerComponentFactoryFunction('gestures', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container scrollable-panel';
                container.getElement().appendChild(wrap);
                systemState.ui.gestures = wrap;
            });

            layout.registerComponentFactoryFunction('tactical', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.innerHTML = `
                    <canvas id="tactical-canvas"></canvas>
                `;
                container.getElement().appendChild(wrap);
                const canvas = wrap.querySelector('#tactical-canvas');
                systemState.ui.tactical = canvas;
                systemState.ui.tacticalCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);

                // V24.5: Tactical Teardown
                container.on('destroy', () => {
                });
            });

            layout.registerComponentFactoryFunction('fsm-viz', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.justifyContent = 'center';
                wrap.style.background = '#050505';
                const canvas = document.createElement('canvas');
                canvas.id = 'fsm-visualizer';
                wrap.appendChild(canvas);
                container.getElement().appendChild(wrap);
                systemState.ui.fsm = canvas;
                systemState.ui.fsmCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                    }
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);
            });

            layout.registerComponentFactoryFunction('palm', (container) => {
                const wrap = document.createElement('div');
                wrap.className = 'component-container';
                wrap.style.display = 'flex';
                wrap.style.alignItems = 'center';
                wrap.style.justifyContent = 'center';
                wrap.style.background = '#050a05';
                const canvas = document.createElement('canvas');
                canvas.id = 'palm-orientation-visualizer';
                wrap.appendChild(canvas);
                container.getElement().appendChild(wrap);

                systemState.ui.palm = canvas;
                systemState.ui.palmCtx = canvas.getContext('2d');

                const handleResize = () => {
                    const rect = wrap.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                    }
                };
                container.on('resize', handleResize);
                setTimeout(handleResize, 200);
            });
        }

        // Initialize with default Essentials mode
        initLayout(systemState.parameters.essentialsMode);

        window.addEventListener('resize', () => {
            layout.updateSize();
            resizeCanvas();
        });

        // Lifecycle Hardening: Guaranteed resource disposal [V24.4]
        window.addEventListener('beforeunload', () => {
            console.log("ðŸŒ€ [HFO LIFECYCLE]: Initiating global disposal sequence...");
            window.hfoLifecycle.disposeAll();
        });

        // ðŸŒ‰ HFO BRIDGE: Sync initial state with Excalidraw on Ready
        window.addEventListener('message', (event) => {
            const { type } = event.data;
            if (type === 'EXCALIDRAW_READY') {
                console.log("ðŸŽ¨ [P3] Excalidraw Ready. Syncing initial tool:", systemState.parameters.excalidraw.activeTool);
                if (systemState.ui.excalidrawIframe) {
                    systemState.ui.excalidrawIframe.contentWindow.postMessage({
                        type: 'SET_TOOL',
                        data: { tool: systemState.parameters.excalidraw.activeTool }
                    }, '*');
                }
            }
        });

        // --- GEN5 v11: Stigmergy surface (additive, inert-by-default) ---
        // Purpose: provide a minimal, contract-friendly emission channel for indirect coordination.
        // Invariant: do not emit anything automatically; only emit when explicitly called.
        window.hfoStigmergy = window.hfoStigmergy || (() => {
            const MAX = 200;
            const buffer = [];

            const nowMs = () => {
                try {
                    return (typeof performance !== 'undefined' && typeof performance.now === 'function')
                        ? performance.now()
                        : Date.now();
                } catch {
                    return Date.now();
                }
            };

            const emit = (type, payload) => {
                const entry = Object.freeze({
                    type: String(type),
                    payload: payload ?? null,
                    ts: nowMs()
                });

                buffer.push(entry);
                if (buffer.length > MAX) buffer.splice(0, buffer.length - MAX);

                try {
                    window.dispatchEvent(new CustomEvent('hfo:stigmergy', { detail: entry }));
                    window.dispatchEvent(new CustomEvent(`hfo:stigmergy:${entry.type}`, { detail: entry }));
                } catch {
                    // ignore: safe in older browsers / restrictive contexts
                }

                return entry;
            };

            const getRecent = (limit = MAX) => {
                const n = Math.max(0, Math.min(MAX, Number(limit) || 0));
                return buffer.slice(-n);
            };

            const subscribe = (handler, type) => {
                const eventName = type ? `hfo:stigmergy:${String(type)}` : 'hfo:stigmergy';
                const listener = (e) => handler(e?.detail);
                window.addEventListener(eventName, listener);
                return () => window.removeEventListener(eventName, listener);
            };

            return Object.freeze({ emit, getRecent, subscribe });
        })();

        // --- GEN5: Ports facade exposure (Option 2) + Adapter registry wiring (Option 4) ---
        // Keep port surfaces stable while adapters evolve behind tokens.
        if (!window.hfoRegistry.has(window.hfoTokens.P3_INJECTOR)) {
            window.hfoRegistry.register(window.hfoTokens.P3_INJECTOR, {
                injectFrame: () => w3cPointerNematocystInjector()
            });
        }

        window.hfoPorts = window.hfoPorts || Object.freeze({
            p0: Object.freeze({
                sense: Object.freeze({
                    readForVideo: (nowMs) => window.hfoRegistry.resolve(window.hfoTokens.P0_SENSE).readForVideo(nowMs)
                }),
                camera: Object.freeze({
                    getStream: (opts) => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).getStream(opts),
                    getUserMediaCallCount: () => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).getUserMediaCallCount(),
                    reset: (stopTracks) => window.hfoRegistry.resolve(window.hfoTokens.P0_CAMERA).reset(stopTracks)
                })
            }),
            p1: Object.freeze({
                weave: (results, dt, nowMs) => {
                    const out = window.hfoRegistry.resolve(window.hfoTokens.P1_FUSE).fuseToDataFabric(results, dt, nowMs);
                    if (out?.dataFabric) {
                        systemState.dataFabric = out.dataFabric;
                        systemState.p1.cursors = systemState.dataFabric.cursors;
                        systemState.dataFabricEnvelope = out?.envelope || null;
                        if (window.hfoTelemetry) window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
                    }
                    return out;
                }
            }),
            p2: Object.freeze({
                physics: Object.freeze({
                    getAdapters: () => window.hfoRegistry.resolve(window.hfoTokens.P2_PHYSICS).getAdapters(),
                    getTelemetry: () => window.hfoRegistry.resolve(window.hfoTokens.P2_PHYSICS).getTelemetry()
                }),
                render: Object.freeze({
                    listJuiceLayers: () => window.hfoRegistry.resolve(window.hfoTokens.P2_RENDER).listJuiceLayers()
                })
            }),
            p3: Object.freeze({
                deliver: () => window.hfoRegistry.resolve(window.hfoTokens.P3_INJECTOR).injectFrame()
            }),
            p4: Object.freeze({
                disrupt: Object.freeze({
                    isEnabled: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).isEnabled(),
                    noOp: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).noOp(),
                    probeAdapters: () => window.hfoRegistry.resolve(window.hfoTokens.P4_DISRUPT).probeAdapters()
                })
            }),
            p5: Object.freeze({
                eval: () => window.hfoRegistry.resolve(window.hfoTokens.EVAL_HFO)
            }),
            p6: Object.freeze({
                store: () => window.hfoRegistry.resolve(window.hfoTokens.P6_STORE)
            }),
            p7: Object.freeze({
                navigate: Object.freeze({
                    getMissionVision: () => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).getMissionVision(),
                    getParameters: () => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).getParameters(),
                    patchParameters: (patch) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).patchParameters(patch),
                    setActiveAdapterTool: (tool) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setActiveAdapterTool(tool),
                    setExcalidrawTool: (tool) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setExcalidrawTool(tool),
                    setVisualEngine: (engine) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setVisualEngine(engine),
                    setIntent: (intent) => window.hfoRegistry.resolve(window.hfoTokens.P7_NAVIGATE).setIntent(intent)
                }),
                apps: Object.freeze({
                    register: (manifest) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).register(manifest),
                    registerIframeAdapter: (opts) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).registerIframeAdapter(opts),
                    list: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).list(),
                    activate: (appId) => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).activate(appId),
                    deactivate: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).deactivate(),
                    getActiveId: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveId(),
                    getActive: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActive(),
                    getActiveTargetRootElement: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).getActiveTargetRootElement(),
                    applyActiveOverlayTuning: () => window.hfoRegistry.resolve(window.hfoTokens.P7_APPHOST).applyActiveOverlayTuning()
                })
            })
        });

        window.hfoDefend = window.hfoDefend || Object.freeze({
            assertRequired: (tokens) => {
                tokens.forEach((t) => window.hfoRegistry.resolve(t));
                return true;
            }
        });

        // Optional strict checks: enable with `?flag-p5-defend-strict=true`
        if (isFlagEnabled('p5-defend-strict')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P6_STORE
            ]);
        }

        // v11 strict hex mode: enable with `?flag-p5-defend-strict-v11=true`
        // Fail-closed intent: require all 8 ports and their core adapters to exist.
        if (isFlagEnabled('p5-defend-strict-v11')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P0_SENSE,
                window.hfoTokens.P0_CAMERA,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P2_PHYSICS,
                window.hfoTokens.P2_RENDER,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P4_DISRUPT,
                window.hfoTokens.P6_STORE,
                window.hfoTokens.P7_NAVIGATE
            ]);

            if (!window.hfoPorts?.p0?.sense?.readForVideo) throw new Error('P0 facade missing');
            if (!window.hfoPorts?.p0?.camera?.getStream) throw new Error('P0.camera facade missing');
            if (!window.hfoPorts?.p1?.weave) throw new Error('P1 facade missing');
            if (!window.hfoPorts?.p2?.physics?.getTelemetry) throw new Error('P2.physics facade missing');
            if (!window.hfoPorts?.p2?.render?.listJuiceLayers) throw new Error('P2.render facade missing');
            if (!window.hfoPorts?.p3?.deliver) throw new Error('P3 facade missing');
            if (!window.hfoPorts?.p4?.disrupt?.noOp) throw new Error('P4 facade missing');
            if (!window.hfoPorts?.p5?.eval) throw new Error('P5 facade missing');
            if (!window.hfoPorts?.p6?.store) throw new Error('P6 facade missing');
            if (!window.hfoPorts?.p7?.navigate?.getMissionVision) throw new Error('P7 facade missing');
        }

        // v11.1 strict mode: enable with `?flag-p5-defend-strict-v11_1=true`
        // Adds fail-closed enforcement for multi-app surfaces.
        if (isFlagEnabled('p5-defend-strict-v11_1')) {
            window.hfoDefend.assertRequired([
                window.hfoTokens.EVAL_HFO,
                window.hfoTokens.P0_SENSE,
                window.hfoTokens.P0_CAMERA,
                window.hfoTokens.P1_FUSE,
                window.hfoTokens.P2_PHYSICS,
                window.hfoTokens.P2_RENDER,
                window.hfoTokens.P3_INJECTOR,
                window.hfoTokens.P3_TARGET_ROUTER,
                window.hfoTokens.P4_DISRUPT,
                window.hfoTokens.P6_STORE,
                window.hfoTokens.P7_NAVIGATE,
                window.hfoTokens.P7_APPHOST,
                window.hfoTokens.UI_LAYOUT
            ]);

            if (!window.hfoPorts?.p7?.apps?.activate) throw new Error('P7.apps facade missing');
            if (!window.hfoPorts?.p7?.apps?.getActiveTargetRootElement) throw new Error('P7.apps routing surface missing');
        }
    </script>
</body>

</html>
