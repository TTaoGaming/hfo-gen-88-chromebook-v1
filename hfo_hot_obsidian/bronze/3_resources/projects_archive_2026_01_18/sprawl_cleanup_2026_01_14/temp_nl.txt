# Medallion: Bronze | Mutation: 0% | HIVE: E
     1	<!-- Medallion: Bronze | Mutation: 0% | HIVE: E -->
     2	<!DOCTYPE html>
     3	<html lang="en">
     4	
     5	<head>
     6	    <meta charset="UTF-8">
     7	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     8	    <title>HFO SHARDS | OMEGA V55.0 | HOT BRONZE</title>
     9	    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap"
    10	        rel="stylesheet">
    11	    <script src="./assets/piano_genie/magenta_music.js"></script>
    12	    <link type="text/css" rel="stylesheet"
    13	        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    14	    <link type="text/css" rel="stylesheet"
    15	        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    16	    <style>
    17	        :root {
    18	            /* M3 HFO Shard Palette (Material Design 3 Dark) */
    19	            --m3-bg: #000000;
    20	            --m3-surface: #121212;
    21	            --m3-surface-bright: #1c1c1c;
    22	            --m3-primary: #ff0000;
    23	            /* Aggressive Red/Black HFO Shard Red */
    24	            --m3-primary-container: #8c0000;
    25	            --m3-on-primary: #ffffff;
    26	            --m3-secondary: #ffb4ab;
    27	            --m3-text: #e6e1e5;
    28	            --m3-text-secondary: #938f99;
    29	            --m3-outline: #49454f;
    30	            --m3-radius: 16px;
    31	            /* M3 Standard for cards */
    32	
    33	            /* HFO Shard Vibe */
    34	            --shard-claw: polygon(0% 0%, 95% 0%, 100% 10%, 100% 100%, 5% 100%, 0% 90%);
    35	        }
    36	
    37	        body,
    38	        html {
    39	            margin: 0;
    40	            padding: 0;
    41	            height: 100vh;
    42	            width: 100vw;
    43	            overflow: hidden;
    44	            background: var(--m3-bg);
    45	            color: var(--m3-text);
    46	            font-family: 'Roboto', sans-serif;
    47	            letter-spacing: 0.01em;
    48	        }
    49	
    50	        /* Material Typography */
    51	        h2,
    52	        h3 {
    53	            font-weight: 500;
    54	            color: var(--m3-primary);
    55	            text-transform: uppercase;
    56	            letter-spacing: 0.1em;
    57	        }
    58	
    59	        #layout-container {
    60	            width: 100%;
    61	            height: 100%;
    62	        }
    63	
    64	        /* Responsive Scrollbar (HFO Shard style) */
    65	        ::-webkit-scrollbar {
    66	            width: 6px;
    67	            height: 6px;
    68	        }
    69	
    70	        ::-webkit-scrollbar-track {
    71	            background: rgba(0, 0, 0, 0.4);
    72	        }
    73	
    74	        ::-webkit-scrollbar-thumb {
    75	            background: var(--m3-primary-container);
    76	            border-radius: 4px;
    77	        }
    78	
    79	        .component-container {
    80	            padding: 24px;
    81	            height: 100%;
    82	            overflow: auto;
    83	            box-sizing: border-box;
    84	            background-color: var(--m3-bg);
    85	            color: var(--m3-text);
    86	            position: relative;
    87	        }
    88	
    89	        .video-feed {
    90	            width: 100%;
    91	            height: 100%;
    92	            object-fit: contain;
    93	            border-radius: 4px;
    94	            background: #000;
    95	            filter: grayscale(1) contrast(1.5) brightness(0.6);
    96	            opacity: 0.4;
    97	            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
    98	            border: 1px solid var(--m3-outline);
    99	        }
   100	
   101	        .video-feed:hover {
   102	            opacity: 0.8;
   103	            filter: grayscale(0.2) contrast(1.1) brightness(0.9);
   104	        }
   105	
   106	        .video-feed.mirrored {
   107	            transform: scaleX(-1);
   108	        }
   109	
   110	        .overlay-canvas {
   111	            position: absolute;
   112	            top: 0;
   113	            left: 0;
   114	            width: 100%;
   115	            height: 100%;
   116	            object-fit: contain;
   117	            pointer-events: none;
   118	        }
   119	
   120	        .overlay-canvas.mirrored {
   121	            transform: scaleX(-1);
   122	        }
   123	
   124	        /* M3 Elevated Card with HFO Shard Claw */
   125	        .data-card {
   126	            background: var(--m3-surface);
   127	            padding: 20px;
   128	            border-radius: var(--m3-radius);
   129	            margin-bottom: 24px;
   130	            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), 0 1px 3px rgba(0, 0, 0, 0.8);
   131	            clip-path: var(--shard-claw);
   132	            border-left: 4px solid var(--m3-primary);
   133	            transition: transform 0.2s cubic-bezier(0, 0, 0.2, 1);
   134	            position: relative;
   135	        }
   136	
   137	        .data-card:hover {
   138	            background: var(--m3-surface-bright);
   139	            transform: scale(1.01);
   140	        }
   141	
   142	        .data-card h3 {
   143	            margin: 0 0 16px 0;
   144	            font-size: 11px;
   145	            font-weight: 700;
   146	            color: var(--m3-primary);
   147	        }
   148	
   149	        code {
   150	            font-family: 'Roboto Mono', monospace;
   151	            color: #ff5252;
   152	            font-size: 12px;
   153	            background: rgba(255, 0, 0, 0.1);
   154	            padding: 2px 6px;
   155	            border-radius: 4px;
   156	        }
   157	
   158	        .state-tag {
   159	            display: inline-block;
   160	            padding: 6px 12px;
   161	            border-radius: 8px;
   162	            font-size: 10px;
   163	            font-weight: 700;
   164	            text-transform: uppercase;
   165	            margin-right: 8px;
   166	            letter-spacing: 0.05em;
   167	        }
   168	
   169	        .tag-port_0_idle {
   170	            background: #1c1b1f;
   171	            color: #938f99;
   172	            border: 1px solid #49454f;
   173	        }
   174	
   175	        .tag-port_1_pointer_ready {
   176	            background: #690005;
   177	            color: #ffffff;
   178	            box-shadow: 0 0 15px rgba(105, 0, 5, 0.5);
   179	        }
   180	
   181	        .tag-port_7_pointer_commit {
   182	            background: var(--m3-primary);
   183	            color: #fff;
   184	            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6);
   185	        }
   186	
   187	        .tag-port_5_pointer_release {
   188	            background: #ff8800;
   189	            color: #000;
   190	            border: 1px solid #ffaa00;
   191	        }
   192	
   193	        .ghost-cursor {
   194	            position: fixed;
   195	            width: 32px;
   196	            height: 32px;
   197	            border: 2px solid var(--m3-primary);
   198	            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
   199	            /* Hex HFO Shard Carapace */
   200	            pointer-events: none;
   201	            z-index: 9999;
   202	            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
   203	            display: none;
   204	            background: rgba(255, 0, 0, 0.1);
   205	        }
   206	
   207	        .ghost-cursor.active {
   208	            display: block;
   209	        }
   210	
   211	        .local-cursor {
   212	            position: fixed;
   213	            width: 8px;
   214	            height: 8px;
   215	            background: var(--m3-primary);
   216	            border-radius: 50%;
   217	            pointer-events: none;
   218	            z-index: 10000;
   219	            display: none;
   220	            box-shadow: 0 0 20px var(--m3-primary);
   221	        }
   222	
   223	        .guide-section {
   224	            padding: 4px;
   225	        }
   226	
   227	        .guide-item {
   228	            margin-bottom: 28px;
   229	            padding: 24px;
   230	            border-radius: var(--m3-radius);
   231	            background: var(--m3-surface);
   232	            border: 1px solid var(--m3-outline);
   233	            clip-path: var(--shard-claw);
   234	        }
   235	
   236	        .guide-item h3 {
   237	            font-size: 14px;
   238	            margin-bottom: 12px;
   239	        }
   240	
   241	        .guide-item p {
   242	            font-size: 13px;
   243	            color: var(--m3-text-secondary);
   244	            line-height: 1.6;
   245	        }
   246	
   247	        /* M3 FAB Style for Controls */
   248	        .camera-controls {
   249	            position: absolute;
   250	            bottom: 40px;
   251	            left: 50%;
   252	            transform: translateX(-50%);
   253	            display: flex;
   254	            gap: 16px;
   255	            z-index: 1000;
   256	            background: var(--m3-surface);
   257	            padding: 12px;
   258	            border-radius: 24px;
   259	            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
   260	            border: 1px solid var(--m3-outline);
   261	        }
   262	
   263	        .camera-btn {
   264	            padding: 12px 24px;
   265	            font-size: 12px;
   266	            font-weight: 500;
   267	            background: var(--m3-surface-bright);
   268	            color: var(--m3-text);
   269	            border: none;
   270	            border-radius: 12px;
   271	            cursor: pointer;
   272	            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
   273	            text-transform: uppercase;
   274	        }
   275	
   276	        .camera-btn:hover {
   277	            background: var(--m3-primary-container);
   278	            color: #fff;
   279	            transform: translateY(-4px);
   280	        }
   281	
   282	        .camera-btn.danger {
   283	            background: #310001;
   284	            color: #ffb4ab;
   285	        }
   286	
   287	        .camera-btn.active {
   288	            background: #00391d;
   289	            color: #b7f397;
   290	        }
   291	
   292	        /* M3 Green contrast */
   293	    </style>
   294	</head>
   295	
   296	<body>
   297	    <div id="layout-container"></div>
   298	    <script type="importmap">
   299	    {
   300	        "imports": {
   301	            "golden-layout": "./assets/vendor/golden-layout.js",
   302	            "lil-gui": "./assets/vendor/lil-gui.js",
   303	            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
   304	            "matter-js": "./assets/vendor/matter-js.js",
   305	            "zod": "./assets/vendor/zod.js",
   306	            "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm"
   307	        }
   308	    }
   309	    </script>
   310	    <script type="module">
   311	        import { GoldenLayout } from 'golden-layout';
   312	        import GUI from 'lil-gui';
   313	        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
   314	        import Matter from 'matter-js';
   315	        import { z } from 'zod';
   316	        import * as duckdb from '@duckdb/duckdb-wasm';
   317	
   318	        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
   319	        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
   320	        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;
   321	
   322	        // ðŸŒ‰ PORT 1: BRIDGE (Contracts)
   323	        // Essence: Contract Enforcement & Logical Harmonization
   324	        // Role: [B]ridging high-frequency streams against Zod 6.0 contracts.
   325	        const Port1CursorBridgeSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
   326	        const Port1HandBridgeSchema = z.object({
   327	            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
   328	            cursors: z.record(Port1CursorBridgeSchema),
   329	            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() }),
   330	            curls: z.object({ index: z.number(), middle: z.number(), ring: z.number(), pinky: z.number() }).optional(),
   331	            palm: z.object({ normal: z.object({ x: z.number(), y: z.number(), z: z.number() }), facingCamera: z.boolean() }).optional()
   332	        });
   333	        const Port1CloudEventBridgeSchema = z.object({
   334	            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(Port1HandBridgeSchema)
   335	        });
   336	
   337	        // ðŸ¤– V55: Formalized 4-State Mosaic FSM
   338	        class GestureFSM {
   339	            constructor() {
   340	                this.state = 'PORT_0_IDLE';
   341	                this.pointerEvent = 'none';
   342	                this.dwellMs = 500;
   343	                this.dwellAccumulator = 0;
   344	                this.lastTimestamp = 0;
   345	            }
   346	
   347	            process(gesture, timestamp, score = 1.0, isPalmFacing = false, currentCurls = null) {
   348	                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
   349	                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
   350	                this.lastTimestamp = timestamp;
   351	                this.pointerEvent = 'none';
   352	                const isConfident = score > 0.6;
   353	
   354	                if (isPalmFacing) {
   355	                    this.dwellAccumulator = Math.min(this.dwellAccumulator + dt, 1000);
   356	                } else {
   357	                    this.dwellAccumulator = Math.max(this.dwellAccumulator - dt * (this.state === 'PORT_7_POINTER_COMMIT' ? 1 : 3), 0);
   358	                }
   359	
   360	                switch (this.state) {
   361	                    case 'PORT_0_IDLE':
   362	                        if (isPalmFacing && this.dwellAccumulator >= this.dwellMs) {
   363	                            this.state = 'PORT_1_POINTER_READY';
   364	                        }
   365	                        break;
   366	                    case 'PORT_1_POINTER_READY':
   367	                        this.pointerEvent = 'pointermove';
   368	                        if (this.dwellAccumulator <= 0) {
   369	                            this.state = 'PORT_0_IDLE';
   370	                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
   371	                            this.state = 'PORT_7_POINTER_COMMIT';
   372	                            this.pointerEvent = 'pointerdown';
   373	                        }
   374	                        break;
   375	                    case 'PORT_7_POINTER_COMMIT':
   376	                        this.pointerEvent = 'pointermove';
   377	                        const isNoneOrLost = (currentGesture === 'NONE' || currentGesture === 'LOST' || !isConfident);
   378	                        if (isNoneOrLost) {
   379	                            this.state = 'PORT_5_POINTER_RELEASE';
   380	                        } else if (currentGesture !== 'POINTING_UP' && isConfident) {
   381	                            this.state = 'PORT_5_POINTER_RELEASE';
   382	                            this.pointerEvent = 'pointerup';
   383	                        }
   384	                        if (this.dwellAccumulator <= 0) {
   385	                            this.state = 'PORT_0_IDLE';
   386	                            this.pointerEvent = 'pointercancel';
   387	                        }
   388	                        break;
   389	                    case 'PORT_5_POINTER_RELEASE':
   390	                        this.pointerEvent = 'pointermove';
   391	                        if (currentGesture === 'POINTING_UP' && isConfident) {
   392	                            this.state = 'PORT_7_POINTER_COMMIT';
   393	                        } else if (currentGesture === 'VICTORY' || currentGesture === 'OPEN_PALM' || (this.dwellAccumulator <= 0)) {
   394	                            this.state = (this.dwellAccumulator > 0) ? 'PORT_1_POINTER_READY' : 'PORT_0_IDLE';
   395	                            this.pointerEvent = 'pointerup';
   396	                        }
   397	                        break;
   398	                }
   399	                return { state: this.state, pointerEvent: this.pointerEvent };
   400	            }
   401	        }
   402	
   403	        // ï¿½ Finger Logic Helpers
   404	        const calculateCurl = (landmarks, indices) => {
   405	            let totalAngle = 0;
   406	            for (let i = 0; i < indices.length - 2; i++) {
   407	                const a = landmarks[indices[i]];
   408	                const b = landmarks[indices[i + 1]];
   409	                const c = landmarks[indices[i + 2]];
   410	                const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
   411	                const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
   412	                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
   413	                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
   414	                const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
   415	                totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
   416	            }
   417	            return Math.min(1.0, totalAngle / Math.PI);
   418	        };
   419	
   420	        const getBoneRatios = (lm) => {
   421	            const dist = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2 + (p1.z - p2.z) ** 2);
   422	            return {
   423	                index: dist(lm[5], lm[6]) / (dist(lm[6], lm[7]) || 1),
   424	                middle: dist(lm[9], lm[10]) / (dist(lm[10], lm[11]) || 1)
   425	            };
   426	        };
   427	
   428	        const getPalmHeuristics = (lm) => {
   429	            const dist = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2 + (p1.z - p2.z) ** 2);
   430	            const width = dist(lm[5], lm[17]); // MCP Index to MCP Pinky
   431	            // Z-Effective is an inverted width proxy (smaller width = farther away)
   432	            const zEffective = 1.0 / (width || 0.1);
   433	            return { width, zEffective };
   434	        };
   435	
   436	        const getCurls = (lm) => ({
   437	            index: calculateCurl(lm, [5, 6, 7, 8]),
   438	            middle: calculateCurl(lm, [9, 10, 11, 12]),
   439	            ring: calculateCurl(lm, [13, 14, 15, 16]),
   440	            pinky: calculateCurl(lm, [17, 18, 19, 20])
   441	        });
   442	
   443	        // ï¿½ðŸ§  Multi-Resolution Filters (Smooth/Snappy Presets)
   444	        class LowPassFilter { constructor(alpha) { this.alpha = alpha; this.s = null; } call(v) { if (this.s === null) this.s = v; else this.s = this.alpha * v + (1 - this.alpha) * this.s; return this.s; } }
   445	        class OneEuroFilter {
   446	            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
   447	                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
   448	                this.xFilter = new LowPassFilter(this.alpha(minCutoff)); this.dxFilter = new LowPassFilter(this.alpha(dCutoff)); this.lastTime = null;
   449	            }
   450	            alpha(c) { const te = 1 / (this.freq || 60); const tau = 1 / (2 * Math.PI * (c || 1.0)); return 1 / (1 + tau / te); }
   451	            call(x, t = null) {
   452	                if (this.lastTime !== null && t !== null) {
   453	                    const dt = (t - this.lastTime) / 1000;
   454	                    if (dt > 0.001) this.freq = 1 / dt;
   455	                }
   456	                this.lastTime = t;
   457	                const prevX = this.xFilter.s;
   458	                const dx = prevX === null ? 0 : (x - prevX) * (this.freq || 60);
   459	                const edx = this.dxFilter.call(dx);
   460	                const c = this.minCutoff + this.beta * Math.abs(edx);
   461	                this.xFilter.alpha = this.alpha(c);
   462	                const result = this.xFilter.call(x);
   463	                return isNaN(result) ? (x || 0) : result;
   464	            }
   465	        }
   466	
   467	        const hfoState = window.hfoState = {
   468	            active: true, debug: true,
   469	            transparency: 1.0, // ðŸ•µï¸ REAL-TIME SENSING QUALITY (0.0 - 1.0)
   470	            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6, dwellMs: 1000 },
   471	            visuals: {
   472	                heroStrategy: 'HEX_SHARD',
   473	                supportStrategy: 'DOT',
   474	                showSkeleton: true,
   475	                excalidrawOpacity: 0.8
   476	            },
   477	            goldenMaster: {
   478	                active: false,
   479	                mode: 'STRAIGHT', // STRAIGHT, LOW_NOISE, HIGH_NOISE
   480	                progress: 0,
   481	                speed: 0.005,
   482	                noiseLevel: 0.0,
   483	                dropProbability: 0.0,
   484	                frameCounter: 0
   485	            },
   486	            physics: {
   487	                stiffness: 0.22, stiffnessArmed: 0.65, damping: 0.85, lookAhead: 1.8,
   488	                velocityDeadzone: 0.05, // ðŸŒªï¸ V52.1: Normalized Resonance Suppression
   489	                springSource: 'snappy', predSource: 'snappy',
   490	                p3Source: 'predictive', p3Mirror: true,
   491	                p0Mirror: true,
   492	                showGlobalCursor: false,
   493	                remoteMode: true,
   494	                purePointerMode: false,
   495	                remoteTargetId: 'excalidraw-iframe', // Default, but can be dynamic
   496	                persistence: { snapDistance: 0.15, coastFrames: 60, repulsionDistance: 0.12, teleportLimit: 0.3 }
   497	            },
   498	            hands: {}, bridge: { lastEvent: null, errorCount: 0, status: 'IDLE', lastValidate: 0 }
   499	        };
   500	
   501	        // ðŸ›°ï¸ V37 System Singleton Guard
   502	        const hfoSystem = window.hfoSystem = {
   503	            initialized: false,
   504	            initializing: false,
   505	            video: null,
   506	            canvas: null,
   507	            ctx: null,
   508	            recognizer: null,
   509	            stream: null,
   510	            loopActive: false,
   511	            lastFrame: 0,
   512	            heroReady: false,
   513	            tuningMirror: {
   514	                db: null,
   515	                conn: null,
   516	                active: false,
   517	                metrics: { rmse: 0, jitter: 0 },
   518	                batch: []
   519	            }
   520	        };
   521	
   522	        const initTuningMirror = async () => {
   523	            try {
   524	                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
   525	                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
   526	                const worker_url = URL.createObjectURL(
   527	                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
   528	                );
   529	
   530	                const worker = new Worker(worker_url);
   531	                const logger = new duckdb.ConsoleLogger();
   532	                const db = new duckdb.AsyncDuckDB(logger, worker);
   533	                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
   534	
   535	                const conn = await db.connect();
   536	                await conn.query(`
   537	                    CREATE TABLE telemetry (
   538	                        ts DOUBLE,
   539	                        hand_id INTEGER,
   540	                        raw_x DOUBLE, raw_y DOUBLE,
   541	                        pred_x DOUBLE, pred_y DOUBLE,
   542	                        mode VARCHAR
   543	                    )
   544	                `);
   545	
   546	                hfoSystem.tuningMirror.db = db;
   547	                hfoSystem.tuningMirror.conn = conn;
   548	                hfoSystem.tuningMirror.active = true;
   549	                if (hfoState.debug) console.log("ðŸ’Ž Tuning Mirror (DuckDB-WASM) Active.");
   550	            } catch (e) {
   551	                console.error("âŒ Tuning Mirror initialization failed:", e);
   552	                hfoSystem.tuningMirror.active = false;
   553	            }
   554	        };
   555	
   556	        let telemetrySeq = 0;
   557	        /**
   558	         * ðŸ”­ PORT 0: OBSERVE (Sense)
   559	         * Essence: Intelligence, Surveillance, Reconnaissance
   560	         * Role: [O]bserving high-fidelity MediaPipe sensing and gesture extraction.
   561	         */
   562	        const port0Observe = (video, recognizer, now) => {
   563	            if (hfoState.goldenMaster.active) return port4GoldenMaster(now);
   564	            if (!video || !recognizer || video.readyState < 2) return null;
   565	            return recognizer.recognizeForVideo(video, now);
   566	        };
   567	
   568	        /**
   569	         * ðŸŽ¯ PORT 4: GOLDEN MASTER (Validate / Analysis)
   570	         * Essence: Disruptive Analysis & Feedback Loops
   571	         * Role: Injecting ground-truth synthetic feeds to analyze filter divergence.
   572	         */
   573	        const port4GoldenMaster = (now) => {
   574	            const gm = hfoState.goldenMaster;
   575	            gm.frameCounter++;
   576	
   577	            // Handle Dropped Frames (Simulated failure in Sense)
   578	            if (gm.mode === 'HIGH_NOISE' && Math.random() < gm.dropProbability) {
   579	                return null;
   580	            }
   581	
   582	            gm.progress = (gm.progress + gm.speed) % 1.0;
   583	
   584	            // Base movement: Sinusoidal path on Y, Linear on X
   585	            const x = 0.2 + (0.6 * gm.progress);
   586	            const y = 0.5 + 0.1 * Math.sin(gm.progress * Math.PI * 4);
   587	
   588	            // Noise Profile configuration
   589	            let noise = 0;
   590	            if (gm.mode === 'LOW_NOISE') noise = 0.002;
   591	            if (gm.mode === 'HIGH_NOISE') noise = 0.02;
   592	
   593	            const nx = x + (Math.random() - 0.5) * noise;
   594	            const ny = y + (Math.random() - 0.5) * noise;
   595	
   596	            // Mock MediaPipe result
   597	            const mockLandmarks = Array(21).fill(0).map(() => ({ x: nx, y: ny, z: 0 }));
   598	            mockLandmarks[8] = { x: nx, y: ny, z: 0 };
   599	
   600	            return {
   601	                landmarks: [mockLandmarks],
   602	                worldLandmarks: [mockLandmarks],
   603	                gestures: [[{ categoryName: 'POINTING_UP', score: 0.99 }]],
   604	                handedness: [[{ categoryName: 'Right', score: 0.99 }]]
   605	            };
   606	        };
   607	
   608	        /**
   609	         * ðŸŒ‰ PORT 1: BRIDGE (Fuse)
   610	         * Essence: Contractual Integrity & Data Transformation
   611	         * Role: [B]ridging hand telemetry stream to Zod 6.0 contracts and P2 Physics coordinates.
   612	         * Medallion: Bronze | Mutation: 88% | HIVE: I
   613	         */
   614	        const port1Bridge = (hands) => {
   615	            const now = performance.now();
   616	            const shouldValidate = (now - hfoState.bridge.lastValidate) > 500;
   617	            try {
   618	                const telemetryData = {};
   619	                const physicsCoordinates = [];
   620	
   621	                for (const id in hands) {
   622	                    const h = hands[id];
   623	                    if (!h.active) continue;
   624	
   625	                    // P0 -> P1 Translation
   626	                    telemetryData[id] = {
   627	                        id: h.id, active: h.active, lastSeen: h.lastSeen, fsm: h.fsm.state,
   628	                        cursors: {
   629	                            raw: h.cursors.raw,
   630	                            smooth: h.cursors.smooth,
   631	                            snappy: h.cursors.snappy,
   632	                            spring: h.cursors.spring,
   633	                            pred: h.cursors.predictive
   634	                        },
   635	                        gestures: h.gestures, palm: h.palm, curls: h.curls
   636	                    };
   637	
   638	                    // P1 -> P2 Coordinate Fusion (Zod 6.0 logic)
   639	                    // We map normalized sensor space (0-1) to Physics Lattice space (W3C standard)
   640	                    physicsCoordinates.push({
   641	                        id: h.id,
   642	                        x: h.cursors.smooth.x,
   643	                        y: h.cursors.smooth.y,
   644	                        velocity: { x: h.physics?.velocity?.x || 0, y: h.physics?.velocity?.y || 0 },
   645	                        isDown: h.gestures.isDown,
   646	                        contract: "Zod_6.0_Stable"
   647	                    });
   648	                }
   649	
   650	                const event = {
   651	                    specversion: "1.0",
   652	                    type: "hfo.omega.v52.hand_update",
   653	                    source: "hfo.port.0.sense",
   654	                    id: `telemetry-${telemetrySeq++}`,
   655	                    time: new Date().toISOString(),
   656	                    data: telemetryData,
   657	                    physics: physicsCoordinates
   658	                };
   659	
   660	                if (shouldValidate) {
   661	                    Port1CloudEventBridgeSchema.parse(event);
   662	                    hfoState.bridge.lastValidate = now;
   663	                    if (hfoState.debug) console.log("ðŸŒ‰ P1_FUSE: System Integrity Audited [Zod 6.0]");
   664	                }
   665	                hfoState.bridge.lastEvent = event; hfoState.bridge.status = 'VALID';
   666	            } catch (e) {
   667	                if (hfoState.debug) console.error("Port 1 BRIDGE Breach:", e);
   668	                hfoState.bridge.status = 'ERROR'; hfoState.bridge.errorCount++;
   669	            }
   670	        };
   671	
   672	        /**
   673	         * ðŸŽ¨ PORT 2: VISUAL STRATEGIES
   674	         * Essence: Aesthetic Form & Strategy Pattern
   675	         */
   676	        const VisualStrategies = {
   677	            HEX_SHARD: (ctx, cursor, size, state, dwellRatio, color) => {
   678	                const canvas = hfoSystem.canvas;
   679	                ctx.beginPath();
   680	                const shardSize = size * (state === 'PORT_7_POINTER_COMMIT' ? 1.5 : (state === 'PORT_1_POINTER_READY' ? 1.2 : 1.0));
   681	                for (let i = 0; i < 6; i++) {
   682	                    const angle = (i * Math.PI) / 3 + (state === 'PORT_7_POINTER_COMMIT' ? (Date.now() / 500) : 0);
   683	                    const hx = cursor.x * canvas.width + shardSize * Math.cos(angle);
   684	                    const hy = cursor.y * canvas.height + shardSize * Math.sin(angle);
   685	                    if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
   686	                }
   687	                ctx.closePath();
   688	
   689	                let strokeColor = 'transparent';
   690	                let shadowBlur = 0;
   691	                let shadowColor = 'transparent';
   692	                let lineWidth = 2;
   693	
   694	                if (state === 'PORT_0_IDLE' && dwellRatio > 0) {
   695	                    strokeColor = `rgba(255, 0, 0, ${dwellRatio})`;
   696	                    lineWidth = 1 + dwellRatio * 2;
   697	                } else if (state === 'PORT_1_POINTER_READY') {
   698	                    strokeColor = '#690005';
   699	                    lineWidth = 3;
   700	                } else if (state === 'PORT_7_POINTER_COMMIT') {
   701	                    strokeColor = '#ff3333';
   702	                    lineWidth = 4;
   703	                    shadowBlur = 25;
   704	                    shadowColor = '#ff0000';
   705	                } else if (state === 'PORT_5_POINTER_RELEASE') {
   706	                    strokeColor = '#ff8800';
   707	                    lineWidth = 2;
   708	                    ctx.setLineDash([5, 5]);
   709	                }
   710	
   711	                ctx.strokeStyle = strokeColor;
   712	                ctx.lineWidth = lineWidth;
   713	                ctx.shadowBlur = shadowBlur;
   714	                ctx.shadowColor = shadowColor;
   715	                ctx.stroke();
   716	                ctx.setLineDash([]);
   717	                ctx.shadowBlur = 0;
   718	
   719	                ctx.fillStyle = color;
   720	                ctx.globalAlpha = 1.0;
   721	                ctx.fill();
   722	            },
   723	            DOT: (ctx, cursor, size, state, dwellRatio, color) => {
   724	                const canvas = hfoSystem.canvas;
   725	                ctx.beginPath();
   726	                ctx.arc(cursor.x * canvas.width, cursor.y * canvas.height, size, 0, 2 * Math.PI);
   727	                ctx.fillStyle = color;
   728	                ctx.globalAlpha = 0.2;
   729	                ctx.fill();
   730	            },
   731	            SKELETON: (ctx, landmarks, dw) => {
   732	                dw.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#cc0000", lineWidth: 5 });
   733	            }
   734	        };
   735	
   736	        /**
   737	         * ðŸ“ PORT 2: SHAPE (Tree Manifold - Step A: Sensing & Anchor Sync)
   738	         */
   739	        const port2ShapeSync = (hand, now, lm) => {
   740	            // Assign Visual Strategy
   741	            hand.visuals = {
   742	                hero: hfoState.visuals.heroStrategy,
   743	                support: hfoState.visuals.supportStrategy,
   744	                showSkeleton: hfoState.visuals.showSkeleton
   745	            };
   746	
   747	            if (lm) {
   748	                // ðŸŽ¯ Handedness-Agnostic Orientation
   749	                const v1 = { x: lm[5].x - lm[0].x, y: lm[5].y - lm[0].y, z: lm[5].z - lm[0].z };
   750	                const v2 = { x: lm[17].x - lm[0].x, y: lm[17].y - lm[0].y, z: lm[17].z - lm[0].z };
   751	
   752	                const cross = {
   753	                    x: (v1.y * v2.z - v1.z * v2.y) || 0,
   754	                    y: (v1.z * v2.x - v1.x * v2.z) || 0,
   755	                    z: (v1.x * v2.y - v1.y * v2.x) || 1
   756	                };
   757	                const mag = Math.sqrt(cross.x ** 2 + cross.y ** 2 + cross.z ** 2) || 1;
   758	                const normal = { x: cross.x / mag, y: cross.y / mag, z: cross.z / mag };
   759	
   760	                const isFacing = Math.abs(normal.z) > 0.5;
   761	                const { width, zEffective } = getPalmHeuristics(lm);
   762	                hand.palm = { normal, facingCamera: isFacing, width, zEffective };
   763	
   764	                // ðŸ§¬ Internal Sharding: The Tree Starts Here
   765	                // Node 1: Raw
   766	                hand.cursors.raw.x = lm[8].x; hand.cursors.raw.y = lm[8].y;
   767	                hand.lastSeen = now; hand.coastCount = 0; hand.active = true;
   768	
   769	                // Node 2 & 3: Filtered Children of Raw
   770	                hand.cursors.smooth.x = hand.filters.sx.call(hand.cursors.raw.x, now);
   771	                hand.cursors.smooth.y = hand.filters.sy.call(hand.cursors.raw.y, now);
   772	                hand.cursors.snappy.x = hand.filters.nx.call(hand.cursors.raw.x, now);
   773	                hand.cursors.snappy.y = hand.filters.ny.call(hand.cursors.raw.y, now);
   774	
   775	                // Store landmarks for skeleton strategy
   776	                hand.landmarks = lm;
   777	            }
   778	
   779	            // ðŸš€ Physics Digital Twin (Syncing Anchor)
   780	            if (engine && hand.active && hfoSystem.canvas) {
   781	                const canvas = hfoSystem.canvas;
   782	                const isEngaged = hand.fsm.state === 'PORT_1_POINTER_READY' || hand.fsm.state === 'PORT_7_POINTER_COMMIT';
   783	                hand.cursors.spring.constraint.stiffness = isEngaged ? hfoState.physics.stiffnessArmed : hfoState.physics.stiffness;
   784	
   785	                // Node 4: Spring is driven by Snappy (Node 3)
   786	                const anchorSource = hand.cursors.snappy;
   787	                Matter.Body.setPosition(hand.cursors.spring.anchor, { x: anchorSource.x * canvas.width, y: anchorSource.y * canvas.height });
   788	            }
   789	            return hand.palm?.facingCamera || false;
   790	        };
   791	
   792	        /**
   793	         * ðŸ“ PORT 2: SHAPE (Tree Manifold - Step B: Predictive Synthesis)
   794	         */
   795	        const port2ShapePredict = (hand, now) => {
   796	            if (engine && hand.active && hfoSystem.canvas) {
   797	                const canvas = hfoSystem.canvas;
   798	
   799	                // Node 5: Predictive is driven by Spring (Node 4) + Velocity projection
   800	                const rawVel = hand.cursors.spring.body.velocity;
   801	
   802	                // ðŸŒªï¸ V52.1: Unified Normalized Suppression
   803	                // Normalize velocity relative to canvas to make constants resolution-independent
   804	                const normVel = { x: rawVel.x / (canvas.width || 1), y: rawVel.y / (canvas.height || 1) };
   805	                const speed = Math.sqrt(normVel.x * normVel.x + normVel.y * normVel.y);
   806	                const dz = hfoState.physics.velocityDeadzone || 0.05;
   807	                const ratio = Math.min(1.0, speed / dz);
   808	                const suppression = ratio * ratio * ratio; // Cubic for tighter low-end stabilization
   809	
   810	                const vel = {
   811	                    x: hand.filters.vx.call(rawVel.x, now) * suppression,
   812	                    y: hand.filters.vy.call(rawVel.y, now) * suppression
   813	                };
   814	
   815	                const lead = {
   816	                    x: vel.x * hfoState.physics.lookAhead,
   817	                    y: vel.y * hfoState.physics.lookAhead
   818	                };
   819	
   820	                // Node 5: Predictive body is projected from the Filtered Anchor (Snappy) 
   821	                // to eliminate cumulative spring lag from the prediction stream.
   822	                const anchorPos = {
   823	                    x: hand.cursors.snappy.x * canvas.width,
   824	                    y: hand.cursors.snappy.y * canvas.height
   825	                };
   826	
   827	                Matter.Body.setPosition(hand.cursors.predictive.body, {
   828	                    x: anchorPos.x + lead.x,
   829	                    y: anchorPos.y + lead.y
   830	                });
   831	
   832	                const SafeW = canvas.width || 1280;
   833	                const SafeH = canvas.height || 720;
   834	                hand.cursors.spring.x = hand.cursors.spring.body.position.x / SafeW;
   835	                hand.cursors.spring.y = hand.cursors.spring.body.position.y / SafeH;
   836	                hand.cursors.predictive.x = hand.cursors.predictive.body.position.x / SafeW;
   837	                hand.cursors.predictive.y = hand.cursors.predictive.body.position.y / SafeH;
   838	            }
   839	        };
   840	
   841	        // ðŸ—¡ï¸ PORT 3: INJECT (Deliver)
   842	        // Essence: W3C Pointer Injection & Event Synthesis
   843	        // ðŸŽ¯ V55.2: Coordinate Substrate Alignment (Letterbox Aware)
   844	        const getContainedRect = (containerWidth, containerHeight, videoWidth, videoHeight) => {
   845	            const containerRatio = containerWidth / containerHeight;
   846	            const videoRatio = videoWidth / videoHeight;
   847	            let width, height, x, y;
   848	
   849	            if (containerRatio > videoRatio) {
   850	                height = containerHeight;
   851	                width = videoHeight * containerRatio; // Wait, this is wrong. 
   852	                // Fix:
   853	                width = containerHeight * videoRatio;
   854	                x = (containerWidth - width) / 2;
   855	                y = 0;
   856	            } else {
   857	                width = containerWidth;
   858	                height = containerWidth / videoRatio;
   859	                x = 0;
   860	                y = (containerHeight - height) / 2;
   861	            }
   862	            return { x, y, width, height };
   863	        };
   864	
   865	        // Role: [I]njecting official W3C pointer events into the DOM.
   866	        const port3Inject = window.port3Inject = window.p3InjectPointer = window.p3Inject = (hand) => {
   867	            try {
   868	                if (!hand.active) {
   869	                    if (hand.ghost) hand.ghost.classList.remove('active');
   870	                    if (hand.localCursor) hand.localCursor.style.display = 'none';
   871	                    if (hand.capturedTarget && hand.capturedTarget.releasePointerCapture) {
   872	                        try { hand.capturedTarget.releasePointerCapture(Number(hand.id) + 10); } catch (e) { }
   873	                        hand.capturedTarget = null;
   874	                    }
   875	                    return;
   876	                }
   877	
   878	                if (!hand.ghost) {
   879	                    hand.ghost = document.createElement('div');
   880	                    hand.ghost.className = 'ghost-cursor';
   881	                    document.body.appendChild(hand.ghost);
   882	                }
   883	
   884	                const types = { 'pointerdown': 'pointerdown', 'pointermove': 'pointermove', 'pointerup': 'pointerup', 'pointercancel': 'pointercancel' };
   885	                const type = types[hand.fsm.pointerEvent];
   886	                const activeType = type || (hand.fsm.state !== 'PORT_0_IDLE' ? 'pointermove' : null);
   887	
   888	                if (!activeType || !hand.active) {
   889	                    hand.ghost.classList.remove('active');
   890	                    if (hand.localCursor) hand.localCursor.style.display = 'none';
   891	                    return;
   892	                }
   893	
   894	                const cursor = hand.cursors[hfoState.physics.p3Source] || hand.cursors.predictive;
   895	                let normX = cursor.x;
   896	                if (hfoState.physics.p3Mirror) normX = 1 - normX;
   897	
   898	                let x, y;
   899	
   900	                // Dynamic Coordinate Mapping
   901	                let activeRemoteId = hfoState.physics.remoteTargetId;
   902	                const remoteEl = activeRemoteId ? document.getElementById(activeRemoteId) : null;
   903	
   904	                if (hfoState.physics.remoteMode && remoteEl) {
   905	                    const rect = remoteEl.getBoundingClientRect();
   906	                    const vW = hfoSystem.video?.videoWidth || 1280;
   907	                    const vH = hfoSystem.video?.videoHeight || 720;
   908	                    const cRect = getContainedRect(rect.width, rect.height, vW, vH);
   909	                    x = rect.left + cRect.x + (normX * cRect.width);
   910	                    y = rect.top + cRect.y + (cursor.y * cRect.height);
   911	                } else {
   912	                    x = normX * window.innerWidth;
   913	                    y = cursor.y * window.innerHeight;
   914	                }
   915	
   916	                const pointerId = Number(hand.id) + 10;
   917	                let target;
   918	                if (hand.capturedTarget) target = hand.capturedTarget;
   919	                else target = document.elementFromPoint(x, y) || document.body;
   920	
   921	                let finalX = x;
   922	                let finalY = y;
   923	
   924	                if (hfoState.physics.remoteMode && activeRemoteId && remoteEl) {
   925	                    const rect = remoteEl.getBoundingClientRect();
   926	                    const localX = x - rect.left;
   927	                    const localY = y - rect.top;
   928	                    if (!hand.capturedTarget) target = remoteEl;
   929	                    if (remoteEl.tagName === 'IFRAME') {
   930	                        try {
   931	                            const innerTarget = remoteEl.contentDocument.elementFromPoint(localX, localY);
   932	                            if (innerTarget && !hand.capturedTarget) {
   933	                                target = innerTarget;
   934	                                finalX = localX;
   935	                                finalY = localY;
   936	                            }
   937	                        } catch (e) { finalX = localX; finalY = localY; }
   938	                    } else { finalX = localX; finalY = localY; }
   939	                }
   940	
   941	                if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
   942	                    const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
   943	                    if (remoteEl) {
   944	                        if (!hand.localCursor) {
   945	                            hand.localCursor = document.createElement('div');
   946	                            hand.localCursor.className = 'local-cursor';
   947	                            document.body.appendChild(hand.localCursor);
   948	                        }
   949	                        const rect = remoteEl.getBoundingClientRect();
   950	                        hand.localCursor.style.display = 'block';
   951	                        hand.localCursor.style.left = `${rect.left + finalX - 5}px`;
   952	                        hand.localCursor.style.top = `${rect.top + finalY - 5}px`;
   953	                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
   954	                    }
   955	                } else if (hand.localCursor) hand.localCursor.style.display = 'none';
   956	
   957	                if (hfoState.physics.showGlobalCursor) {
   958	                    hand.ghost.style.left = `${x - 10}px`;
   959	                    hand.ghost.style.top = `${y - 10}px`;
   960	                    hand.ghost.classList.add('active');
   961	                    const colors = {
   962	                        'PORT_0_IDLE': '#938f99',
   963	                        'PORT_1_POINTER_READY': '#ff5252',
   964	                        'PORT_7_POINTER_COMMIT': '#ff0000',
   965	                        'PORT_5_POINTER_RELEASE': '#ff8800'
   966	                    };
   967	                    hand.ghost.style.background = colors[hand.fsm.state] || '#ff0000';
   968	                    hand.ghost.className = `ghost-cursor active ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
   969	                    if (hand.fsm.state === 'PORT_7_POINTER_COMMIT') hand.ghost.classList.add('committed');
   970	                    else hand.ghost.classList.remove('committed');
   971	                } else hand.ghost.classList.remove('active');
   972	
   973	                if (activeType === 'pointerdown') {
   974	                    hand.lastTargetOnDown = target;
   975	                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId, clientX: finalX, clientY: finalY }));
   976	                    target.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, clientX: finalX, clientY: finalY }));
   977	                }
   978	
   979	                if (activeType === 'pointerdown' && target.setPointerCapture) {
   980	                    try { target.setPointerCapture(pointerId); hand.capturedTarget = target; } catch (e) { }
   981	                }
   982	
   983	                if (hand.lastTarget && hand.lastTarget !== target && !hand.capturedTarget) {
   984	                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerout', { bubbles: true, pointerId, clientX: x, clientY: y }));
   985	                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId, clientX: x, clientY: y }));
   986	                }
   987	
   988	                const movementX = hand.lastX !== undefined ? x - hand.lastX : 0;
   989	                const movementY = hand.lastY !== undefined ? y - hand.lastY : 0;
   990	                hand.lastX = x; hand.lastY = y; hand.lastTarget = target;
   991	
   992	                const isDown = (hand.fsm.state === 'PORT_7_POINTER_COMMIT');
   993	                const handList = Object.values(hfoState.hands).filter(h => h.active);
   994	                const committedHands = handList.filter(h => h.fsm.state === 'PORT_7_POINTER_COMMIT').sort((a, b) => a.id - b.id);
   995	                const readyHands = handList.filter(h => h.fsm.state === 'PORT_1_POINTER_READY').sort((a, b) => a.id - b.id);
   996	
   997	                let isPrimary = false;
   998	                if (committedHands.length > 0) isPrimary = (Number(hand.id) === Number(committedHands[0].id));
   999	                else if (readyHands.length > 0) isPrimary = (Number(hand.id) === Number(readyHands[0].id));
  1000	
  1001	                const ev = new PointerEvent(activeType, {
  1002	                    bubbles: true, cancelable: true, pointerType: 'touch',
  1003	                    view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
  1004	                    pointerId, clientX: finalX, clientY: finalY, movementX, movementY,
  1005	                    width: 20, height: 20, pressure: isDown ? 0.9 : 0.0, buttons: isDown ? 1 : 0,
  1006	                    button: (activeType === 'pointerdown' || activeType === 'pointerup') ? 0 : -1, isPrimary
  1007	                });
  1008	                target.dispatchEvent(ev);
  1009	
  1010	                if (!hfoState.physics.purePointerMode && isPrimary && (activeType === 'pointerdown' || activeType === 'pointerup')) {
  1011	                    const mouseType = activeType === 'pointerdown' ? 'mousedown' : 'mouseup';
  1012	                    target.dispatchEvent(new MouseEvent(mouseType, { bubbles: true, clientX: finalX, clientY: finalY, button: 0, buttons: isDown ? 1 : 0 }));
  1013	                    if (activeType === 'pointerup' && target === hand.lastTargetOnDown) {
  1014	                        target.dispatchEvent(new MouseEvent('click', { bubbles: true, clientX: finalX, clientY: finalY, button: 0 }));
  1015	                        const btn = target.tagName === 'BUTTON' ? target : target.closest('button');
  1016	                        if (btn) btn.click();
  1017	                    }
  1018	                }
  1019	
  1020	                if ((activeType === 'pointerup' || activeType === 'pointercancel') && hand.capturedTarget) {
  1021	                    try { hand.capturedTarget.releasePointerCapture(pointerId); } catch (e) { }
  1022	                    hand.capturedTarget = null;
  1023	                }
  1024	
  1025	            } catch (err) { if (hfoState.debug) console.error("W3C Injection Error:", err); }
  1026	        };
  1027	
  1028	        /**
  1029	         * ðŸŒªï¸ PORT 4: DISRUPT (Supression)
  1030	         * Role: [D]isrupting noise and handle feedback suppression.
  1031	         */
  1032	        const port4Disrupt = (hand) => { /* Internal suppression logic */ };
  1033	
  1034	        /**
  1035	         * ðŸ›¡ï¸ PORT 5: IMMUNIZE (Force Protection)
  1036	         * Essence: Defensive Shields
  1037	         * Role: [I]mmunizing the system against invalid state transitions and sensor noise.
  1038	         * V42.1: Sensor-Aware Coasting Audit.
  1039	         */
  1040	        const port5Immunize = (hand, nextState, confidence = 1.0) => {
  1041	            const prevState = hand.fsm.state;
  1042	            const isLowConfidence = confidence < 0.3;
  1043	
  1044	            // ðŸ§¬ Kinetic Coasting Trigger
  1045	            if (isLowConfidence && hand.active) {
  1046	                if (hfoState.debug) console.warn(`ðŸ›¡ï¸ P5: Low confidence (${confidence.toFixed(2)}). Engaging Kinetic Coast.`);
  1047	                return 'COAST';
  1048	            }
  1049	
  1050	            const validTransitions = {
  1051	                'PORT_0_IDLE': ['PORT_0_IDLE', 'PORT_1_POINTER_READY'],
  1052	                'PORT_1_POINTER_READY': ['PORT_0_IDLE', 'PORT_1_POINTER_READY', 'PORT_7_POINTER_COMMIT'],
  1053	                'PORT_7_POINTER_COMMIT': ['PORT_0_IDLE', 'PORT_7_POINTER_COMMIT', 'PORT_5_POINTER_RELEASE'],
  1054	                'PORT_5_POINTER_RELEASE': ['PORT_0_IDLE', 'PORT_1_POINTER_READY', 'PORT_5_POINTER_RELEASE', 'PORT_7_POINTER_COMMIT']
  1055	            };
  1056	
  1057	            const allowed = validTransitions[prevState]?.includes(nextState) || false;
  1058	            if (!allowed && hfoState.debug) {
  1059	                console.warn(`ðŸ›¡ï¸ P5 HardGate BREACH: ${prevState} -> ${nextState} blocked.`);
  1060	            }
  1061	            return allowed ? 'ALLOW' : 'BLOCK';
  1062	        };
  1063	
  1064	        /**
  1065	         * ðŸ“¦ PORT 6: ASSIMILATE (Store)
  1066	         * Essence: State Persistence & Assimilation
  1067	         * Role: [A]ssimilating gesture telemetry into the FSM store.
  1068	         */
  1069	        const port6Assimilate = (hand, gestureName, score, now, isFacing, confidence = 1.0) => {
  1070	            // P5 HardGate Validation with Coasting Support
  1071	            const fsmRes = hand.fsm.process(gestureName, now, score, isFacing);
  1072	            const auditResult = port5Immunize(hand, fsmRes.state, confidence);
  1073	
  1074	            if (auditResult === 'ALLOW') {
  1075	                return fsmRes;
  1076	            } else if (auditResult === 'COAST') {
  1077	                hand.fsm.lastTimestamp = now;
  1078	                hand.isCoasting = true;
  1079	                return { state: hand.fsm.state, pointerEvent: 'none' };
  1080	            } else {
  1081	                hand.fsm.lastTimestamp = now;
  1082	                return { state: hand.fsm.state, pointerEvent: 'none' };
  1083	            }
  1084	        };
  1085	
  1086	        /**
  1087	         * ðŸ•¸ï¸ PORT 7: NAVIGATE (Plan)
  1088	         * Role: [N]avigating orchestration and BMC2 intent.
  1089	         */
  1090	        const port7Navigate = (intent) => { /* Strategic planning */ };
  1091	
  1092	        const createCursorSet = (handId, hue) => {
  1093	            const h = {
  1094	                id: handId, lastSeen: 0, active: false, coastCount: 0, fsm: new GestureFSM(),
  1095	                cursors: {
  1096	                    raw: { x: 0.5, y: 0.5, color: `hsl(${hue}, 10%, 40%)`, label: `Raw Input` },
  1097	                    smooth: { x: 0.5, y: 0.5, color: `hsl(${hue}, 40%, 40%)`, label: `1Euro Smooth` },
  1098	                    snappy: { x: 0.5, y: 0.5, color: `hsl(${hue}, 70%, 40%)`, label: `1Euro Snappy` },
  1099	                    spring: { x: 0.5, y: 0.5, body: null, anchor: null, constraint: null, color: `hsl(${hue}, 90%, 50%)`, label: `1Euro Spring-Mass-Damper` },
  1100	                    predictive: { x: 0.5, y: 0.5, body: null, color: `hsl(${hue}, 100%, 50%)`, label: `1Euro Kinetic Lookahead` }
  1101	                },
  1102	                filters: {
  1103	                    sx: new OneEuroFilter(30, 0.5, 0.001), sy: new OneEuroFilter(30, 0.5, 0.001),
  1104	                    nx: new OneEuroFilter(30, 1.0, 0.01), ny: new OneEuroFilter(30, 1.0, 0.01),
  1105	                    vx: new OneEuroFilter(30, 0.5, 0.01), vy: new OneEuroFilter(30, 0.5, 0.01) // Velocity Filters for Pred
  1106	                },
  1107	                gestures: { active: 'None', score: 0, isDown: false, pointerEvent: 'none' },
  1108	                lastTarget: null,
  1109	                lastTargetOnDown: null
  1110	            };
  1111	            if (engine) {
  1112	                const { Bodies, Composite, Constraint } = Matter;
  1113	                h.cursors.spring.anchor = Bodies.circle(0.5, 0.5, 1, { isStatic: true, isSensor: true });
  1114	                h.cursors.spring.body = Bodies.circle(0.5, 0.5, 10, { frictionAir: 0.1, label: `H${handId}-SpringB` });
  1115	                h.cursors.spring.constraint = Constraint.create({ bodyA: h.cursors.spring.anchor, bodyB: h.cursors.spring.body, stiffness: hfoState.physics.stiffness, damping: hfoState.physics.damping, length: 0 });
  1116	                h.cursors.predictive.body = Bodies.circle(0.5, 0.5, 10, { isStatic: true, label: `H${handId}-PredB` });
  1117	                Composite.add(engine.world, [h.cursors.spring.anchor, h.cursors.spring.body, h.cursors.spring.constraint, h.cursors.predictive.body]);
  1118	            }
  1119	            return h;
  1120	        };
  1121	
  1122	        let engine, runner, gestureRecognizer;
  1123	        const initPhysics = window.initPhysics = () => {
  1124	            if (hfoSystem.initialized) return;
  1125	            engine = Matter.Engine.create(); engine.gravity.scale = 0;
  1126	            // Removed Matter.Runner for sync stepping in the loop
  1127	            hfoState.hands[0] = createCursorSet(0, 0); hfoState.hands[1] = createCursorSet(1, 350);
  1128	            hfoSystem.initialized = true;
  1129	            initTuningMirror();
  1130	        };
  1131	
  1132	        const initMediaPipe = async (container) => {
  1133	            // Ensure container is ready for absolute children and styled correctly
  1134	            container.style.position = 'relative';
  1135	            container.style.backgroundColor = '#000';
  1136	            container.classList.add('camera-container');
  1137	
  1138	            // UI Controls
  1139	            if (!container.querySelector('.camera-controls')) {
  1140	                const controls = document.createElement('div');
  1141	                controls.className = 'camera-controls';
  1142	
  1143	                const btnStart = document.createElement('button');
  1144	                btnStart.className = 'camera-btn start';
  1145	                btnStart.innerText = 'Start Video';
  1146	
  1147	                const btnStop = document.createElement('button');
  1148	                btnStop.className = 'camera-btn stop';
  1149	                btnStop.innerText = 'Stop';
  1150	                btnStop.style.display = 'none';
  1151	
  1152	                const btnFlip = document.createElement('button');
  1153	                btnFlip.className = 'camera-btn flip';
  1154	                btnFlip.innerText = 'Flip';
  1155	
  1156	                controls.appendChild(btnStart);
  1157	                controls.appendChild(btnStop);
  1158	                controls.appendChild(btnFlip);
  1159	                container.appendChild(controls);
  1160	
  1161	                const updateButtons = (active) => {
  1162	                    btnStart.style.display = active ? 'none' : 'block';
  1163	                    btnStop.style.display = active ? 'block' : 'none';
  1164	                };
  1165	
  1166	                btnStart.onclick = async () => {
  1167	                    try {
  1168	                        hfoSystem.stream = await navigator.mediaDevices.getUserMedia({
  1169	                            video: { width: 1280, height: 720, facingMode: "user" }
  1170	                        });
  1171	                        hfoSystem.video.srcObject = hfoSystem.stream;
  1172	                        hfoSystem.video.onloadedmetadata = () => {
  1173	                            hfoSystem.video.play();
  1174	                            hfoSystem.canvas.width = hfoSystem.video.videoWidth;
  1175	                            hfoSystem.canvas.height = hfoSystem.video.videoHeight;
  1176	                            hfoSystem.loopActive = true;
  1177	                            updateButtons(true);
  1178	                            if (!hfoSystem.initialized) initPhysics();
  1179	                        };
  1180	                    } catch (e) {
  1181	                        console.error("Camera access failed:", e);
  1182	                        alert("Camera access failed. Check permissions.");
  1183	                    }
  1184	                };
  1185	
  1186	                btnStop.onclick = () => {
  1187	                    if (hfoSystem.stream) {
  1188	                        hfoSystem.stream.getTracks().forEach(t => t.stop());
  1189	                        hfoSystem.stream = null;
  1190	                        hfoSystem.video.srcObject = null;
  1191	                    }
  1192	                    hfoSystem.loopActive = false;
  1193	                    updateButtons(false);
  1194	                    if (hfoSystem.ctx) hfoSystem.ctx.clearRect(0, 0, hfoSystem.canvas.width, hfoSystem.canvas.height);
  1195	                };
  1196	
  1197	                btnFlip.onclick = () => {
  1198	                    hfoState.physics.p0Mirror = !hfoState.physics.p0Mirror;
  1199	                    hfoState.physics.p3Mirror = hfoState.physics.p0Mirror; // ðŸ›¡ï¸ SYNC: Ensure pointer logic follows visual flip
  1200	
  1201	                    if (hfoState.physics.p0Mirror) {
  1202	                        hfoSystem.video.classList.add('mirrored');
  1203	                        hfoSystem.canvas.classList.add('mirrored');
  1204	                    } else {
  1205	                        hfoSystem.video.classList.remove('mirrored');
  1206	                        hfoSystem.canvas.classList.remove('mirrored');
  1207	                    }
  1208	                };
  1209	            }
  1210	
  1211	            if (hfoSystem.initializing) {
  1212	                // Wait and re-mount if already initializing (don't return empty container)
  1213	                setTimeout(() => initMediaPipe(container), 200);
  1214	                return;
  1215	            }
  1216	
  1217	            hfoSystem.initializing = true;
  1218	            try {
  1219	                if (!hfoSystem.video) {
  1220	                    hfoSystem.video = document.createElement('video');
  1221	                    hfoSystem.video.autoplay = true;
  1222	                    hfoSystem.video.playsinline = true;
  1223	                    hfoSystem.video.className = 'video-feed mirrored';
  1224	                }
  1225	                if (!hfoSystem.canvas) {
  1226	                    hfoSystem.canvas = document.createElement('canvas');
  1227	                    hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
  1228	                    hfoSystem.canvas.className = 'overlay-canvas mirrored';
  1229	                }
  1230	
  1231	                // Force mount to current container (singleton moves)
  1232	                // Dedup check: only append if not already child
  1233	                if (hfoSystem.video.parentElement !== container) {
  1234	                    container.appendChild(hfoSystem.video);
  1235	                }
  1236	                if (hfoSystem.canvas.parentElement !== container) {
  1237	                    container.appendChild(hfoSystem.canvas);
  1238	                }
  1239	
  1240	                if (hfoSystem.recognizer) {
  1241	                    hfoSystem.initializing = false;
  1242	                    return;
  1243	                }
  1244	
  1245	                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
  1246	                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
  1247	                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
  1248	                    runningMode: "VIDEO", ...hfoState.mpOptions
  1249	                });
  1250	                hfoSystem.recognizer = gestureRecognizer;
  1251	
  1252	                const render = () => {
  1253	                    let lastIter = performance.now();
  1254	                    const loop = () => {
  1255	                        const now = performance.now();
  1256	                        const dt = now - lastIter;
  1257	                        lastIter = now;
  1258	                        hfoSystem.lastFrame = now;
  1259	
  1260	                        if (hfoState.active && hfoSystem.loopActive) {
  1261	                            try {
  1262	                                const res = port0Observe(hfoSystem.video, hfoSystem.recognizer, now);
  1263	
  1264	                                // ðŸ•µï¸ TRANSPARENCY CALCULATION
  1265	                                let rawQuality = 0;
  1266	                                if (res && res.landmarks && res.landmarks.length > 0) {
  1267	                                    rawQuality = res.gestures?.[0]?.[0]?.score || 0.8;
  1268	                                }
  1269	
  1270	                                // Penalty for low FPS (Target 30fps = 33ms)
  1271	                                const fpsPenalty = dt > 50 ? 0.2 : 0;
  1272	                                hfoState.transparency = Math.max(0, Math.min(1.0, rawQuality - fpsPenalty));
  1273	
  1274	                                if (res) {
  1275	                                    const ctx = hfoSystem.ctx;
  1276	                                    const canvas = hfoSystem.canvas;
  1277	                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
  1278	                                    const dw = new DrawingUtils(ctx);
  1279	
  1280	                                    const landmarks = res.landmarks || [];
  1281	                                    const landmarkCurls = landmarks.map(lm => getCurls(lm));
  1282	                                    const landmarkRatios = landmarks.map(lm => getBoneRatios(lm));
  1283	
  1284	                                    const handIds = Object.keys(hfoState.hands);
  1285	                                    const assignedLandmarks = new Set();
  1286	                                    const currentAssignments = {};
  1287	
  1288	                                    // PASS 1: Sticky Tracking (Kinetic Snaplock)
  1289	                                    handIds.filter(id => hfoState.hands[id].active).forEach(id => {
  1290	                                        const h = hfoState.hands[id];
  1291	                                        let bestLIdx = -1;
  1292	                                        let minCost = hfoState.physics.persistence.teleportLimit;
  1293	                                        landmarks.forEach((lm, lIdx) => {
  1294	                                            if (assignedLandmarks.has(lIdx)) return;
  1295	                                            const d = Math.sqrt((lm[8].x - h.cursors.spring.x) ** 2 + (lm[8].y - h.cursors.spring.y) ** 2);
  1296	                                            if (d < minCost) { minCost = d; bestLIdx = lIdx; }
  1297	                                        });
  1298	                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
  1299	                                    });
  1300	
  1301	                                    // PASS 2: Discovery
  1302	                                    handIds.filter(id => !currentAssignments.hasOwnProperty(id)).forEach(id => {
  1303	                                        const h = hfoState.hands[id];
  1304	                                        let bestLIdx = -1;
  1305	                                        let minD = hfoState.physics.persistence.snapDistance;
  1306	                                        landmarks.forEach((lm, lIdx) => {
  1307	                                            if (assignedLandmarks.has(lIdx)) return;
  1308	                                            const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
  1309	                                            if (d < minD) { minD = d; bestLIdx = lIdx; }
  1310	                                        });
  1311	                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
  1312	                                    });
  1313	
  1314	                                    // APPLY - Part 1: Sync Landmarks & Anchors
  1315	                                    handIds.forEach(id => {
  1316	                                        const h = hfoState.hands[id];
  1317	                                        if (currentAssignments.hasOwnProperty(id)) {
  1318	                                            const lIdx = currentAssignments[id];
  1319	                                            const lm = landmarks[lIdx];
  1320	                                            h.curls = landmarkCurls[lIdx];
  1321	                                            h.ratios = landmarkRatios[lIdx];
  1322	                                            h.isFacing = port2ShapeSync(h, now, lm);
  1323	                                            h.isCoasting = false;
  1324	                                        } else {
  1325	                                            h.palm = { normal: { x: 0, y: 0, z: 0 }, facingCamera: false };
  1326	                                            h.coastCount++;
  1327	                                            if (h.coastCount > hfoState.physics.persistence.coastFrames) h.active = false;
  1328	                                            port2ShapeSync(h, now, null);
  1329	                                        }
  1330	                                    });
  1331	
  1332	                                    // ðŸ’ª Physics ACT (Matter.js Step)
  1333	                                    if (engine) Matter.Engine.update(engine, dt);
  1334	
  1335	                                    // APPLY - Part 2: Predict, Draw, & Inject
  1336	                                    handIds.forEach(id => {
  1337	                                        const h = hfoState.hands[id];
  1338	                                        if (currentAssignments.hasOwnProperty(id)) {
  1339	                                            const lIdx = currentAssignments[id];
  1340	                                            port2ShapePredict(h, now);
  1341	
  1342	                                            if (res.gestures?.[lIdx]) {
  1343	                                                const g = res.gestures[lIdx][0];
  1344	                                                const fsmRes = port6Assimilate(h, g.categoryName, g.score, now, h.isFacing, g.score);
  1345	                                                h.gestures = { active: g.categoryName, score: g.score, isDown: (h.fsm.state === 'PORT_7_POINTER_COMMIT'), pointerEvent: fsmRes.pointerEvent };
  1346	                                            }
  1347	                                        } else {
  1348	                                            const fsmRes = port6Assimilate(h, 'LOST', 0, now, false, 0);
  1349	                                            h.gestures.isDown = (h.fsm.state === 'PORT_7_POINTER_COMMIT');
  1350	                                            h.gestures.pointerEvent = fsmRes.pointerEvent;
  1351	                                            port2ShapePredict(h, now);
  1352	                                        }
  1353	
  1354	                                        if (h.active) {
  1355	                                            if (h.visuals.showSkeleton && h.landmarks) {
  1356	                                                VisualStrategies.SKELETON(ctx, h.landmarks, dw);
  1357	                                            }
  1358	
  1359	                                            [h.cursors.raw, h.cursors.smooth, h.cursors.snappy, h.cursors.spring, h.cursors.predictive].forEach(c => {
  1360	                                                const isHero = c.label.includes('Pred');
  1361	                                                if (!hfoState.debug && !isHero) return;
  1362	
  1363	                                                const state = h.fsm.state;
  1364	                                                const dwellRatio = h.fsm.dwellAccumulator / h.fsm.dwellMs;
  1365	                                                const strategy = isHero ? h.visuals.hero : h.visuals.support;
  1366	                                                const size = isHero ? 14 : 3;
  1367	
  1368	                                                if (VisualStrategies[strategy]) {
  1369	                                                    VisualStrategies[strategy](ctx, c, size, state, dwellRatio, c.color);
  1370	                                                }
  1371	
  1372	                                                if (hfoState.debug) {
  1373	                                                    ctx.globalAlpha = 1.0;
  1374	                                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.font = '10px Roboto';
  1375	                                                    ctx.fillText(c.label.split(' ')[1], c.x * canvas.width + size + 8, c.y * canvas.height + 3);
  1376	                                                }
  1377	                                            });
  1378	
  1379	                                            // ðŸ“Š PORT 4: ANALYSIS (Golden Master Results)
  1380	                                            if (hfoState.goldenMaster.active && hfoState.debug) {
  1381	                                                const tx = 50, ty = 100;
  1382	                                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  1383	                                                ctx.fillRect(tx - 10, ty - 20, 250, 150);
  1384	                                                ctx.strokeStyle = '#ff0000';
  1385	                                                ctx.strokeRect(tx - 10, ty - 20, 250, 150);
  1386	
  1387	                                                ctx.fillStyle = '#fff';
  1388	                                                ctx.font = 'bold 12px Roboto';
  1389	                                                ctx.fillText('PORT 4: GOLDEN MASTER ANALYSIS', tx, ty);
  1390	
  1391	                                                const metrics = [
  1392	                                                    { l: 'MODE', v: hfoState.goldenMaster.mode },
  1393	                                                    { l: 'DB_RMSE', v: hfoSystem.tuningMirror.metrics.rmse.toFixed(5) },
  1394	                                                    { l: 'DB_JITTER', v: hfoSystem.tuningMirror.metrics.jitter.toFixed(5) },
  1395	                                                    { l: '1EURO_SMOOTH_V', v: (h.cursors.smooth.x - h.cursors.raw.x).toFixed(5) },
  1396	                                                    { l: 'STIFFNESS_ERROR', v: (h.cursors.spring.body.position.x - h.cursors.spring.anchor.position.x).toFixed(5) },
  1397	                                                    { l: 'PRED_BIAS', v: (h.cursors.predictive.x - h.cursors.spring.x).toFixed(5) },
  1398	                                                    { l: 'SENSE_QUALITY', v: hfoState.transparency.toFixed(2) }
  1399	                                                ];
  1400	
  1401	                                                if (hfoState.goldenMaster.frameCounter % 60 === 0 && hfoSystem.tuningMirror.active) {
  1402	                                                    hfoSystem.tuningMirror.conn.query(`
  1403	                                                        SELECT 
  1404	                                                            sqrt(avg(pow(raw_x - pred_x, 2) + pow(raw_y - pred_y, 2))) as rmse,
  1405	                                                            avg(abs(pred_x - lag(pred_x) over (order by ts))) as jitter
  1406	                                                        FROM telemetry 
  1407	                                                        WHERE ts > ${now - 2000}
  1408	                                                    `).then(res => {
  1409	                                                        const row = res.toArray()[0];
  1410	                                                        if (row) {
  1411	                                                            hfoSystem.tuningMirror.metrics.rmse = row.rmse || 0;
  1412	                                                            hfoSystem.tuningMirror.metrics.jitter = row.jitter || 0;
  1413	                                                        }
  1414	                                                    });
  1415	                                                }
  1416	
  1417	                                                metrics.forEach((m, i) => {
  1418	                                                    ctx.fillStyle = '#ff5252';
  1419	                                                    ctx.fillText(m.l + ':', tx, ty + 25 + i * 20);
  1420	                                                    ctx.fillStyle = '#fff';
  1421	                                                    ctx.fillText(m.v, tx + 100, ty + 25 + i * 20);
  1422	                                                });
  1423	                                            }
  1424	
  1425	                                            // ðŸ§¬ Node Telemetry
  1426	                                            if (hfoState.debug) {
  1427	                                                const tx = h.cursors.raw.x * canvas.width + 15;
  1428	                                                const ty = h.cursors.raw.y * canvas.height + 25;
  1429	                                                ctx.fillStyle = '#ff0000';
  1430	                                                ctx.font = '11px Roboto Mono';
  1431	                                                const curlStr = `N1-Index: ${h.curls.index.toFixed(2)}`;
  1432	                                                ctx.fillText(curlStr, tx, ty);
  1433	                                                ctx.fillText(`COLLECTIVE_ID: ${h.id}`, tx, ty + 14);
  1434	                                            }
  1435	                                            port3Inject(h);
  1436	
  1437	                                            // ðŸ“¥ Log to Tuning Mirror
  1438	                                            if (hfoSystem.tuningMirror.active) {
  1439	                                                hfoSystem.tuningMirror.batch.push(`(${now}, ${h.id}, ${h.cursors.raw.x}, ${h.cursors.raw.y}, ${h.cursors.predictive.x}, ${h.cursors.predictive.y}, '${hfoState.goldenMaster.mode}')`);
  1440	                                                if (hfoSystem.tuningMirror.batch.length > 30) {
  1441	                                                    const batch = hfoSystem.tuningMirror.batch.splice(0, 30);
  1442	                                                    hfoSystem.tuningMirror.conn.query(`INSERT INTO telemetry VALUES ${batch.join(',')}`);
  1443	                                                }
  1444	                                            }
  1445	                                        }
  1446	                                    });
  1447	                                } else {
  1448	                                    // ðŸš€ Synthetic Support
  1449	                                    const activeHands = Object.values(hfoState.hands).filter(h => h.active);
  1450	                                    activeHands.forEach(h => port2ShapeSync(h, now, null));
  1451	                                    if (engine) Matter.Engine.update(engine, dt);
  1452	                                    activeHands.forEach(h => {
  1453	                                        port2ShapePredict(h, now);
  1454	                                        port3Inject(h);
  1455	                                    });
  1456	                                }
  1457	                                port1Bridge(hfoState.hands);
  1458	                            } catch (loopErr) {
  1459	                                console.error("Loop Error Cycle:", loopErr);
  1460	                            }
  1461	                        }
  1462	                        requestAnimationFrame(loop);
  1463	                    };
  1464	                    loop();
  1465	                };
  1466	
  1467	                render();
  1468	            } catch (err) {
  1469	                console.error("Critical MediaPipe Failure:", err);
  1470	            } finally {
  1471	                hfoSystem.initializing = false;
  1472	            }
  1473	        };
  1474	
  1475	        const initPhysicsPanel = (container) => {
  1476	            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
  1477	            const update = () => {
  1478	                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
  1479	                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
  1480	                else {
  1481	                    if (div.querySelectorAll('.hand-section').length !== ids.length) {
  1482	                        div.innerHTML = '';
  1483	                        ids.sort().forEach(id => {
  1484	                            const s = document.createElement('div'); s.className = 'hand-section'; s.id = `section-h${id}`;
  1485	                            s.innerHTML = `<h2 style="font-size: 11px; color: #ff0000; margin: 10px 0 5px 0;">HAND ID: ${id}</h2>
  1486	                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
  1487	                                    <div class="data-card" style="border-left-color: #666; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Raw</h3><code class="val-raw" style="font-size:9px;">...</code></div>
  1488	                                    <div class="data-card" style="border-left-color: #990000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Smooth</h3><code class="val-smooth" style="font-size:9px;">...</code></div>
  1489	                                    <div class="data-card" style="border-left-color: #cc0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Snappy</h3><code class="val-snappy" style="font-size:9px;">...</code></div>
  1490	                                    <div class="data-card" style="border-left-color: #ff0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Spring</h3><code class="val-spring" style="font-size:9px;">...</code></div>
  1491	                                    <div class="data-card" style="border-left-color: #ff4d4d; padding: 4px; border-radius: 4px; grid-column: span 2;"><h3 style="font-size:9px;">Pred</h3><code class="val-pred" style="font-size:9px;">...</code></div>
  1492	                                </div>`;
  1493	                            div.appendChild(s);
  1494	                        });
  1495	                    }
  1496	                    ids.forEach(id => {
  1497	                        const h = data[id]; const s = div.querySelector(`#section-h${id}`);
  1498	                        if (s) {
  1499	                            s.querySelector('.val-raw').innerText = `X:${h.cursors.raw.x.toFixed(3)}`;
  1500	                            s.querySelector('.val-smooth').innerText = `X:${h.cursors.smooth.x.toFixed(3)}`;
  1501	                            s.querySelector('.val-snappy').innerText = `X:${h.cursors.snappy.x.toFixed(3)}`;
  1502	                            s.querySelector('.val-spring').innerText = `X:${h.cursors.spring.x.toFixed(3)}`;
  1503	                            s.querySelector('.val-pred').innerText = `X:${h.cursors.pred.x.toFixed(3)}, Y:${h.cursors.pred.y.toFixed(3)}`;
  1504	                        }
  1505	                    });
  1506	                }
  1507	                requestAnimationFrame(update);
  1508	            }; update();
  1509	        };
  1510	
  1511	        const initTransparencyPanel = (container) => {
  1512	            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
  1513	            div.innerHTML = `
  1514	                <div class="data-card" style="border-left-color: #ff0000; height: 100%; display: flex; flex-direction: column; justify-content: center;">
  1515	                    <h3 style="font-size: 11px; margin-bottom: 10px;">P5 IMMUNIZE: TRANSPARENCY INDEX</h3>
  1516	                    <div style="background: #222; height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
  1517	                        <div id="transparency-bar" style="background: linear-gradient(90deg, #ff0000, #ff8800, #00ff00); height: 100%; width: 100%; transition: width 0.1s;"></div>
  1518	                    </div>
  1519	                    <div id="transparency-val" style="font-size: 32px; font-weight: bold; margin-top: 10px; color: #ff0000; text-align: center;">1.00</div>
  1520	                    <div style="font-size: 9px; color: #666; margin-top: 10px; text-align: center;">
  1521	                        <span style="color: #ff0000;">STUB DETECTED:</span> Reward for Honesty. <br>
  1522	                        Honest "0.00" > Fake "1.00" (AI Theater)
  1523	                    </div>
  1524	                </div>
  1525	            `;
  1526	            const bar = div.querySelector('#transparency-bar');
  1527	            const val = div.querySelector('#transparency-val');
  1528	            const update = () => {
  1529	                const score = window.hfoState.transparency || 0;
  1530	                bar.style.width = `${score * 100}%`;
  1531	                val.innerText = score.toFixed(2);
  1532	                if (score < 0.8) val.style.color = '#ff0000';
  1533	                else if (score < 0.9) val.style.color = '#ff8800';
  1534	                else val.style.color = '#00ff00';
  1535	                requestAnimationFrame(update);
  1536	            };
  1537	            update();
  1538	        };
  1539	
  1540	        const initGesturesPanel = (container) => {
  1541	            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
  1542	            const update = () => {
  1543	                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
  1544	                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
  1545	                else {
  1546	                    if (div.querySelectorAll('.hand-gesture-section').length !== ids.length) {
  1547	                        div.innerHTML = '';
  1548	                        ids.sort().forEach(id => {
  1549	                            const s = document.createElement('div'); s.className = 'hand-gesture-section'; s.id = `gesture-section-h${id}`;
  1550	                            s.innerHTML = `<div class="data-card" style="border-left-color: #cc00ff; padding: 10px; margin-bottom:10px;">
  1551	                                <div style="display:flex; justify-content:space-between; align-items:center;">
  1552	                                    <h3 style="margin:0; font-size:12px;">HAND ${id}</h3>
  1553	                                    <span class="val-tag state-tag tag-port_0_idle">PORT_0_IDLE</span>
  1554	                                </div>
  1555	                                <h1 class="val-gesture" style="font-size: 24px; margin: 10px 0;">NONE</h1>
  1556	                                <div style="display:flex; gap: 5px; align-items:center;">
  1557	                                    <div class="val-event" style="background:#000; padding: 2px 5px; border-radius:3px; color:#00ff88; font-size:10px; font-family:monospace;">none</div>
  1558	                                    <div class="val-score" style="color: #666; font-size: 10px;">Conf: 0%</div>
  1559	                                </div>
  1560	                           </div>`;
  1561	                            div.appendChild(s);
  1562	                        });
  1563	                    }
  1564	                    ids.forEach(id => {
  1565	                        const h = data[id]; const s = div.querySelector(`#gesture-section-h${id}`);
  1566	                        if (s) {
  1567	                            const tag = s.querySelector('.val-tag');
  1568	                            tag.innerText = h.fsm;
  1569	                            tag.className = `val-tag state-tag tag-${h.fsm.toLowerCase()}`;
  1570	                            s.querySelector('.val-gesture').innerText = h.gestures.active;
  1571	                            s.querySelector('.val-event').innerText = h.gestures.pointerEvent;
  1572	                            s.querySelector('.val-score').innerText = `Conf: ${(h.gestures.score * 100).toFixed(1)}%`;
  1573	                        }
  1574	                    });
  1575	                }
  1576	                requestAnimationFrame(update);
  1577	            }; update();
  1578	        };
  1579	
  1580	        const initPalmConePanel = (container) => {
  1581	            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
  1582	            const update = () => {
  1583	                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
  1584	                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting for Palm Data...</div>';
  1585	                else {
  1586	                    if (div.querySelectorAll('.hand-palm-section').length !== ids.length) {
  1587	                        div.innerHTML = '';
  1588	                        ids.sort().forEach(id => {
  1589	                            const s = document.createElement('div'); s.className = 'hand-palm-section'; s.id = `palm-section-h${id}`;
  1590	                            s.innerHTML = `<div class="data-card" style="border-left-color: #ffaa00; padding: 10px; margin-bottom:10px;">
  1591	                                <h3 style="margin:0; font-size:12px;">PALM ${id}</h3>
  1592	                                <div style="display:flex; align-items:center; gap: 20px; margin-top:10px;">
  1593	                                    <div class="palm-visual" style="width:60px; height:60px; background:#000; border:2px solid #555; position:relative; border-radius:50%; overflow:hidden;">
  1594	                                        <div class="palm-dot" style="width:10px; height:10px; background:#ffaa00; position:absolute; top:50%; left:50%; border-radius:50%; transform:translate(-50%, -50%);"></div>
  1595	                                    </div>
  1596	                                    <div>
  1597	                                        <div class="val-facing" style="font-size:14px; font-weight:bold; color:#ffaa00;">FACING: NO</div>
  1598	                                        <code class="val-norm" style="font-size:10px; color:#888;">Z: 0.00</code>
  1599	                                    </div>
  1600	                                </div>
  1601	                           </div>`;
  1602	                            div.appendChild(s);
  1603	                        });
  1604	                    }
  1605	                    ids.forEach(id => {
  1606	                        const h = data[id]; const s = div.querySelector(`#palm-section-h${id}`);
  1607	                        if (s && h.palm) {
  1608	                            const visual = s.querySelector('.palm-visual');
  1609	                            const dot = s.querySelector('.palm-dot');
  1610	                            const facing = s.querySelector('.val-facing');
  1611	                            const norm = s.querySelector('.val-norm');
  1612	
  1613	                            facing.innerText = `FACING: ${h.palm.facingCamera ? 'YES' : 'NO'}`;
  1614	                            facing.style.color = h.palm.facingCamera ? '#00ff88' : '#ff4444';
  1615	                            norm.innerText = `X:${h.palm.normal.x.toFixed(2)} Y:${h.palm.normal.y.toFixed(2)} Z:${h.palm.normal.z.toFixed(2)}`;
  1616	
  1617	                            // Visual hint: move dot based on X/Y normal
  1618	                            dot.style.left = `${50 + h.palm.normal.x * 40}%`;
  1619	                            dot.style.top = `${50 + h.palm.normal.y * 40}%`;
  1620	                            visual.style.borderColor = h.palm.facingCamera ? '#00ff88' : '#555';
  1621	                        }
  1622	                    });
  1623	                }
  1624	                requestAnimationFrame(update);
  1625	            }; update();
  1626	        };
  1627	
  1628	        const initInteractionTest = (container) => {
  1629	            const div = document.createElement('div'); div.className = 'component-container';
  1630	            div.innerHTML = `
  1631	                <div class="data-card">
  1632	                    <h3>HFO Shard Injection Node</h3>
  1633	                    <button id="test-btn" style="width:100%; height:56px; background:var(--m3-primary-container); color:white; border:none; border-radius:12px; font-size:14px; font-weight:700; cursor:pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s cubic-bezier(0, 0, 0.2, 1); text-transform:uppercase;">COMMIT GESTURE</button>
  1634	                    <div id="click-status" style="margin-top:16px; font-family:'Roboto Mono', monospace; font-size:12px; color:var(--m3-text-secondary);">Hive Status: Idle</div>
  1635	                </div>
  1636	                <div class="data-card">
  1637	                    <h3>HFO Shard Parameter Tuning</h3>
  1638	                    <input type="range" id="test-slider" style="width:100%; accent-color: var(--m3-primary);">
  1639	                </div>
  1640	            `;
  1641	            container.appendChild(div);
  1642	            const btn = div.querySelector('#test-btn');
  1643	            const status = div.querySelector('#click-status');
  1644	            btn.addEventListener('pointerdown', () => {
  1645	                btn.style.transform = 'scale(0.98) translateY(2px)';
  1646	                btn.style.boxShadow = 'none';
  1647	                status.innerText = 'Hive Status: SIGNAL_PULSE';
  1648	            });
  1649	            btn.addEventListener('pointerup', () => {
  1650	                btn.style.transform = 'scale(1) translateY(0)';
  1651	                btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
  1652	                status.innerText = 'Hive Status: SIGNAL_RESOLVED';
  1653	            });
  1654	            btn.addEventListener('click', () => {
  1655	                status.innerText = 'Hive Status: INTENT_COMMITTED ðŸš€';
  1656	                setTimeout(() => { if (status.innerText.includes('PORT_7_POINTER_COMMIT')) status.innerText = 'Hive Status: Idle'; }, 2000);
  1657	            });
  1658	        };
  1659	
  1660	        const initPianoGenie = (container) => {
  1661	            const div = document.createElement('div');
  1662	            div.className = 'component-container';
  1663	            div.style.background = '#000';
  1664	            div.style.display = 'flex';
  1665	            div.style.flexDirection = 'column';
  1666	            div.style.alignItems = 'center';
  1667	            div.style.justifyContent = 'center';
  1668	            div.style.padding = '0px';
  1669	            div.style.overflow = 'hidden';
  1670	
  1671	            // Official Magenta Palette
  1672	            const genieColors = [
  1673	                '#EE2B29', '#ff9800', '#ffff00', '#c6ff00',
  1674	                '#00e5ff', '#2979ff', '#651fff', '#d500f9'
  1675	            ];
  1676	
  1677	            div.innerHTML = `
  1678	                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center;">
  1679	                    <div style="color: var(--m3-primary); font-weight: bold; font-family: 'Roboto Mono'; letter-spacing: 4px; font-size: 18px;">PIANO GENIE</div>
  1680	                    <div id="piano-status" style="font-size: 10px; font-family: 'Roboto Mono'; color: #555; margin-top: 8px;">WAITING FOR INITIALIZATION</div>
  1681	                </div>
  1682	                
  1683	                <canvas id="waterfall-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 120px); pointer-events: none;"></canvas>
  1684	
  1685	                <div id="genie-buttons" style="display: flex; gap: 4px; opacity: 0.2; pointer-events: none; width: 100%; height: 120px; position: absolute; bottom: 0; background: #111;">
  1686	                    ${[0, 1, 2, 3, 4, 5, 6, 7].map(i => `
  1687	                        <button data-id="${i}" class="genie-btn" style="
  1688	                            flex-grow: 1;
  1689	                            background: #222;
  1690	                            border: none;
  1691	                            border-top: 4px solid ${genieColors[i]};
  1692	                            cursor: pointer;
  1693	                            transition: background 0.1s;
  1694	                            display: flex;
  1695	                            align-items: center;
  1696	                            justify-content: center;
  1697	                            position: relative;
  1698	                        ">
  1699	                            <span style="color: #666; font-weight: bold; font-size: 14px; pointer-events: none;">${i + 1}</span>
  1700	                            <div class="active-glow" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: ${genieColors[i]}; opacity: 0; transition: opacity 0.1s;"></div>
  1701	                        </button>
  1702	                    `).join('')}
  1703	                </div>
  1704	                
  1705	                <button id="start-audio" style="z-index: 20; background: var(--m3-primary); border: none; padding: 16px 32px; color: black; border-radius: 4px; cursor: pointer; font-weight: bold; font-family: 'Roboto Mono'; text-transform: uppercase;">Load Official Model</button>
  1706	            `;
  1707	            container.appendChild(div);
  1708	
  1709	            const status = div.querySelector('#piano-status');
  1710	            const buttons = div.querySelectorAll('[data-id]');
  1711	            const btnGroup = div.querySelector('#genie-buttons');
  1712	            const btnStart = div.querySelector('#start-audio');
  1713	            const canvas = div.querySelector('#waterfall-canvas');
  1714	            const ctx = canvas.getContext('2d');
  1715	
  1716	            let genie;
  1717	            let player;
  1718	            const heldNotes = new Map();
  1719	            const temperature = 0.25;
  1720	            const LOWEST_MIDI_NOTE = 21;
  1721	
  1722	            // ðŸŒŠ Waterfall Physics State
  1723	            const activeNotes = []; // { body, color, on }
  1724	
  1725	            const init = async () => {
  1726	                try {
  1727	                    btnStart.innerText = 'SYNCING WEIGHTS...';
  1728	                    btnStart.disabled = true;
  1729	
  1730	                    // Initialize with local assets
  1731	                    genie = new mm.PianoGenie('./assets/piano_genie/');
  1732	                    await genie.initialize();
  1733	
  1734	                    player = new mm.SoundFontPlayer('./assets/piano_genie/sgm_plus');
  1735	
  1736	                    status.innerText = 'GENIE READY';
  1737	                    status.style.color = 'var(--m3-primary)';
  1738	                    btnStart.style.display = 'none';
  1739	                    btnGroup.style.opacity = '1';
  1740	                    btnGroup.style.pointerEvents = 'all';
  1741	
  1742	                    // Start visual loop
  1743	                    resizeCanvas();
  1744	                    requestAnimationFrame(drawLoop);
  1745	                } catch (e) {
  1746	                    console.error("Piano Genie Load Failed:", e);
  1747	                    status.innerText = 'INITIALIZATION ERROR';
  1748	                    status.style.color = '#ff5252';
  1749	                    btnStart.innerText = 'RETRY';
  1750	                    btnStart.disabled = false;
  1751	                }
  1752	            };
  1753	
  1754	            const resizeCanvas = () => {
  1755	                const rect = div.getBoundingClientRect();
  1756	                canvas.width = rect.width;
  1757	                canvas.height = rect.height - 120;
  1758	            };
  1759	            window.addEventListener('resize', resizeCanvas);
  1760	
  1761	            const buttonDown = async (buttonIndex) => {
  1762	                if (!genie || !player) return;
  1763	
  1764	                if (mm.Player.tone.context.state !== 'running') {
  1765	                    await mm.Player.tone.context.resume();
  1766	                }
  1767	
  1768	                const noteIdx = genie.next(buttonIndex, temperature);
  1769	                const pitch = LOWEST_MIDI_NOTE + noteIdx;
  1770	
  1771	                player.playNoteDown({ pitch: pitch });
  1772	
  1773	                // create visual body
  1774	                const btn = div.querySelector(`[data-id="${buttonIndex}"]`);
  1775	                const rect = btn.getBoundingClientRect();
  1776	                const divRect = div.getBoundingClientRect();
  1777	                const x = rect.left - divRect.left;
  1778	                const width = rect.width;
  1779	
  1780	                const noteBody = {
  1781	                    x: x,
  1782	                    y: canvas.height, // falling from bottom up? No, traditional is top down.
  1783	                    // But buttons are at the bottom.
  1784	                    width: width,
  1785	                    height: 0,
  1786	                    color: genieColors[buttonIndex],
  1787	                    on: true
  1788	                };
  1789	
  1790	                activeNotes.push(noteBody);
  1791	                heldNotes.set(buttonIndex, { pitch, noteBody });
  1792	
  1793	                btn.querySelector('.active-glow').style.opacity = '0.4';
  1794	                btn.style.background = '#333';
  1795	            };
  1796	
  1797	            const buttonUp = (buttonIndex) => {
  1798	                const data = heldNotes.get(buttonIndex);
  1799	                if (data) {
  1800	                    player.playNoteUp({ pitch: data.pitch });
  1801	                    data.noteBody.on = false;
  1802	                    heldNotes.delete(buttonIndex);
  1803	
  1804	                    const btn = div.querySelector(`[data-id="${buttonIndex}"]`);
  1805	                    btn.querySelector('.active-glow').style.opacity = '0';
  1806	                    btn.style.background = '#222';
  1807	                }
  1808	            };
  1809	
  1810	            const drawLoop = () => {
  1811	                if (!genie) return;
  1812	                ctx.clearRect(0, 0, canvas.width, canvas.height);
  1813	
  1814	                const dy = 4; // Waterfall speed
  1815	
  1816	                for (let i = activeNotes.length - 1; i >= 0; i--) {
  1817	                    const note = activeNotes[i];
  1818	                    if (note.on) {
  1819	                        note.height += dy;
  1820	                        // Note Grows UPWARDS from the button
  1821	                    } else {
  1822	                        note.y -= dy;
  1823	                        // Finished note floats UPWARDS
  1824	                    }
  1825	
  1826	                    ctx.fillStyle = note.color;
  1827	                    ctx.globalAlpha = 0.8;
  1828	                    // Draw note (growing from bottom of canvas)
  1829	                    ctx.fillRect(note.x, canvas.height - note.y - note.height, note.width, note.height);
  1830	
  1831	                    // Cleanup
  1832	                    if (!note.on && (canvas.height - note.y - note.height) < -100) {
  1833	                        activeNotes.splice(i, 1);
  1834	                    }
  1835	                }
  1836	
  1837	                requestAnimationFrame(drawLoop);
  1838	            };
  1839	
  1840	            buttons.forEach(btn => {
  1841	                btn.addEventListener('pointerdown', (e) => {
  1842	                    const idx = parseInt(btn.getAttribute('data-id'));
  1843	                    buttonDown(idx);
  1844	                });
  1845	                btn.addEventListener('pointerup', (e) => {
  1846	                    const idx = parseInt(btn.getAttribute('data-id'));
  1847	                    buttonUp(idx);
  1848	                });
  1849	                btn.addEventListener('pointerleave', (e) => {
  1850	                    const idx = parseInt(btn.getAttribute('data-id'));
  1851	                    buttonUp(idx);
  1852	                });
  1853	            });
  1854	
  1855	            btnStart.onclick = init;
  1856	        };
  1857	
  1858	        const initExcalidraw = (container) => {
  1859	            const wrapper = document.createElement('div');
  1860	            wrapper.className = 'canvas-gate';
  1861	            wrapper.style.width = '100%';
  1862	            wrapper.style.height = '100%';
  1863	            wrapper.style.position = 'relative';
  1864	            wrapper.style.background = '#000';
  1865	
  1866	            // ðŸŽ¥ Background Camera Layer
  1867	            const bgVideo = document.createElement('video');
  1868	            bgVideo.autoplay = true;
  1869	            bgVideo.playsinline = true;
  1870	            bgVideo.muted = true;
  1871	            bgVideo.style.position = 'absolute';
  1872	            bgVideo.style.top = '0';
  1873	            bgVideo.style.left = '0';
  1874	            bgVideo.style.width = '100%';
  1875	            bgVideo.style.height = '100%';
  1876	            bgVideo.style.objectFit = 'contain';
  1877	            bgVideo.style.zIndex = '0';
  1878	            bgVideo.className = 'video-feed mirrored';
  1879	            wrapper.appendChild(bgVideo);
  1880	
  1881	            // Sync with global stream
  1882	            const syncCamera = () => {
  1883	                if (hfoSystem.stream && bgVideo.srcObject !== hfoSystem.stream) {
  1884	                    bgVideo.srcObject = hfoSystem.stream;
  1885	                }
  1886	                const isMirrored = hfoState.physics.p0Mirror;
  1887	                if (isMirrored) bgVideo.classList.add('mirrored');
  1888	                else bgVideo.classList.remove('mirrored');
  1889	            };
  1890	            setInterval(syncCamera, 1000);
  1891	
  1892	            const iframe = document.createElement('iframe');
  1893	            iframe.src = './excalidraw_v31_wrapper.html';
  1894	            iframe.style.width = '100%';
  1895	            iframe.style.height = '100%';
  1896	            iframe.style.border = 'none';
  1897	            iframe.style.position = 'relative';
  1898	            iframe.style.zIndex = '1';
  1899	            iframe.style.opacity = hfoState.visuals.excalidrawOpacity;
  1900	            iframe.id = 'excalidraw-iframe';
  1901	            wrapper.appendChild(iframe);
  1902	
  1903	            hfoSystem.excalidrawIframe = iframe;
  1904	            container.appendChild(wrapper);
  1905	        };
  1906	
  1907	        const initGuide = (container) => {
  1908	            const div = document.createElement('div');
  1909	            div.className = 'component-container';
  1910	            div.innerHTML = `
  1911	                <div class="guide-section">
  1912	                    <h2 style="font-size: 18px; margin-bottom: 24px; border-bottom: 2px solid var(--m3-primary); padding-bottom: 8px;">HFO G88: QUICK START</h2>
  1913	                    <div class="guide-item" style="border-left-color: #ff0000; background: rgba(255,0,0,0.05);">
  1914	                        <h3 style="color: #ff0000;">1. THE AWAKENING (SENSE)</h3>
  1915	                        <p><strong>Face Palm towards Camera:</strong> This initiates the dwell timer. Once the hand is set on fire (visual juice), you enter <code>POINTER_READY</code>.</p>
  1916	                    </div>
  1917	                    <div class="guide-item" style="border-left-color: #ffffff; background: rgba(255,255,255,0.05);">
  1918	                        <h3 style="color: #ffffff;">2. THE COMMAND (COMMIT)</h3>
  1919	                        <p><strong>Pointer Finger UP:</strong> Extend your index finger with confidence to trigger <code>POINTER_COMMIT</code>. The fireball will compress, and an explosion effect will fire reaching the digital substrate.</p>
  1920	                    </div>
  1921	                    <div class="guide-item" style="border-left-color: #938f99; background: rgba(147,143,153,0.05);">
  1922	                        <h3 style="color: #938f99;">3. THE FADE (RELEASE)</h3>
  1923	                        <p><strong>Palm Away:</strong> Turn your palm away from the camera to enter <code>POINTER_RELEASE</code>. The Hand of Fire will slowly fade from tip to wrist as the leaky bucket drains.</p>
  1924	                    </div>
  1925	                    <div class="guide-item">
  1926	                        <h3>Optimization Protocol</h3>
  1927	                        <ul>
  1928	                            <li><strong>Light:</strong> Ensure high contrast for sensor clarity.</li>
  1929	                            <li><strong>State:</strong> Hold palm flat to reset the hive's orientation.</li>
  1930	                        </ul>
  1931	                    </div>
  1932	                </div>
  1933	            `;
  1934	            container.appendChild(div);
  1935	        };
  1936	
  1937	        const initSettings = (container) => {
  1938	            const gui = new GUI({ container, autoPlace: false });
  1939	
  1940	            const phys = gui.addFolder('Hive Dynamics');
  1941	            phys.add(hfoState.physics, 'stiffness', 0, 1).name('Node Tension');
  1942	            phys.add(hfoState.physics, 'stiffnessArmed', 0, 1).name('Commit Tension');
  1943	            phys.add(hfoState.physics, 'damping', 0, 1).name('Viscous Drag');
  1944	            phys.add(hfoState.physics, 'lookAhead', 0, 10).name('Scout Range');
  1945	            phys.open();
  1946	
  1947	            const p3 = gui.addFolder('Neuro-Interaction');
  1948	            p3.add(hfoState.physics, 'p3Source', ['raw', 'smooth', 'snappy', 'spring', 'predictive']).name('Control Node');
  1949	            p3.add(hfoState.physics, 'p3Mirror').name('Invert Neural Axis');
  1950	            p3.add(hfoState.physics, 'purePointerMode').name('Raw Injection');
  1951	            p3.open();
  1952	
  1953	            const vis = gui.addFolder('Elemental Visuals');
  1954	            vis.add(hfoState.visuals, 'excalidrawOpacity', 0, 1).name('Canvas Clarity').onChange(v => {
  1955	                if (hfoSystem.excalidrawIframe) {
  1956	                    hfoSystem.excalidrawIframe.style.opacity = v;
  1957	                }
  1958	            });
  1959	            vis.add(hfoState.visuals, 'showSkeleton').name('Wireframe Carapace');
  1960	            vis.open();
  1961	
  1962	            const mp = gui.addFolder('Sensor Intelligence');
  1963	            mp.add(hfoState.mpOptions, 'minHandDetectionConfidence', 0, 1).name('Sense Sensitivity');
  1964	            mp.add(hfoState.mpOptions, 'minTrackingConfidence', 0, 1).name('Neural Lock Strength');
  1965	            mp.add(hfoState, 'debug').name('Overlay Synapses');
  1966	            mp.open();
  1967	
  1968	            container.appendChild(gui.domElement);
  1969	        };
  1970	
  1971	        const config = {
  1972	            root: {
  1973	                type: 'row', content: [
  1974	                    {
  1975	                        type: 'stack',
  1976	                        width: 61.8,
  1977	                        content: [
  1978	                            {
  1979	                                type: 'component',
  1980	                                componentType: 'Excalidraw',
  1981	                                title: 'OMEGA: EXCALIDRAW'
  1982	                            },
  1983	                            {
  1984	                                type: 'component',
  1985	                                componentType: 'PianoGenie',
  1986	                                title: 'OMEGA: PIANO GENIE'
  1987	                            }
  1988	                        ]
  1989	                    },
  1990	                    {
  1991	                        type: 'column',
  1992	                        width: 38.2,
  1993	                        content: [
  1994	                            {
  1995	                                type: 'stack',
  1996	                                height: 61.8,
  1997	                                content: [
  1998	                                    { type: 'component', componentType: 'Guide', title: 'P7: GETTING STARTED' },
  1999	                                    { type: 'component', componentType: 'Transparency', title: 'P5: IMMUNIZE' },
  2000	                                    { type: 'component', componentType: 'Settings', title: 'P7: NAVIGATE' },
  2001	                                    { type: 'component', componentType: 'Physics', title: 'P2: SHAPE' },
  2002	                                    { type: 'component', componentType: 'Gestures', title: 'P3: INJECT' },
  2003	                                    { type: 'component', componentType: 'PalmCone', title: 'P0: OBSERVE' }
  2004	                                ]
  2005	                            },
  2006	                            {
  2007	                                type: 'component',
  2008	                                componentType: 'MediaPipe',
  2009	                                title: 'P0: SENSOR (ISR)',
  2010	                                height: 38.2
  2011	                            }
  2012	                        ]
  2013	                    }
  2014	                ]
  2015	            }
  2016	        };
  2017	        const layout = new GoldenLayout(document.getElementById('layout-container'));
  2018	        layout.registerComponentFactoryFunction('Transparency', c => initTransparencyPanel(c.element));
  2019	        layout.registerComponentFactoryFunction('PianoGenie', c => initPianoGenie(c.element));
  2020	        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
  2021	        layout.registerComponentFactoryFunction('Physics', c => initPhysicsPanel(c.element));
  2022	        layout.registerComponentFactoryFunction('Gestures', c => initGesturesPanel(c.element));
  2023	        layout.registerComponentFactoryFunction('PalmCone', c => initPalmConePanel(c.element));
  2024	        layout.registerComponentFactoryFunction('Interaction', c => initInteractionTest(c.element));
  2025	        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
  2026	        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
  2027	        layout.registerComponentFactoryFunction('Guide', c => initGuide(c.element));
  2028	        layout.loadLayout(config); window.addEventListener('resize', () => layout.updateSize());
  2029	    </script>
  2030	</body>
  2031	
  2032	</html>
