<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!-- OMEGA GEN 4 V24.21 (UX/HIG Alignment | Skeleton Lifecycle | Fade-on-Lost) -->
<!-- Evolution of v24.20: Implementing skeleton fade-out when hand tracking is lost -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN 4 | V24.21</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet"
        href="./lib/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="./lib/css/goldenlayout-dark-theme.css" />

    <!-- Babylon.js Dependencies -->
    <script src="./lib/js/babylon.js"></script>
    <script src="./lib/js/babylon.loaders.min.js"></script>

    <!-- OpenFeature SDK -->
    <script src="./lib/js/web-sdk.min.js"></script>

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 1000;
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        /* üìú SECURED SCROLLING PANEL */
        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            /* Above Pixi Juice (10) */
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        /* ÔøΩ BABYLON/PIXI OVERLAY CONTAINERS */
        .visual-substrate {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ÔøΩüíé M3 INTEGRATION */
        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA V24.6 - TELEMETRY TESTING]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./lib/js/golden-layout.esm.js",
            "lil-gui": "./lib/js/lil-gui.esm.js",
            "@mediapipe/tasks-vision": "./lib/js/vision_bundle.js",
            "zod": "./lib/js/zod.esm.js",
            "planck": "https://cdn.jsdelivr.net/npm/planck-js@0.3.31/+esm",
            "pixi": "https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/+esm"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';
        import * as PIXI from 'pixi';

        // --- üö© OPENFEATURE CONFIGURATION (V24.2 Evolution) ---
        const urlParams = new URLSearchParams(window.location.search);

        const featureConfig = {
            'phoenix-core': true,
            'engine-babylon': true,
            'engine-canvas': false,
            'engine-pixi': false,
            'physics-planck': true,
            'ui-golden-layout': true,
            'ui-excalidraw': true,
            'ui-lil-gui': true,
            'p3-injector': true,
            'data-fabric': true
        };

        const HFOFeatureProvider = {
            metadata: { name: 'HFODefaultProvider' },
            resolveBooleanEvaluation(flagKey, defaultValue) {
                // Priority: URL Param > Config Map > Default
                let val = featureConfig[flagKey] ?? defaultValue;
                if (urlParams.has(`flag-${flagKey}`)) {
                    val = urlParams.get(`flag-${flagKey}`) === 'true';
                }
                return { value: val };
            }
        };

                // üõ°Ô∏è [HFO] Initialize OpenFeature (Local UMD Bridge)
        const OF_ROOT = window.OpenFeature || {};
        const api = OF_ROOT.OpenFeature || OF_ROOT.default || OF_ROOT;

        if (typeof api.setProvider === 'function') {
            api.setProvider(HFOFeatureProvider);
            console.log("üöÄ [HFO] OpenFeature Hardened (Offline Ready)");
        } else {
            console.warn("‚ö†Ô∏è [HFO] OpenFeature API not found in expected UMD location.");
        }
                const featureClient = typeof api.getClient === 'function' ? api.getClient() : {
            getBooleanValue: (key, def) => {
                if (urlParams.has(`flag-${key}`)) return urlParams.get(`flag-${key}`) === 'true';
                return featureConfig[key] ?? def;
            }
        };

        const isFlagEnabled = (key) => featureClient.getBooleanValue(key, false);

        // --- HFO BASE CONSTANTS: Shared Registry [V24.21] ---
        const HFO_CONSTANTS = {
            msPerSec: 1000,
            byteMaskCC00: 0xFFCC00,
            byteMask4500: 0xFF4500,
            byteMaskFFFF: 0xFFFFFF,
            byteMaskD700: 0xFFD700,
            redShift: 16,
            greenShift: 8,
            byteMask: 0xFF
        };

        // --- MEDALLION LIFECYCLE: Resource Zero-Trust [V24.5] ---
        class LifecycleManager {
            constructor() {
                this.disposables = new Set();
                this.engines = new Map(); // Track singleton engines
            }
            register(id, obj) {
                if (obj && typeof obj.dispose === 'function') {
                    this.disposables.add(obj);
                    if (id) this.engines.set(id, obj);
                }
                return obj;
            }
            unregister(obj) {
                this.disposables.delete(obj);
            }
            dispose(id) {
                if (id) {
                    const obj = this.engines.get(id);
                    if (obj) {
                        try { obj.dispose(); } catch (e) { console.error(`[LIFECYCLE] Error disposing ${id}:`, e); }
                        this.disposables.delete(obj);
                        this.engines.delete(id);
                        console.log(`[LIFECYCLE] Disposed engine: ${id}`);
                    }
                }
            }
            disposeAll() {
                this.disposables.forEach(obj => {
                    try { obj.dispose(); } catch (e) { }
                });
                this.disposables.clear();
                this.engines.clear();
                console.log("[LIFECYCLE] All resources purged.");
            }
        }
        window.hfoLifecycle = new LifecycleManager();

        // --- TELEMETRY: Deterministic Replay Substrate [V24.5] ---
        class TelemetryRecorder {
            constructor() {
                this.buffer = [];
                this.isRecording = false;
                this.maxEntries = systemState.parameters.telemetry.maxEntries;
            }
            start() {
                this.buffer = [];
                this.isRecording = true;
                console.log("‚è∫Ô∏è [TELEMETRY] Recording started.");
            }
            stop() {
                this.isRecording = false;
                console.log("‚èπÔ∏è [TELEMETRY] Recording stopped. Entries:", this.buffer.length);
            }
            record(phase, data) {
                if (!this.isRecording || window.hfoPlayer.isPlaying) return;
                this.buffer.push({
                    timestamp: performance.now(),
                    phase: phase,
                    data: JSON.parse(JSON.stringify(data)) // Deep clone
                });
                if (this.buffer.length > this.maxEntries) this.buffer.shift();
            }
            exportJSONL() {
                const content = this.buffer.map(e => JSON.stringify(e)).join('\n');
                const blob = new Blob([content], { type: 'application/x-jsonlines' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hfo_telemetry_${new Date().toISOString()}.jsonl`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // --- TELEMETRY PLAYER: Golden Master Replay [V24.6] ---
        class TelemetryPlayer {
            constructor() {
                this.sequence = [];
                this.index = 0;
                this.isPlaying = false;
                this.loop = false;
            }
            async load(file) {
                const text = await file.text();
                this.sequence = text.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
                this.index = 0;
                console.log("üéûÔ∏è [TELEMETRY] Sequence loaded. Entries:", this.sequence.length);
            }
            start() {
                if (this.sequence.length === 0) return console.warn("P6: No sequence loaded.");
                this.index = 0;
                this.isPlaying = true;
                systemState.parameters.p0Active = true; // Force loop
                console.log("‚ñ∂Ô∏è [TELEMETRY] Playback started.");
            }
            stop() {
                this.isPlaying = false;
                console.log("‚èπÔ∏è [TELEMETRY] Playback stopped.");
            }
            pause() {
                this.isPlaying = false;
                console.log("‚è∏Ô∏è [TELEMETRY] Playback paused.");
            }
            getNextFrame() {
                if (!this.isPlaying || this.sequence.length === 0) return null;
                const frame = this.sequence[this.index];
                this.index++;
                if (this.index >= this.sequence.length) {
                    if (this.loop) this.index = 0;
                    else this.stop();
                }
                return frame;
            }
        }

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                resolutionWidth: z.number().default(1280),
                resolutionHeight: z.number().default(720),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                minPresenceConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            constants: z.object({
                msPerSec: z.number().default(1000)
            }),
            interaction: z.object({
                domDepthLimit: z.number().default(5),
                pulseSettleMs: z.number().default(10)
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            palm: z.object({
                enterThreshold: z.number().min(0).max(1),
                exitThreshold: z.number().min(0).max(1)
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(100),
                hysteresisLow: z.number().min(0).max(100),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1),
                tensionMs: z.number().min(0),
                commitExitDelayMs: z.number().min(0),
                maxBucketLevel: z.number().default(100),
                pointerIdOffset: z.number().default(10)
            }),
            coasting: z.object({
                timeoutMs: z.number().min(0),
                confidenceThreshold: z.number().min(0).max(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(), // V20.6: User Requested Feature Flag
                directProjectionOffset: z.number().min(0), // V20.6: Tuning for LI/Direct stability
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']), // V20.4: HFO Trigram Bagua
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                oneEuroRodMinCutoff: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                fireScale: z.number().min(0.1).default(1.0),
                fireIntensity: z.number().min(0.1).default(1.0),
                palmRodMultiplier: z.number().min(0.5).max(10), // V18: Palm-width based scaling
                showLaserBeam: z.boolean(),
                predictiveLookahead: z.number().min(0),
                scalePxToM: z.number().min(10).max(1000).default(100.0),
                planckLinearDamping: z.number().default(2.0),
                planckAngularDamping: z.number().default(5.0),
                planckFixtureRadius: z.number().default(0.1),
                planckFixtureDensity: z.number().default(1.0),
                planckFixtureFriction: z.number().default(0.3),
                planckMaxStepDt: z.number().default(0.033),
                planckDefaultStiffness: z.number().default(5.0),
                planckDefaultDamping: z.number().default(0.7),
                oneEuroDefaultMinCutoff: z.number().default(1.0),
                oneEuroDefaultBeta: z.number().default(0.0),
                oneEuroDerivCutoff: z.number().default(1.0),
                oneEuroRateFallback: z.number().default(30),
                massSpringDefaultStiffness: z.number().default(0.15),
                massSpringDefaultDamping: z.number().default(0.05),
                worldProjectionPrecision: z.number().default(0.0001),
                normalZThreshold: z.number().default(0.7),
                normalZMultiplier: z.number().default(0.5)
            }),
            anatomy: z.object({
                palmWidthCm: z.number().min(3).max(15),
                rodExtensionMultiplier: z.number().min(0.1).max(10),
                skeletonDepthMultiplier: z.number().min(1).max(5).default(1.5),
                mathEpsilon: z.number().default(1e-6),
                landmarkZScale: z.number().default(0.1),
                handSkeletonMap: z.array(z.array(z.number())).default([
                    [0, 1], [1, 2], [2, 3], [3, 4], // thumb
                    [0, 5], [5, 6], [6, 7], [7, 8], // index
                    [0, 9], [9, 10], [10, 11], [11, 12], // middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // pinky
                    [5, 9], [9, 13], [13, 17] // palm
                ]),
                indices: z.object({
                    WRIST: z.number().default(0),
                    INDEX_MCP: z.number().default(5),
                    INDEX_TIP: z.number().default(8),
                    MIDDLE_MCP: z.number().default(9),
                    RING_MCP: z.number().default(13),
                    PINKY_MCP: z.number().default(17),
                    THUMB_TIP: z.number().default(4)
                }).default({
                    WRIST: 0,
                    INDEX_MCP: 5,
                    INDEX_TIP: 8,
                    MIDDLE_MCP: 9,
                    RING_MCP: 13,
                    PINKY_MCP: 17,
                    THUMB_TIP: 4
                }),
                curlGroups: z.object({
                    index: z.array(z.number()).default([5, 6, 7, 8]),
                    middle: z.array(z.number()).default([9, 10, 11, 12]),
                    ring: z.array(z.number()).default([13, 14, 15, 16]),
                    pinky: z.array(z.number()).default([17, 18, 19, 20])
                }).default({
                    index: [5, 6, 7, 8],
                    middle: [9, 10, 11, 12],
                    ring: [13, 14, 15, 16],
                    pinky: [17, 18, 19, 20]
                })
            }),
            visuals: z.object({
                engine: z.enum(['BABYLON', 'PIXI']),
                variant: z.string(),
                skeletonAlphaSphere: z.number().min(0).max(1).default(0.12),
                skeletonAlphaBone: z.number().min(0).max(1).default(0.08),
                skeletonAlphaClaw: z.number().min(0).max(1).default(0.2),
                skeletonFadeSpeed: z.number().min(0.01).max(1.0).default(0.18),
                cameraPosition: z.object({ x: z.number(), y: z.number(), z: z.number() }).default({ x: 0, y: 0, z: -10 }),
                lightPosition: z.object({ x: z.number(), y: z.number(), z: z.number() }).default({ x: 0, y: 0, z: -5 }),
                lightIntensity: z.number().default(0.8),
                perfLerpFactor: z.number().default(0.95),
                perfMin: z.number().default(0.2),
                perfMax: z.number().default(1.5),
                trailAlpha: z.number().default(0.2),
                trailCommitAlpha: z.number().default(0.3),
                trailCommitColor: z.object({ r: z.number(), g: z.number(), b: z.number() }).default({ r: 0, g: 0.7, b: 1 }),
                trailReadyColor: z.object({ r: z.number(), g: z.number(), b: z.number() }).default({ r: 1, g: 0.4, b: 0 }),
                boneColor: z.object({ r: z.number(), g: z.number(), b: z.number() }).default({ r: 0.8, g: 0.8, b: 0.8 }),
                clawColor: z.object({ r: z.number(), g: z.number(), b: z.number() }).default({ r: 0.9, g: 0.9, b: 1.0 }),
                fire: z.object({
                    highSpeedMultiplier: z.number().default(20),
                    lowSpeedMultiplier: z.number().default(10),
                    highDensityMax: z.number().default(2.5),
                    lowDensityMax: z.number().default(2.0),
                    highBaseRate: z.number().default(600),
                    lowBaseRate: z.number().default(250),
                    highJitter: z.number().default(0.03),
                    lowJitter: z.number().default(0.06),
                    highMinSize: z.number().default(0.06),
                    lowMinSize: z.number().default(0.1),
                    highMaxSize: z.number().default(0.24),
                    lowMaxSize: z.number().default(0.3),
                    highMinLife: z.number().default(0.25),
                    lowMinLife: z.number().default(0.4),
                    highMaxLife: z.number().default(0.5),
                    lowMaxLife: z.number().default(0.8),
                    highGravityY: z.number().default(4),
                    lowGravityY: z.number().default(2),
                    alpha1: z.number().default(0.4),
                    alpha2: z.number().default(0.2),
                    colorMultiplier: z.number().default(0.5)
                }).default({}),
                skeleton: z.object({
                    sphereDiameter: z.number().default(0.12),
                    sphereCount: z.number().default(21),
                    trailDiameter: z.number().default(0.08),
                    trailLength: z.number().default(30),
                    emitterDiameter: z.number().default(0.05),
                    alphaThreshold: z.number().default(0.01),
                    lifecycleAlphaThreshold: z.number().default(0.01),
                    fireMinEmitBoxScale: z.number().default(-0.8),
                    fireMaxEmitBoxScale: z.number().default(-1.0),
                    fireJitterY: z.number().default(-0.02),
                    fireBoxY: z.number().default(0.02)
                }).default({}),
                particles: z.object({
                    minEmitBox: z.object({ x: z.number(), y: z.number(), z: z.number() }).default({ x: -0.05, y: 0, z: -0.05 }),
                    maxEmitBox: z.object({ x: z.number(), y: z.number(), z: z.number() }).default({ x: 0.05, y: 0, z: 0.05 }),
                    minLifeTime: z.number().default(0.1),
                    maxLifeTime: z.number().default(0.3),
                    gravity: z.object({ x: z.number(), y: z.number(), z: z.number() }).default({ x: 0, y: 2, z: 0 }),
                    minBloomSize: z.number().default(0.1)
                }).default({}),
                canvasCursors: z.object({
                    fireSizeBase: z.number().default(15),
                    fireSizeCommit: z.number().default(25),
                    pulseRate: z.number().default(250),
                    pulseMagnitude: z.number().default(3),
                    sparkCountCommit: z.number().default(5),
                    sparkCountReady: z.number().default(2),
                    sparkDuration: z.number().default(1000),
                    sparkSpreadX: z.number().default(30),
                    sparkSpreadY: z.number().default(10),
                    sparkRise: z.number().default(60),
                    shadowBlur: z.number().default(10),
                    arcSizeCommit: z.number().default(8),
                    arcSizeReady: z.number().default(5),
                    ghostSize: z.number().default(12),
                    crosshairSize: z.number().default(10),
                    rippleSizeBase: z.number().default(15),
                    rippleSizeCommit: z.number().default(25),
                    ripplePulseRate: z.number().default(150),
                    waterWaveSteps: z.number().default(20),
                    waterWaveFrequency: z.number().default(150),
                    waterWaveScale: z.number().default(5),
                    waterWaveMagnitude: z.number().default(10),
                    fireballBloomScale: z.number().default(4),
                    fireballPulseRate: z.number().default(150),
                    fireballPulseMagnitude: z.number().default(0.5),
                    fireballSpikeCount: z.number().default(8),
                    fireballSpikeRate: z.number().default(200),
                    fireballSpikeLengthScale: z.number().default(2.5),
                    fireballSpikeFrequency: z.number().default(50),
                    fireballSpikeMagnitude: z.number().default(0.8),
                    juiceThreshold: z.number().default(5),
                    // HFO Expansion Pack
                    gridSteps: z.number().default(8),
                    gridAlpha: z.number().default(0.2),
                    skeletonConnectorAlpha: z.number().default(0.15),
                    skeletonLandmarkAlpha: z.number().default(0.2),
                    skeletonLineWidth: z.number().default(1.2),
                    skeletonRadius: z.number().default(5),
                    skeletonRadiusMultiplier: z.number().default(1.5),
                    skeletonAlphaReady: z.number().default(0.4),
                    skeletonAlphaCommit: z.number().default(0.9),
                    skeletonAlphaCoast: z.number().default(0.1),
                    whiteCoreAlpha: z.number().default(0.4),
                    whiteCoreWidth: z.number().default(1),
                    ripplePulseMagnitude: z.number().default(5),
                    bubbleOrbitSpeed: z.number().default(500),
                    bubbleCount: z.number().default(8),
                    facingDotSize: z.number().default(4),
                    normalLineAlpha: z.number().default(0.3),
                    depthRingAlpha: z.number().default(0.4),
                    gradStopA: z.number().default(0),
                    gradStopB: z.number().default(0.4),
                    gradStopC: z.number().default(1),
                    glowTimeDivisor: z.number().default(1000),
                    glowColorOffset: z.number().default(100),
                    panelAlpha: z.number().default(0.05),
                    anchorX: z.number().default(0.5),
                    anchorY: z.number().default(0.85),
                    randomThreshold: z.number().default(0.8),
                    arcSizeCommitFactor: z.number().default(2.5),
                    arcSizeReadyFactor: z.number().default(1.5),
                    historyLimit: z.number().default(88),
                    goldilocksThreshold: z.number().default(0.88),
                    dashLength: z.number().default(2),
                    dashGap: z.number().default(2),
                    radiusBase: z.number().default(40),
                    gageWidth: z.number().default(12),
                    gageHeight: z.number().default(80),
                    gageOffset: z.number().default(20),
                    sparklinePadding: z.number().default(10),
                    shadowBlurPalm: z.number().default(15),
                    bucketWidth: z.number().default(12),
                    bucketHeight: z.number().default(80),
                    bucketOffset: z.number().default(20),
                    uiLineOffset: z.number().default(2),
                    uiIndicatorOffset: z.number().default(5)
                }).default({}),
                pixi: z.object({
                    glowSizeLarge: z.number().default(128),
                    glowSizeSmall: z.number().default(64),
                    colorGold: z.number().default(HFO_CONSTANTS.byteMaskCC00),
                    colorRed: z.number().default(HFO_CONSTANTS.byteMask4500),
                    colorWhite: z.number().default(HFO_CONSTANTS.byteMaskFFFF),
                    readyLayerCount: z.number().default(4),
                    sparklineSteps: z.number().default(64),
                    commitLayerCount: z.number().default(6),
                    timerIncrement: z.number().default(0.05),
                    readyPulseScaleBase: z.number().default(1.2),
                    readyPulseScaleMagnitude: z.number().default(0.3),
                    readyPhaseOffset: z.number().default(0.8),
                    readyPulseRate: z.number().default(0.8),
                    readyRotationBase: z.number().default(0.5),
                    readyRotationStep: z.number().default(0.1),
                    readyAlphaBase: z.number().default(0.4),
                    readyAlphaFreq: z.number().default(1.5),
                    readyAlphaMag: z.number().default(0.2),
                    commitPhaseRate: z.number().default(2.0),
                    commitPhaseStep: z.number().default(0.5),
                    commitFreq: z.number().default(0.7),
                    commitXStep: z.number().default(3),
                    commitScaleXBase: z.number().default(0.6),
                    commitScaleXMag: z.number().default(0.2),
                    commitScaleYBase: z.number().default(1.8),
                    commitScaleYFreq: z.number().default(1.3),
                    commitScaleYMag: z.number().default(0.6),
                    commitAlphaBase: z.number().default(0.8),
                    commitAlphaStep: z.number().default(10),
                    sparkProb: z.number().default(0.8),
                    sparkSize: z.number().default(2),
                    sparkVxMag: z.number().default(4),
                    sparkVyBase: z.number().default(-4),
                    sparkVyMag: z.number().default(6),
                    sparkDecayBase: z.number().default(0.02),
                    sparkDecayMag: z.number().default(0.03),
                    sparkGravity: z.number().default(0.08),
                    sparkFriction: z.number().default(0.95)
                }).default({}),
                colors: z.object({
                    commit: z.array(z.string()).default(['rgba(255, 255, 255, 1.0)', 'rgba(255, 69, 0, 0.8)', 'rgba(255, 140, 0, 0.6)']),
                    ready: z.array(z.string()).default(['rgba(255, 255, 255, 0.6)', 'rgba(255, 195, 0, 0.5)', 'rgba(255, 69, 0, 0.3)']),
                    coast: z.array(z.string()).default(['rgba(255, 255, 255, 0.2)', 'rgba(255, 140, 0, 0.2)', 'rgba(128, 0, 0, 0.1)']),
                    waterCommit: z.array(z.string()).default(['rgba(255, 255, 255, 1.0)', 'rgba(0, 191, 255, 0.8)', 'rgba(0, 123, 255, 0.6)']),
                    waterReady: z.array(z.string()).default(['rgba(255, 255, 255, 0.6)', 'rgba(173, 216, 230, 0.5)', 'rgba(0, 191, 255, 0.3)']),
                    waterCoast: z.array(z.string()).default(['rgba(255, 255, 255, 0.2)', 'rgba(224, 247, 250, 0.2)', 'rgba(178, 235, 242, 0.1)']),
                    fireballCommit: z.array(z.string()).default(['rgba(255, 255, 255, 1.0)', 'rgba(255, 236, 61, 0.9)', 'rgba(255, 77, 79, 0.8)', 'rgba(255, 30, 0, 0)']),
                    fireballReady: z.array(z.string()).default(['rgba(255, 255, 255, 0.8)', 'rgba(255, 251, 143, 0.7)', 'rgba(255, 169, 64, 0.6)', 'rgba(255, 169, 64, 0)']),
                    fireballCoast: z.array(z.string()).default(['rgba(255, 255, 255, 0.4)', 'rgba(145, 213, 255, 0.3)', 'rgba(9, 109, 217, 0.2)', 'rgba(9, 109, 217, 0)']),
                    spark: z.string().default('#FFD700'),
                    qCommit: z.string().default('#FF4136'),
                    qReady: z.string().default('#FFD700'),
                    qIdle: z.string().default('#0074D9'),
                    white: z.string().default('#fff'),
                    bLight: z.object({ r: z.number(), g: z.number(), b: z.number() }).default({ r: 1, g: 0.4, b: 0.1 }),
                    bFire1: z.object({ r: z.number(), g: z.number(), b: z.number(), a: z.number() }).default({ r: 1.0, g: 0.6, b: 0.1, a: 1.0 }),
                    bFire2: z.object({ r: z.number(), g: z.number(), b: z.number(), a: z.number() }).default({ r: 1, g: 0.2, b: 0, a: 0.5 }),
                    bFireDead: z.object({ r: z.number(), g: z.number(), b: z.number(), a: z.number() }).default({ r: 0, g: 0, b: 0, a: 0 })
                }).default({})
            }),
            telemetry: z.object({
                maxEntries: z.number().default(10000)
            })
        });

        const LandmarkSchema = z.object({
            x: z.number(),
            y: z.number(),
            z: z.number()
        });

        // üèóÔ∏è PORT 1: FUSION CONTRACTS
        const FusionSchema = z.object({
            screenX: z.number(),
            screenY: z.number(),
            normX: z.number(),
            normY: z.number(),
            normZ: z.number(), // V24.21: Depth Parity
            rawX: z.number(), // V18: Required for laser origin
            rawY: z.number(), // V18: Required for laser origin
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(),
            confidence: z.number(),
            isPalmFacing: z.boolean(),
            normalZ: z.number(),
            palmConeAngle: z.number(), // V20.3: Anatomical Stability Factor
            palmNormal: z.object({
                x: z.number(),
                y: z.number(),
                z: z.number()
            }),
            bucketLevel: z.number(),
            handIndex: z.number(),
            pointerId: z.number(), // V24.4: Stable ABI ID
            curls: z.object({
                index: z.number(),
                middle: z.number(),
                ring: z.number(),
                pinky: z.number()
            }),
            landmarks: z.array(z.object({ x: z.number(), y: z.number(), z: z.number() })).optional(), // V24.17: Skeletal Fabric
            timestamp: z.number().optional()
        });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        const CoordinateSchema = FusionSchema;

        // --- PRODUCTION STATE ---
        const systemState = {
            parameters: {
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                landmarks: { minConfidence: 0.5, minTrackingConfidence: 0.5, minPresenceConfidence: 0.5, numHands: 2, showSkeleton: true },
                constants: HFO_CONSTANTS,
                interaction: { domDepthLimit: 5, pulseSettleMs: 10 },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.80, exitThreshold: 0.64 },
                fsm: {
                    hysteresisHigh: 80,
                    hysteresisLow: 64,
                    chargeTimeMs: 266,
                    releaseTimeMs: 200,
                    coastDrainTimeMs: 1200, // Slower drain for Inertia [V16]
                    tensionMs: 100,
                    commitExitDelayMs: 250,
                    maxBucketLevel: 100,
                    pointerIdOffset: 10
                },
                coasting: { timeoutMs: 150, confidenceThreshold: 0.4 },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true, // V20.6 Feature Flag (Default ON)
                    directProjectionOffset: 0.04, // V20.6 Custom Offset for Direct projection
                    cursorTheme: 'LI', // V20.5 stable evolution
                    oneEuroMinCutoff: 0.85,
                    oneEuroBeta: 0.02,
                    oneEuroRodMinCutoff: 0.8,
                    planckStiffness: 4.5,
                    planckDamping: 1.2,
                    palmRodMultiplier: 0.64,
                    showLaserBeam: true,
                    showTrailMesh: false, // V24.17: Off by default
                    showHFOClaw: false, // V24.18: Off by default
                    predictiveLookahead: 0.5,
                    scalePxToM: 100.0,
                    planckLinearDamping: 2.0,
                    planckAngularDamping: 5.0,
                    planckFixtureRadius: 0.1,
                    planckFixtureDensity: 1.0,
                    planckFixtureFriction: 0.3,
                    planckMaxStepDt: 0.033,
                    planckDefaultStiffness: 5.0,
                    planckDefaultDamping: 0.7,
                    oneEuroDefaultMinCutoff: 1.0,
                    oneEuroDefaultBeta: 0.0,
                    oneEuroRateFallback: 30,
                    massSpringDefaultStiffness: 0.15,
                    massSpringDefaultDamping: 0.05,
                    worldProjectionPrecision: 0.0001,
                    fireScale: 2.0, // V24.11 Default
                    fireIntensity: 2.0 // V24.11 Default
                },
                anatomy: {
                    palmWidthCm: 8,
                    rodExtensionMultiplier: 0.125,
                    skeletonDepthMultiplier: 1.5,
                    mathEpsilon: 1e-6,
                    landmarkZScale: 0.1,
                    handSkeletonMap: [
                        [0, 1], [1, 2], [2, 3], [3, 4], // thumb
                        [0, 5], [5, 6], [6, 7], [7, 8], // index
                        [0, 9], [9, 10], [10, 11], [11, 12], // middle
                        [0, 13], [13, 14], [14, 15], [15, 16], // ring
                        [0, 17], [17, 18], [18, 19], [19, 20], // pinky
                        [5, 9], [9, 13], [13, 17] // palm
                    ],
                    indices: {
                        WRIST: 0,
                        INDEX_MCP: 5,
                        INDEX_TIP: 8,
                        MIDDLE_MCP: 9,
                        RING_MCP: 13,
                        PINKY_MCP: 17,
                        THUMB_TIP: 4
                    },
                    curlGroups: {
                        index: [5, 6, 7, 8],
                        middle: [9, 10, 11, 12],
                        ring: [13, 14, 15, 16],
                        pinky: [17, 18, 19, 20]
                    }
                },
                excalidraw: {
                    opacity: 0.8,
                    enabled: true,
                    activeTool: 'draw'
                },
                visuals: {
                    engine: 'BABYLON',
                    variant: 'PHOENIX_CORE',
                    skeletonAlphaSphere: 0.12,
                    skeletonAlphaBone: 0.08,
                    skeletonAlphaClaw: 0.2,
                    skeletonFadeSpeed: 0.18,
                    cameraPosition: { x: 0, y: 0, z: -10 },
                    lightPosition: { x: 0, y: 0, z: -5 },
                    lightIntensity: 0.8,
                    perfLerpFactor: 0.95,
                    perfMin: 0.2,
                    perfMax: 1.5,
                    trailAlpha: 0.2,
                    trailCommitAlpha: 0.3,
                    trailCommitColor: { r: 0, g: 0.7, b: 1 },
                    trailReadyColor: { r: 1, g: 0.4, b: 0 },
                    boneColor: { r: 0.8, g: 0.8, b: 0.8 },
                    clawColor: { r: 0.9, g: 0.9, b: 1.0 },
                    fire: {
                        highSpeedMultiplier: 20,
                        lowSpeedMultiplier: 10,
                        highDensityMax: 2.5,
                        lowDensityMax: 2.0,
                        highBaseRate: 600,
                        lowBaseRate: 250,
                        highJitter: 0.03,
                        lowJitter: 0.06,
                        highMinSize: 0.06,
                        lowMinSize: 0.1,
                        highMaxSize: 0.24,
                        lowMaxSize: 0.3,
                        highMinLife: 0.25,
                        lowMinLife: 0.4,
                        highMaxLife: 0.5,
                        lowMaxLife: 0.8,
                        highGravityY: 4,
                        lowGravityY: 2
                    },
                    skeleton: {
                        sphereDiameter: 0.12,
                        sphereCount: 21,
                        trailDiameter: 0.08,
                        trailLength: 30,
                        emitterDiameter: 0.05,
                        alphaThreshold: 0.01,
                        lifecycleAlphaThreshold: 0.01,
                        fireMinEmitBoxScale: -0.8,
                        fireMaxEmitBoxScale: -1.0,
                        fireJitterY: -0.02,
                        fireBoxY: 0.02
                    },
                    particles: {
                        minEmitBox: { x: -0.05, y: 0, z: -0.05 },
                        maxEmitBox: { x: 0.05, y: 0, z: 0.05 },
                        minLifeTime: 0.1,
                        maxLifeTime: 0.3,
                        gravity: { x: 0, y: 2, z: 0 }
                    },
                    canvasCursors: {
                        fireSizeBase: 15,
                        fireSizeCommit: 25,
                        pulseRate: 250,
                        pulseMagnitude: 3,
                        sparkCountCommit: 5,
                        sparkCountReady: 2,
                        sparkDuration: 1000,
                        sparkSpreadX: 30,
                        sparkSpreadY: 10,
                        sparkRise: 60,
                        shadowBlur: 10,
                        arcSizeCommit: 8,
                        arcSizeReady: 5,
                        ghostSize: 12,
                        crosshairSize: 10,
                        juiceThreshold: 5,
                        // UX Parameterization [V24.21]
                        waterWaveSteps: 20,
                        waterWaveFrequency: 150,
                        waterWaveScale: 5,
                        waterWaveMagnitude: 10,
                        whiteCoreAlpha: 0.4,
                        whiteCoreWidth: 1,
                        rippleSizeBase: 15,
                        rippleSizeCommit: 25,
                        ripplePulseRate: 150,
                        ripplePulseMagnitude: 5,
                        bubbleCount: 8,
                        glowTimeDivisor: 1000,
                        skeletonRadiusMultiplier: 1.5,
                        skeletonAlphaReady: 0.4,
                        skeletonAlphaCoast: 0.1,
                        skeletonRadius: 5,
                        panelAlpha: 0.05,
                        gridAlpha: 0.2,
                        dashLength: 2,
                        dashGap: 2,
                        radiusBase: 40,
                        depthRingAlpha: 0.4,
                        normalLineAlpha: 0.3,
                        facingDotSize: 4,
                        shadowBlurPalm: 15,
                        goldilocksThreshold: 0.88,
                        gageWidth: 12,
                        gageOffset: 20,
                        sparklinePadding: 10,
                        uiLineOffset: 2,
                        uiIndicatorOffset: 5,
                        bucketWidth: 12,
                        bucketHeight: 80,
                        bucketOffset: 20,
                        historyLimit: 88,
                        gridSteps: 8,
                        glowColorOffset: 100,
                        arcSizeCommitFactor: 2.5,
                        arcSizeReadyFactor: 1.5,
                        gradStopA: 0,
                        gradStopB: 0.4,
                        gradStopC: 1
                    },
                    pixi: {
                        glowSizeLarge: 128,
                        glowSizeSmall: 64,
                        colorGold: HFO_CONSTANTS.byteMaskCC00,
                        colorRed: HFO_CONSTANTS.byteMask4500,
                        colorWhite: HFO_CONSTANTS.byteMaskFFFF,
                        readyLayerCount: 4,
                        commitLayerCount: 6,
                        timerIncrement: 0.05,
                        readyPulseScaleBase: 1.2,
                        readyPulseScaleMagnitude: 0.3,
                        readyPhaseOffset: 0.8,
                        readyPulseRate: 0.8,
                        readyRotationBase: 0.5,
                        readyRotationStep: 0.1,
                        readyAlphaBase: 0.4,
                        readyAlphaFreq: 1.5,
                        readyAlphaMag: 0.2,
                        commitPhaseRate: 2.0,
                        commitPhaseStep: 0.5,
                        commitFreq: 0.7,
                        commitXStep: 3,
                        commitScaleXBase: 0.6,
                        commitScaleXMag: 0.2,
                        commitScaleYBase: 1.8,
                        commitScaleYFreq: 1.3,
                        commitScaleYMag: 0.6,
                        commitAlphaBase: 0.8,
                        commitAlphaStep: 10,
                        sparkProb: 0.8,
                        sparkSize: 2,
                        sparkVxMag: 4,
                        sparkVyBase: -4,
                        sparkVyMag: 6,
                        sparkDecayBase: 0.02,
                        sparkDecayMag: 0.03,
                        sparkGravity: 0.08
                    },
                    colors: {
                        commit: ['rgba(255, 255, 255, 1.0)', 'rgba(255, 69, 0, 0.8)', 'rgba(255, 140, 0, 0.6)'],
                        ready: ['rgba(255, 255, 255, 0.6)', 'rgba(255, 195, 0, 0.5)', 'rgba(255, 69, 0, 0.3)'],
                        coast: ['rgba(255, 255, 255, 0.2)', 'rgba(255, 140, 0, 0.2)', 'rgba(128, 0, 0, 0.1)'],
                        spark: '#FFD700',
                        qCommit: '#FF4136',
                        qReady: '#FFD700',
                        qIdle: '#0074D9',
                        white: '#fff',
                        bLight: { r: 1, g: 0.4, b: 0.1 },
                        bFire1: { r: 1.0, g: 0.6, b: 0.1, a: 1.0 },
                        bFire2: { r: 1, g: 0.2, b: 0, a: 0.5 },
                        bFireDead: { r: 0, g: 0, b: 0, a: 0 }
                    },
                    particleMaxCount: 2000,
                    particleEmitRate: 400,
                    particleTexture: "https://playground.babylonjs.com/textures/flare.png"
                },
                telemetry: {
                    maxEntries: 10000
                },
                p0Active: false,
                devMode: false
            },
            fsm: {
                currentState: 'IDLE',
                lastState: 'IDLE',
                lastCommitTime: 0,
                commitExitStartTime: 0,
                primaryHandIndex: null,
                nematocystTargetLock: null,
                lastTarget: null,
                activePointers: {} // V24.4: Tracks down status per pointerId
            },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [],
                buckets: [0, 0, 0, 0], // Per-hand leaky buckets
                fsmStates: ['IDLE', 'IDLE', 'IDLE', 'IDLE'], // Per-hand FSM states [V15]
                palmFacingStates: [false, false, false, false], // Hysteresis state
                lastPalmFacingTimes: [0, 0, 0, 0], // Tension/Coyote timers
                lastData: [null, null, null, null], // Per-hand coasting data
                coastStartTimes: [0, 0, 0, 0], // Per-hand coast timers
                filters: [null, null, null, null], // OneEuroFilters
                rodFilters: [null, null, null, null], // V19.2: Stabilize rod length
                anchorFilters: [null, null, null, null], // V19.2: Stabilize anchor point
                directionFilters: [null, null, null, null], // V19.2: Stabilize rod direction
                physicsState: [null, null, null, null] // Mass-Spring state
            },
            ui: {
                gestures: null,
                palm: null,
                palmCtx: null,
                fsm: null,
                fsmCtx: null,
                juiceLayers: [],
                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0 }
            },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
        };

        window.hfoTelemetry = new TelemetryRecorder();
        window.hfoPlayer = new TelemetryPlayer();

        // --- P4: VISUAL JUICE (BabylonJS Substrate) ---
        class BabylonJuiceSubstrate {
            constructor(container) {
                // V24.4: Hard Enforcement of Single-Engine Invariant
                window.hfoLifecycle.dispose('BABYLON_ENGINE');

                this.canvas = document.createElement('canvas');
                this.canvas.id = 'babylon-canvas';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '0';
                this.canvas.style.top = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.zIndex = '9';
                this.canvas.style.display = 'none'; // Hidden by default
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                const v = systemState.parameters.visuals;
                this.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(v.cameraPosition.x, v.cameraPosition.y, v.cameraPosition.z), this.scene);
                this.camera.setTarget(BABYLON.Vector3.Zero());

                this.light = new BABYLON.PointLight("light1", new BABYLON.Vector3(v.lightPosition.x, v.lightPosition.y, v.lightPosition.z), this.scene);
                this.light.intensity = v.lightIntensity;
                this.light.diffuse = new BABYLON.Color3(v.colors.bLight.r, v.colors.bLight.g, v.colors.bLight.b);

                this.emitterRoots = [];
                this.particleSystems = [];
                this.trails = []; // V24.16: Hybrid Geometric Core
                this.skeletons = []; // V24.17: Skeletal Data Fabric
                this.skeletonAlphas = []; // V24.21: Skeleton Fade Lifecycle
                this.lastPositions = [];
                this.perfMultiplier = 1.0; // V24.14: Adaptive Performance Scaling

                this.engine.runRenderLoop(() => {
                    if (this.canvas && this.canvas.style.display !== 'none') {
                        this.scene.render();

                        // V24.15: Mobile Optimization Target
                        const fps = this.engine.getFps();
                        if (fps > 0) {
                            const params = systemState.parameters;
                            const target = params.camera.fpsTarget || params.physics.oneEuroRateFallback;
                            const v = params.visuals;
                            this.perfMultiplier = this.perfMultiplier * v.perfLerpFactor + (fps / target) * (1.0 - v.perfLerpFactor);
                            this.perfMultiplier = Math.max(v.perfMin, Math.min(this.perfMultiplier, v.perfMax));
                        }
                    }
                });

                window.hfoLifecycle.register('BABYLON_ENGINE', this);
            }

            dispose() {
                if (this.engine) {
                    // Loop through all hand-specific resources
                    this.emitterRoots.forEach((root, i) => {
                        this.particleSystems[i]?.forEach(s => s.dispose());
                        this.trails[i]?.dispose();
                        this.skeletons[i]?.root.dispose();
                        root?.dispose();
                    });

                    this.engine.dispose();
                    this.engine = null;
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                console.log("[BABYLON] Engine and all associated trails/emitters disposed via Lifecycle hook.");
            }

            update(cursors) {
                const width = this.engine.getRenderWidth();
                const height = this.engine.getRenderHeight();

                const activeIndices = new Set();

                cursors.forEach((c) => {
                    const i = c.handIndex;
                    activeIndices.add(i);

                    if (!this.emitterRoots[i]) this.createEffect(i);
                    const root = this.emitterRoots[i];
                    const systems = this.particleSystems[i];
                    const trail = this.trails[i];
                    const skeleton = this.skeletons[i];

                    const isActive = (c.fsmState !== 'IDLE');
                    const isCoast = (c.fsmState === 'COAST');
                    const showSkeleton = systemState.parameters.landmarks.showSkeleton;
                    const hasLandmarks = !!(c.landmarks && c.landmarks.length > 0);

                    // V24.18: Sovereign Skeleton Visibility (IDLE, READY, COMMIT)
                    if (skeleton && hasLandmarks) {
                        // Always update positions if we have landmarks
                        c.landmarks.forEach((lm, lIndex) => {
                            const targetZ = lm.z * systemState.parameters.anatomy.skeletonDepthMultiplier;
                            const lmPos = this.projectToWorld(lm.x, lm.y, width, height, targetZ);
                            skeleton.spheres[lIndex].position.copyFrom(lmPos);
                        });

                        const showClaw = systemState.parameters.physics.showHFOClaw || false;
                        if (showClaw && isActive) {
                            const targetPos = this.projectToWorld(c.normX, c.normY, width, height, (c.normZ || 0) * systemState.parameters.anatomy.skeletonDepthMultiplier);
                            const tipPos = skeleton.spheres[8].position;
                            const clawPoints = [tipPos, targetPos];
                            skeleton.claw = BABYLON.MeshBuilder.CreateLines("claw" + i, { points: clawPoints, instance: skeleton.claw }, this.scene);
                            const isCommit = (c.fsmState === 'COMMIT');
                            const v = systemState.parameters.visuals;
                            const cCol = v.trailCommitColor;
                            const rCol = v.clawColor;
                            skeleton.claw.color = isCommit ? new BABYLON.Color3(cCol.r, cCol.g, cCol.b) : new BABYLON.Color3(rCol.r, rCol.g, rCol.b);
                        } else {
                            skeleton.claw.setEnabled(false);
                        }

                        systemState.parameters.anatomy.handSkeletonMap.forEach((conn, bIndex) => {
                            const p1 = skeleton.spheres[conn[0]].position;
                            const p2 = skeleton.spheres[conn[1]].position;
                            const bonePoints = [p1, p2];
                            skeleton.bones[bIndex] = BABYLON.MeshBuilder.CreateLines("bone" + i + "_" + bIndex, { points: bonePoints, instance: skeleton.bones[bIndex] }, this.scene);
                        });
                    }

                    if (isActive) {
                        systems.forEach(s => { if (!s.isStarted()) s.start(); });

                        // V24.17: Toggleable TrailMesh (Off by default)
                        if (trail) {
                            trail.isVisible = systemState.parameters.physics.showTrailMesh || false;
                        }

                        // Pixel to World Projection for the pointer root
                        const targetPos = this.projectToWorld(c.normX, c.normY, width, height, (c.normZ || 0) * systemState.parameters.anatomy.skeletonDepthMultiplier);

                        let motionVector = BABYLON.Vector3.Zero();
                        if (this.lastPositions[i]) {
                            motionVector = targetPos.subtract(this.lastPositions[i]);
                        }
                        this.lastPositions[i] = targetPos.clone();
                        root.position.copyFrom(targetPos);

                        // V24.10: Plasma Needle Scion (Fire Lab V3 Aesthetics)
                        const scale = systemState.parameters.physics.fireScale || 1.0;
                        const intensity = systemState.parameters.physics.fireIntensity || 1.0;

                        const v = systemState.parameters.visuals;
                        const cCol = v.trailCommitColor;
                        const rCol = v.trailReadyColor;

                        if (c.fsmState === 'COMMIT') {
                            if (trail) {
                                trail.material.emissiveColor = new BABYLON.Color3(cCol.r, cCol.g, cCol.b);
                                trail.material.alpha = v.trailCommitAlpha;
                            }
                            systems.forEach(s => {
                                s.color1 = new BABYLON.Color4(cCol.r, cCol.g, cCol.b, systemState.parameters.visuals.fire.alpha1);
                                s.color2 = new BABYLON.Color4(cCol.r * systemState.parameters.visuals.fire.colorMultiplier, cCol.g * systemState.parameters.visuals.fire.colorMultiplier, cCol.b, systemState.parameters.visuals.fire.alpha2);
                                this.tuneFireSystem(s, motionVector, scale, intensity, true);
                            });
                        } else {
                            // READY, COAST, etc.
                            const isCyan = (c.fsmState === 'COAST'); // Coast maintains visual of last state (often COMMIT)
                            if (isCyan) {
                                // COAST keeps Cyan if it was COMMIT-ing
                                if (trail) { trail.material.emissiveColor = new BABYLON.Color3(cCol.r, cCol.g, cCol.b); }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(cCol.r, cCol.g, cCol.b, systemState.parameters.visuals.fire.alpha1);
                                    s.color2 = new BABYLON.Color4(cCol.r * systemState.parameters.visuals.fire.colorMultiplier, cCol.g * systemState.parameters.visuals.fire.colorMultiplier, cCol.b, systemState.parameters.visuals.fire.alpha2);
                                });
                            } else {
                                if (trail) {
                                    trail.material.emissiveColor = new BABYLON.Color3(rCol.r, rCol.g, rCol.b);
                                    trail.material.alpha = v.trailAlpha;
                                }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(rCol.r, rCol.g, rCol.b, 0.5);
                                    s.color2 = new BABYLON.Color4(rCol.r, rCol.g * systemState.parameters.visuals.fire.colorMultiplier, 0, systemState.parameters.visuals.fire.alpha2);
                                    this.tuneFireSystem(s, motionVector, scale, intensity, false);
                                });
                            }
                        }
                    } else {
                        systems.forEach(s => s.stop());
                        if (trail) trail.isVisible = false;
                        this.lastPositions[i] = null;
                    }
                });

                // V24.21: Skeleton Lifecycle Guard (Fade & Lifecycle)
                this.skeletons.forEach((skeleton, i) => {
                    if (!skeleton) return;

                    const c = cursors.find(cur => cur.handIndex === i);
                    const isCoast = c ? (c.fsmState === 'COAST') : true;
                    const hasLandmarks = c ? (c.landmarks && c.landmarks.length > 0) : false;
                    const showSkeleton = systemState.parameters.landmarks.showSkeleton;

                    const targetAlpha = (!isCoast && showSkeleton && hasLandmarks && activeIndices.has(i)) ? 1.0 : 0.0;
                    const speed = systemState.parameters.visuals.skeletonFadeSpeed;
                    this.skeletonAlphas[i] = (this.skeletonAlphas[i] || 0) * (1.0 - speed) + targetAlpha * speed;

                    if (this.skeletonAlphas[i] < systemState.parameters.visuals.skeleton.lifecycleAlphaThreshold) {
                        skeleton.root.setEnabled(false);
                    } else {
                        skeleton.root.setEnabled(true);
                        const v = systemState.parameters.visuals;
                        if (skeleton.mat) skeleton.mat.alpha = v.skeletonAlphaSphere * this.skeletonAlphas[i];
                        if (skeleton.claw) skeleton.claw.alpha = v.skeletonAlphaClaw * this.skeletonAlphas[i];
                        skeleton.bones.forEach(b => { b.alpha = v.skeletonAlphaBone * this.skeletonAlphas[i]; });
                    }
                });

                // V24.16: Production Hardening (Prune Lost Emitters)
                // Hide or Dispose emitters for hands not present in cursors
                this.emitterRoots.forEach((root, i) => {
                    if (!activeIndices.has(i)) {
                        this.particleSystems[i]?.forEach(s => s.stop());
                        if (this.trails[i]) this.trails[i].isVisible = false;

                        // If tracking is lost entirely (no bucket level), dispose of resources
                        const bucket = systemState.p1.buckets[i] || 0;
                        if (bucket <= 0 && this.emitterRoots[i] && (this.skeletonAlphas[i] || 0) < systemState.parameters.visuals.skeleton.lifecycleAlphaThreshold) {
                            console.log(`[BABYLON] Pruning stale emitter for Hand ${i}`);
                            this.particleSystems[i]?.forEach(s => s.dispose());
                            this.trails[i]?.dispose();
                            this.skeletons[i]?.root.dispose();
                            this.emitterRoots[i]?.dispose();

                            delete this.particleSystems[i];
                            delete this.trails[i];
                            delete this.skeletons[i];
                            delete this.emitterRoots[i];
                            this.lastPositions[i] = null;
                        }
                    }
                });
            }

            projectToWorld(nx, ny, width, height, targetZ = 0) {
                const vectorNear = new BABYLON.Vector3(nx * width, ny * height, 0);
                const worldCoordNear = BABYLON.Vector3.Unproject(
                    vectorNear, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const vectorFar = new BABYLON.Vector3(nx * width, ny * height, 1);
                const worldCoordFar = BABYLON.Vector3.Unproject(
                    vectorFar, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const direction = worldCoordFar.subtract(worldCoordNear).normalize();
                if (Math.abs(direction.z) > systemState.parameters.physics.worldProjectionPrecision) {
                    const distance = (targetZ - worldCoordNear.z) / direction.z;
                    return worldCoordNear.add(direction.scale(distance));
                }
                return worldCoordNear;
            }

            tuneFireSystem(s, motionVector, scale, intensity, isHigh) {
                const speed = motionVector.length();
                const f = systemState.parameters.visuals.fire;
                const sk = systemState.parameters.visuals.skeleton;
                const densityMultiplier = 1.0 + Math.min(speed * (isHigh ? f.highSpeedMultiplier : f.lowSpeedMultiplier), isHigh ? f.highDensityMax : f.lowDensityMax);
                const baseRate = (isHigh ? f.highBaseRate : f.lowBaseRate) * scale;
                s.emitRate = baseRate * densityMultiplier * this.perfMultiplier;

                const jitter = (isHigh ? f.highJitter * (1.0 + speed) : f.lowJitter);
                s.minEmitBox = motionVector.scale(isHigh ? sk.fireMaxEmitBoxScale : sk.fireMinEmitBoxScale).add(new BABYLON.Vector3(-jitter, isHigh ? sk.fireJitterY : -jitter, -jitter));
                s.maxEmitBox = new BABYLON.Vector3(jitter, isHigh ? sk.fireBoxY : jitter, jitter);

                s.minSize = (isHigh ? f.highMinSize : f.lowMinSize) * scale;
                s.maxSize = (isHigh ? f.highMaxSize : f.lowMaxSize) * scale;
                s.minLifeTime = isHigh ? f.highMinLife : f.lowMinLife;
                s.maxLifeTime = isHigh ? f.highMaxLife : f.lowMaxLife;
                s.gravity = new BABYLON.Vector3(0, (isHigh ? f.highGravityY : f.lowGravityY) * intensity, 0);
            }

            createSkeleton(index) {
                const root = new BABYLON.TransformNode("skeleton" + index, this.scene);
                const spheres = [];
                const bones = [];
                const v = systemState.parameters.visuals;
                const sk = v.skeleton;

                const mat = new BABYLON.StandardMaterial("skeletonMat" + index, this.scene);
                mat.emissiveColor = new BABYLON.Color3(v.boneColor.r, v.boneColor.g, v.boneColor.b); // Bone White
                mat.diffuseColor = new BABYLON.Color3(v.boneColor.r, v.boneColor.g, v.boneColor.b);
                mat.alpha = v.skeletonAlphaSphere; // V24.18: Transparent Bone
                mat.disableLighting = true;

                for (let i = 0; i < sk.sphereCount; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere("tm_" + index + "_" + i, { diameter: sk.sphereDiameter }, this.scene);
                    sphere.material = mat;
                    sphere.parent = root;
                    spheres.push(sphere);
                }

                // Initial claw line
                const claw = BABYLON.MeshBuilder.CreateLines("claw" + index, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                claw.color = new BABYLON.Color3(v.clawColor.r, v.clawColor.g, v.clawColor.b); // Bright Bone Claw
                claw.parent = root;
                claw.alpha = v.skeletonAlphaClaw;

                // Wire skeleton bones
                systemState.parameters.anatomy.handSkeletonMap.forEach((_, bIndex) => {
                    const bone = BABYLON.MeshBuilder.CreateLines("bone" + index + "_" + bIndex, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                    bone.color = new BABYLON.Color3(v.boneColor.r, v.boneColor.g, v.boneColor.b);
                    bone.alpha = v.skeletonAlphaBone; // Delicate Bone Structure
                    bone.parent = root;
                    bones.push(bone);
                });

                return { root, spheres, bones, claw, mat };
            }

            createEffect(index) {
                const v = systemState.parameters.visuals;
                const p = v.particles;
                const sk = v.skeleton;
                const c = v.colors;

                const root = BABYLON.MeshBuilder.CreateSphere("emitter" + index, { diameter: sk.emitterDiameter }, this.scene);
                root.isVisible = false;
                this.emitterRoots[index] = root;

                // Initialize Skeleton
                this.skeletons[index] = this.createSkeleton(index);
                this.skeletonAlphas[index] = 0; // Start hidden

                // V24.16: Hybrid Geometric Core (Exemplar TrailMesh)
                const trail = new BABYLON.TrailMesh("trail" + index, root, this.scene, sk.trailDiameter, sk.trailLength, true);
                const trailMat = new BABYLON.StandardMaterial("trailMat" + index, this.scene);
                trailMat.emissiveColor = new BABYLON.Color3(v.trailReadyColor.r, v.trailReadyColor.g, v.trailReadyColor.b);
                trailMat.alpha = v.trailAlpha;
                trailMat.disableLighting = true;
                trail.material = trailMat;
                trail.isVisible = false;
                this.trails[index] = trail;

                const defaultTexture = v.particleTexture;

                // PHOENIX CORE EFFECT
                const fire = new BABYLON.ParticleSystem("fire", v.particleMaxCount, this.scene);
                fire.particleTexture = new BABYLON.Texture(defaultTexture, this.scene);
                fire.emitter = root;
                fire.minEmitBox = new BABYLON.Vector3(p.minEmitBox.x, p.minEmitBox.y, p.minEmitBox.z);
                fire.maxEmitBox = new BABYLON.Vector3(p.maxEmitBox.x, p.maxEmitBox.y, p.maxEmitBox.z);
                fire.color1 = new BABYLON.Color4(c.bFire1.r, c.bFire1.g, c.bFire1.b, c.bFire1.a);
                fire.color2 = new BABYLON.Color4(c.bFire2.r, c.bFire2.g, c.bFire2.b, c.bFire2.a);
                fire.colorDead = new BABYLON.Color4(c.bFireDead.r, c.bFireDead.g, c.bFireDead.b, c.bFireDead.a);
                fire.minLifeTime = p.minLifeTime; fire.maxLifeTime = p.maxLifeTime;
                fire.emitRate = v.particleEmitRate;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(p.gravity.x, p.gravity.y, p.gravity.z);
                this.particleSystems[index] = [fire];
            }

            resize() { this.engine.resize(); }
        }

        // --- P4: VISUAL JUICE (PixiJS Substrate) ---
        /**
         * üéÜ Legendary Sprite-Based Fire v4.0 (Ultra Stable)
         * Optimized for restricted WebGL environments (e.g. Chromebook/SwiftShader).
         * Replaces custom shaders with layered alpha-sprite stacks for BFT robustness.
         */
        function createGlowTexture(size, color) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const center = size / 2;
            const grad = ctx.createRadialGradient(center, center, 0, center, center, size / 2);
            const r = (color >> HFO_CONSTANTS.redShift) & HFO_CONSTANTS.byteMask;
            const g = (color >> HFO_CONSTANTS.greenShift) & HFO_CONSTANTS.byteMask;
            const b = color & HFO_CONSTANTS.byteMask;
            grad.addColorStop(cur.gradStopA, `rgba(${r},${g},${b}, 1)`);
            grad.addColorStop(cur.gradStopMid, `rgba(${r},${g},${b}, 0.5)`);
            grad.addColorStop(cur.gradStopC, `rgba(${r},${g},${b}, 0)`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
            return PIXI.Texture.from(canvas);
        }

        class JuiceEffect {
            constructor(parent) {
                this.container = new PIXI.Container();
                parent.addChild(this.container);

                const v = systemState.parameters.visuals;
                const px = v.pixi;

                // Texture Cache (Procedural/Non-Shader dependent)
                this.texGold = createGlowTexture(px.glowSizeLarge, px.colorGold);
                this.texRed = createGlowTexture(px.glowSizeLarge, px.colorRed);
                this.texCore = createGlowTexture(px.glowSizeSmall, px.colorWhite);

                // 1. READY LAYERS (Gilded Shimmer)
                this.readyLayers = new PIXI.Container();
                for (let i = 0; i < px.readyLayerCount; i++) {
                    const s = new PIXI.Sprite(this.texGold);
                    s.anchor.set(0.5);
                    s.blendMode = PIXI.BLEND_MODES.ADD;
                    this.readyLayers.addChild(s);
                }
                this.container.addChild(this.readyLayers);

                // 2. COMMIT LAYERS (Plasma Tongues)
                this.commitLayers = new PIXI.Container();
                const halfCommit = Math.floor(px.commitLayerCount / 2);
                for (let i = 0; i < px.commitLayerCount; i++) {
                    const s = new PIXI.Sprite(i < halfCommit ? this.texRed : this.texCore);
                    s.anchor.set(cur.anchorX, cur.anchorY);
                    s.blendMode = PIXI.BLEND_MODES.ADD;
                    this.commitLayers.addChild(s);
                }
                this.container.addChild(this.commitLayers);

                // 3. SPARKS (Particle Container for efficiency)
                this.sparks = new PIXI.ParticleContainer(100, { position: true, alpha: true, scale: true });
                this.container.addChild(this.sparks);

                this.timer = 0;
                this.intensity = 0;
            }

            update(x, y, state) {
                const px = systemState.parameters.visuals.pixi;
                this.timer += px.timerIncrement;
                this.container.position.set(x, y);

                const isReady = (state === 'READY' || state === 'COMMIT' || state === 'COAST');
                const isCommit = (state === 'COMMIT' || state === 'COAST');

                // Visibility Toggle (Simple & Stable)
                this.readyLayers.visible = isReady && !isCommit;
                this.commitLayers.visible = isCommit;

                if (isReady && !isCommit) {
                    this.readyLayers.children.forEach((s, i) => {
                        const phase = this.timer + i * px.readyPhaseOffset;
                        s.scale.set(px.readyPulseScaleBase + Math.sin(phase * px.readyPulseRate) * px.readyPulseScaleMagnitude);
                        s.rotation = this.timer * (px.readyRotationBase + i * px.readyRotationStep) * (i % 2 === 0 ? 1 : -1);
                        s.alpha = px.readyAlphaBase + Math.sin(phase * px.readyAlphaFreq) * px.readyAlphaMag;
                    });
                }

                if (isCommit) {
                    this.commitLayers.children.forEach((s, i) => {
                        const phase = this.timer * px.commitPhaseRate + i * px.commitPhaseStep;
                        s.x = Math.sin(phase * px.commitFreq) * (i * px.commitXStep);
                        s.scale.x = px.commitScaleXBase + Math.sin(phase) * px.commitScaleXMag;
                        s.scale.y = px.commitScaleYBase + Math.cos(phase * px.commitScaleYFreq) * px.commitScaleYMag;
                        s.alpha = (1.0 - (i / px.commitAlphaStep)) * px.commitAlphaBase;
                    });
                }

                // Spark Emission
                if (isReady && Math.random() > px.sparkProb) {
                    this.emitSpark(isCommit);
                }
                this.updateSparks();
            }

            emitSpark(isCommit) {
                const px = systemState.parameters.visuals.pixi;
                const s = new PIXI.Sprite(PIXI.Texture.WHITE);
                s.width = s.height = px.sparkSize;
                s.tint = isCommit ? HFO_CONSTANTS.byteMask4500 : HFO_CONSTANTS.byteMaskD700;
                s.anchor.set(0.5);
                s.vx = (Math.random() - 0.5) * px.sparkVxMag;
                s.vy = px.sparkVyBase - Math.random() * px.sparkVyMag;
                s.life = 1.0;
                s.decay = px.sparkDecayBase + Math.random() * px.sparkDecayMag;
                this.sparks.addChild(s);
            }

            updateSparks() {
                const px = systemState.parameters.visuals.pixi;
                for (let i = this.sparks.children.length - 1; i >= 0; i--) {
                    const s = this.sparks.children[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += px.sparkGravity;
                    s.life -= s.decay;
                    s.alpha = s.life;
                    s.scale.set(s.life);
                    if (s.life <= 0) this.sparks.removeChild(s);
                }
            }
        }

        class JuiceSubstrate {
            constructor(container) {
                // V24.4: Hard Enforcement of Single-Engine Invariant
                window.hfoLifecycle.dispose('PIXI_ENGINE');

                this.app = new PIXI.Application({
                    resizeTo: container,
                    backgroundAlpha: 0,
                    antialias: true
                });
                container.appendChild(this.app.view);
                this.effects = [];

                window.hfoLifecycle.register('PIXI_ENGINE', this);
            }

            dispose() {
                if (this.app) {
                    this.app.destroy(true, { children: true, texture: true, baseTexture: true });
                    this.app = null;
                }
                console.log("[PIXI] Application disposed via Lifecycle hook.");
            }

            update(cursors) {
                // V19.2: Correct PixiJS relative coordinates for Golden Layout
                const { width, height } = this.app.renderer;

                const activeIndices = new Set();

                // Ensure we have an effect for each potential cursor
                cursors.forEach((c) => {
                    const i = c.handIndex;
                    activeIndices.add(i);

                    if (!this.effects[i]) {
                        this.effects[i] = new JuiceEffect(this.app.stage);
                    }
                    this.effects[i].container.visible = true;

                    const px = c.normX * width;
                    const py = c.normY * height;
                    this.effects[i].update(px, py, c.fsmState);
                });

                // Hide unused effects
                this.effects.forEach((eff, i) => {
                    if (eff && !activeIndices.has(i)) {
                        eff.container.visible = false;
                    }
                });
            }

            resize(width, height) {
                this.app.renderer.resize(width, height);
            }
        }

        window.hfoState = systemState;

        // --- P2: AGNOSTIC PHYSICS MANIFOLD ---
        /**
         * IPhysicsAdapter: Interface for vendor-agnostic physics steering.
         * Decouples the FSM and Pointer logic from specific engines (Planck, Matter, Rapier).
         */
        class IPhysicsAdapter {
            update(targetX, targetY, dt) { throw new Error("Not implemented"); }
            setParams(params) { throw new Error("Not implemented"); }
            reset(x, y) { throw new Error("Not implemented"); }
            setBallistic(enabled) { throw new Error("Not implemented"); }
            getTelemetry() { return {}; }
        }

        /**
         * PlanckPhysicsAdapter: High-fidelity deterministic Box2D (Planck.js) implementation.
         * Uses MKS scaling (1 meter = 100 pixels) for numerical stability.
         */
        class PlanckPhysicsAdapter extends IPhysicsAdapter {
            constructor(stiffness, damping, scale) {
                super();
                const p = systemState.parameters.physics;
                this.SCALE = scale || p.scalePxToM; // Scalable Physics [V24.21]
                this.world = planck.World({ gravity: planck.Vec2(0, 0) });
                this.stiffness = (stiffness !== undefined) ? stiffness : p.planckDefaultStiffness;
                this.damping = (damping !== undefined) ? damping : p.planckDefaultDamping;
                this.isBallistic = false;

                // Cursor Body (Dynamic)
                this.cursor = this.world.createBody({
                    type: 'dynamic',
                    position: planck.Vec2(0, 0),
                    linearDamping: p.planckLinearDamping,
                    angularDamping: p.planckAngularDamping
                });
                this.cursor.createFixture(planck.Circle(p.planckFixtureRadius), { density: p.planckFixtureDensity, friction: p.planckFixtureFriction });

                // Target Body (Kinematic)
                this.target = this.world.createBody({ type: 'kinematic', position: planck.Vec2(0, 0) });

                // Constant Distance Joint (Rod) or Spring (DistanceJoint with frequency)
                this.joint = this.world.createJoint(planck.DistanceJoint({
                    bodyA: this.target,
                    bodyB: this.cursor,
                    anchorA: planck.Vec2(0, 0),
                    anchorB: planck.Vec2(0, 0),
                    frequencyHz: this.stiffness, // Stiffness as frequency
                    dampingRatio: this.damping,    // Damping
                    length: 0
                }));

                this.lastPos = { x: 0, y: 0 };
            }

            setBallistic(enabled) {
                this.isBallistic = enabled;
                if (enabled) {
                    this.joint.setFrequency(0); // Effectively detach
                } else {
                    this.joint.setFrequency(this.stiffness);
                }
            }

            update(targetX, targetY, dt) {
                if (!this.isBallistic) {
                    const tx = targetX / this.SCALE;
                    const ty = targetY / this.SCALE;
                    this.target.setPosition(planck.Vec2(tx, ty));
                }

                // Step world
                this.world.step(Math.min(dt / HFO_CONSTANTS.msPerSec, systemState.parameters.physics.planckMaxStepDt));

                const pos = this.cursor.getPosition();
                this.lastPos = { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
                return this.lastPos;
            }

            setParams(params) {
                const phys = systemState.parameters.physics;
                this.stiffness = params.stiffness || phys.planckDefaultStiffness;
                this.damping = params.dampingRatio || phys.planckDefaultDamping;
                if (!this.isBallistic) {
                    this.joint.setFrequency(this.stiffness);
                }
                this.joint.setDampingRatio(this.damping);
            }

            reset(x, y) {
                const px = x / this.SCALE;
                const py = y / this.SCALE;
                this.cursor.setPosition(planck.Vec2(px, py));
                this.target.setPosition(planck.Vec2(px, py));
                this.cursor.setLinearVelocity(planck.Vec2(0, 0));
            }

            getTelemetry() {
                const vel = this.cursor.getLinearVelocity();
                return {
                    velocity: { x: vel.x * this.SCALE, y: vel.y * this.SCALE },
                    speed: vel.length() * this.SCALE,
                    position: { ...this.lastPos }
                };
            }
        }

        // --- COORDINATE SUBSTRATE: 1EURO ---
        class OneEuroFilter {
            constructor(minCutoff, beta) {
                const p = systemState.parameters.physics;
                this.minCutoff = (minCutoff !== undefined) ? minCutoff : p.oneEuroDefaultMinCutoff;
                this.beta = (beta !== undefined) ? beta : p.oneEuroDefaultBeta;
                this.xPrev = null;
                this.dxPrev = 0;
            }

            filter(x, rate) {
                const p = systemState.parameters.physics;
                const r = rate || p.oneEuroRateFallback;
                if (this.xPrev === null) {
                    this.xPrev = x;
                    return x;
                }
                const dx = (x - this.xPrev) * r;
                const edx = this.alpha(r, p.oneEuroDerivCutoff); // Simple smoothing for derivative
                const dxHat = edx * dx + (1 - edx) * this.dxPrev;
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(r, cutoff);
                const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat;
                this.dxPrev = dxHat;
                return xHat;
            }

            alpha(rate, cutoff) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                const te = 1.0 / rate;
                return 1.0 / (1.0 + tau / te);
            }
        }

        class MassSpringDampener {
            constructor(stiffness, damping) {
                const p = systemState.parameters.physics;
                this.pos = null;
                this.vel = { x: 0, y: 0 };
                this.stiffness = (stiffness !== undefined) ? stiffness : p.massSpringDefaultStiffness;
                this.damping = (damping !== undefined) ? damping : p.massSpringDefaultDamping;
            }

            update(targetX, targetY) {
                if (this.pos === null) {
                    this.pos = { x: targetX, y: targetY };
                    return this.pos;
                }
                const forceX = (targetX - this.pos.x) * this.stiffness;
                const forceY = (targetY - this.pos.y) * this.stiffness;

                this.vel.x = this.vel.x * (1 - this.damping) + forceX;
                this.vel.y = this.vel.y * (1 - this.damping) + forceY;

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                return this.pos;
            }
        }

        // --- P1 BRIDGER: CONTRACT ENFORCEMENT ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                const eps = systemState.parameters.anatomy.mathEpsilon;
                const zScale = systemState.parameters.anatomy.landmarkZScale;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]];
                    const b = landmarks[indices[i + 1]];
                    const c = landmarks[indices[i + 2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * zScale };
                    const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * zScale };
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || eps;
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || eps;
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static validateConfig(config) {
                try {
                    return ConfigSchema.parse(config);
                } catch (e) {
                    console.error("üö® P1_CONFIG_CONTRACT_BREACH:", e.errors);
                    return null;
                }
            }

            static fuse(results, dt) {
                const cursors = [];
                const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;

                for (let i = 0; i < numHands; i++) {
                    const landmarks = results.landmarks?.[i];
                    const bestGesture = results.gestures?.[i]?.[0];
                    let cursorData = null;

                    if (landmarks) {
                        try {
                            const validatedLandmarks = landmarks.map(l => LandmarkSchema.parse(l));
                            const { width, height } = systemState.p0.videoBounds || { width: 0, height: 0 };
                            const lm = validatedLandmarks;
                            const idx = systemState.parameters.anatomy.indices;
                            const eps = systemState.parameters.anatomy.mathEpsilon;

                            // V20.3: ANATOMICAL STABILITY (Hardened Rod)
                            const p5 = lm[idx.INDEX_MCP];
                            const p17 = lm[idx.PINKY_MCP];
                            const p0_palm = lm[idx.WRIST];

                            // Observed 3D Palm Span (Index MCP to Pinky MCP) - Absolute Measure
                            const observedPalmSpan = Math.sqrt(
                                (p5.x - p17.x) ** 2 +
                                (p5.y - p17.y) ** 2 +
                                (p5.z - p17.z) ** 2
                            ) || eps;

                            // V20.3: Calculate Palm Orientation / normalZ Early for stabilization
                            const v1_palm = { x: p5.x - p0_palm.x, y: p5.y - p0_palm.y, z: p5.z - p0_palm.z };
                            const v2_palm = { x: p17.x - p0_palm.x, y: p17.y - p0_palm.y, z: p17.z - p0_palm.z };
                            const cross_palm = {
                                x: (v1_palm.y * v2_palm.z - v1_palm.z * v2_palm.y) || 0,
                                y: (v1_palm.z * v2_palm.x - v1_palm.x * v2_palm.z) || 0,
                                z: (v1_palm.x * v2_palm.y - v1_palm.y * v2_palm.x) || 1
                            };
                            const mag_palm = Math.sqrt(cross_palm.x ** 2 + cross_palm.y ** 2 + cross_palm.z ** 2) || 1;
                            const nz = Math.abs(cross_palm.z / mag_palm);
                            const normalZ = nz;
                            const palmConeAngle = Math.acos(Math.min(1.0, normalZ));

                            // V20.3: Harden Rod length with Palm Cone Angle damping to stop longitudinal bouncing
                            if (!systemState.p1.rodFilters[i]) {
                                systemState.p1.rodFilters[i] = new OneEuroFilter(systemState.parameters.physics.oneEuroRodMinCutoff, systemState.parameters.physics.oneEuroBeta);
                            }
                            // Adaptive cutoff: smoother if tilting away (noisy Z)
                            systemState.p1.rodFilters[i].minCutoff = normalZ > systemState.parameters.physics.normalZThreshold ?
                                systemState.parameters.physics.oneEuroRodMinCutoff :
                                systemState.parameters.physics.oneEuroRodMinCutoff * systemState.parameters.physics.normalZMultiplier;

                            let baseRodLength;
                            const theme = systemState.parameters.physics.cursorTheme;
                            if (theme === 'LI') {
                                // V20.6: User Tunable Fixed Standoff for Fire (Li) stability
                                baseRodLength = systemState.parameters.physics.directProjectionOffset;
                            } else {
                                baseRodLength = observedPalmSpan * systemState.parameters.anatomy.rodExtensionMultiplier;
                            }
                            const rodLength = systemState.p1.rodFilters[i].filter(baseRodLength);

                            // V19.1: Anchor at Index Tip (8), Project further based on Palm Span
                            const mcp = lm[idx.INDEX_MCP];
                            const tipRaw = lm[idx.INDEX_TIP];
                            const dx_dir = tipRaw.x - mcp.x;
                            const dy_dir = tipRaw.y - mcp.y;
                            const dz_dir = tipRaw.z - mcp.z;
                            const mag_dir = Math.sqrt(dx_dir ** 2 + dy_dir ** 2 + dz_dir ** 2) || eps;

                            // Projected point starts at Tip (8) and extends rodLength
                            const projectedPoint = {
                                x: tipRaw.x + (dx_dir / mag_dir) * rodLength,
                                y: tipRaw.y + (dy_dir / mag_dir) * rodLength,
                                z: tipRaw.z + (dz_dir / mag_dir) * rodLength
                            };

                            // V19.4: MIRROR AWARENESS (Global Port 1 Flip)
                            const isMirror = systemState.parameters.camera.mirror;

                            // V24.17 Fix: Mirror individual landmarks for shared data fabric parity
                            const mirroredLandmarks = lm.map(l => ({
                                x: isMirror ? (1.0 - l.x) : l.x,
                                y: l.y,
                                z: l.z
                            }));

                            const finalProjX = isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x;
                            const finalTipX = isMirror ? (1.0 - tipRaw.x) : tipRaw.x;

                            const screenX = finalProjX * width;
                            const screenY = projectedPoint.y * height;

                            // V24.17 Fix: Also mirror the raw anchor point and projected point in 3D
                            const mirroredProjected3D = {
                                x: isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x,
                                y: projectedPoint.y,
                                z: projectedPoint.z
                            };

                            // V19.2: Apply Smoothing to Anchor Point (Tip) to stop jitter
                            if (!systemState.p1.anchorFilters[i]) {
                                systemState.p1.anchorFilters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const anchorX = systemState.p1.anchorFilters[i].x.filter(finalTipX * width);
                            const anchorY = systemState.p1.anchorFilters[i].y.filter(tipRaw.y * height);

                            // Palm Orientation (Calculated bridger_nx, bridger_ny for telemetry/mirroring)
                            let bridger_nx = cross_palm.x / mag_palm;
                            let bridger_ny = cross_palm.y / mag_palm;

                            // V19.5: Mirror the normal X-component to match mirrored coordinate space
                            if (isMirror) {
                                bridger_nx = -bridger_nx;
                            }

                            // Palm Facing Hysteresis (80 Enter, 64 Exit)
                            let isPalmFacing = systemState.p1.palmFacingStates[i];
                            if (!isPalmFacing) {
                                if (normalZ > systemState.parameters.palm.enterThreshold) isPalmFacing = true;
                            } else {
                                if (normalZ < systemState.parameters.palm.exitThreshold) isPalmFacing = false;
                            }
                            systemState.p1.palmFacingStates[i] = isPalmFacing;

                            const category = bestGesture?.categoryName || 'None';
                            const confidence = bestGesture?.score || 0;

                            // Apply 1EuroFilter (Always applied for landmark jitter)
                            if (!systemState.p1.filters[i]) {
                                systemState.p1.filters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const smoothedX = systemState.p1.filters[i].x.filter(screenX);
                            const smoothedY = systemState.p1.filters[i].y.filter(screenY);

                            // V24.3: TRIPLE FLOW FSM
                            const fsmState = systemState.p1.fsmStates[i];
                            const isPointing = (category === 'Pointing_Up' && confidence > systemState.parameters.gestures.minGestureConfidence);
                            const hasConfidence = (confidence > systemState.parameters.coasting.confidenceThreshold);

                            if (isPalmFacing) systemState.p1.lastPalmFacingTimes[i] = now;
                            const isCharging = isPalmFacing || (now - systemState.p1.lastPalmFacingTimes[i] < systemState.parameters.fsm.tensionMs);
                            const isCoasting = (fsmState === 'COAST');
                            const maxBucket = systemState.parameters.fsm.maxBucketLevel;

                            if (isCharging) {
                                const fillAmount = (maxBucket / systemState.parameters.fsm.chargeTimeMs) * dt;
                                systemState.p1.buckets[i] = Math.min(maxBucket, systemState.p1.buckets[i] + fillAmount);
                            } else {
                                const drainTime = isCoasting ? systemState.parameters.fsm.coastDrainTimeMs : systemState.parameters.fsm.releaseTimeMs;
                                const drainAmount = (maxBucket / drainTime) * dt;
                                systemState.p1.buckets[i] = Math.max(0, systemState.p1.buckets[i] - drainAmount);
                            }

                            let fsmStateNew = fsmState;
                            const bucket = systemState.p1.buckets[i];
                            const primary = systemState.fsm.primaryHandIndex;
                            const isSeatAvailable = (primary === null || primary === i);

                            if (fsmState === 'IDLE') {
                                if (bucket >= systemState.parameters.fsm.hysteresisHigh) fsmStateNew = 'READY';
                            } else if (fsmState === 'READY') {
                                if (bucket <= systemState.parameters.fsm.hysteresisLow) fsmStateNew = 'IDLE';
                                else if (!hasConfidence) fsmStateNew = 'COAST';
                                else if (isPointing && isPalmFacing && isSeatAvailable) {
                                    fsmStateNew = 'COMMIT';
                                    systemState.fsm.primaryHandIndex = i;
                                }
                            } else if (fsmState === 'COMMIT') {
                                if (bucket <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (!hasConfidence) fsmStateNew = 'COAST';
                            } else if (fsmState === 'COAST') {
                                if (bucket <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (hasConfidence && isPalmFacing) {
                                    fsmStateNew = isPointing ? 'COMMIT' : 'READY';
                                }
                            }
                            systemState.p1.fsmStates[i] = fsmStateNew;

                            let finalX, finalY;
                            const forceDirect = systemState.parameters.physics.useDirectProjection;

                            if (systemState.parameters.physics.mode === 'STATIC_ROD' || forceDirect) {
                                finalX = smoothedX;
                                finalY = smoothedY;
                            } else {
                                // PLANCK_SPRING Mode
                                if (isFlagEnabled('physics-planck') && !(systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter)) {
                                    systemState.p1.physicsState[i] = new PlanckPhysicsAdapter(
                                        systemState.parameters.physics.planckStiffness,
                                        systemState.parameters.physics.planckDamping,
                                        systemState.parameters.physics.scalePxToM
                                    );
                                    systemState.p1.physicsState[i].reset(smoothedX, smoothedY);
                                }

                                let physicsPos = { x: smoothedX, y: smoothedY };
                                if (systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter) {
                                    systemState.p1.physicsState[i].setBallistic(fsmStateNew === 'COAST');
                                    systemState.p1.physicsState[i].setParams({
                                        stiffness: systemState.parameters.physics.planckStiffness,
                                        dampingRatio: systemState.parameters.physics.planckDamping
                                    });
                                    physicsPos = systemState.p1.physicsState[i].update(smoothedX, smoothedY, dt);
                                }

                                // V19.2: CLAW RIGID PROJECTION
                                const dx = smoothedX - anchorX;
                                const dy = smoothedY - anchorY;
                                const mag = Math.sqrt(dx * dx + dy * dy) || systemState.parameters.anatomy.mathEpsilon;
                                let ux = dx / mag;
                                let uy = dy / mag;

                                if (!systemState.p1.directionFilters[i]) {
                                    systemState.p1.directionFilters[i] = {
                                        x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                        y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                    };
                                }
                                ux = systemState.p1.directionFilters[i].x.filter(ux);
                                uy = systemState.p1.directionFilters[i].y.filter(uy);
                                const mag_filtered = Math.sqrt(ux * ux + uy * uy) || systemState.parameters.anatomy.mathEpsilon;
                                ux /= mag_filtered; uy /= mag_filtered;

                                const vx = physicsPos.x - anchorX;
                                const vy = physicsPos.y - anchorY;
                                const d_proj = vx * ux + vy * uy;

                                finalX = anchorX + ux * d_proj;
                                finalY = anchorY + uy * d_proj;
                            }

                            const cG = systemState.parameters.anatomy.curlGroups;
                            const curls = {
                                index: this.calculateCurl(lm, cG.index),
                                middle: this.calculateCurl(lm, cG.middle),
                                ring: this.calculateCurl(lm, cG.ring),
                                pinky: this.calculateCurl(lm, cG.pinky)
                            };

                            const rawCursorData = {
                                screenX: finalX, screenY: finalY,
                                normX: finalX / width, normY: finalY / height,
                                normZ: projectedPoint.z,
                                fsmState: fsmStateNew, gesture: category,
                                confidence, isPalmFacing, bucketLevel: bucket,
                                handIndex: i, pointerId: systemState.parameters.fsm.pointerIdOffset + i, // V24.4: Stable Hand ID
                                curls,
                                landmarks: mirroredLandmarks, // Fixed: Mirrored landmarks
                                rawX: anchorX, rawY: anchorY,
                                normalZ: normalZ,
                                palmConeAngle: palmConeAngle,
                                palmNormal: { x: bridger_nx, y: bridger_ny, z: nz },
                                timestamp: now
                            };

                            cursorData = FusionSchema.parse(rawCursorData);
                            systemState.p1.lastData[i] = cursorData;
                        } catch (e) {
                            console.error("üö® P1_FUSE_CONTRACT_BREACH:", e);
                        }
                    } else {
                        // Coasting Logic for missing landmarks (V24.3: Ballistic Inertia)
                        const last = systemState.p1.lastData[i];
                        const fsmState = systemState.p1.fsmStates[i];

                        if (last && fsmState !== 'IDLE') {
                            const isCoasting = (fsmState === 'COAST' || fsmState === 'COMMIT');
                            const drainTime = isCoasting ? systemState.parameters.fsm.coastDrainTimeMs : systemState.parameters.fsm.releaseTimeMs;
                            const drainAmount = (100 / drainTime) * dt;
                            systemState.p1.buckets[i] = Math.max(0, systemState.p1.buckets[i] - drainAmount);

                            const bucket = systemState.p1.buckets[i];
                            if (bucket > systemState.parameters.fsm.hysteresisLow) {
                                // Update Physics in Ballistic mode to get inertial position
                                let coastPos = { x: last.screenX, y: last.screenY };
                                const adapter = systemState.p1.physicsState[i];
                                if (adapter instanceof PlanckPhysicsAdapter) {
                                    adapter.setBallistic(true);
                                    coastPos = adapter.update(last.screenX, last.screenY, dt);
                                }

                                cursorData = FusionSchema.parse({
                                    ...last,
                                    screenX: coastPos.x,
                                    screenY: coastPos.y,
                                    fsmState: 'COAST',
                                    bucketLevel: bucket,
                                    handIndex: i,
                                    landmarks: [], // V24.18: Clear landmarks during COAST to hide skeleton
                                    timestamp: now
                                });
                                systemState.p1.fsmStates[i] = 'COAST';
                            } else {
                                // Terminal Drain reached
                                systemState.p1.lastData[i] = null;
                                systemState.p1.fsmStates[i] = 'IDLE';
                                if (systemState.fsm.primaryHandIndex === i) systemState.fsm.primaryHandIndex = null;
                            }
                        }
                    }

                    if (cursorData) {
                        const validated = FusionSchema.parse({ ...cursorData, timestamp: now });
                        cursors.push(validated);
                    }
                }

                // V24.7: MULTI-READY / SINGLE-COMMIT (HOT SEAT V2)
                // Return ALL active cursors for visual feedback.
                const primary = systemState.fsm.primaryHandIndex;
                const primaryHand = cursors.find(c => c.handIndex === primary);

                if (primaryHand) {
                    systemState.fsm.currentState = primaryHand.fsmState;
                } else if (cursors.length > 0) {
                    const states = cursors.map(c => c.fsmState);
                    if (states.includes('COMMIT')) systemState.fsm.currentState = 'COMMIT';
                    else if (states.includes('COAST')) systemState.fsm.currentState = 'COAST';
                    else if (states.includes('READY')) systemState.fsm.currentState = 'READY';
                    else systemState.fsm.currentState = 'IDLE';
                } else {
                    systemState.fsm.currentState = 'IDLE';
                }

                // üåê UPDATE DATA FABRIC
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });

                return cursors;
            }
        }

        // Expose to window for hardened testing [V24.3]
        window.systemState = systemState;
        window.PlanckPhysicsAdapter = PlanckPhysicsAdapter;
        window.P1Bridger = P1Bridger;
        window.drawResults = drawResults;

        // --- P0: SENSE ---
        async function initP0() {
            logMission("P0: Initializing V7 Laser Cluster...");
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: 'GPU'
                },
                runningMode: "VIDEO",
                numHands: systemState.parameters.landmarks.numHands
            });
            logMission("‚úÖ P0: Sensing Cluster Online");
        }

        let lastFrameTime = performance.now();
        function predictLoop() {
            if (!systemState.parameters.p0Active) return;
            const now = performance.now();
            const dt = now - lastFrameTime;
            lastFrameTime = now;

            // V24.6: Telemetry Replay Logic (Golden Master)
            if (window.hfoPlayer.isPlaying) {
                const frame = window.hfoPlayer.getNextFrame();
                if (frame && frame.phase === 'P1_FUSE') {
                    systemState.dataFabric = DataFabricSchema.parse(frame.data);
                    systemState.p1.cursors = systemState.dataFabric.cursors;
                    // Skip remaining sensing/fusion
                    requestAnimationFrame(predictLoop);
                    return;
                }
            }

            // üíâ P4: INJECTION HOOK (For E2E/Stress Testing)
            let results;
            if (window.hfoMockResults) {
                results = window.hfoMockResults;
            } else {
                results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
            }

            // P1 BRIDGE: Fusing sensing to coordinates under contract
            const cursors = P1Bridger.fuse(results, dt);

            // V19.4: VALIDATED SHARED DATA FABRIC ENFORCEMENT
            try {
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });
                // Maintain legacy pointer for back-compat with existing FSM logic
                systemState.p1.cursors = systemState.dataFabric.cursors;

                // V24.5 Telemetry Recording
                window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
            } catch (e) {
                console.error("PORT 1 CONTRACT BREACH:", e);
                // Fail-safe to last known good or empty
            }

            // üìä P5: State Transparency (For E2E Testing)
            window.hfoState = {
                hands: systemState.dataFabric.cursors,
                parameters: systemState.parameters,
                fsm: systemState.fsm,
                lineage: 'SHARED_DATA_FABRIC_V19.5'
            };

            // V19.5: Unified Draw Call (Only skeleton receives raw results for ISR overlay)
            // V24.10: Substrate Gating (Prevent visual muddiness when Babylon is active)
            if (isFlagEnabled('engine-canvas')) {
                drawResults(results, systemState.dataFabric);
            }

            if (isFlagEnabled('ui-lil-gui')) {
                updateVisualPanels(results);
            }

            if (isFlagEnabled('p3-injector')) {
                w3cPointerNematocystInjector(); // V20.1: Rebranded Hydra Port
            }

            // HYBRID ENGINE SWITCHING (Gated by OpenFeature)
            const engine = systemState.parameters.visuals.engine;
            systemState.ui.juiceLayers.forEach(layer => {
                if (engine === 'PIXI' && layer instanceof JuiceSubstrate) {
                    layer.app.view.style.display = 'block';
                    layer.update(systemState.dataFabric.cursors);
                } else if (engine === 'PIXI' && layer instanceof BabylonJuiceSubstrate) {
                    layer.canvas.style.display = 'none';
                } else if (engine === 'BABYLON' && layer instanceof BabylonJuiceSubstrate) {
                    layer.canvas.style.display = 'block';
                    layer.update(systemState.dataFabric.cursors);
                } else if (engine === 'BABYLON' && layer instanceof JuiceSubstrate) {
                    layer.app.view.style.display = 'none';
                }
            });

            requestAnimationFrame(predictLoop);
        }

        /**
         * ÔøΩ W3C POINTER INJECTOR (Hybrid Strategy Adapter - V27)
         * Implements industry-standard event chains for UI Interaction.
         */
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            const video = systemState.p0.video;
            if (!video) return;

            const videoWidth = video.videoWidth || parseInt(systemState.parameters.camera.resolution.split('x')[0]) || systemState.parameters.camera.resolutionWidth;
            const videoHeight = video.videoHeight || parseInt(systemState.parameters.camera.resolution.split('x')[1]) || systemState.parameters.camera.resolutionHeight;
            const rect = video.getBoundingClientRect();
            const rectWidth = rect.width || videoWidth;
            const rectHeight = rect.height || videoHeight;
            const rectLeft = rect.left || 0;
            const rectTop = rect.top || 0;

            const currentIds = new Set();

            cursors.forEach(cursor => {
                const pid = cursor.pointerId;

                // V24.7: Hot Seat V2 Interaction Gating
                // Ensures only ONE hand can interact with the system at a time.
                // READY hands provide multiple visual fireballs, but only the primary hand injects events.
                const isPrimary = (systemState.fsm.primaryHandIndex === cursor.handIndex);
                let pState = systemState.fsm.activePointers[pid];

                // If not primary, only allow processing if it was previously active (to cleanup)
                if (!isPrimary && (!pState || !pState.wasDown)) return;

                currentIds.add(pid);

                const nx = cursor.screenX / (systemState.p0.videoBounds?.width || videoWidth);
                const ny = cursor.screenY / (systemState.p0.videoBounds?.height || videoHeight);

                // V24.20: Interaction Parity Fix
                // Use the centered visual bounds instead of raw container rect
                const bounds = systemState.ui.viewBounds || { width: rectWidth, height: rectHeight, offsetX: 0, offsetY: 0 };
                const viewX = rectLeft + bounds.offsetX + (nx * bounds.width);
                const viewY = rectTop + bounds.offsetY + (ny * bounds.height);

                const isDown = (cursor.fsmState === 'COMMIT' || cursor.fsmState === 'COAST');
                const pressure = isDown ? (cursor.fsmState === 'COMMIT' ? 1.0 : 0.5) : 0.0;

                if (!pState) {
                    systemState.fsm.activePointers[pid] = { lastTarget: null, lock: null, wasDown: false };
                    pState = systemState.fsm.activePointers[pid];
                }

                let target = pState.lock;
                let finalX = viewX;
                let finalY = viewY;

                if (!target) {
                    let probe = document.elementFromPoint(viewX, viewY) || document.body;
                    if (probe && probe.tagName === 'IFRAME') {
                        try {
                            const iframeRect = probe.getBoundingClientRect();
                            const subX = viewX - iframeRect.left;
                            const subY = viewY - iframeRect.top;
                            const inner = probe.contentDocument.elementFromPoint(subX, subY);
                            if (inner) {
                                probe = inner;
                                finalX = subX;
                                finalY = subY;
                            }
                        } catch (e) { }
                    }
                    target = probe;
                } else {
                    if (target.ownerDocument !== document) {
                        const iframe = Array.from(document.querySelectorAll('iframe')).find(f => f.contentDocument === target.ownerDocument);
                        if (iframe) {
                            const r = iframe.getBoundingClientRect();
                            finalX = viewX - r.left;
                            finalY = viewY - r.top;
                        }
                    }
                }

                const eventInit = {
                    bubbles: true, cancelable: true, pointerId: pid, pointerType: 'mouse',
                    clientX: finalX, clientY: finalY, screenX: viewX, screenY: viewY,
                    pressure: pressure, buttons: isDown ? 1 : 0, button: isDown ? 0 : -1,
                    width: 1, height: 1, isPrimary: pid === 10
                };

                if (target !== pState.lastTarget) {
                    if (pState.lastTarget) {
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerout', eventInit));
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerleave', eventInit));
                    }
                    if (target) {
                        dispatchToHydraHydrant(target, new PointerEvent('pointerover', eventInit));
                        dispatchToHydraHydrant(target, new PointerEvent('pointerenter', eventInit));
                    }
                    pState.lastTarget = target;
                }

                if (isDown && !pState.wasDown) {
                    pState.lock = target;
                    if (target.setPointerCapture) try { target.setPointerCapture(pid); } catch (e) { }
                    dispatchToHydraHydrant(target, new PointerEvent('pointerdown', eventInit), true);
                }

                dispatchToHydraHydrant(target, new PointerEvent('pointermove', eventInit));

                if (!isDown && pState.wasDown) {
                    dispatchToHydraHydrant(target, new PointerEvent('pointerup', { ...eventInit, pressure: 0.0, buttons: 0, button: 0 }));
                    if (target.releasePointerCapture) try { target.releasePointerCapture(pid); } catch (e) { }
                    pState.lock = null;
                }

                pState.wasDown = isDown;
            });

            // V24.4: Real pointercancel path for lost tracking
            Object.keys(systemState.fsm.activePointers).forEach(pidStr => {
                const pid = parseInt(pidStr);
                if (!currentIds.has(pid)) {
                    const pState = systemState.fsm.activePointers[pid];
                    if (pState.wasDown && pState.lock) {
                        dispatchToHydraHydrant(pState.lock, new PointerEvent('pointercancel', {
                            pointerId: pid, bubbles: true, pointerType: 'mouse'
                        }));
                        if (pState.lock.releasePointerCapture) try { pState.lock.releasePointerCapture(pid); } catch (e) { }
                        if (systemState.parameters.devMode) console.log(`[P3] Handled pointer-loss cancel for id: ${pid}`);
                    }
                    delete systemState.fsm.activePointers[pid];
                }
            });
        }

        /**
         * üî± HYDRA HYDRANT: Payload Delivery Mechanism (Formalized V20.8 Pulse Strategy)
         * Optimized for React/Excalidraw and universal target discovery.
         * @param {Boolean} isPulse - If true, triggers immediate click sequence.
         */
        function dispatchToHydraHydrant(t, e, isPulse = false) {
            if (!t) return;

            // V28: Target Normalization (Find nearest interactive ancestor if child hit)
            const findControl = (el) => {
                let curr = el;
                // Traverse up to 5 levels or until a known interactive tag/role is found
                for (let i = 0; i < systemState.parameters.interaction.domDepthLimit && curr && curr !== document.body; i++) {
                    const tag = curr.tagName ? curr.tagName.toLowerCase() : '';
                    const role = curr.getAttribute ? curr.getAttribute('role') : null;
                    if (tag === 'button' || tag === 'a' || tag === 'input' || tag === 'select' ||
                        role === 'button' || role === 'link' || role === 'checkbox' ||
                        curr.classList?.contains('ToolIcon') || curr.onclick) {
                        return curr;
                    }
                    curr = curr.parentElement;
                }
                return el;
            };

            const control = findControl(t);
            t.dispatchEvent(e);

            // Legacy Mouse Simulation & V20.8 Pulse Sequence
            if (e.type === 'pointerdown' || e.type === 'pointerup') {
                const mouseType = e.type === 'pointerdown' ? 'mousedown' : 'mouseup';
                const mouseEv = new MouseEvent(mouseType, {
                    bubbles: true,
                    cancelable: true,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    buttons: e.buttons,
                    button: 0,
                    view: t.ownerDocument.defaultView || window
                });
                t.dispatchEvent(mouseEv);

                // Focus Priming on Down
                if (e.type === 'pointerdown') {
                    if (control.focus) control.focus();
                }

                // V20.8 "Pulse Trigger": Force click on DOWN if pulse is active
                if (isPulse && e.type === 'pointerdown') {
                    // 10ms settle buffer for React to finalize hover/focus state
                    setTimeout(() => {
                        if (control.click) {
                            control.click();
                        } else {
                            const clickEv = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                clientX: e.clientX,
                                clientY: e.clientY,
                                view: t.ownerDocument.defaultView || window
                            });
                            control.dispatchEvent(clickEv);
                        }
                        if (systemState.parameters.devMode) console.log(`[P3] PULSE CLICK triggered on ${control.tagName}`);
                    }, systemState.parameters.interaction.pulseSettleMs);
                }

                // Legacy Release Click (Fallback/Safety)
                if (e.type === 'pointerup' && !isPulse) {
                    setTimeout(() => {
                        if (control.click) control.click();
                    }, systemState.parameters.interaction.pulseSettleMs);
                }
            }
        }

        // --- SPARKLINE HELPER ---
        function drawSparkline(ctx, x, y, w, h, data, color, markers = []) {
            const pixi = systemState.parameters.visuals.pixi;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            const step = w / pixi.sparklineSteps;
            data.forEach((val, i) => {
                const px = x + i * step;
                const py = y + h - (val * h);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Draw Markers
            markers.forEach(m => {
                const my = y + h - (m.val * h);
                ctx.strokeStyle = m.color;
                ctx.setLineDash([2, 1]);
                ctx.beginPath(); ctx.moveTo(x, my); ctx.lineTo(x + w, my); ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        // --- üå† ELEMENTAL JUICE HELPERS ---
        function drawFireball(ctx, x, y, size, intensity, state) {
            const time = Date.now();
            const v = systemState.parameters.visuals;
            const c = v.colors;
            const cur = v.canvasCursors;

            const themeColors = {
                'COMMIT': c.fireballCommit,
                'READY': c.fireballReady,
                'COAST': c.fireballCoast
            };
            const activeColors = themeColors[state] || c.fireballReady;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Outer Gloom/Heat Distortion
            const bloomSize = size * (cur.fireballBloomScale + Math.sin(time / cur.fireballPulseRate) * cur.fireballPulseMagnitude);
            const bloomSizeCapped = Math.max(systemState.parameters.visuals.particles.minBloomSize, bloomSize);
            const bloomGrad = ctx.createRadialGradient(x, y, 0, x, y, bloomSizeCapped);
            bloomGrad.addColorStop(0, activeColors[2]);
            bloomGrad.addColorStop(cur.gradStopB, activeColors[3]);
            ctx.fillStyle = bloomGrad;
            ctx.beginPath(); ctx.arc(x, y, bloomSizeCapped, 0, Math.PI * 2); ctx.fill();

            // Core Plasma
            const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
            coreGrad.addColorStop(0, activeColors[0]);
            coreGrad.addColorStop(cur.gradStopMid, activeColors[1]);
            coreGrad.addColorStop(cur.gradStopC, activeColors[2]);
            coreGrad.addColorStop(1, activeColors[3]);

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Pulsing spikes/tendrils
            if (state === 'COMMIT') {
                ctx.strokeStyle = activeColors[1];
                ctx.lineWidth = 2;
                for (let i = 0; i < cur.fireballSpikeCount; i++) {
                    const angle = (time / cur.fireballSpikeRate) + (i * Math.PI / (cur.fireballSpikeCount / 2));
                    const length = size * (cur.fireballSpikeLengthScale + Math.sin(time / cur.fireballSpikeFrequency + i) * cur.fireballSpikeMagnitude);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- üåä WATER ELEMENT CURSOR (V20.4) ---
        function drawWaterCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const v = systemState.parameters.visuals;
            const c = v.colors;
            const cur = v.canvasCursors;

            const themeColors = {
                'COMMIT': c.waterCommit,
                'READY': c.waterReady,
                'COAST': c.waterCoast
            };
            const activeColors = themeColors[state] || c.waterReady;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Fluid Laser / Beam Path
            if (systemState.parameters.physics.showLaserBeam) {
                const dist = Math.sqrt((x - rawX) ** 2 + (y - rawY) ** 2);
                const steps = cur.waterWaveSteps;
                ctx.lineWidth = state === 'COMMIT' ? cur.arcSizeCommit : cur.arcSizeReady;
                ctx.strokeStyle = activeColors[1];
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);

                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    // Sine wave distortion for water feel
                    const wave = Math.sin(time / cur.waterWaveFrequency + ratio * cur.waterWaveScale) * cur.waterWaveMagnitude * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();

                // Inner white fluid core
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.strokeStyle = c.white;
                ctx.lineWidth = 1;
                ctx.globalAlpha = cur.whiteCoreAlpha;
                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    const wave = Math.sin(time / cur.waterWaveFrequency + ratio * cur.waterWaveScale) * 2 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();
            }

            // 2. Ripple Effect at Tip
            const rippleSize = (state === 'COMMIT' ? cur.rippleSizeCommit : cur.rippleSizeBase) + Math.sin(time / cur.ripplePulseRate) * cur.ripplePulseMagnitude;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, rippleSize);
            grad.addColorStop(cur.gradStopA, activeColors[0]);
            grad.addColorStop(cur.gradStopB, activeColors[1]);
            grad.addColorStop(cur.gradStopC, `rgba(0, ${cur.glowColorOffset + 23}, 255, 0)`);

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, rippleSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Bubbles/Droplets if committed
            if (state === 'COMMIT') {
                for (let i = 0; i < cur.bubbleCount; i++) {
                    const bTime = (time + i * cur.sparkDuration) % (cur.sparkDuration * 2);
                    const bScale = bTime / (cur.sparkDuration * 2);
                    const bx = x + Math.cos(i * 2 + time / cur.glowTimeDivisor) * cur.sparkSpreadX * bScale;
                    const by = y - cur.sparkRise * 0.5 * bScale; // Rise up
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - bScale) + ')';
                    ctx.beginPath(); ctx.arc(bx, by, cur.skeletonRadiusMultiplier * (1 - bScale), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        // --- üî• FIRE ELEMENT CURSOR (V20.4) ---
        function drawFireCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const v = systemState.parameters.visuals;
            const c = v.colors;
            const cur = v.canvasCursors;

            const themeColors = {
                'COMMIT': c.commit,
                'READY': c.ready,
                'COAST': c.coast
            };
            const activeColors = themeColors[state] || c.ready;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Heat Distortion Beam
            if (systemState.parameters.physics.showLaserBeam) {
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = activeColors[1];
                ctx.lineWidth = state === 'COMMIT' ? cur.arcSizeCommit * cur.arcSizeCommitFactor : cur.arcSizeReady * cur.arcSizeReadyFactor;
                ctx.lineCap = 'round';
                ctx.globalAlpha = cur.skeletonAlphaReady;
                ctx.stroke();

                // Subtler Flicker Core (V20.5)
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x + (Math.random() - 0.5) * cur.skeletonRadius * cur.skeletonRadiusMultiplier, y + (Math.random() - 0.5) * cur.skeletonRadius * cur.skeletonRadiusMultiplier);
                ctx.strokeStyle = c.white;
                ctx.lineWidth = 2;
                ctx.globalAlpha = cur.gridAlpha;
                ctx.stroke();
            }

            // 2. Rising Fireball at Tip
            const fireSize = (state === 'COMMIT' ? cur.fireSizeCommit : cur.fireSizeBase) + Math.sin(time / cur.pulseRate) * cur.pulseMagnitude;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, fireSize);
            grad.addColorStop(cur.gradStopA, activeColors[0]);
            grad.addColorStop(cur.gradStopB, activeColors[1]);
            grad.addColorStop(cur.gradStopC, 'rgba(255, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, fireSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Emitted Sparks
            if (state === 'COMMIT' || state === 'READY') {
                const sparkCount = state === 'COMMIT' ? cur.sparkCountCommit : cur.sparkCountReady;
                for (let i = 0; i < sparkCount; i++) {
                    const sparkTime = (time + i * (cur.sparkDuration / 2)) % cur.sparkDuration;
                    const sRatio = sparkTime / cur.sparkDuration;
                    const angle = (i * Math.PI * 2 / sparkCount) + time / cur.sparkDuration;
                    const sx = x + Math.cos(angle) * cur.sparkSpreadX * sRatio;
                    const sy = y + Math.sin(angle) * cur.sparkSpreadY * sRatio - cur.sparkRise * sRatio;
                    ctx.fillStyle = c.spark;
                    ctx.globalAlpha = 1 - sRatio;
                    ctx.beginPath(); ctx.arc(sx, sy, 2 * (1 - sRatio), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawElementalJuice(ctx, landmarks, bucketLevel, canvasWidth, canvasHeight) {
            const v = systemState.parameters.visuals;
            const f = systemState.parameters.fsm;
            const cur = v.canvasCursors;
            const c = v.colors;

            if (bucketLevel <= cur.juiceThreshold) return;
            const intensity = bucketLevel / f.maxBucketLevel;
            const time = Date.now();

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Scale points based on intensity
            const targetPoints = systemState.parameters.anatomy.handSkeletonMap.flat();
            // Use unique points
            const uniquePoints = Array.from(new Set(targetPoints));
            const activeCount = Math.floor(uniquePoints.length * intensity);

            for (let i = 0; i < activeCount; i++) {
                const lm = landmarks[uniquePoints[i]];
                const x = lm.x * canvasWidth;
                const y = lm.y * canvasHeight;

                const size = (cur.fireSizeBase + Math.sin(time / cur.pulseRate + i) * cur.pulseMagnitude) * intensity;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(cur.gradStopA, `rgba(255, ${cur.glowColorOffset + Math.random() * cur.glowColorOffset}, 50, ${cur.whiteCoreAlpha * 1.5 * intensity})`);
                grad.addColorStop(cur.gradStopC, `rgba(255, ${cur.sparkSpreadY * 5}, 0, 0)`);

                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();

                // Upward Ash/Sparks
                if (Math.random() > cur.randomThreshold) {
                    const sx = x + (Math.random() - 0.5) * cur.sparkSpreadX;
                    const sy = y - (time % cur.sparkDuration / cur.sparkDuration) * cur.sparkRise * 0.5 * intensity;
                    ctx.fillStyle = c.spark;
                    ctx.globalAlpha = Math.random() * intensity;
                    ctx.beginPath(); ctx.arc(sx, sy, cur.skeletonRadius * cur.skeletonRadiusMultiplier, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }

        function updateVisualPanels(results) {
            const v = systemState.parameters.visuals;
            const cur = v.canvasCursors;
            const vColors = v.colors;
            
            // Update Gestures Panel
            if (systemState.ui.gestures) {
                let html = '<div class="scrollable-panel">';
                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((cursor, i) => {
                        const hIdx = cursor.handIndex;
                        const gesture = cursor.gesture;
                        const score = cursor.confidence;
                        // Handedness still comes from raw results for now
                        const handedness = results.handedness?.[hIdx]?.[0]?.categoryName || 'Unknown';

                        const isCoasting = cursor.fsmState === 'COAST';
                        const stateColor = cursor.fsmState === 'COMMIT' ? 'var(--hfo-red)' : (isCoasting ? '#FFA500' : 'var(--md-sys-color-primary)');

                        // Deep Debug Data
                        const phys = systemState.p1.physicsState[hIdx];
                        const telemetry = phys && phys.getTelemetry ? phys.getTelemetry() : { speed: 0 };
                        const speed = telemetry.speed.toFixed(2);

                        const isPrimary = systemState.fsm.primaryHandIndex === hIdx;
                        const labelPrefix = isPrimary ? 'üéñÔ∏è [PRIMARY] ' : '';

                        html += `
                            <div class="m3-card" style="border-left: 4px solid ${stateColor}">
                                <div class="m3-label">${labelPrefix}Hand ${hIdx} | ${handedness}</div>
                                <div class="m3-stat">
                                    <span>Gesture | Confidence</span>
                                    <span style="font-weight:bold">${gesture} | ${(score * 100).toFixed(0)}%</span>
                                </div>
                                <div class="m3-stat" style="margin-top:8px">
                                    <span>Planck Speed (px/s)</span>
                                    <span style="color:var(--hfo-gold)">${speed}</span>
                                </div>
                                <div class="m3-stat">
                                    <span>Bucket Charge</span>
                                    <span>${(cursor.bucketLevel || 0).toFixed(1)}%</span>
                                </div>
                                <div class="m3-progress-container">
                                    <div class="m3-progress-bar" style="width: ${cursor.bucketLevel || 0}%; background: ${stateColor}"></div>
                                </div>
                                <div class="m3-stat">
                                    <span>Rod Sync (Projected)</span>
                                    <span style="font-family:monospace">${cursor.screenX.toFixed(0)}/${cursor.screenY.toFixed(0)}</span>
                                </div>
                                <div class="m3-stat" style="margin-top:4px; font-size:10px; opacity:0.7">
                                    <span>FSM State</span>
                                    <span>${cursor.fsmState || 'IDLE'}</span>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += '<div style="color:var(--md-sys-color-outline); text-align:center; margin-top:40px;">No hands detected</div>';
                }
                html += '</div>';
                systemState.ui.gestures.innerHTML = html;
            }

            // Update Palm Panel
            if (systemState.ui.palmCtx) {
                const ctx = systemState.ui.palmCtx;
                const canvas = systemState.ui.palm;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((c, i) => {
                        const x = (i === 0 ? canvas.width * 0.25 : canvas.width * 0.75);
                        const y = canvas.height * 0.5;
                        const radius = cur.radiusBase;

                        // üü¢ Palm Orientation Sphere (Enhanced V14)
                        const enterT = systemState.parameters.palm.enterThreshold;
                        const exitT = systemState.parameters.palm.exitThreshold;

                        // Background Sphere
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = c.isPalmFacing ? `rgba(0, 255, ${cur.glowColorOffset - 35}, ${cur.panelAlpha})` : `rgba(255, ${cur.glowColorOffset - 35}, 54, ${cur.panelAlpha})`;
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Hysteresis Rings (Target Zones)
                        ctx.setLineDash([cur.dashLength, cur.dashGap]);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${cur.skeletonAlphaCoast})`;
                        ctx.beginPath(); ctx.arc(x, y, radius * enterT, 0, Math.PI * 2); ctx.stroke(); // Enter Ring
                        ctx.strokeStyle = `rgba(255, 255, 255, ${cur.gridAlpha})`;
                        ctx.beginPath(); ctx.arc(x, y, radius * exitT, 0, Math.PI * 2); ctx.stroke();  // Exit Ring
                        ctx.setLineDash([]);

                        // Face Dot & Normal (Fabric Driven)
                        const nx = c.palmNormal.x;
                        const ny = c.palmNormal.y;
                        const nz = c.normalZ;

                        if (true) { // Fabric always has normal data if cursor exists
                            // üìä UPDATE SPARKLINE BUFFERS
                            if (!systemState.ui.history) systemState.ui.history = [];
                            if (!systemState.ui.history[i]) systemState.ui.history[i] = { zNorm: [], bucket: [] };

                            systemState.ui.history[i].zNorm.push(nz);
                            systemState.ui.history[i].bucket.push(c.bucketLevel / 100);
                            if (systemState.ui.history[i].zNorm.length > cur.historyLimit) { // Pareto-length history
                                systemState.ui.history[i].zNorm.shift();
                                systemState.ui.history[i].bucket.shift();
                            }

                            // Dynamic Color based on facing status
                            const stateColor = c.isPalmFacing ? '#00FF41' : '#FF4136';

                            // Depth Progress Ring (Fidelity Visualization)
                            ctx.beginPath();
                            ctx.arc(x, y, radius * nz, 0, Math.PI * 2);
                            ctx.strokeStyle = stateColor;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = cur.depthRingAlpha;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;

                            // Draw Normal Vector Shadow/Pointer
                            const dotX = x + nx * radius;
                            const dotY = y + ny * radius;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(dotX, dotY);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${cur.normalLineAlpha})`;
                            ctx.stroke();

                            // Facing Dot (Orientation Feedback)
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, cur.facingDotSize, 0, Math.PI * 2);
                            ctx.fillStyle = stateColor;
                            ctx.shadowBlur = c.isPalmFacing ? cur.shadowBlurPalm : 0;
                            ctx.shadowColor = stateColor;
                            ctx.fill();
                            ctx.shadowBlur = 0;

                            // Crosshair if inside "Goldilocks" area (approx)
                            if (nz > cur.goldilocksThreshold) {
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(dotX - cur.crosshairSize, dotY); ctx.lineTo(dotX + cur.crosshairSize, dotY); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(dotX, dotY - cur.crosshairSize); ctx.lineTo(dotX, dotY + cur.crosshairSize); ctx.stroke();
                            }

                            // üìä Z-NORM Hysteresis Gauge
                            const gageW = cur.gageWidth, gageH = cur.gageHeight;
                            const gageX = x + radius + cur.gageOffset, gageY = y - gageH / 2;

                            // Track
                            ctx.fillStyle = '#111';
                            ctx.fillRect(gageX, gageY, gageW, gageH);

                            // üìä SPARKLINE: Z-NORM HISTORY
                            const zHistory = systemState.ui.history[i].zNorm;
                            drawSparkline(ctx, gageX - cur.sparklinePadding / 2, gageY, gageW + cur.sparklinePadding, gageH, zHistory, '#00FF4144');

                            // Thresholds (0.80 & 0.64) & Goldilocks (0.88)
                            const enterY = gageY + gageH * (1 - systemState.parameters.palm.enterThreshold);
                            const exitY = gageY + gageH * (1 - systemState.parameters.palm.exitThreshold);
                            const goldY = gageY + gageH * (1 - cur.goldilocksThreshold); // 88% Pareto Target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(gageX - cur.sparklinePadding / 2, enterY); ctx.lineTo(gageX + gageW + cur.uiLineOffset, enterY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(gageX - cur.sparklinePadding / 2, exitY); ctx.lineTo(gageX + gageW + cur.uiLineOffset, exitY); ctx.stroke();

                            // 88% Goldilocks Marker
                            ctx.strokeStyle = '#FFD700'; // Gold
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(gageX - cur.uiIndicatorOffset, goldY); ctx.lineTo(gageX + gageW + cur.uiIndicatorOffset, goldY); ctx.stroke();
                            ctx.setLineDash([]);

                            // Fill
                            const normFill = gageH * Math.max(0, Math.min(1, nz));
                            ctx.fillStyle = c.isPalmFacing ? '#00FF41' : '#444';
                            ctx.fillRect(gageX, gageY + gageH - normFill, gageW, normFill);

                            // ‚öñÔ∏è Leaky Bucket Hysteresis Visualizer
                            const buckW = cur.bucketWidth, buckH = cur.bucketHeight;
                            const buckX = x - radius - cur.bucketOffset, buckY = y - buckH / 2;
                            const bucketLevel = systemState.p1.buckets[i] || 0;

                            ctx.fillStyle = '#111';
                            ctx.fillRect(buckX, buckY, buckW, buckH);

                            // üìä SPARKLINE: BUCKET HISTORY
                            const bHistory = systemState.ui.history[i].bucket;
                            drawSparkline(ctx, buckX - cur.sparklinePadding / 2, buckY, buckW + cur.sparklinePadding, buckH, bHistory, '#D0BCFF44');

                            const highY = buckY + buckH * (1 - systemState.parameters.fsm.hysteresisHigh / 100);
                            const lowY = buckY + buckH * (1 - systemState.parameters.fsm.hysteresisLow / 100);
                            const targetY = buckY + buckH * (1 - cur.goldilocksThreshold); // 88% HIVE target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(buckX - 2, highY); ctx.lineTo(buckX + buckW + 2, highY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(buckX - 2, lowY); ctx.lineTo(buckX + buckW + 2, lowY); ctx.stroke();

                            // 88% Target Marker
                            ctx.strokeStyle = '#D0BCFF';
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(buckX - cur.sparklinePadding / 2, targetY); ctx.lineTo(buckX + buckW + cur.sparklinePadding / 2, targetY); ctx.stroke();
                            ctx.setLineDash([]);

                            const fillH = buckH * (bucketLevel / 100);
                            ctx.fillStyle = c.fsmState === 'READY' ? '#FFD700' : (c.fsmState === 'COMMIT' ? '#FF4136' : '#D0BCFF');
                            ctx.fillRect(buckX, buckY + buckH - fillH, buckW, fillH);

                            // Textual readout
                            ctx.fillStyle = '#AAA';
                            ctx.font = '9px Roboto';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${(systemState.parameters.palm.enterThreshold * 100).toFixed(0)}/${(systemState.parameters.palm.exitThreshold * 100).toFixed(0)} Z`, gageX + gageW / 2, gageY - cur.uiIndicatorOffset);
                            ctx.fillText(`${(cur.goldilocksThreshold * 100).toFixed(0)}% HFO`, buckX + buckW / 2, buckY - cur.uiIndicatorOffset);
                            ctx.fillText(`Z: ${nz.toFixed(2)}`, gageX + gageW / 2, gageY + gageH + cur.sparklinePadding + 2);
                            ctx.fillText(`BUCKET: ${bucketLevel.toFixed(0)}%`, buckX + buckW / 2, buckY + buckH + cur.sparklinePadding + 2);
                            ctx.fillText(`FSM: ${c.fsmState}`, x, y + radius + cur.sparklinePadding * 3.5);
                        }
                    });
                }
            }

            // --- V18: TACTICAL VIEW (P3 GHOST CURSOR) ---
            if (systemState.ui.tacticalCtx) {
                const ctx = systemState.ui.tacticalCtx;
                const canvas = systemState.ui.tactical;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Grid lines for tactical feel
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i <= cur.gridSteps; i++) {
                    const gx = (i / cur.gridSteps) * canvas.width;
                    const gy = (i / cur.gridSteps) * canvas.height;
                    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
                }

                if (systemState.p1.cursors.length > 0) {
                    systemState.p1.cursors.forEach((c) => {
                        const tx = (c.screenX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ty = (c.screenY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        // Origin Pointer (Raw Sensing)
                        const rx = (c.rawX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ry = (c.rawY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        ctx.beginPath();
                        ctx.moveTo(rx, ry);
                        ctx.lineTo(tx, ty);
                        ctx.strokeStyle = '#555';
                        ctx.setLineDash([1, 1]);
                        ctx.stroke();

                        // Ghost Cursor (Tactical UI)
                        ctx.beginPath();
                        ctx.arc(tx, ty, cur.facingDotSize + 2, 0, Math.PI * 2);
                        ctx.strokeStyle = c.fsmState === 'COMMIT' ? '#FF4136' : '#FFD700';
                        ctx.setLineDash([]);
                        ctx.stroke();

                        // Pressure Indicator
                        if (c.fsmState === 'COMMIT') {
                            ctx.beginPath();
                            ctx.arc(tx, ty, 10 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, ${cur.glowColorOffset - 35}, 54, 0.2)`;
                            ctx.fill();
                        }

                        // Identifier
                        ctx.fillStyle = '#888';
                        ctx.font = '9px monospace';
                        ctx.fillText(`H${c.handIndex}:${c.fsmState}`, tx + 10, ty - 10);
                    });
                }
            }

            // Update FSM Visualization Panel
            if (systemState.ui.fsmCtx) {
                const ctx = systemState.ui.fsmCtx;
                const canvas = systemState.ui.fsm;
                if (canvas.width === 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const nodes = [
                    { id: 'IDLE', x: 0.15, y: 0.5 },
                    { id: 'READY', x: 0.4, y: 0.5 },
                    { id: 'COMMIT', x: 0.65, y: 0.5 },
                    { id: 'COAST', x: 0.9, y: 0.5 }
                ];

                const nodeWidth = 70, nodeHeight = 35;
                const current = systemState.fsm.currentState;

                // Draw Transitions
                ctx.strokeStyle = '#333';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                // IDLE -> READY
                ctx.moveTo(canvas.width * 0.15 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.4 - nodeWidth / 2, canvas.height * 0.5);
                // READY -> COMMIT
                ctx.moveTo(canvas.width * 0.4 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.65 - nodeWidth / 2, canvas.height * 0.5);
                // COMMIT -> COAST
                ctx.moveTo(canvas.width * 0.65 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.9 - nodeWidth / 2, canvas.height * 0.5);
                // Transitions back and to IDLE omitted for clarity in simple viz
                ctx.stroke();
                ctx.setLineDash([]);

                nodes.forEach(node => {
                    const nx = canvas.width * node.x;
                    const ny = canvas.height * node.y;
                    const isActive = node.id === current;

                    // Glow for active node
                    if (isActive) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF')));
                    }

                    ctx.fillStyle = isActive ? '#000' : '#111';
                    ctx.strokeStyle = isActive ? (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF'))) : '#444';
                    ctx.beginPath();
                    ctx.roundRect(nx - nodeWidth / 2, ny - nodeHeight / 2, nodeWidth, nodeHeight, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = isActive ? '#FFF' : '#888';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.id, nx, ny + 5);

                    // Draw Leaky Bucket Gauge for active state
                    if (isActive && node.id !== 'IDLE') {
                        const pIdx = systemState.fsm.primaryHandIndex !== null ? systemState.fsm.primaryHandIndex : 0;
                        const charge = systemState.p1.buckets[pIdx] || 0;
                        const high = systemState.parameters.fsm.hysteresisHigh;
                        const low = systemState.parameters.fsm.hysteresisLow;

                        ctx.fillStyle = '#222';
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth, 6);

                        // Fill
                        ctx.fillStyle = (node.id === 'COAST' ? '#FFA500' : '#FFD700');
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth * (charge / 100), 6);

                        // HFO Threshold Markers (80/64)
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * (high / 100), ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * (high / 100), ny + 30);
                        ctx.stroke();

                        ctx.strokeStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * (low / 100), ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * (low / 100), ny + 30);
                        ctx.stroke();
                    }
                });
            }
        }

        function updateFSM(state) {
            if (systemState.fsm.currentState !== state) {
                systemState.fsm.currentState = state;
                const status = document.getElementById('state-indicator');
                status.innerText = `P1: CONTRACTS ACTIVE | FSM: ${state}`;
            }
        }

        function drawResults(rawResults, fabric) {
            window.drawResults = drawResults;
            window.lastDrawResults = Date.now();
            const { ctx, canvas } = systemState.p0;
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cursors = fabric.cursors;
            const isMirror = systemState.parameters.camera.mirror;
            const cur = systemState.parameters.visuals.canvasCursors;

            // --- V19.6: INTEGRATED TACTICAL GRID ---
            ctx.save();
            ctx.strokeStyle = `rgba(255, 255, 255, ${cur.gridAlpha})`;
            ctx.lineWidth = 1;
            for (let i = 0; i <= cur.gridSteps; i++) {
                const gx = (i / cur.gridSteps) * canvas.width;
                const gy = (i / cur.gridSteps) * canvas.height;
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }
            ctx.restore();

            // --- P0 ISR SKELETON (Restricted Bypass) ---
            // V24.18: Consolidated skeleton drawing to Port 1 Fabric loop below for state-awareness.

            // --- PORT 1 FABRIC VISUALS (Enforced) ---
            cursors.forEach((c, i) => {
                const { screenX, screenY, fsmState, rawX, rawY, landmarks } = c;

                // V24.19 Parity Fix: landmarks are already mirrored/processed by P1Bridger.
                // Do NOT re-mirror them here.
                if ((fsmState === 'IDLE' || fsmState === 'READY' || fsmState === 'COMMIT') && landmarks && landmarks.length > 0 && systemState.parameters.landmarks.showSkeleton) {
                    const utils = new DrawingUtils(ctx);
                    // Use landmarks directly from DataFabric
                    utils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, { color: `rgba(255, 255, 255, ${cur.skeletonConnectorAlpha})`, lineWidth: cur.skeletonLineWidth });
                    utils.drawLandmarks(landmarks, { color: `rgba(255, 255, 255, ${cur.skeletonLandmarkAlpha})`, radius: cur.skeletonRadius });
                }

                if (fsmState === 'IDLE') return;

                const theme = systemState.parameters.physics.cursorTheme;
                const v = systemState.parameters.visuals;
                const palette = v.colors;
                const cur = v.canvasCursors;

                if (theme === 'LI') {
                    drawFireCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'DUI') {
                    drawWaterCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'QIAN') {
                    // Legacy Rigid Rod Logic (Metal/Heaven)
                    const color = fsmState === 'COMMIT' ? palette.qCommit : (fsmState === 'READY' ? palette.qReady : palette.qIdle);
                    if (systemState.parameters.physics.showLaserBeam) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = fsmState === 'COMMIT' ? cur.arcSizeCommit : cur.arcSizeReady;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = fsmState === 'COMMIT' ? cur.skeletonAlphaCommit : cur.skeletonAlphaReady;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = palette.white;
                        ctx.lineWidth = fsmState === 'COMMIT' ? 3 : 2;
                        ctx.globalAlpha = cur.whiteCoreAlpha;
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? cur.arcSizeCommit : cur.arcSizeReady, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = cur.shadowBlur;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Placeholder for other 5 elements (ZHEN, XUN, KAN, GEN, KUN)
                    const themeColors = {
                        'ZHEN': '#9400D3', 'XUN': '#00FF00', 'KAN': '#00008B',
                        'GEN': '#8B4513', 'KUN': '#A52A2A'
                    };
                    const color = themeColors[theme] || palette.white;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 10 : 6, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = palette.white;
                    ctx.stroke();
                }

                // --- V19.6: INTEGRATED GHOST CURSOR (Tactical Layer) ---
                const ghostColor = fsmState === 'COMMIT' ? palette.qCommit : (fsmState === 'READY' ? palette.qReady : palette.qIdle);
                ctx.save();
                ctx.beginPath();
                ctx.arc(screenX, screenY, cur.ghostSize, 0, Math.PI * 2);
                ctx.strokeStyle = ghostColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.restore();

                // Focal Crosshair (Goldilocks Zone)
                if (fsmState === 'COMMIT') {
                    ctx.strokeStyle = palette.white;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - cur.crosshairSize, screenY); ctx.lineTo(screenX + cur.crosshairSize, screenY);
                    ctx.moveTo(screenX, screenY - cur.crosshairSize); ctx.lineTo(screenX, screenY + cur.crosshairSize);
                    ctx.stroke();
                }
            });
        }

        // --- P7: NAVIGATOR (Settings Shell) ---
        class P7Navigator {
            static init(container) {
                const div = document.createElement('div');
                div.className = 'scrollable-panel';
                container.appendChild(div);

                const gui = new GUI({ container: div, title: 'üõ∞Ô∏è NAVIGATOR CONFIG', autoPlace: false });
                const fTelem = gui.addFolder('P6: Telemetry & Replay [V24.6]');
                fTelem.add(window.hfoTelemetry, 'isRecording').name('RECORDING ACTIVE').listen();
                fTelem.add({ start: () => window.hfoTelemetry.start() }, 'start').name('Start Recording');
                fTelem.add({ stop: () => window.hfoTelemetry.stop() }, 'stop').name('Stop Recording');
                fTelem.add({ export: () => window.hfoTelemetry.exportJSONL() }, 'export').name('Export .jsonl');

                // Replay Controls (Golden Master)
                fTelem.add(window.hfoPlayer, 'isPlaying').name('REPLAY ACTIVE').listen();
                fTelem.add(window.hfoPlayer, 'loop').name('Loop Replay');
                fTelem.add({
                    load: () => {
                        const inp = document.createElement('input');
                        inp.type = 'file';
                        inp.accept = '.jsonl';
                        inp.onchange = (e) => {
                            const file = e.target.files[0];
                            if (file) window.hfoPlayer.load(file);
                        };
                        inp.click();
                    }
                }, 'load').name('Load JSONL Replay');
                fTelem.add({ start: () => window.hfoPlayer.start() }, 'start').name('‚ñ∂ Start Replay');
                fTelem.add({ stop: () => window.hfoPlayer.stop() }, 'stop').name('‚èπ Stop Replay');
                fTelem.add({ pause: () => window.hfoPlayer.pause() }, 'pause').name('‚è∏ Pause Replay');

                const fVisuals = gui.addFolder('üöÄ P4: Visual Engines');
                fVisuals.add(systemState.parameters.visuals, 'engine', ['BABYLON', 'PIXI']).name('Visual Engine').onChange(val => {
                    logMission(`Visual Engine Switched to ${val}`);
                });
                fVisuals.add(systemState.parameters.visuals, 'variant', ['PHOENIX_CORE']).name('Visual Variant');
                fVisuals.add(systemState.parameters.physics, 'showTrailMesh').name('Show Trail Ribbon (Legacy)');
                fVisuals.add(systemState.parameters.physics, 'showHFOClaw').name('Show HFO Pointer Claw');

                const fCam = gui.addFolder('P0: Camera Range');
                fCam.add(systemState.parameters.camera, 'resolution', ['640x480', '1280x720', '1920x1080']).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'fpsTarget', 15, 60, 1).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'mirror').onChange(syncConfig);

                const fLand = gui.addFolder('P0: Neural Shards');
                fLand.add(systemState.parameters.landmarks, 'minConfidence', 0.1, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'numHands', 1, 4, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'showSkeleton');

                const fGest = gui.addFolder('P1: Gesture Confidence');
                fGest.add(systemState.parameters.gestures, 'minGestureConfidence', 0, 1).name('Confidence Threshold');
                fGest.add(systemState.parameters.gestures, 'preferredHand', ['Any', 'Left', 'Right']);

                const fPalm = gui.addFolder('P1: Palm Cone Orientation');
                fPalm.add(systemState.parameters.palm, 'enterThreshold', 0, 1).name('Enter Threshold (80)');
                fPalm.add(systemState.parameters.palm, 'exitThreshold', 0, 1).name('Exit Threshold (64)');

                const fFSM = gui.addFolder('P2: Sharding & Hysteresis (Dev)');
                fFSM.add(systemState.parameters.fsm, 'hysteresisHigh', 0, 100).name('Ready Threshold');
                fFSM.add(systemState.parameters.fsm, 'hysteresisLow', 0, 100).name('Idle Threshold');
                fFSM.add(systemState.parameters.fsm, 'chargeTimeMs', 10, 1000).name('Charge Time (ms)');
                fFSM.add(systemState.parameters.fsm, 'releaseTimeMs', 10, 1000).name('Release Time (ms)');
                fFSM.add(systemState.parameters.fsm, 'coastDrainTimeMs', 10, 3000).name('Coast Drain (ms)'); // V16
                fFSM.add(systemState.parameters.fsm, 'tensionMs', 0, 500).name('Tension/Coyote (ms)');
                fFSM.add(systemState.parameters.fsm, 'commitExitDelayMs', 0, 1000).name('Sticky Exit (ms)');

                const fCoast = gui.addFolder('P4: Coasting Control');
                fCoast.add(systemState.parameters.coasting, 'timeoutMs', 0, 1000).name('Coast Timeout (ms)');
                fCoast.add(systemState.parameters.coasting, 'confidenceThreshold', 0, 1).name('Min Signal Confidence');

                const fPhys = gui.addFolder('P2: Coordinate Substrate');
                fPhys.add(systemState.parameters.physics, 'mode', ['STATIC_ROD', 'PLANCK_SPRING']).name('Physics Mode').onChange(syncConfig);
                fPhys.add(systemState.parameters.physics, 'useDirectProjection').name('Direct Projection Flag'); // V20.6
                fPhys.add(systemState.parameters.physics, 'directProjectionOffset', 0, 0.5, 0.01).name('Direct Offset (LI)'); // V20.6
                fPhys.add(systemState.parameters.physics, 'cursorTheme', ['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']).name('HFO Element (Trigram)'); // V20.4
                fPhys.add(systemState.parameters.physics, 'oneEuroMinCutoff', 0.1, 5).name('Smoothing MinCutoff');
                fPhys.add(systemState.parameters.physics, 'oneEuroBeta', 0, 0.5).name('Smoothing Beta');
                fPhys.add(systemState.parameters.physics, 'planckStiffness', 0.1, 20).name('Planck Stiffness (Hz)');
                fPhys.add(systemState.parameters.physics, 'planckDamping', 0.0, 1.0).name('Planck Damping Ratio');
                fPhys.add(systemState.parameters.physics, 'palmRodMultiplier', 0.5, 10.0).step(0.1).name('Rod Length Factor');
                fPhys.add(systemState.parameters.physics, 'showLaserBeam').name('Show Beam Path');
                fPhys.add(systemState.parameters.physics, 'predictiveLookahead', 0, 5).name('Lookahead Factor');

                // V20: EXCALIDRAW OVERLAY CONTROL
                const fExcal = gui.addFolder('P3: Excalidraw Overlay');
                fExcal.add(systemState.parameters.excalidraw, 'enabled').name('Enabled').onChange(val => {
                    if (systemState.ui.excalidrawOverlay) {
                        systemState.ui.excalidrawOverlay.style.display = val ? 'block' : 'none';
                    }
                });
                fExcal.add(systemState.parameters.excalidraw, 'opacity', 0, 1).name('Transparency').onChange(val => {
                    if (systemState.ui.excalidrawOverlay) {
                        systemState.ui.excalidrawOverlay.style.opacity = val;
                    }
                });

                const fTools = gui.addFolder('P3: Excalidraw Tools');
                fTools.add(systemState.parameters.excalidraw, 'activeTool', [
                    'selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'draw', 'text', 'eraser'
                ]).name('Active Tool').onChange(val => {
                    if (systemState.ui.excalidrawIframe) {
                        systemState.ui.excalidrawIframe.contentWindow.postMessage({
                            type: 'SET_TOOL',
                            data: { tool: val }
                        }, '*');
                    }
                });

                const fAnat = gui.addFolder('P1: Anatomical Constraints');
                fAnat.add(systemState.parameters.anatomy, 'palmWidthCm', 4, 12, 0.1).name('Palm Width (cm)').onChange(syncConfig);
                fAnat.add(systemState.parameters.anatomy, 'rodExtensionMultiplier', 0.1, 5, 0.1).name('Rod Extension Factor').onChange(syncConfig);

                const fDebug = gui.addFolder('P5: Deep Visual Debugging');
                fDebug.add(systemState.parameters, 'devMode').name('Enable Full Telemetry').onChange(syncConfig);
                fDebug.add(systemState.parameters.landmarks, 'showSkeleton').name('Draw Skeleton');

                function syncConfig() {
                    const valid = P1Bridger.validateConfig(systemState.parameters);
                    if (valid) {
                        if (systemState.p0.recognizer) {
                            systemState.p0.recognizer.setOptions({
                                numHands: valid.landmarks.numHands,
                                minHandDetectionConfidence: valid.landmarks.minConfidence
                            });
                        }
                        logMission("P7: Configuration Synchronized & Validated");
                    } else {
                        logMission("‚ö†Ô∏è P1: Configuration Breach Detected", '#FF4136');
                    }
                }
            }
        }

        function resizeCanvas() {
            const { video, canvas } = systemState.p0;
            if (!video || !canvas) return;

            // V28: Fallback resolution for headless/mock testing
            const [w_param, h_param] = systemState.parameters.camera.resolution.split('x').map(Number);
            const vw = video.videoWidth || w_param || systemState.parameters.camera.resolutionWidth;
            const vh = video.videoHeight || h_param || systemState.parameters.camera.resolutionHeight;

            systemState.p0.videoBounds = { width: vw, height: vh };

            const parent = video.parentElement;
            if (!parent) return;
            const pRect = parent.getBoundingClientRect();

            // Handle 0 dimensions in headless
            const parentWidth = pRect.width || vw;
            const parentHeight = pRect.height || vh;

            const vRatio = vw / vh;

            let drawW = parentWidth, drawH = parentWidth / vRatio;
            if (drawH > parentHeight) { drawH = parentHeight; drawW = drawH * vRatio; }

            // Set buffer size to match video source (High-fidelity sensing baseline)
            canvas.width = vw;
            canvas.height = vh;

            // V24.19: Substrate Parity Alignment
            // Center overlays to match object-fit: contain video centering
            const offsetX = (parentWidth - drawW) / 2;
            const offsetY = (parentHeight - drawH) / 2;

            // V24.20: Store view bounds for coordinate transformation parity
            systemState.ui.viewBounds = {
                width: drawW,
                height: drawH,
                offsetX: offsetX,
                offsetY: offsetY
            };

            // Sync all canvas elements (Overlay, Babylon, Pixi)
            // V24.20: Including Excalidraw UI in the parity box
            const substrates = [
                canvas,
                ...systemState.ui.juiceLayers.map(l => l.canvas || l.app?.view),
                systemState.ui.excalidrawOverlay
            ];

            substrates.forEach(el => {
                if (el) {
                    el.style.position = 'absolute';
                    el.style.left = `${offsetX}px`;
                    el.style.top = `${offsetY}px`;
                    el.style.width = `${drawW}px`;
                    el.style.height = `${drawH}px`;
                }
            });

            // Trigger engine resizes to match the new CSS bounds
            systemState.ui.juiceLayers.forEach(l => {
                if (l.resize) l.resize(drawW, drawH);
            });
        }

        function logMission(msg, color = '#00ff41') {
            const logs = document.getElementById('mission-logs');
            if (!logs) return;
            const entry = document.createElement('div');
            entry.style.color = color;
            entry.innerText = `[${new Date().toLocaleTimeString('en-GB')}] ${msg}`;
            logs.prepend(entry);
        }

        // --- LAYOUT ENGINE ---
        const container = document.getElementById('layout-container');
        const layout = new GoldenLayout(container);

        layout.registerComponentFactoryFunction('hero', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.innerHTML = `
                <div class="hero-view-container">
                    <video id="video-feed" autoplay playsinline></video>
                    
                    <!-- EXCALIDRAW OVERLAY LAYER [V20.1: Dark Mode Hardening] -->
                    ${isFlagEnabled('ui-excalidraw') ? `
                    <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8;">
                        <iframe 
                            id="excalidraw-iframe"
                            src="excalidraw_v20_wrapper.html" 
                            style="width:100%; height:100%; border:none; filter: contrast(1.1) brightness(0.9); background: transparent;"
                            allow="clipboard-read; clipboard-write; unload">
                        </iframe>
                    </div>
                    ` : ''}

                    <div id="babylon-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:9;"></div>
                    <div id="pixi-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:10;"></div>
                    <canvas id="overlay-canvas" style="z-index:11;"></canvas>
                    <button id="btn-ignite" class="hfo-btn" style="position:absolute; bottom:30px; z-index:20;">IGNITE OMEGA</button>
                </div>
            `;
            container.getElement().appendChild(wrap);
            systemState.p0.video = wrap.querySelector('#video-feed');
            systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
            systemState.p0.ctx = systemState.p0.canvas.getContext('2d');

            // Reference for opacity control
            systemState.ui.excalidrawOverlay = wrap.querySelector('#excalidraw-hero-overlay');
            systemState.ui.excalidrawIframe = wrap.querySelector('#excalidraw-iframe');

            // V23: Initialize Hybrid Substrates (Gated by V24.1 OpenFeature)
            const babylonWrap = wrap.querySelector('#babylon-juice-overlay');
            const pixiWrap = wrap.querySelector('#pixi-juice-overlay');
            let babylonJuice = null;
            let pixiJuice = null;

            if (isFlagEnabled('engine-babylon') && babylonWrap) {
                babylonJuice = new BabylonJuiceSubstrate(babylonWrap);
            }
            if (isFlagEnabled('engine-pixi') && pixiWrap) {
                pixiJuice = new JuiceSubstrate(pixiWrap);
            }

            systemState.ui.juiceLayers = [babylonJuice, pixiJuice].filter(l => l !== null);

            wrap.querySelector('#btn-ignite').onclick = async (e) => {
                e.target.style.display = 'none';

                // V24.1: Ensure only enabled engines are displayed
                if (babylonJuice) babylonJuice.canvas.style.display = 'block';
                if (pixiJuice) pixiJuice.app.view.style.display = 'block';

                await initP0();
                const [w, h] = systemState.parameters.camera.resolution.split('x');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: parseInt(w), height: parseInt(h) } });
                    systemState.p0.video.srcObject = stream;
                    systemState.p0.video.onloadeddata = () => {
                        systemState.parameters.p0Active = true;
                        resizeCanvas(); predictLoop();
                    };
                } catch (err) {
                    console.warn("P0 Camera Error:", err);
                    // Playwright Fallback: Ensure the loop starts for mock-based testing
                    systemState.parameters.p0Active = true;
                    resizeCanvas();
                    predictLoop();
                }
            };

            // Responsiveness: Hub Listener
            container.on('resize', () => {
                resizeCanvas();
                const rect = (pixiWrap || wrap).getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (babylonJuice) babylonJuice.resize();
                    if (pixiJuice) pixiJuice.resize(rect.width, rect.height);
                }
            });

            // V24.5: Component Teardown Integration
            container.on('destroy', () => {
                console.log("[LIFECYCLE] Destroying Hero Component...");
                if (babylonJuice) window.hfoLifecycle.unregister(babylonJuice);
                if (pixiJuice) window.hfoLifecycle.unregister(pixiJuice);
                systemState.p0.video = null;
                systemState.p0.canvas = null;
                systemState.ui.juiceLayers = [];
            });
        });

        layout.registerComponentFactoryFunction('navigator', (container) => {
            P7Navigator.init(container.getElement());
        });

        layout.registerComponentFactoryFunction('logs', (container) => {
            const div = document.createElement('div');
            div.id = 'mission-logs';
            div.className = 'scrollable-panel';
            div.style.background = '#000'; div.style.fontSize = '10px'; div.style.fontFamily = 'monospace';
            container.getElement().appendChild(div);
            logMission("SYSTEM_LOGS: READY");
        });

        layout.registerComponentFactoryFunction('excalidraw', (container) => {
            if (!isFlagEnabled('ui-excalidraw')) {
                container.getElement().innerHTML = '<div style="color:red; padding:20px;">EXCALIDRAW_DISABLED</div>';
                return;
            }
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.background = '#000';
            wrap.innerHTML = `
                <iframe 
                    src="https://excalidraw.com/?theme=dark&transparent=true" 
                    style="width:100%; height:100%; border:none; opacity: 0.8; filter: contrast(1.2) brightness(0.8);">
                </iframe>
                <div style="position:absolute; top:10px; right:10px; color:#555; font-size:9px; pointer-events:none;">OBSIDIAN MIRROR V8.0</div>
            `;
            container.getElement().appendChild(wrap);
        });

        layout.registerComponentFactoryFunction('gestures', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container scrollable-panel';
            container.getElement().appendChild(wrap);
            systemState.ui.gestures = wrap;
        });

        layout.registerComponentFactoryFunction('tactical', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.innerHTML = `
                <div id="pixi-tac-juice" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:3;"></div>
                <canvas id="tactical-canvas"></canvas>
            `;
            container.getElement().appendChild(wrap);
            const canvas = wrap.querySelector('#tactical-canvas');
            systemState.ui.tactical = canvas;
            systemState.ui.tacticalCtx = canvas.getContext('2d');

            // V19.6: Add PixiJS Layer to Tactical View
            const pixiWrap = wrap.querySelector('#pixi-tac-juice');
            let tacJuice = null;
            if (isFlagEnabled('engine-pixi')) {
                tacJuice = new JuiceSubstrate(pixiWrap);
                systemState.ui.juiceLayers.push(tacJuice);
            }

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                if (rect.width > 0 && rect.height > 0) {
                    if (tacJuice) tacJuice.resize(rect.width, rect.height);
                }
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);

            // V24.5: Tactical Teardown
            container.on('destroy', () => {
                if (tacJuice) {
                    window.hfoLifecycle.unregister(tacJuice);
                    tacJuice.dispose();
                }
            });
        });

        layout.registerComponentFactoryFunction('fsm-viz', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.justifyContent = 'center';
            wrap.style.background = '#050505';
            const canvas = document.createElement('canvas');
            canvas.id = 'fsm-visualizer';
            wrap.appendChild(canvas);
            container.getElement().appendChild(wrap);
            systemState.ui.fsm = canvas;
            systemState.ui.fsmCtx = canvas.getContext('2d');

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);
        });

        layout.registerComponentFactoryFunction('palm', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.display = 'flex';
            wrap.style.alignItems = 'center';
            wrap.style.justifyContent = 'center';
            wrap.style.background = '#050a05';
            const canvas = document.createElement('canvas');
            canvas.id = 'palm-orientation-visualizer';
            wrap.appendChild(canvas);
            container.getElement().appendChild(wrap);

            systemState.ui.palm = canvas;
            systemState.ui.palmCtx = canvas.getContext('2d');

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);
        });

        layout.loadLayout({
            root: {
                type: 'row', content: [
                    {
                        type: 'stack', width: 60, content: [
                            { type: 'component', componentType: 'hero', title: 'Tactical Workspace' }
                        ]
                    },
                    {
                        type: 'column', width: 40, content: [
                            {
                                type: 'row', height: 40, content: [
                                    { type: 'component', componentType: 'gestures', title: 'P1: Gestures' },
                                    { type: 'component', componentType: 'palm', title: 'P1: Palm Orientation' },
                                    { type: 'component', componentType: 'tactical', title: 'P3: Integrated Tactical' }
                                ]
                            },
                            { type: 'component', componentType: 'fsm-viz', title: 'Tactical FSM Visualization', height: 15 },
                            { type: 'component', componentType: 'navigator', title: 'Port 7: Navigator', height: 20 },
                            { type: 'component', componentType: 'logs', title: 'System Telemetry', height: 5 }
                        ]
                    }
                ]
            }
        });

        window.addEventListener('resize', () => {
            layout.updateSize();
            resizeCanvas();
        });

        // Lifecycle Hardening: Guaranteed resource disposal [V24.4]
        window.addEventListener('beforeunload', () => {
            console.log("üåÄ [HFO LIFECYCLE]: Initiating global disposal sequence...");
            window.hfoLifecycle.disposeAll();
        });
    </script>
</body>

</html>