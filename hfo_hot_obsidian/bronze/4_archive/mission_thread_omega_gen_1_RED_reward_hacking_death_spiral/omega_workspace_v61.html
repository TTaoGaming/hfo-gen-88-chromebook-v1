<!-- Medallion: Bronze | Mutation: 0% | HIVE: E -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO SHARDS | OMEGA V61.0 | HIGH-VIZ DIAGNOSTIC</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <script src="./assets/piano_genie/magenta_music.js"></script>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        :root {
            /* M3 HFO Shard Palette (Material Design 3 Dark) */
            --m3-bg: #000000;
            --m3-surface: #121212;
            --m3-surface-bright: #1c1c1c;
            --m3-primary: #ff0000;
            /* Aggressive Red/Black HFO Shard Red */
            --m3-primary-container: #8c0000;
            --m3-on-primary: #ffffff;
            --m3-secondary: #ffb4ab;
            --m3-text: #e6e1e5;
            --m3-text-secondary: #938f99;
            --m3-outline: #49454f;
            --m3-radius: 16px;

            /* HFO Shard Vibe */
            --shard-claw: polygon(0% 0%, 95% 0%, 100% 10%, 100% 100%, 5% 100%, 0% 90%);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--m3-bg);
            color: var(--m3-text);
            font-family: 'Roboto', sans-serif;
            letter-spacing: 0.01em;
        }

        h2,
        h3 {
            font-weight: 500;
            color: var(--m3-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 0; /* Remove padding for video/canvas parity */
            height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            background-color: var(--m3-bg);
            color: var(--m3-text);
            position: relative;
        }

        .video-feed {
            width: 100%;
            height: 100%;
            object-fit: fill; /* Critical for coordinate parity */
            background: #000;
            filter: grayscale(1) contrast(1.5) brightness(0.6);
            opacity: 0.6;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
        }

        .video-feed.mirrored,
        .overlay-canvas.mirrored {
            transform: scaleX(-1);
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: fill;
            pointer-events: none;
        }

        .camera-controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            background: var(--m3-surface);
            padding: 8px;
            border-radius: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--m3-outline);
        }

        .camera-btn {
            padding: 8px 20px;
            font-size: 11px;
            font-weight: 500;
            background: var(--m3-surface-bright);
            color: var(--m3-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
            text-transform: uppercase;
        }

        .camera-btn:hover {
            background: var(--m3-primary-container);
            color: #fff;
        }

        .camera-btn.active {
            background: #00391d;
            color: #b7f397;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./assets/vendor/golden-layout.js",
            "lil-gui": "./assets/vendor/lil-gui.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "./assets/vendor/matter-js.js",
            "zod": "./assets/vendor/zod.js",
            "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸ¤– V61 FSM
        class GestureFSM {
            constructor() {
                this.state = 'PORT_0_IDLE';
                this.bucketFill = 0;
                this.lastTimestamp = 0;
            }
            process(gesture, timestamp, score = 1.0) {
                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
                this.lastTimestamp = timestamp;
                // Simple state logic for 2-hand diagnostic
                if (score > 0.6) this.state = 'ACTIVE';
                else this.state = 'IDLE';
                return this.state;
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: false,
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5 },
            leakyBucket: { fillRate: 1.2, drainRate: 0.5, threshold: 1000 },
            physics: { p0Mirror: true },
            visuals: { excalidrawOpacity: 0.7, showSkeleton: true },
            hands: {}
        };

        const hfoSystem = window.hSystem = {
            video: null, canvas: null, ctx: null, stream: null, recognizer: null,
            loopActive: false, overlays: []
        };

        const initMediaPipe = async (container) => {
            container.style.position = 'relative';
            const controls = document.createElement('div');
            controls.className = 'camera-controls';
            const btnStart = document.createElement('button');
            btnStart.className = 'camera-btn'; btnStart.innerText = 'Start Video';
            const btnFlip = document.createElement('button');
            btnFlip.className = 'camera-btn'; btnFlip.innerText = 'Flip';
            controls.append(btnStart, btnFlip);
            container.appendChild(controls);

            hfoSystem.video = document.createElement('video');
            hfoSystem.video.autoplay = true; hfoSystem.video.playsinline = true;
            hfoSystem.video.className = \`video-feed \${hfoState.physics.p0Mirror ? 'mirrored' : ''}\`;
            hfoSystem.canvas = document.createElement('canvas');
            hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
            hfoSystem.canvas.className = \`overlay-canvas \${hfoState.physics.p0Mirror ? 'mirrored' : ''}\`;
            container.append(hfoSystem.video, hfoSystem.canvas);
            hfoSystem.overlays.push({ canvas: hfoSystem.canvas, ctx: hfoSystem.ctx });

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
            hfoSystem.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });

            btnStart.onclick = async () => {
                if (!hfoSystem.stream) {
                    hfoSystem.stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                    hfoSystem.video.srcObject = hfoSystem.stream;
                    hfoSystem.video.onloadedmetadata = () => {
                        hfoSystem.video.play();
                        hfoSystem.canvas.width = hfoSystem.video.videoWidth;
                        hfoSystem.canvas.height = hfoSystem.video.videoHeight;
                        hfoSystem.loopActive = true;
                    };
                    btnStart.innerText = 'Stop'; btnStart.classList.add('active');
                } else {
                    hfoSystem.stream.getTracks().forEach(t => t.stop());
                    hfoSystem.stream = null; hfoSystem.video.srcObject = null;
                    hfoSystem.loopActive = false;
                    btnStart.innerText = 'Start Video'; btnStart.classList.remove('active');
                }
            };

            btnFlip.onclick = () => {
                hfoState.physics.p0Mirror = !hfoState.physics.p0Mirror;
                const m = hfoState.physics.p0Mirror;
                hfoSystem.video.classList.toggle('mirrored', m);
                hfoSystem.canvas.classList.toggle('mirrored', m);
            };

            const loop = (now) => {
                if (hfoSystem.loopActive && hfoSystem.recognizer) {
                    const res = hfoSystem.recognizer.recognizeForVideo(hfoSystem.video, now);
                    hfoSystem.ctx.clearRect(0, 0, hfoSystem.canvas.width, hfoSystem.canvas.height);
                    if (res && res.landmarks) {
                        const dw = new DrawingUtils(hfoSystem.ctx);
                        res.landmarks.forEach((landmarks, index) => {
                            // ðŸŒˆ HIGH-VIZ DIAGNOSTIC (2 Hands)
                            dw.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, {
                                color: index === 0 ? "#00FF00" : "#00FFFF",
                                lineWidth: 5
                            });
                            dw.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 1, radius: 2 });
                            
                            // ðŸ“Š Telemetry Overlay
                            if (hfoState.debug) {
                                const pos = landmarks[0];
                                hfoSystem.ctx.fillStyle = "#FFF";
                                hfoSystem.ctx.font = "bold 14px Roboto Mono";
                                hfoSystem.ctx.fillText(\`HAND_\${index}: \${res.gestures[index]?.[0]?.categoryName || 'NONE'}\`, pos.x * hfoSystem.canvas.width, pos.y * hfoSystem.canvas.height - 20);
                            }
                        });
                    }
                }
                requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        };

        const initExcalidraw = (container) => {
            const iframe = document.createElement('iframe');
            iframe.src = 'https://excalidraw.com?embed=1&theme=dark';
            iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
            iframe.style.opacity = hfoState.visuals.excalidrawOpacity;
            container.appendChild(iframe);
            window.excalIframe = iframe;
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });
            gui.add(hfoState.visuals, 'excalidrawOpacity', 0, 1).name('Canvas Opacity').onChange(v => window.excalIframe.style.opacity = v);
            gui.add(hfoState, 'debug').name('Show Telemetry');
            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    { type: 'component', componentType: 'Excalidraw', title: 'HERO', width: 70 },
                    {
                        type: 'column', width: 30, content: [
                            { type: 'component', componentType: 'Settings', title: 'SETTINGS', height: 30 },
                            { type: 'component', componentType: 'MediaPipe', title: 'DIAGNOSTIC VIDEO', height: 70 }
                        ]
                    }
                ]
            }
        };

        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.loadLayout(config);
        window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>
