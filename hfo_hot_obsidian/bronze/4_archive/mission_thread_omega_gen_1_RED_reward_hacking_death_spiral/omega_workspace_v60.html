<!-- Medallion: Bronze | Mutation: 0% | HIVE: E -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO SHARDS | OMEGA V60.0 | PHOENIX REBUILD</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <script src="./assets/piano_genie/magenta_music.js"></script>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        :root {
            /* M3 HFO Shard Palette (Material Design 3 Dark) */
            --m3-bg: #000000;
            --m3-surface: #121212;
            --m3-surface-bright: #1c1c1c;
            --m3-primary: #ff0000;
            /* Aggressive Red/Black HFO Shard Red */
            --m3-primary-container: #8c0000;
            --m3-on-primary: #ffffff;
            --m3-secondary: #ffb4ab;
            --m3-text: #e6e1e5;
            --m3-text-secondary: #938f99;
            --m3-outline: #49454f;
            --m3-radius: 16px;

            /* HFO Shard Vibe */
            --shard-claw: polygon(0% 0%, 95% 0%, 100% 10%, 100% 100%, 5% 100%, 0% 90%);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--m3-bg);
            color: var(--m3-text);
            font-family: 'Roboto', sans-serif;
            letter-spacing: 0.01em;
        }

        h2,
        h3 {
            font-weight: 500;
            color: var(--m3-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 24px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
            background-color: var(--m3-bg);
            color: var(--m3-text);
            position: relative;
        }

        .video-feed {
            width: 100%;
            height: 100%;
            object-fit: fill;
            border-radius: 4px;
            background: #000;
            filter: grayscale(1) contrast(1.5) brightness(0.6);
            opacity: 0.4;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
            border: 1px solid var(--m3-outline);
        }

        .video-feed:hover {
            opacity: 0.8;
            filter: grayscale(0.2) contrast(1.1) brightness(0.9);
        }

        .video-feed.mirrored,
        .overlay-canvas.mirrored {
            transform: scaleX(-1);
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: fill;
            pointer-events: none;
        }

        /* M3 Elevated Card with HFO Shard Claw */
        .data-card {
            background: var(--m3-surface);
            padding: 20px;
            border-radius: var(--m3-radius);
            margin-bottom: 24px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), 0 1px 3px rgba(0, 0, 0, 0.8);
            clip-path: var(--shard-claw);
            border-left: 4px solid var(--m3-primary);
            transition: transform 0.2s cubic-bezier(0, 0, 0.2, 1);
            position: relative;
        }

        .camera-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            background: var(--m3-surface);
            padding: 8px;
            border-radius: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--m3-outline);
        }

        .camera-btn {
            padding: 8px 16px;
            font-size: 11px;
            font-weight: 500;
            background: var(--m3-surface-bright);
            color: var(--m3-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
            text-transform: uppercase;
        }

        .camera-btn:hover {
            background: var(--m3-primary-container);
            color: #fff;
        }

        .camera-btn.active {
            background: #00391d;
            color: #b7f397;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./assets/vendor/golden-layout.js",
            "lil-gui": "./assets/vendor/lil-gui.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "./assets/vendor/matter-js.js",
            "zod": "./assets/vendor/zod.js",
            "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';
        import * as duckdb from '@duckdb/duckdb-wasm';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸŒ‰ PORT 1: BRIDGE (Contracts)
        const Port1CursorBridgeSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
        const Port1HandBridgeSchema = z.object({
            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
            cursors: z.record(Port1CursorBridgeSchema),
            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() })
        });
        const Port1CloudEventBridgeSchema = z.object({
            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(Port1HandBridgeSchema)
        });

        // ðŸ¤– V60: 4-State Gesture FSM
        class GestureFSM {
            constructor() {
                this.state = 'PORT_0_IDLE';
                this.pointerEvent = 'none';
                this.bucketFill = 0;
                this.lastTimestamp = 0;
                this.dwellRatio = 0;
            }

            process(gesture, timestamp, score = 1.0, isPalmConeFacing = false) {
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
                this.lastTimestamp = timestamp;
                const isConfident = score > 0.6;
                const config = hfoState.leakyBucket;

                if (isPalmConeFacing) {
                    this.bucketFill = Math.min(this.bucketFill + dt * config.fillRate, config.threshold);
                } else {
                    this.bucketFill = Math.max(this.bucketFill - dt * config.drainRate, 0);
                }
                this.dwellRatio = this.bucketFill / config.threshold;

                switch (this.state) {
                    case 'PORT_0_IDLE':
                        if (this.bucketFill >= config.threshold) this.state = 'PORT_1_POINTER_READY';
                        break;
                    case 'PORT_1_POINTER_READY':
                        this.pointerEvent = 'pointermove';
                        if (this.bucketFill <= 0) this.state = 'PORT_0_IDLE';
                        else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'PORT_7_POINTER_COMMIT';
                            this.pointerEvent = 'pointerdown';
                        }
                        break;
                    case 'PORT_7_POINTER_COMMIT':
                        this.pointerEvent = 'pointermove';
                        if (currentGesture !== 'POINTING_UP' && isConfident) {
                            this.state = 'PORT_5_POINTER_RELEASE';
                            this.pointerEvent = 'pointerup';
                        }
                        if (this.bucketFill <= 0) this.state = 'PORT_0_IDLE';
                        break;
                    case 'PORT_5_POINTER_RELEASE':
                        if (currentGesture === 'POINTING_UP' && isConfident) this.state = 'PORT_7_POINTER_COMMIT';
                        else if (this.bucketFill <= 0) this.state = 'PORT_0_IDLE';
                        break;
                }
                return { state: this.state, pointerEvent: this.pointerEvent, dwellRatio: this.dwellRatio };
            }
        }

        // ðŸ§  Filters
        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0) {
                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta;
                this.x = null; this.dx = 0; this.lastTime = null;
            }
            alpha(c) { const te = 1 / (this.freq || 60); const tau = 1 / (2 * Math.PI * c); return 1 / (1 + tau / te); }
            call(v, t = null) {
                if (this.lastTime && t) this.freq = 1000 / (t - this.lastTime);
                this.lastTime = t;
                if (this.x === null) { this.x = v; return v; }
                const a_d = this.alpha(1.0);
                this.dx = a_d * (v - this.x) + (1 - a_d) * this.dx;
                const c = this.minCutoff + this.beta * Math.abs(this.dx);
                const a = this.alpha(c);
                this.x = a * v + (1 - a) * this.x;
                return this.x;
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: false,
            transparency: 1.0,
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6 },
            leakyBucket: { fillRate: 1.2, drainRate: 0.5, threshold: 1000 },
            physics: { stiffness: 0.15, damping: 0.05, p0Mirror: true, p3Mirror: true, p3Source: 'predictive' },
            visuals: { excalidrawOpacity: 0.7, showSkeleton: true, hero: 'HEX_SHARD', support: 'DOT' },
            hands: {}
        };

        const hfoSystem = window.hfoSystem = {
            video: null, canvas: null, ctx: null, stream: null, recognizer: null,
            loopActive: false, initialized: false, overlays: []
        };

        const initMediaPipe = async (container) => {
            container.style.position = 'relative';
            container.style.backgroundColor = '#000';

            const controls = document.createElement('div');
            controls.className = 'camera-controls';
            const btnStart = document.createElement('button');
            btnStart.className = 'camera-btn'; btnStart.innerText = 'Start';
            const btnFlip = document.createElement('button');
            btnFlip.className = 'camera-btn'; btnFlip.innerText = 'Flip';
            controls.append(btnStart, btnFlip);
            container.appendChild(controls);

            btnStart.onclick = async () => {
                if (!hfoSystem.stream) {
                    hfoSystem.stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                    hfoSystem.video.srcObject = hfoSystem.stream;
                    hfoSystem.video.play();
                    hfoSystem.loopActive = true;
                    btnStart.innerText = 'Stop'; btnStart.classList.add('active');
                } else {
                    hfoSystem.stream.getTracks().forEach(t => t.stop());
                    hfoSystem.stream = null; hfoSystem.video.srcObject = null;
                    hfoSystem.loopActive = false;
                    btnStart.innerText = 'Start'; btnStart.classList.remove('active');
                }
            };

            btnFlip.onclick = () => {
                hfoState.physics.p0Mirror = !hfoState.physics.p0Mirror;
                const isMirrored = hfoState.physics.p0Mirror;
                hfoSystem.video.classList.toggle('mirrored', isMirrored);
                hfoSystem.overlays.forEach(o => o.canvas.classList.toggle('mirrored', isMirrored));
            };

            hfoSystem.video = document.createElement('video');
            hfoSystem.video.autoplay = true; hfoSystem.video.playsinline = true;
            hfoSystem.video.className = `video-feed ${hfoState.physics.p0Mirror ? 'mirrored' : ''}`;
            hfoSystem.canvas = document.createElement('canvas');
            hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
            hfoSystem.canvas.className = `overlay-canvas ${hfoState.physics.p0Mirror ? 'mirrored' : ''}`;
            container.append(hfoSystem.video, hfoSystem.canvas);
            hfoSystem.overlays.push({ canvas: hfoSystem.canvas, ctx: hfoSystem.ctx, mode: 'MAIN' });

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
            hfoSystem.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO"
            });

            const render = () => {
                const loop = (now) => {
                    if (hfoSystem.loopActive && hfoSystem.recognizer) {
                        try {
                            const res = hfoSystem.recognizer.recognizeForVideo(hfoSystem.video, now);
                            
                            // Clear all overlays
                            hfoSystem.overlays.forEach(o => o.ctx.clearRect(0, 0, o.canvas.width, o.canvas.height));

                            if (res && res.landmarks) {
                                const ctx = hfoSystem.ctx;
                                const canvas = hfoSystem.canvas;
                                const dw = new DrawingUtils(ctx);

                                // Update Hands
                                res.landmarks.forEach((lm, lIdx) => {
                                    if (!hfoState.hands[lIdx]) {
                                        hfoState.hands[lIdx] = {
                                            fsm: new GestureFSM(),
                                            filterX: new OneEuroFilter(30, 1.0, 0.01),
                                            filterY: new OneEuroFilter(30, 1.0, 0.01)
                                        };
                                    }
                                    const hand = hfoState.hands[lIdx];
                                    const gesture = res.gestures?.[lIdx]?.[0] || { categoryName: 'None', score: 0 };
                                    
                                    // P0 -> P6 Assimilate
                                    const fsmRes = hand.fsm.process(gesture.categoryName, now, gesture.score, true);
                                    
                                    // Visual Strategy: HEX_SHARD
                                    const rawX = lm[8].x;
                                    const rawY = lm[8].y;
                                    const x = hand.filterX.call(rawX, now) * canvas.width;
                                    const y = hand.filterY.call(rawY, now) * canvas.height;

                                    // Draw Skeleton if enabled
                                    if (hfoState.visuals.showSkeleton) {
                                        dw.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { color: "rgba(255, 255, 255, 0.1)", lineWidth: 1 });
                                    }

                                    // Draw Hex Shard
                                    ctx.beginPath();
                                    const size = fsmRes.state === 'PORT_7_POINTER_COMMIT' ? 20 : 12;
                                    for (let i = 0; i < 6; i++) {
                                        const angle = (i * Math.PI) / 3;
                                        const hx = x + size * Math.cos(angle);
                                        const hy = y + size * Math.sin(angle);
                                        if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
                                    }
                                    ctx.closePath();
                                    ctx.strokeStyle = fsmRes.state === 'PORT_7_POINTER_COMMIT' ? '#ff0000' : '#ffffff';
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                    
                                    if (hfoState.debug) {
                                        ctx.fillStyle = '#fff';
                                        ctx.font = '10px Roboto Mono';
                                        ctx.fillText(`${fsmRes.state} (${gesture.score.toFixed(2)})`, x + 15, y);
                                    }
                                });
                            }
                        } catch (e) {
                            console.error("Render Loop Error:", e);
                        }
                    }
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            };
            render();
        };

        const initExcalidraw = (container) => {
            const iframe = document.createElement('iframe');
            iframe.src = 'https://excalidraw.com?embed=1&theme=dark';
            iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
            iframe.style.opacity = hfoState.visuals.excalidrawOpacity;
            container.appendChild(iframe);
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });
            gui.add(hfoState.visuals, 'excalidrawOpacity', 0, 1).name('Opacity');
            gui.add(hfoState, 'debug').name('Debug Mode');
            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    { type: 'component', componentType: 'Excalidraw', title: 'HERO', width: 70 },
                    {
                        type: 'column', width: 30, content: [
                            { type: 'component', componentType: 'Settings', title: 'SETTINGS', height: 40 },
                            { type: 'component', componentType: 'MediaPipe', title: 'VIDEO', height: 60 }
                        ]
                    }
                ]
            }
        };

        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.loadLayout(config);
        window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>
