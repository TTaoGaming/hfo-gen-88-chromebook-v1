<!-- Medallion: Bronze | Mutation: 88% | HIVE: I -->
<!-- OMEGA GEN 4 V23.1 - PHOENIX REBIRTH (BABYLON + PIXI HYBRID) -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN 4 | V23.1 BABYLON REBIRTH</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 1000;
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        /* ðŸ“œ SECURED SCROLLING PANEL */
        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15; /* Above Pixi/Babylon Juice (10) */
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        /* ðŸ’Ž M3 INTEGRATION */
        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }
    </style>

    <!-- BabylonJS External Scripts (v7.x Stable) -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA V23.1 - PHOENIX REBIRTH]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm",
            "planck": "https://cdn.jsdelivr.net/npm/planck-js@0.3.31/+esm",
            "pixi": "https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/+esm"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';
        import * as PIXI from 'pixi';

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                minPresenceConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            palm: z.object({
                enterThreshold: z.number().min(0).max(1),
                exitThreshold: z.number().min(0).max(1)
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(100),
                hysteresisLow: z.number().min(0).max(100),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1),
                tensionMs: z.number().min(0),
                commitExitDelayMs: z.number().min(0)
            }),
            coasting: z.object({
                timeoutMs: z.number().min(0),
                confidenceThreshold: z.number().min(0).max(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(),
                directProjectionOffset: z.number().min(0),
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']),
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                oneEuroRodMinCutoff: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                palmRodMultiplier: z.number().min(0.5).max(10),
                showLaserBeam: z.boolean(),
                predictiveLookahead: z.number().min(0)
            }),
            anatomy: z.object({
                palmWidthCm: z.number().min(3).max(15),
                rodExtensionMultiplier: z.number().min(0.1).max(10)
            }),
            excalidraw: z.object({
                opacity: z.number().min(0).max(1),
                enabled: z.boolean(),
                activeTool: z.string()
            }),
            visuals: z.object({
                engine: z.enum(['PIXI', 'BABYLON'])
            })
        });

        const LandmarkSchema = z.object({
            x: z.number(),
            y: z.number(),
            z: z.number()
        });

        const FusionSchema = z.object({
            screenX: z.number(),
            screenY: z.number(),
            normX: z.number(),
            normY: z.number(),
            rawX: z.number(),
            rawY: z.number(),
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(),
            confidence: z.number(),
            isPalmFacing: z.boolean(),
            normalZ: z.number(), 
            palmConeAngle: z.number(), 
            palmNormal: z.object({
                x: z.number(),
                y: z.number(),
                z: z.number()
            }),
            bucketLevel: z.number(),
            handIndex: z.number(),
            curls: z.object({
                index: z.number(),
                middle: z.number(),
                ring: z.number(),
                pinky: z.number()
            }),
            timestamp: z.number().optional()
        });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        // --- PRODUCTION STATE ---
        const systemState = {
            parameters: {
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                landmarks: { minConfidence: 0.5, minTrackingConfidence: 0.5, minPresenceConfidence: 0.5, numHands: 2, showSkeleton: true },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.80, exitThreshold: 0.64 },
                fsm: {
                    hysteresisHigh: 80,
                    hysteresisLow: 64,
                    chargeTimeMs: 266,
                    releaseTimeMs: 200,
                    coastDrainTimeMs: 1200,
                    tensionMs: 100,
                    commitExitDelayMs: 250
                },
                coasting: { timeoutMs: 150, confidenceThreshold: 0.4 },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true,
                    directProjectionOffset: 0.04,
                    cursorTheme: 'LI',
                    oneEuroMinCutoff: 0.85, 
                    oneEuroBeta: 0.02,
                    oneEuroRodMinCutoff: 0.8,
                    planckStiffness: 4.5,
                    planckDamping: 1.2, 
                    palmRodMultiplier: 0.64,
                    showLaserBeam: true,
                    predictiveLookahead: 0.5
                },
                anatomy: {
                    palmWidthCm: 8,
                    rodExtensionMultiplier: 0.125
                },
                excalidraw: {
                    opacity: 0.8,
                    enabled: true,
                    activeTool: 'draw'
                },
                visuals: {
                    engine: 'BABYLON'
                },
                p0Active: false,
                devMode: false
            },
            fsm: {
                currentState: 'IDLE',
                lastState: 'IDLE',
                lastCommitTime: 0,
                commitExitStartTime: 0,
                primaryHandIndex: null,
                nematocystTargetLock: null,
                lastTarget: null
            },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [],
                buckets: [0, 0, 0, 0], 
                fsmStates: ['IDLE', 'IDLE', 'IDLE', 'IDLE'], 
                palmFacingStates: [false, false, false, false], 
                lastPalmFacingTimes: [0, 0, 0, 0], 
                lastData: [null, null, null, null], 
                coastStartTimes: [0, 0, 0, 0], 
                filters: [null, null, null, null], 
                rodFilters: [null, null, null, null], 
                anchorFilters: [null, null, null, null], 
                directionFilters: [null, null, null, null], 
                physicsState: [null, null, null, null] 
            },
            ui: { gestures: null, palm: null, palmCtx: null, fsm: null, fsmCtx: null, juiceLayers: [], excalidrawOverlay: null, excalidrawIframe: null },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
        };

        // --- P4: BABYLON JUICE SUBSTRATE (Phoenix Core) ---
        class BabylonJuiceSubstrate {
            constructor(container) {
                this.canvas = document.createElement('canvas');
                this.canvas.style.width = '100%'; this.canvas.style.height = '100%';
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true, { alpha: true });
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                this.camera = new BABYLON.FreeCamera("juiceweb", new BABYLON.Vector3(0, 0, -5), this.scene);
                this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                this.setOrtho();

                this.emitters = [];
                this.engine.runRenderLoop(() => { 
                    if(systemState.parameters.visuals.engine === 'BABYLON') this.scene.render(); 
                });
                window.addEventListener("resize", () => { this.engine.resize(); this.setOrtho(); });
            }

            setOrtho() {
                const aspect = this.engine.getRenderWidth() / this.engine.getRenderHeight();
                const vSize = 2.5;
                this.camera.orthoTop = vSize; this.camera.orthoBottom = -vSize;
                this.camera.orthoLeft = -vSize * aspect; this.camera.orthoRight = vSize * aspect;
            }

            createPhoenixCore(handIndex) {
                const emitter = BABYLON.MeshBuilder.CreateSphere("emitter-" + handIndex, { diameter: 0.01 }, this.scene);
                emitter.isVisible = false;
                const fire = new BABYLON.ParticleSystem("fire-" + handIndex, 2000, this.scene);
                fire.particleTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/flare.png", this.scene);
                fire.emitter = emitter;
                fire.color1 = new BABYLON.Color4(1.0, 0.6, 0.2, 1.0);
                fire.color2 = new BABYLON.Color4(1.0, 0.2, 0.0, 1.0);
                fire.colorDead = new BABYLON.Color4(0.2, 0, 0, 0.0);
                fire.minSize = 0.1; fire.maxSize = 0.4;
                fire.emitRate = 0;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(0, 5, 0);
                fire.start();
                return { emitter, fire };
            }

            update(cursors) {
                const isBabylon = systemState.parameters.visuals.engine === 'BABYLON';
                this.canvas.style.display = isBabylon ? 'block' : 'none';
                if (!isBabylon) return;

                const aspect = this.engine.getRenderWidth() / this.engine.getRenderHeight();
                const vSize = 2.5;

                cursors.forEach((c, i) => {
                    if (!this.emitters[i]) this.emitters[i] = this.createPhoenixCore(i);
                    const { emitter, fire } = this.emitters[i];
                    const x = (c.normX * 2 - 1) * vSize * aspect;
                    const y = -(c.normY * 2 - 1) * vSize;
                    emitter.position.set(x, y, 0);

                    if (c.fsmState === 'COMMIT') {
                        fire.emitRate = 1200;
                        fire.minSize = 0.2; fire.maxSize = 0.8;
                    } else if (c.fsmState === 'READY' || c.fsmState === 'COAST') {
                        fire.emitRate = 400;
                        fire.minSize = 0.1; fire.maxSize = 0.3;
                    } else {
                        fire.emitRate = 0;
                    }
                });
            }

            resize() { this.engine.resize(); this.setOrtho(); }
        }

        // --- P4: PIXI JUICE SUBSTRATE (V21.1 LEGACY) ---
        function createGlowTexture(size, color) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const center = size / 2;
            const grad = ctx.createRadialGradient(center, center, 0, center, center, size/2);
            const r = (color >> 16) & 0xFF;
            const g = (color >> 8) & 0xFF;
            const b = color & 0xFF;
            grad.addColorStop(0, `rgba(${r},${g},${b}, 1)`);
            grad.addColorStop(0.3, `rgba(${r},${g},${b}, 0.5)`);
            grad.addColorStop(1, `rgba(${r},${g},${b}, 0)`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
            return PIXI.Texture.from(canvas);
        }

        class JuiceEffect {
            constructor(parent) {
                this.container = new PIXI.Container();
                parent.addChild(this.container);
                this.texGold = createGlowTexture(128, 0xFFCC00);
                this.texRed = createGlowTexture(128, 0xFF4500);
                this.texCore = createGlowTexture(64, 0xFFFFFF);
                this.readyLayers = new PIXI.Container();
                for(let i=0; i<4; i++) {
                    const s = new PIXI.Sprite(this.texGold);
                    s.anchor.set(0.5); s.blendMode = PIXI.BLEND_MODES.ADD;
                    this.readyLayers.addChild(s);
                }
                this.container.addChild(this.readyLayers);
                this.commitLayers = new PIXI.Container();
                for(let i=0; i<6; i++) {
                    const s = new PIXI.Sprite(i < 4 ? this.texRed : this.texCore);
                    s.anchor.set(0.5, 0.85); s.blendMode = PIXI.BLEND_MODES.ADD;
                    this.commitLayers.addChild(s);
                }
                this.container.addChild(this.commitLayers);
                this.sparks = new PIXI.ParticleContainer(100, { position: true, alpha: true, scale: true });
                this.container.addChild(this.sparks);
                this.timer = 0;
            }

            update(x, y, state) {
                this.timer += 0.05;
                this.container.position.set(x, y);
                const isReady = (state === 'READY' || state === 'COMMIT' || state === 'COAST');
                const isCommit = (state === 'COMMIT');
                this.readyLayers.visible = isReady && !isCommit;
                this.commitLayers.visible = isCommit;
                if (isReady && !isCommit) {
                    this.readyLayers.children.forEach((s, i) => {
                        const phase = this.timer + i * 0.8;
                        s.scale.set(1.2 + Math.sin(phase * 0.8) * 0.3);
                        s.rotation = this.timer * (0.5 + i * 0.1) * (i % 2 === 0 ? 1 : -1);
                        s.alpha = 0.4 + Math.sin(phase * 1.5) * 0.2;
                    });
                }
                if (isCommit) {
                    this.commitLayers.children.forEach((s, i) => {
                        const phase = this.timer * 2.0 + i * 0.5;
                        s.x = Math.sin(phase * 0.7) * (i * 3);
                        s.scale.x = 0.6 + Math.sin(phase) * 0.2;
                        s.scale.y = 1.8 + Math.cos(phase * 1.3) * 0.6;
                        s.alpha = (1.0 - (i/10)) * 0.8;
                    });
                }
                if (isReady && Math.random() > 0.8) this.emitSpark(isCommit);
                this.updateSparks();
            }

            emitSpark(isCommit) {
                const s = new PIXI.Sprite(PIXI.Texture.WHITE);
                s.width = s.height = 2; s.tint = isCommit ? 0xFF4500 : 0xFFD700;
                s.anchor.set(0.5); s.vx = (Math.random() - 0.5) * 4; s.vy = -4 - Math.random() * 6;
                s.life = 1.0; s.decay = 0.02 + Math.random() * 0.03;
                this.sparks.addChild(s);
            }

            updateSparks() {
                for (let i = this.sparks.children.length - 1; i >= 0; i--) {
                    const s = this.sparks.children[i];
                    s.x += s.vx; s.y += s.vy; s.vy += 0.08; s.life -= s.decay; s.alpha = s.life;
                    s.scale.set(s.life);
                    if (s.life <= 0) this.sparks.removeChild(s);
                }
            }
        }

        class JuiceSubstrate {
            constructor(container) {
                this.container = container;
                this.app = new PIXI.Application({
                    resizeTo: container,
                    backgroundAlpha: 0,
                    antialias: true
                });
                container.appendChild(this.app.view);
                this.effects = [];
            }

            update(cursors) {
                const isPixi = systemState.parameters.visuals.engine === 'PIXI';
                this.container.style.display = isPixi ? 'block' : 'none';
                if (!isPixi) return;

                const { width, height } = this.app.renderer;
                cursors.forEach((c, i) => {
                    if (!this.effects[i]) this.effects[i] = new JuiceEffect(this.app.stage);
                    const px = c.normX * width;
                    const py = c.normY * height;
                    this.effects[i].container.visible = true;
                    this.effects[i].update(px, py, c.fsmState);
                });
                for (let i = cursors.length; i < this.effects.length; i++) {
                    if (this.effects[i]) this.effects[i].container.visible = false;
                }
            }

            resize(width, height) { this.app.renderer.resize(width, height); }
        }

        // --- P2: PHYSICS ---
        class PlanckPhysicsAdapter {
            constructor(stiffness = 5.0, damping = 0.7) {
                this.SCALE = 100.0;
                this.world = planck.World({ gravity: planck.Vec2(0, 0) });
                this.cursor = this.world.createBody({ type: 'dynamic', position: planck.Vec2(0, 0), linearDamping: 5.0 });
                this.cursor.createFixture(planck.Circle(0.1), { density: 1.0 });
                this.target = this.world.createBody({ type: 'kinematic', position: planck.Vec2(0, 0) });
                this.joint = this.world.createJoint(planck.DistanceJoint({
                    bodyA: this.target, bodyB: this.cursor, frequencyHz: stiffness, dampingRatio: damping, length: 0
                }));
                this.lastPos = { x: 0, y: 0 };
            }
            update(tx, ty, dt) {
                this.target.setPosition(planck.Vec2(tx / this.SCALE, ty / this.SCALE));
                this.world.step(Math.min(dt / 1000, 0.033));
                const pos = this.cursor.getPosition();
                this.lastPos = { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
                return this.lastPos;
            }
            setParams(p) { this.joint.setFrequency(p.stiffness); this.joint.setDampingRatio(p.dampingRatio); }
            reset(x, y) { this.cursor.setPosition(planck.Vec2(x / this.SCALE, y / this.SCALE)); }
            getTelemetry() { return { speed: this.cursor.getLinearVelocity().length() * this.SCALE }; }
        }

        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.0) { this.minCutoff = minCutoff; this.beta = beta; this.xPrev = null; this.dxPrev = 0; }
            filter(x, rate = 30) {
                if (this.xPrev === null) { this.xPrev = x; return x; }
                const dx = (x - this.xPrev) * rate;
                const a = this.alpha(rate, this.minCutoff + this.beta * Math.abs(this.dxPrev));
                const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat; this.dxPrev = dx; return xHat;
            }
            alpha(r, c) { const tau = 1.0 / (2 * Math.PI * c); return 1.0 / (1.0 + tau / (1.0 / r)); }
        }

        // --- P1 BRIDGER ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]], b = landmarks[indices[i+1]], c = landmarks[indices[i+2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                    const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (Math.sqrt(v1.x**2+v1.y**2+v1.z**2) * Math.sqrt(v2.x**2+v2.y**2+v2.z**2) || 1e-6);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static validateConfig(config) { try { return ConfigSchema.parse(config); } catch (e) { return null; } }

            static fuse(results, dt) {
                const cursors = [];
                const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;
                const isMirror = systemState.parameters.camera.mirror;

                for (let i = 0; i < numHands; i++) {
                    const landmarks = results.landmarks?.[i];
                    const bestGesture = results.gestures?.[i]?.[0];
                    if (landmarks) {
                        const { width, height } = systemState.p0.videoBounds || { width: 1280, height: 720 };
                        const lm = landmarks;
                        const p5 = lm[5], p17 = lm[17], p0_palm = lm[0];
                        const span = Math.sqrt((p5.x-p17.x)**2 + (p5.y-p17.y)**2 + (p5.z-p17.z)**2) || 1e-6;
                        const v1 = { x: p5.x-p0_palm.x, y: p5.y-p0_palm.y, z: p5.z-p0_palm.z };
                        const v2 = { x: p17.x-p0_palm.x, y: p17.y-p0_palm.y, z: p17.z-p0_palm.z };
                        const cp = { x: v1.y*v2.z-v1.z*v2.y, y: v1.z*v2.x-v1.x*v2.z, z: v1.x*v2.y-v1.y*v2.x };
                        const mag = Math.sqrt(cp.x**2 + cp.y**2 + cp.z**2) || 1;
                        const nz = Math.abs(cp.z / mag);
                        
                        if (!systemState.p1.rodFilters[i]) systemState.p1.rodFilters[i] = new OneEuroFilter(0.8, 0.02);
                        const rod = systemState.p1.rodFilters[i].filter(span * systemState.parameters.anatomy.rodExtensionMultiplier);
                        
                        const tip = lm[8], mcp = lm[5];
                        const d = { x: tip.x-mcp.x, y: tip.y-mcp.y, z: tip.z-mcp.z };
                        const dmag = Math.sqrt(d.x**2 + d.y**2 + d.z**2) || 1e-6;
                        const proj = { x: tip.x + (d.x/dmag)*rod, y: tip.y + (d.y/dmag)*rod };
                        
                        const normX = isMirror ? (1.0 - proj.x) : proj.x;
                        const tipX = isMirror ? (1.0 - tip.x) : tip.x;
                        const screenX = normX * width, screenY = proj.y * height;
                        
                        if (!systemState.p1.filters[i]) {
                            systemState.p1.filters[i] = { x: new OneEuroFilter(0.85, 0.02), y: new OneEuroFilter(0.85, 0.02) };
                            systemState.p1.anchorFilters[i] = { x: new OneEuroFilter(0.85, 0.02), y: new OneEuroFilter(0.85, 0.02) };
                        }
                        const smoothedX = systemState.p1.filters[i].x.filter(screenX);
                        const smoothedY = systemState.p1.filters[i].y.filter(screenY);
                        const anchorX = systemState.p1.anchorFilters[i].x.filter(tipX * width);
                        const anchorY = systemState.p1.anchorFilters[i].y.filter(tip.y * height);

                        // FSM Logic
                        let facing = systemState.p1.palmFacingStates[i];
                        if (!facing && nz > 0.8) facing = true; else if (facing && nz < 0.64) facing = false;
                        systemState.p1.palmFacingStates[i] = facing;
                        if (facing) systemState.p1.lastPalmFacingTimes[i] = now;

                        const isPointing = bestGesture?.categoryName === 'Pointing_Up' && bestGesture?.score > 0.7;
                        const charging = facing || (now - systemState.p1.lastPalmFacingTimes[i] < 100);
                        if (charging) systemState.p1.buckets[i] = Math.min(100, systemState.p1.buckets[i] + (100/266)*dt);
                        else systemState.p1.buckets[i] = Math.max(0, systemState.p1.buckets[i] - (100/200)*dt);

                        let state = systemState.p1.fsmStates[i];
                        const b = systemState.p1.buckets[i];
                        if (state === 'IDLE') { if(b >= 80) state = 'READY'; }
                        else if (state === 'READY') { if(b <= 64) state = 'IDLE'; else if(isPointing && facing) state = 'COMMIT'; }
                        else if (state === 'COMMIT') { if(b <= 64) state = 'IDLE'; else if(bestGesture?.score < 0.4) state = 'COAST'; }
                        else if (state === 'COAST') { if(b <= 64) state = 'IDLE'; else if(bestGesture?.score > 0.4 && facing) state = (isPointing ? 'COMMIT' : 'READY'); }
                        systemState.p1.fsmStates[i] = state;

                        const cursor = {
                            screenX: smoothedX, screenY: smoothedY, normX, normY: proj.y, rawX: anchorX, rawY: anchorY,
                            fsmState: state, gesture: bestGesture?.categoryName || 'None', confidence: bestGesture?.score || 0,
                            isPalmFacing: facing, normalZ: nz, palmConeAngle: Math.acos(Math.min(1, nz)), handIndex: i, bucketLevel: b,
                            palmNormal: { x: cp.x/mag, y: cp.y/mag, z: nz },
                            curls: { index: this.calculateCurl(lm, [5,6,7,8]), middle: this.calculateCurl(lm, [9,10,11,12]), ring: this.calculateCurl(lm, [13,14,15,16]), pinky: this.calculateCurl(lm, [17,18,19,20]) }
                        };
                        cursors.push(FusionSchema.parse(cursor));
                        systemState.p1.lastData[i] = cursor;
                    }
                }
                systemState.dataFabric = DataFabricSchema.parse({ cursors, systemTime: now, frameId: (systemState.dataFabric.frameId || 0) + 1 });
                systemState.p1.cursors = systemState.dataFabric.cursors;
                return cursors;
            }
        }

        // --- CORE LOOP ---
        async function initP0() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: 'GPU' },
                runningMode: "VIDEO", numHands: 2
            });
        }

        let lastFrame = performance.now();
        function predictLoop() {
            if (!systemState.parameters.p0Active) return;
            const now = performance.now(); const dt = now - lastFrame; lastFrame = now;
            const results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
            P1Bridger.fuse(results, dt);
            drawResults(results, systemState.dataFabric);
            updateVisualPanels(results);
            w3cPointerNematocystInjector();
            systemState.ui.juiceLayers.forEach(j => j.update(systemState.dataFabric.cursors));
            requestAnimationFrame(predictLoop);
        }

        // --- P3 INJECTOR ---
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            if (cursors.length === 0) return;
            const v = systemState.p0.video; const rect = v.getBoundingClientRect();
            const c = cursors.find(c => c.fsmState === 'COMMIT') || cursors[0];
            const vx = rect.left + (c.screenX / (systemState.p0.videoBounds?.width || 1280)) * rect.width;
            const vy = rect.top + (c.screenY / (systemState.p0.videoBounds?.height || 720)) * rect.height;
            const isDown = c.fsmState === 'COMMIT';
            const target = document.elementFromPoint(vx, vy) || document.body;
            const eventInit = { bubbles: true, cancelable: true, pointerId: 1, pointerType: 'mouse', clientX: vx, clientY: vy, buttons: isDown ? 1 : 0 };
            
            if (target !== systemState.fsm.lastTarget) {
                if (systemState.fsm.lastTarget) systemState.fsm.lastTarget.dispatchEvent(new PointerEvent('pointerout', eventInit));
                target.dispatchEvent(new PointerEvent('pointerover', eventInit));
                systemState.fsm.lastTarget = target;
            }
            if (isDown && systemState.fsm.lastState !== 'COMMIT') {
                target.dispatchEvent(new PointerEvent('pointerdown', eventInit));
                setTimeout(() => target.click(), 10);
            } else if (!isDown && systemState.fsm.lastState === 'COMMIT') {
                target.dispatchEvent(new PointerEvent('pointerup', eventInit));
            }
            target.dispatchEvent(new PointerEvent('pointermove', eventInit));
            systemState.fsm.lastState = c.fsmState;
        }

        // --- UI DRAWING & PANELS ---
        function drawSparkline(ctx, x, y, w, h, data, color) {
            ctx.strokeStyle = color; ctx.beginPath();
            data.forEach((v, i) => { const px = x + i * (w/data.length), py = y + h - (v*h); if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py); });
            ctx.stroke();
        }

        function drawResults(raw, fabric) {
            const { ctx, canvas } = systemState.p0; if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (systemState.parameters.landmarks.showSkeleton && raw.landmarks) {
                const utils = new DrawingUtils(ctx);
                raw.landmarks.forEach(lms => {
                    const drawLms = systemState.parameters.camera.mirror ? lms.map(l => ({...l, x: 1-l.x})) : lms;
                    utils.drawConnectors(drawLms, GestureRecognizer.HAND_CONNECTIONS, { color: '#ffffff44', lineWidth: 1 });
                });
            }
            fabric.cursors.forEach(c => {
                if (c.fsmState === 'IDLE') return;
                ctx.beginPath(); ctx.arc(c.screenX, c.screenY, 8, 0, Math.PI*2);
                ctx.fillStyle = c.fsmState === 'COMMIT' ? '#ff4136' : '#ffd700'; ctx.fill();
            });
        }

        function updateVisualPanels(results) {
            if (systemState.ui.gestures) {
                let html = '';
                systemState.dataFabric.cursors.forEach(c => {
                    html += `<div class="m3-card">
                        <div class="m3-label">Hand ${c.handIndex} | ${c.fsmState}</div>
                        <div class="m3-stat"><span>Bucket</span><span>${c.bucketLevel.toFixed(1)}%</span></div>
                        <div class="m3-progress-container"><div class="m3-progress-bar" style="width:${c.bucketLevel}%"></div></div>
                    </div>`;
                });
                systemState.ui.gestures.innerHTML = html || 'No hands detected';
            }
            if (systemState.ui.palmCtx) {
                const ctx = systemState.ui.palmCtx, canvas = systemState.ui.palm;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                systemState.dataFabric.cursors.forEach((c, i) => {
                    const x = (i===0?0.25:0.75)*canvas.width, y = canvas.height*0.5;
                    ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI*2); ctx.strokeStyle = '#333'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(x + c.palmNormal.x*30, y + c.palmNormal.y*30, 5, 0, Math.PI*2); 
                    ctx.fillStyle = c.isPalmFacing ? '#00ff41' : '#ff4136'; ctx.fill();
                });
            }
        }

        // --- LAYOUT ---
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('hero', (container) => {
            const wrap = document.createElement('div'); wrap.className = 'component-container';
            wrap.innerHTML = `<div class="hero-view-container">
                <video id="video-feed" autoplay playsinline></video>
                <div id="babylon-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:9;"></div>
                <div id="pixi-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:10;"></div>
                <canvas id="overlay-canvas" style="z-index:11;"></canvas>
                <button id="btn-ignite" class="hfo-btn" style="position:absolute; bottom:30px; z-index:20;">IGNITE</button>
            </div>`;
            container.getElement().appendChild(wrap);
            systemState.p0.video = wrap.querySelector('#video-feed');
            systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
            systemState.p0.ctx = systemState.p0.canvas.getContext('2d');
            
            const pixiLayer = new JuiceSubstrate(wrap.querySelector('#pixi-juice-overlay'));
            const babylonLayer = new BabylonJuiceSubstrate(wrap.querySelector('#babylon-juice-overlay'));
            systemState.ui.juiceLayers.push(pixiLayer, babylonLayer);

            wrap.querySelector('#btn-ignite').onclick = async () => {
                await initP0();
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                systemState.p0.video.srcObject = stream;
                systemState.p0.video.onloadeddata = () => { systemState.parameters.p0Active = true; predictLoop(); };
                wrap.querySelector('#btn-ignite').style.display = 'none';
            };
        });

        layout.registerComponentFactoryFunction('navigator', (container) => {
            const gui = new GUI({ container: container.getElement(), title: 'NAVIGATOR' });
            gui.add(systemState.parameters.visuals, 'engine', ['PIXI', 'BABYLON']).name('Visual Engine');
            gui.add(systemState.parameters.camera, 'mirror').name('Mirror Mode');
        });

        layout.registerComponentFactoryFunction('gestures', (container) => {
            const div = document.createElement('div'); div.className = 'scrollable-panel';
            container.getElement().appendChild(div); systemState.ui.gestures = div;
        });

        layout.registerComponentFactoryFunction('palm', (container) => {
            const canvas = document.createElement('canvas'); canvas.style.width = '100%'; canvas.style.height = '100%';
            container.getElement().appendChild(canvas); systemState.ui.palm = canvas; systemState.ui.palmCtx = canvas.getContext('2d');
        });

        layout.loadLayout({
            root: { type: 'row', content: [
                { type: 'component', componentType: 'hero', title: 'Main View', width: 70 },
                { type: 'column', content: [
                    { type: 'component', componentType: 'gestures', title: 'Gestures' },
                    { type: 'component', componentType: 'palm', title: 'Palm' },
                    { type: 'component', componentType: 'navigator', title: 'Config' }
                ]}
            ]}
        });

        window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>
</html>
