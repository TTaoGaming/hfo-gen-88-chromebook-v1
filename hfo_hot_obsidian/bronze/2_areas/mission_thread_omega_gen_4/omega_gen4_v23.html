<!-- Medallion: Bronze | Mutation: 88% | HIVE: I -->
<!-- OMEGA GEN 4 V23 - BABYLON.JS REBIRTH (FEATURE PARITY CLONE OF V21.1) -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN 4 | V23 PHOENIX REBIRTH (BABYLON)</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 1000;
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            width: 100%;
            height: 100%;
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }
    </style>
    
    <!-- BabylonJS External Scripts (v7.x Stable) -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA V23 - BABYLON REBIRTH]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm",
            "planck": "https://cdn.jsdelivr.net/npm/planck-js@0.3.31/+esm",
            "pixi": "https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/+esm"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';
        import * as PIXI from 'pixi';

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(100),
                hysteresisLow: z.number().min(0).max(100),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(),
                directProjectionOffset: z.number().min(0),
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']),
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                showLaserBeam: z.boolean()
            }),
            excalidraw: z.object({
                opacity: z.number().min(0).max(1),
                enabled: z.boolean()
            }),
            visuals: z.object({
                engine: z.enum(['PIXI', 'BABYLON'])
            })
        }).partial();

        const LandmarkSchema = z.object({ x: z.number(), y: z.number(), z: z.number() });
        const FusionSchema = z.object({
            screenX: z.number(), screenY: z.number(),
            normX: z.number(), normY: z.number(),
            rawX: z.number(), rawY: z.number(),
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(), confidence: z.number(),
            isPalmFacing: z.boolean(), normalZ: z.number(),
            palmNormal: z.object({ x: z.number(), y: z.number(), z: z.number() }),
            bucketLevel: z.number(), handIndex: z.number(),
            curls: z.object({ index: z.number(), middle: z.number(), ring: z.number(), pinky: z.number() }),
            timestamp: z.number().optional()
        });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        const systemState = {
            parameters: {
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                landmarks: { minConfidence: 0.5, numHands: 2, showSkeleton: true },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.80, exitThreshold: 0.64 },
                fsm: {
                    hysteresisHigh: 80, hysteresisLow: 64,
                    chargeTimeMs: 266, releaseTimeMs: 200, coastDrainTimeMs: 1200,
                    tensionMs: 100, commitExitDelayMs: 250
                },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true,
                    directProjectionOffset: 0.04,
                    cursorTheme: 'LI',
                    oneEuroMinCutoff: 0.85, oneEuroBeta: 0.02,
                    planckStiffness: 4.5, planckDamping: 1.2,
                    showLaserBeam: true
                },
                anatomy: { palmWidthCm: 8, rodExtensionMultiplier: 0.125 },
                excalidraw: { opacity: 0.8, enabled: true, activeTool: 'draw' },
                visuals: { engine: 'BABYLON' }, // FEATURE FLAG
                p0Active: false, devMode: false
            },
            fsm: { currentState: 'IDLE', lastState: 'IDLE', primaryHandIndex: null, nematocystTargetLock: null, lastTarget: null },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [], buckets: [0, 0], fsmStates: ['IDLE', 'IDLE'],
                palmFacingStates: [false, false], lastPalmFacingTimes: [0, 0],
                filters: [null, null], rodFilters: [null, null], anchorFilters: [null, null], directionFilters: [null, null],
                physicsState: [null, null], lastData: [null, null]
            },
            ui: { gestures: null, palm: null, palmCtx: null, fsm: null, fsmCtx: null, juiceLayers: [], excalidrawOverlay: null, excalidrawIframe: null },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
        };

        // --- P4: BABYLON JUICE SUBSTRATE (Phoenix Core) ---
        class BabylonJuiceSubstrate {
            constructor(container) {
                this.canvas = document.createElement('canvas');
                this.canvas.style.width = '100%'; this.canvas.style.height = '100%';
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true, { alpha: true });
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                this.camera = new BABYLON.FreeCamera("juiceweb", new BABYLON.Vector3(0, 0, -5), this.scene);
                this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                this.setOrtho();

                this.emitters = [];
                this.engine.runRenderLoop(() => { if(systemState.parameters.visuals.engine === 'BABYLON') this.scene.render(); });
                window.addEventListener("resize", () => { this.engine.resize(); this.setOrtho(); });
            }

            setOrtho() {
                const aspect = this.engine.getRenderWidth() / this.engine.getRenderHeight();
                const vSize = 2.5;
                this.camera.orthoTop = vSize; this.camera.orthoBottom = -vSize;
                this.camera.orthoLeft = -vSize * aspect; this.camera.orthoRight = vSize * aspect;
            }

            createPhoenixCore(handIndex) {
                const emitter = BABYLON.MeshBuilder.CreateSphere("emitter-" + handIndex, { diameter: 0.01 }, this.scene);
                emitter.isVisible = false;
                const fire = new BABYLON.ParticleSystem("fire-" + handIndex, 2000, this.scene);
                fire.particleTexture = new BABYLON.Texture("https://playground.babylonjs.com/textures/flare.png", this.scene);
                fire.emitter = emitter;
                fire.color1 = new BABYLON.Color4(1.0, 0.6, 0.2, 1.0);
                fire.color2 = new BABYLON.Color4(1.0, 0.2, 0.0, 1.0);
                fire.colorDead = new BABYLON.Color4(0.2, 0, 0, 0.0);
                fire.minSize = 0.1; fire.maxSize = 0.4;
                fire.emitRate = 0;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(0, 5, 0);
                fire.start();
                return { emitter, fire };
            }

            update(cursors) {
                this.canvas.style.display = systemState.parameters.visuals.engine === 'BABYLON' ? 'block' : 'none';
                if (systemState.parameters.visuals.engine !== 'BABYLON') return;

                const aspect = this.engine.getRenderWidth() / this.engine.getRenderHeight();
                const vSize = 2.5;

                cursors.forEach((c, i) => {
                    if (!this.emitters[i]) this.emitters[i] = this.createPhoenixCore(i);
                    const { emitter, fire } = this.emitters[i];
                    const x = (c.normX * 2 - 1) * vSize * aspect;
                    const y = -(c.normY * 2 - 1) * vSize;
                    emitter.position.set(x, y, 0);

                    if (c.fsmState === 'COMMIT') {
                        fire.emitRate = 1200;
                        fire.minSize = 0.2; fire.maxSize = 0.8;
                    } else if (c.fsmState === 'READY' || c.fsmState === 'COAST') {
                        fire.emitRate = 400;
                        fire.minSize = 0.1; fire.maxSize = 0.3;
                    } else {
                        fire.emitRate = 0;
                    }
                });
            }
            resize(w, h) { this.engine.resize(); this.setOrtho(); }
        }

        // --- P4: PIXI JUICE SUBSTRATE (V21.1 LEGACY) ---
        function createGlowTexture(size, color) {
            const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'); const center = size / 2;
            const grad = ctx.createRadialGradient(center, center, 0, center, center, size/2);
            const r = (color >> 16) & 0xFF; const g = (color >> 8) & 0xFF; const b = color & 0xFF;
            grad.addColorStop(0, `rgba(${r},${g},${b}, 1)`); grad.addColorStop(1, `rgba(${r},${g},${b}, 0)`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
            return PIXI.Texture.from(canvas);
        }

        class JuiceEffect {
            constructor(parent) {
                this.container = new PIXI.Container(); parent.addChild(this.container);
                this.texGold = createGlowTexture(128, 0xFFCC00); this.texRed = createGlowTexture(128, 0xFF4500);
                this.readyLayers = new PIXI.Container(); for(let i=0; i<4; i++) { const s = new PIXI.Sprite(this.texGold); s.anchor.set(0.5); s.blendMode = PIXI.BLEND_MODES.ADD; this.readyLayers.addChild(s); }
                this.commitLayers = new PIXI.Container(); for(let i=0; i<6; i++) { const s = new PIXI.Sprite(0xFFFFFF); s.anchor.set(0.5, 0.85); s.blendMode = PIXI.BLEND_MODES.ADD; this.commitLayers.addChild(s); }
                this.container.addChild(this.readyLayers, this.commitLayers);
                this.timer = 0;
            }
            update(x, y, state) {
                this.timer += 0.05; this.container.position.set(x, y);
                this.readyLayers.visible = (state === 'READY' || state === 'COAST');
                this.commitLayers.visible = (state === 'COMMIT');
            }
        }

        class JuiceSubstrate {
            constructor(container) {
                this.app = new PIXI.Application({ resizeTo: container, backgroundAlpha: 0, antialias: true });
                container.appendChild(this.app.view); this.effects = [];
            }
            update(cursors) {
                this.app.view.style.display = systemState.parameters.visuals.engine === 'PIXI' ? 'block' : 'none';
                if (systemState.parameters.visuals.engine !== 'PIXI') return;
                const { width, height } = this.app.renderer;
                cursors.forEach((c, i) => {
                    if (!this.effects[i]) this.effects[i] = new JuiceEffect(this.app.stage);
                    this.effects[i].container.visible = true;
                    this.effects[i].update(c.normX * width, c.normY * height, c.fsmState);
                });
            }
            resize(w, h) { this.app.renderer.resize(w, h); }
        }

        // --- P2: PHYSICS & FILTERS ---
        class PlanckPhysicsAdapter {
            constructor(stiffness = 5.0, damping = 0.7) {
                this.SCALE = 100.0; this.world = planck.World();
                this.cursor = this.world.createBody({ type: 'dynamic', linearDamping: 5.0 });
                this.target = this.world.createBody({ type: 'kinematic' });
                this.joint = this.world.createJoint(planck.DistanceJoint({ bodyA: this.target, bodyB: this.cursor, frequencyHz: stiffness, dampingRatio: damping, length: 0 }));
            }
            update(tx, ty, dt) {
                this.target.setPosition(planck.Vec2(tx / this.SCALE, ty / this.SCALE));
                this.world.step(Math.min(dt / 1000, 0.033));
                const pos = this.cursor.getPosition(); return { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
            }
            setParams(p) { this.joint.setFrequency(p.stiffness); this.joint.setDampingRatio(p.damping); }
            reset(x, y) { const px = x / this.SCALE, py = y / this.SCALE; this.cursor.setPosition(planck.Vec2(px, py)); this.target.setPosition(planck.Vec2(px, py)); }
        }

        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.0) { this.minCutoff = minCutoff; this.beta = beta; this.xPrev = null; this.dxPrev = 0; }
            filter(x, rate = 30) {
                if (this.xPrev === null) { this.xPrev = x; return x; }
                const dx = (x - this.xPrev) * rate; const edx = this.alpha(rate, 1.0);
                const dxHat = edx * dx + (1 - edx) * this.dxPrev;
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(rate, cutoff); const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat; this.dxPrev = dxHat; return xHat;
            }
            alpha(rate, cutoff) { const tau = 1.0 / (2 * Math.PI * cutoff); return 1.0 / (1.0 + tau / (1.0 / rate)); }
        }

        // --- P1: BRIDGER FUSION ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]], b = landmarks[indices[i + 1]], c = landmarks[indices[i + 2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 }, v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (Math.sqrt(v1.x**2+v1.y**2+v1.z**2) * Math.sqrt(v2.x**2+v2.y**2+v2.z**2) || 1e-6);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static fuse(results, dt) {
                const cursors = []; const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;
                const { width, height } = systemState.p0.videoBounds || { width: 1280, height: 720 };

                for (let i = 0; i < numHands; i++) {
                    const lmRaw = results.landmarks?.[i];
                    if (lmRaw) {
                        const lm = lmRaw;
                        const tip = lm[8], mcp = lm[5], p17 = lm[17], palmBase = lm[0];
                        const span = Math.sqrt((mcp.x - p17.x)**2 + (mcp.y - p17.y)**2 + (mcp.z - p17.z)**2) || 1e-6;
                        
                        // Normal Vector
                        const v1 = { x: mcp.x - palmBase.x, y: mcp.y - palmBase.y, z: mcp.z - palmBase.z };
                        const v2 = { x: p17.x - palmBase.x, y: p17.y - palmBase.y, z: p17.z - palmBase.z };
                        const cp = { x: v1.y*v2.z-v1.z*v2.y, y: v1.z*v2.x-v1.x*v2.z, z: v1.x*v2.y-v1.y*v2.x };
                        const mag = Math.sqrt(cp.x**2+cp.y**2+cp.z**2) || 1;
                        const nz = Math.abs(cp.z/mag);
                        
                        let isFacing = systemState.p1.palmFacingStates[i];
                        if (!isFacing && nz > systemState.parameters.palm.enterThreshold) isFacing = true;
                        if (isFacing && nz < systemState.parameters.palm.exitThreshold) isFacing = false;
                        systemState.p1.palmFacingStates[i] = isFacing;

                        const isMirror = systemState.parameters.camera.mirror;
                        const tipX = isMirror ? (1.0 - tip.x) : tip.x;
                        const projX = isMirror ? (1.0 - (tip.x + (tip.x-mcp.x)*systemState.parameters.physics.directProjectionOffset)) : (tip.x + (tip.x-mcp.x)*systemState.parameters.physics.directProjectionOffset);
                        const projY = tip.y + (tip.y-mcp.y)*systemState.parameters.physics.directProjectionOffset;

                        if (!systemState.p1.filters[i]) systemState.p1.filters[i] = { x: new OneEuroFilter(0.85, 0.02), y: new OneEuroFilter(0.85, 0.02) };
                        const fx = systemState.p1.filters[i].x.filter(projX * width);
                        const fy = systemState.p1.filters[i].y.filter(projY * height);

                        if (!systemState.p1.anchorFilters[i]) systemState.p1.anchorFilters[i] = { x: new OneEuroFilter(0.85, 0.02), y: new OneEuroFilter(0.85, 0.02) };
                        const ax = systemState.p1.anchorFilters[i].x.filter(tipX * width);
                        const ay = systemState.p1.anchorFilters[i].y.filter(tip.y * height);

                        let finalX = fx, finalY = fy;
                        if (systemState.parameters.physics.mode === 'PLANCK_SPRING') {
                            if (!systemState.p1.physicsState[i]) { systemState.p1.physicsState[i] = new PlanckPhysicsAdapter(); systemState.p1.physicsState[i].reset(fx, fy); }
                            systemState.p1.physicsState[i].setParams({ stiffness: systemState.parameters.physics.planckStiffness, damping: systemState.parameters.physics.planckDamping });
                            const phys = systemState.p1.physicsState[i].update(fx, fy, dt);
                            finalX = phys.x; finalY = phys.y;
                        }

                        // FSM
                        const gesture = results.gestures?.[i]?.[0]?.categoryName || 'None';
                        const score = results.gestures?.[i]?.[0]?.score || 0;
                        const isPointing = gesture === 'Pointing_Up' && score > systemState.parameters.gestures.minGestureConfidence;
                        
                        let bucket = systemState.p1.buckets[i];
                        if (isFacing) systemState.p1.lastPalmFacingTimes[i] = now;
                        if (isFacing || (now - systemState.p1.lastPalmFacingTimes[i] < systemState.parameters.fsm.tensionMs)) bucket = Math.min(100, bucket + (100/systemState.parameters.fsm.chargeTimeMs)*dt);
                        else bucket = Math.max(0, bucket - (100/systemState.parameters.fsm.releaseTimeMs)*dt);
                        systemState.p1.buckets[i] = bucket;

                        let state = systemState.p1.fsmStates[i];
                        if (state === 'IDLE' && bucket >= systemState.parameters.fsm.hysteresisHigh) state = 'READY';
                        else if (state === 'READY' && bucket <= systemState.parameters.fsm.hysteresisLow) state = 'IDLE';
                        else if (state === 'READY' && isPointing && isFacing) { state = 'COMMIT'; systemState.fsm.primaryHandIndex = i; }
                        else if (state === 'COMMIT' && !isPointing) state = 'READY';
                        else if (state === 'COMMIT' && bucket <= systemState.parameters.fsm.hysteresisLow) { state = 'IDLE'; systemState.fsm.primaryHandIndex = null; }
                        systemState.p1.fsmStates[i] = state;

                        const cursor = {
                            screenX: finalX, screenY: finalY, normX: finalX / width, normY: finalY / height,
                            rawX: ax, rawY: ay, fsmState: state, gesture, confidence: score,
                            isPalmFacing: isFacing, normalZ: nz, palmNormal: { x: cp.x/mag, y: cp.y/mag, z: nz },
                            bucketLevel: bucket, handIndex: i, curls: { index: this.calculateCurl(lm, [5,6,7,8]), middle: 0, ring: 0, pinky: 0 },
                            timestamp: now
                        };
                        cursors.push(FusionSchema.parse(cursor));
                        systemState.p1.lastData[i] = cursor;
                    }
                }
                systemState.dataFabric = DataFabricSchema.parse({ cursors, systemTime: now, frameId: (systemState.dataFabric.frameId || 0) + 1 });
                if (cursors.length > 0) systemState.fsm.currentState = cursors[0].fsmState;
                return cursors;
            }
        }

        // --- P0: SENSE LOOP ---
        async function initP0() {
            logMission("P0: Initializing Shards...");
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: 'GPU' },
                runningMode: "VIDEO", numHands: 2
            });
            logMission("âœ… P0: Sensing Cluster Online");
        }

        let lastFrameTime = performance.now();
        function predictLoop() {
            if (!systemState.parameters.p0Active) return;
            const now = performance.now(); const dt = now - lastFrameTime; lastFrameTime = now;
            const results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
            const cursors = P1Bridger.fuse(results, dt);
            
            drawResults(results, systemState.dataFabric);
            updateVisualPanels(results);
            w3cPointerNematocystInjector();
            systemState.ui.juiceLayers.forEach(j => j.update(cursors));
            requestAnimationFrame(predictLoop);
        }

        // --- P3: W3C INJECTOR ---
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            if (cursors.length === 0) return;
            const video = systemState.p0.video; if (!video) return;
            const rect = video.getBoundingClientRect();
            const cursor = cursors.find(c => c.handIndex === systemState.fsm.primaryHandIndex) || cursors[0];
            
            const viewX = rect.left + cursor.normX * rect.width;
            const viewY = rect.top + cursor.normY * rect.height;
            const isDown = (cursor.fsmState === 'COMMIT' || cursor.fsmState === 'COAST');

            let target = systemState.fsm.nematocystTargetLock || document.elementFromPoint(viewX, viewY);
            let finalX = viewX, finalY = viewY;
            if (target?.tagName === 'IFRAME') {
                try {
                const irect = target.getBoundingClientRect();
                finalX = viewX - irect.left; finalY = viewY - irect.top;
                target = target.contentDocument.elementFromPoint(finalX, finalY) || target;
                } catch(e){}
            }

            const evInit = { bubbles: true, cancelable: true, pointerId: 1, pointerType: 'mouse', clientX: finalX, clientY: finalY, buttons: isDown ? 1 : 0 };
            const wasActive = (systemState.fsm.lastState === 'COMMIT' || systemState.fsm.lastState === 'COAST');
            
            if (isDown && !wasActive) { systemState.fsm.nematocystTargetLock = target; dispatchToHydra(target, new PointerEvent('pointerdown', evInit), true); }
            dispatchToHydra(target, new PointerEvent('pointermove', evInit));
            if (!isDown && wasActive) { dispatchToHydra(target, new PointerEvent('pointerup', evInit)); systemState.fsm.nematocystTargetLock = null; }
            systemState.fsm.lastState = cursor.fsmState;
        }

        function dispatchToHydra(t, e, pulse = false) {
            if (!t) return; t.dispatchEvent(e);
            if (pulse && e.type === 'pointerdown') setTimeout(() => t.click ? t.click() : t.dispatchEvent(new MouseEvent('click', e)), 10);
        }

        // --- UI HELPERS ---
        function drawResults(results, fabric) {
            const { ctx, canvas } = systemState.p0; if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (results.landmarks && systemState.parameters.landmarks.showSkeleton) {
                const utils = new DrawingUtils(ctx);
                results.landmarks.forEach(lms => {
                    const dlms = systemState.parameters.camera.mirror ? lms.map(l => ({...l, x: 1-l.x})) : lms;
                    utils.drawConnectors(dlms, GestureRecognizer.HAND_CONNECTIONS, { color: 'rgba(255,255,255,0.2)', lineWidth: 1 });
                });
            }
            fabric.cursors.forEach(c => {
                if (systemState.parameters.visuals.engine === 'BABYLON') return;
                ctx.beginPath(); ctx.arc(c.screenX, c.screenY, 5, 0, Math.PI*2); ctx.fillStyle = c.fsmState==='COMMIT'?'#f00':'#ff0'; ctx.fill();
            });
        }

        function updateVisualPanels(results) {
            if (systemState.ui.gestures) {
                systemState.ui.gestures.innerHTML = systemState.dataFabric.cursors.map(c => `
                    <div class="m3-card" style="border-left: 4px solid ${c.fsmState==='COMMIT'?'#f00':'#d0bcff'}">
                        <div class="m3-label">Hand ${c.handIndex} | ${c.fsmState}</div>
                        <div class="m3-stat"><span>Confidence</span><span>${(c.confidence*100).toFixed(0)}%</span></div>
                        <div class="m3-progress-container"><div class="m3-progress-bar" style="width:${c.bucketLevel}%"></div></div>
                    </div>
                `).join('');
            }
        }

        function logMission(msg) {
            const logs = document.getElementById('mission-logs'); if (!logs) return;
            const entry = document.createElement('div'); entry.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logs.prepend(entry);
        }

        // --- GOLDEN LAYOUT ---
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('hero', (container) => {
            const wrap = document.createElement('div'); wrap.className = 'component-container';
            wrap.innerHTML = `
                <div class="hero-view-container">
                    <video id="video-feed" autoplay playsinline></video>
                    <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8;">
                        <iframe id="excalidraw-iframe" src="excalidraw_v20_wrapper.html" style="width:100%; height:100%; border:none; background: transparent;"></iframe>
                    </div>
                    <div id="babylon-juice" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:10;"></div>
                    <div id="pixi-juice" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:9;"></div>
                    <canvas id="overlay-canvas" style="z-index:11;"></canvas>
                    <button id="btn-ignite" class="hfo-btn" style="position:absolute; bottom:30px; z-index:20;">IGNITE OMEGA</button>
                </div>
            `;
            container.getElement().appendChild(wrap);
            systemState.p0.video = wrap.querySelector('#video-feed');
            systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
            systemState.p0.ctx = systemState.p0.canvas.getContext('2d');
            systemState.ui.excalidrawOverlay = wrap.querySelector('#excalidraw-hero-overlay');
            systemState.ui.excalidrawIframe = wrap.querySelector('#excalidraw-iframe');

            const babylonJuice = new BabylonJuiceSubstrate(wrap.querySelector('#babylon-juice'));
            const pixiJuice = new JuiceSubstrate(wrap.querySelector('#pixi-juice'));
            systemState.ui.juiceLayers.push(babylonJuice, pixiJuice);

            wrap.querySelector('#btn-ignite').onclick = async (e) => {
                e.target.style.display = 'none'; await initP0();
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                systemState.p0.video.srcObject = stream;
                systemState.p0.video.onloadeddata = () => { systemState.p0.videoBounds = { width: 1280, height: 720 }; systemState.p0.canvas.width = 1280; systemState.p0.canvas.height = 720; systemState.parameters.p0Active = true; predictLoop(); };
            };
            container.on('resize', () => { systemState.ui.juiceLayers.forEach(j => j.resize()); });
        });

        layout.registerComponentFactoryFunction('navigator', (container) => {
            const div = document.createElement('div'); div.className = 'scrollable-panel';
            container.getElement().appendChild(div);
            const gui = new GUI({ container: div, title: 'ðŸ›°ï¸ NAVIGATOR', autoPlace: false });
            gui.add(systemState.parameters.visuals, 'engine', ['PIXI', 'BABYLON']).name('Visual Engine');
            gui.add(systemState.parameters.camera, 'mirror');
            gui.add(systemState.parameters.physics, 'mode', ['STATIC_ROD', 'PLANCK_SPRING']);
            gui.add(systemState.parameters.excalidraw, 'opacity', 0, 1).onChange(v => systemState.ui.excalidrawOverlay.style.opacity = v);
        });

        layout.registerComponentFactoryFunction('gestures', (container) => { const wrap = document.createElement('div'); wrap.className = 'scrollable-panel'; container.getElement().appendChild(wrap); systemState.ui.gestures = wrap; });
        layout.registerComponentFactoryFunction('logs', (container) => { const div = document.createElement('div'); div.id = 'mission-logs'; div.className = 'scrollable-panel'; container.getElement().appendChild(div); logMission("READY"); });

        layout.loadLayout({
            root: { type: 'row', content: [
                { type: 'component', componentType: 'hero', title: 'Tactical Workspace', width: 70 },
                { type: 'column', content: [
                    { type: 'component', componentType: 'navigator', title: 'Settings' },
                    { type: 'component', componentType: 'gestures', title: 'Telemetry' },
                    { type: 'component', componentType: 'logs', title: 'Logs', height: 20 }
                ]}
            ]}
        });
    </script>
</body>
</html>
