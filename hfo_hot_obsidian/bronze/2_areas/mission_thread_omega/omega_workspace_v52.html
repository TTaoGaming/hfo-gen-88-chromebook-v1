<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO SHARDS | OMEGA V51.0 | HOT BRONZE</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <script src="./assets/piano_genie/magenta_music.js"></script>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        :root {
            /* M3 HFO Shard Palette (Material Design 3 Dark) */
            --m3-bg: #000000;
            --m3-surface: #121212;
            --m3-surface-bright: #1c1c1c;
            --m3-primary: #ff0000;
            /* Aggressive Red/Black HFO Shard Red */
            --m3-primary-container: #8c0000;
            --m3-on-primary: #ffffff;
            --m3-secondary: #ffb4ab;
            --m3-text: #e6e1e5;
            --m3-text-secondary: #938f99;
            --m3-outline: #49454f;
            --m3-radius: 16px;
            /* M3 Standard for cards */

            /* HFO Shard Vibe */
            --shard-claw: polygon(0% 0%, 95% 0%, 100% 10%, 100% 100%, 5% 100%, 0% 90%);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--m3-bg);
            color: var(--m3-text);
            font-family: 'Roboto', sans-serif;
            letter-spacing: 0.01em;
        }

        /* Material Typography */
        h2,
        h3 {
            font-weight: 500;
            color: var(--m3-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        /* Responsive Scrollbar (HFO Shard style) */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.4);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--m3-primary-container);
            border-radius: 4px;
        }

        .component-container {
            padding: 24px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
            background-color: var(--m3-bg);
            color: var(--m3-text);
            position: relative;
        }

        .video-feed {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
            background: #000;
            filter: grayscale(1) contrast(1.5) brightness(0.6);
            opacity: 0.4;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
            border: 1px solid var(--m3-outline);
        }

        .video-feed:hover {
            opacity: 0.8;
            filter: grayscale(0.2) contrast(1.1) brightness(0.9);
        }

        .video-feed.mirrored {
            transform: scaleX(-1);
        }

        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .overlay-canvas.mirrored {
            transform: scaleX(-1);
        }

        /* M3 Elevated Card with HFO Shard Claw */
        .data-card {
            background: var(--m3-surface);
            padding: 20px;
            border-radius: var(--m3-radius);
            margin-bottom: 24px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5), 0 1px 3px rgba(0, 0, 0, 0.8);
            clip-path: var(--shard-claw);
            border-left: 4px solid var(--m3-primary);
            transition: transform 0.2s cubic-bezier(0, 0, 0.2, 1);
            position: relative;
        }

        .data-card:hover {
            background: var(--m3-surface-bright);
            transform: scale(1.01);
        }

        .data-card h3 {
            margin: 0 0 16px 0;
            font-size: 11px;
            font-weight: 700;
            color: var(--m3-primary);
        }

        code {
            font-family: 'Roboto Mono', monospace;
            color: #ff5252;
            font-size: 12px;
            background: rgba(255, 0, 0, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .state-tag {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            margin-right: 8px;
            letter-spacing: 0.05em;
        }

        .tag-idle {
            background: #1c1b1f;
            color: #938f99;
            border: 1px solid #49454f;
        }

        .tag-arming {
            background: #310001;
            color: #ffb4ab;
            border: 1px solid #690005;
        }

        .tag-armed {
            background: #690005;
            color: #ffffff;
            box-shadow: 0 0 15px rgba(105, 0, 5, 0.5);
        }

        .tag-committing {
            background: var(--m3-primary);
            color: #fff;
        }

        .tag-committed {
            background: var(--m3-primary);
            color: #fff;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6);
        }

        .tag-releasing {
            background: #ff8800;
            color: #000;
            border: 1px solid #ffaa00;
        }

        .ghost-cursor {
            position: fixed;
            width: 32px;
            height: 32px;
            border: 2px solid var(--m3-primary);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            /* Hex HFO Shard Carapace */
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
            display: none;
            background: rgba(255, 0, 0, 0.1);
        }

        .ghost-cursor.active {
            display: block;
        }

        .local-cursor {
            position: fixed;
            width: 8px;
            height: 8px;
            background: var(--m3-primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 20px var(--m3-primary);
        }

        .guide-section {
            padding: 4px;
        }

        .guide-item {
            margin-bottom: 28px;
            padding: 24px;
            border-radius: var(--m3-radius);
            background: var(--m3-surface);
            border: 1px solid var(--m3-outline);
            clip-path: var(--shard-claw);
        }

        .guide-item h3 {
            font-size: 14px;
            margin-bottom: 12px;
        }

        .guide-item p {
            font-size: 13px;
            color: var(--m3-text-secondary);
            line-height: 1.6;
        }

        /* M3 FAB Style for Controls */
        .camera-controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            z-index: 1000;
            background: var(--m3-surface);
            padding: 12px;
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--m3-outline);
        }

        .camera-btn {
            padding: 12px 24px;
            font-size: 12px;
            font-weight: 500;
            background: var(--m3-surface-bright);
            color: var(--m3-text);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.1, 0.7, 0.1, 1);
            text-transform: uppercase;
        }

        .camera-btn:hover {
            background: var(--m3-primary-container);
            color: #fff;
            transform: translateY(-4px);
        }

        .camera-btn.danger {
            background: #310001;
            color: #ffb4ab;
        }

        .camera-btn.active {
            background: #00391d;
            color: #b7f397;
        }

        /* M3 Green contrast */
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "https://cdn.jsdelivr.net/npm/matter-js@0.19.0/+esm",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm",
            "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';
        import * as duckdb from '@duckdb/duckdb-wasm';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸŒ‰ PORT 1: BRIDGE (Contracts)
        // Essence: Contract Enforcement & Logical Harmonization
        // Role: [B]ridging high-frequency streams against Zod 6.0 contracts.
        const Port1CursorBridgeSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
        const Port1HandBridgeSchema = z.object({
            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
            cursors: z.record(Port1CursorBridgeSchema),
            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() }),
            curls: z.object({ index: z.number(), middle: z.number(), ring: z.number(), pinky: z.number() }).optional(),
            palm: z.object({ normal: z.object({ x: z.number(), y: z.number(), z: z.number() }), facingCamera: z.boolean() }).optional()
        });
        const Port1CloudEventBridgeSchema = z.object({
            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(Port1HandBridgeSchema)
        });

        // ðŸ¤– V42: Hierarchical Anti-Midas FSM (Dwell + Palm Cone + Gesture)
        class GestureFSM {
            constructor() {
                this.state = 'IDLE';
                this.pointerEvent = 'none';
                this.dwellMs = 500;
                this.dwellAccumulator = 0;
                this.lastTimestamp = 0;
            }

            process(gesture, timestamp, score = 1.0, isPalmFacing = false, currentCurls = null) {
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
                this.lastTimestamp = timestamp;
                this.pointerEvent = 'none';
                const isConfident = score > 0.6;

                if (isPalmFacing) {
                    this.dwellAccumulator = Math.min(this.dwellAccumulator + dt, 1000);
                } else {
                    this.dwellAccumulator = Math.max(this.dwellAccumulator - dt * (this.state === 'PORT_7_POINTER_COMMITTED' ? 1 : 3), 0);
                }

                switch (this.state) {
                    case 'IDLE':
                        if (isPalmFacing && this.dwellAccumulator > 0) this.state = 'PORT_0_READY_DWELL';
                        break;
                    case 'PORT_0_READY_DWELL':
                        if (this.dwellAccumulator >= this.dwellMs) this.state = 'PORT_0_POINTER_READY';
                        else if (this.dwellAccumulator <= 0) this.state = 'IDLE';
                        break;
                    case 'PORT_0_POINTER_READY':
                        this.pointerEvent = 'pointermove';
                        if (this.dwellAccumulator <= 0) this.state = 'IDLE';
                        else if (currentGesture === 'NONE' || !isConfident) this.state = 'PORT_7_COMMIT_PENDING';
                        else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'PORT_7_POINTER_COMMITTED';
                            this.pointerEvent = 'pointerdown';
                        }
                        break;
                    case 'PORT_7_COMMIT_PENDING':
                        this.pointerEvent = 'pointermove';
                        if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'PORT_7_POINTER_COMMITTED';
                            this.pointerEvent = 'pointerdown';
                        } else if (this.dwellAccumulator <= 0 || (currentGesture !== 'NONE' && currentGesture !== 'POINTING_UP' && isConfident)) {
                            this.state = isPalmFacing ? 'PORT_0_POINTER_READY' : 'IDLE';
                        }
                        break;
                    case 'PORT_7_POINTER_COMMITTED':
                        this.pointerEvent = 'pointermove';
                        const isNoneOrLost = (currentGesture === 'NONE' || currentGesture === 'LOST' || !isConfident);
                        if (isNoneOrLost) this.state = 'PORT_7_RELEASE_PENDING';
                        else if (currentGesture !== 'POINTING_UP' && isConfident) {
                            this.state = isPalmFacing ? 'PORT_0_POINTER_READY' : 'IDLE';
                            this.pointerEvent = 'pointerup';
                        }
                        if (this.dwellAccumulator <= 0) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointercancel';
                        }
                        break;
                    case 'PORT_7_RELEASE_PENDING':
                        this.pointerEvent = 'pointermove';
                        if (currentGesture === 'POINTING_UP' && isConfident) this.state = 'PORT_7_POINTER_COMMITTED';
                        else if (currentGesture === 'VICTORY' || currentGesture === 'OPEN_PALM' || (this.dwellAccumulator <= 0)) {
                            this.state = (this.dwellAccumulator > 0) ? 'PORT_0_POINTER_READY' : 'IDLE';
                            this.pointerEvent = 'pointerup';
                        }
                        break;
                }
                return { state: this.state, pointerEvent: this.pointerEvent };
            }
        }

        // ï¿½ Finger Logic Helpers
        const calculateCurl = (landmarks, indices) => {
            let totalAngle = 0;
            for (let i = 0; i < indices.length - 2; i++) {
                const a = landmarks[indices[i]];
                const b = landmarks[indices[i + 1]];
                const c = landmarks[indices[i + 2]];
                const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
            }
            return Math.min(1.0, totalAngle / Math.PI);
        };

        const getBoneRatios = (lm) => {
            const dist = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2 + (p1.z - p2.z) ** 2);
            return {
                index: dist(lm[5], lm[6]) / (dist(lm[6], lm[7]) || 1),
                middle: dist(lm[9], lm[10]) / (dist(lm[10], lm[11]) || 1)
            };
        };

        const getCurls = (lm) => ({
            index: calculateCurl(lm, [5, 6, 7, 8]),
            middle: calculateCurl(lm, [9, 10, 11, 12]),
            ring: calculateCurl(lm, [13, 14, 15, 16]),
            pinky: calculateCurl(lm, [17, 18, 19, 20])
        });

        // ï¿½ðŸ§  Multi-Resolution Filters (Smooth/Snappy Presets)
        class LowPassFilter { constructor(alpha) { this.alpha = alpha; this.s = null; } call(v) { if (this.s === null) this.s = v; else this.s = this.alpha * v + (1 - this.alpha) * this.s; return this.s; } }
        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
                this.xFilter = new LowPassFilter(this.alpha(minCutoff)); this.dxFilter = new LowPassFilter(this.alpha(dCutoff)); this.lastTime = null;
            }
            alpha(c) { const te = 1 / (this.freq || 60); const tau = 1 / (2 * Math.PI * (c || 1.0)); return 1 / (1 + tau / te); }
            call(x, t = null) {
                if (this.lastTime !== null && t !== null) {
                    const dt = (t - this.lastTime) / 1000;
                    if (dt > 0.001) this.freq = 1 / dt;
                }
                this.lastTime = t;
                const prevX = this.xFilter.s;
                const dx = prevX === null ? 0 : (x - prevX) * (this.freq || 60);
                const edx = this.dxFilter.call(dx);
                const c = this.minCutoff + this.beta * Math.abs(edx);
                this.xFilter.alpha = this.alpha(c);
                const result = this.xFilter.call(x);
                return isNaN(result) ? (x || 0) : result;
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: true,
            transparency: 1.0, // ðŸ•µï¸ REAL-TIME SENSING QUALITY (0.0 - 1.0)
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6, dwellMs: 1000 },
            visuals: {
                heroStrategy: 'HEX_SHARD',
                supportStrategy: 'DOT',
                showSkeleton: true
            },
            goldenMaster: {
                active: false,
                mode: 'STRAIGHT', // STRAIGHT, LOW_NOISE, HIGH_NOISE
                progress: 0,
                speed: 0.005,
                noiseLevel: 0.0,
                dropProbability: 0.0,
                frameCounter: 0
            },
            physics: {
                stiffness: 0.12, stiffnessArmed: 0.65, damping: 0.85, lookAhead: 2.2,
                velocityDeadzone: 0.05, // ðŸŒªï¸ V52.0 Enhanced Resonance Suppression
                springSource: 'snappy', predSource: 'snappy',
                p3Source: 'predictive', p3Mirror: true,
                p0Mirror: true,
                showGlobalCursor: false,
                remoteMode: true,
                purePointerMode: false,
                remoteTargetId: 'excalidraw-iframe',
                persistence: { snapDistance: 0.15, coastFrames: 60, repulsionDistance: 0.12, teleportLimit: 0.3 }
            },
            hands: {}, bridge: { lastEvent: null, errorCount: 0, status: 'IDLE', lastValidate: 0 }
        };

        // ðŸ›°ï¸ V37 System Singleton Guard
        const hfoSystem = window.hfoSystem = {
            initialized: false,
            initializing: false,
            video: null,
            canvas: null,
            ctx: null,
            recognizer: null,
            stream: null,
            loopActive: false,
            lastFrame: 0,
            heroReady: false,
            tuningMirror: {
                db: null,
                conn: null,
                active: false,
                metrics: { rmse: 0, jitter: 0 },
                batch: []
            }
        };

        const initTuningMirror = async () => {
            try {
                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
                const worker_url = URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
                );

                const worker = new Worker(worker_url);
                const logger = new duckdb.ConsoleLogger();
                const db = new duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

                const conn = await db.connect();
                await conn.query(`
                    CREATE TABLE telemetry (
                        ts DOUBLE,
                        hand_id INTEGER,
                        raw_x DOUBLE, raw_y DOUBLE,
                        pred_x DOUBLE, pred_y DOUBLE,
                        mode VARCHAR
                    )
                `);

                hfoSystem.tuningMirror.db = db;
                hfoSystem.tuningMirror.conn = conn;
                hfoSystem.tuningMirror.active = true;
                if (hfoState.debug) console.log("ðŸ’Ž Tuning Mirror (DuckDB-WASM) Active.");
            } catch (e) {
                console.error("âŒ Tuning Mirror initialization failed:", e);
                hfoSystem.tuningMirror.active = false;
            }
        };

        let telemetrySeq = 0;
        /**
         * ðŸ”­ PORT 0: OBSERVE (Sense)
         * Essence: Intelligence, Surveillance, Reconnaissance
         * Role: [O]bserving high-fidelity MediaPipe sensing and gesture extraction.
         */
        const port0Observe = (video, recognizer, now) => {
            if (hfoState.goldenMaster.active) return port4GoldenMaster(now);
            if (!video || !recognizer || video.readyState < 2) return null;
            return recognizer.recognizeForVideo(video, now);
        };

        /**
         * ðŸŽ¯ PORT 4: GOLDEN MASTER (Validate / Analysis)
         * Essence: Disruptive Analysis & Feedback Loops
         * Role: Injecting ground-truth synthetic feeds to analyze filter divergence.
         */
        const port4GoldenMaster = (now) => {
            const gm = hfoState.goldenMaster;
            gm.frameCounter++;

            // Handle Dropped Frames (Simulated failure in Sense)
            if (gm.mode === 'HIGH_NOISE' && Math.random() < gm.dropProbability) {
                return null;
            }

            gm.progress = (gm.progress + gm.speed) % 1.0;

            // Base movement: Sinusoidal path on Y, Linear on X
            const x = 0.2 + (0.6 * gm.progress);
            const y = 0.5 + 0.1 * Math.sin(gm.progress * Math.PI * 4);

            // Noise Profile configuration
            let noise = 0;
            if (gm.mode === 'LOW_NOISE') noise = 0.002;
            if (gm.mode === 'HIGH_NOISE') noise = 0.02;

            const nx = x + (Math.random() - 0.5) * noise;
            const ny = y + (Math.random() - 0.5) * noise;

            // Mock MediaPipe result
            const mockLandmarks = Array(21).fill(0).map(() => ({ x: nx, y: ny, z: 0 }));
            mockLandmarks[8] = { x: nx, y: ny, z: 0 };

            return {
                landmarks: [mockLandmarks],
                worldLandmarks: [mockLandmarks],
                gestures: [[{ categoryName: 'POINTING_UP', score: 0.99 }]],
                handedness: [[{ categoryName: 'Right', score: 0.99 }]]
            };
        };

        /**
         * ðŸŒ‰ PORT 1: BRIDGE (Fuse)
         * Essence: Contractual Integrity & Data Transformation
         * Role: [B]ridging hand telemetry stream to Zod 6.0 contracts and P2 Physics coordinates.
         * Medallion: Bronze | Mutation: 88% | HIVE: I
         */
        const port1Bridge = (hands) => {
            const now = performance.now();
            const shouldValidate = (now - hfoState.bridge.lastValidate) > 500;
            try {
                const telemetryData = {};
                const physicsCoordinates = [];

                for (const id in hands) {
                    const h = hands[id];
                    if (!h.active) continue;

                    // P0 -> P1 Translation
                    telemetryData[id] = {
                        id: h.id, active: h.active, lastSeen: h.lastSeen, fsm: h.fsm.state,
                        cursors: {
                            raw: h.cursors.raw,
                            smooth: h.cursors.smooth,
                            snappy: h.cursors.snappy,
                            spring: h.cursors.spring,
                            pred: h.cursors.predictive
                        },
                        gestures: h.gestures, palm: h.palm, curls: h.curls
                    };

                    // P1 -> P2 Coordinate Fusion (Zod 6.0 logic)
                    // We map normalized sensor space (0-1) to Physics Lattice space (W3C standard)
                    physicsCoordinates.push({
                        id: h.id,
                        x: h.cursors.smooth.x,
                        y: h.cursors.smooth.y,
                        velocity: { x: h.physics?.velocity?.x || 0, y: h.physics?.velocity?.y || 0 },
                        isDown: h.gestures.isDown,
                        contract: "Zod_6.0_Stable"
                    });
                }

                const event = {
                    specversion: "1.0",
                    type: "hfo.omega.v52.hand_update",
                    source: "hfo.port.0.sense",
                    id: `telemetry-${telemetrySeq++}`,
                    time: new Date().toISOString(),
                    data: telemetryData,
                    physics: physicsCoordinates
                };

                if (shouldValidate) {
                    Port1CloudEventBridgeSchema.parse(event);
                    hfoState.bridge.lastValidate = now;
                    if (hfoState.debug) console.log("ðŸŒ‰ P1_FUSE: System Integrity Audited [Zod 6.0]");
                }
                hfoState.bridge.lastEvent = event; hfoState.bridge.status = 'VALID';
            } catch (e) {
                if (hfoState.debug) console.error("Port 1 BRIDGE Breach:", e);
                hfoState.bridge.status = 'ERROR'; hfoState.bridge.errorCount++;
            }
        };

        /**
         * ðŸŽ¨ PORT 2: VISUAL STRATEGIES
         * Essence: Aesthetic Form & Strategy Pattern
         */
        const VisualStrategies = {
            HEX_SHARD: (ctx, cursor, size, state, dwellRatio, color) => {
                const canvas = hfoSystem.canvas;
                ctx.beginPath();
                const shardSize = size * (state === 'PORT_7_POINTER_COMMITTED' ? 1.5 : (state === 'PORT_0_POINTER_READY' ? 1.2 : 1.0));
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3 + (state === 'PORT_7_POINTER_COMMITTED' ? (Date.now() / 500) : 0);
                    const hx = cursor.x * canvas.width + shardSize * Math.cos(angle);
                    const hy = cursor.y * canvas.height + shardSize * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
                }
                ctx.closePath();

                let strokeColor = 'transparent';
                let shadowBlur = 0;
                let shadowColor = 'transparent';
                let lineWidth = 2;

                if (state === 'PORT_0_READY_DWELL') {
                    strokeColor = `rgba(255, 0, 0, ${dwellRatio})`;
                    lineWidth = 1 + dwellRatio * 2;
                } else if (state === 'PORT_0_POINTER_READY') {
                    strokeColor = '#690005';
                    lineWidth = 3;
                } else if (state === 'PORT_7_COMMIT_PENDING') {
                    strokeColor = '#ff0000';
                    lineWidth = 4;
                    ctx.setLineDash([2, 5]);
                } else if (state === 'PORT_7_POINTER_COMMITTED') {
                    strokeColor = '#ff3333';
                    lineWidth = 4;
                    shadowBlur = 25;
                    shadowColor = '#ff0000';
                } else if (state === 'PORT_7_RELEASE_PENDING') {
                    strokeColor = '#ff8800';
                    lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                }

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = shadowColor;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;

                ctx.fillStyle = color;
                ctx.globalAlpha = 1.0;
                ctx.fill();
            },
            DOT: (ctx, cursor, size, state, dwellRatio, color) => {
                const canvas = hfoSystem.canvas;
                ctx.beginPath();
                ctx.arc(cursor.x * canvas.width, cursor.y * canvas.height, size, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.2;
                ctx.fill();
            },
            SKELETON: (ctx, landmarks, dw) => {
                dw.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#cc0000", lineWidth: 5 });
            }
        };

        /**
         * ðŸ“ PORT 2: SHAPE (Tree Manifold - Step A: Sensing & Anchor Sync)
         */
        const port2ShapeSync = (hand, now, lm) => {
            // Assign Visual Strategy
            hand.visuals = {
                hero: hfoState.visuals.heroStrategy,
                support: hfoState.visuals.supportStrategy,
                showSkeleton: hfoState.visuals.showSkeleton
            };

            if (lm) {
                // ðŸŽ¯ Handedness-Agnostic Orientation
                const v1 = { x: lm[5].x - lm[0].x, y: lm[5].y - lm[0].y, z: lm[5].z - lm[0].z };
                const v2 = { x: lm[17].x - lm[0].x, y: lm[17].y - lm[0].y, z: lm[17].z - lm[0].z };

                const cross = {
                    x: (v1.y * v2.z - v1.z * v2.y) || 0,
                    y: (v1.z * v2.x - v1.x * v2.z) || 0,
                    z: (v1.x * v2.y - v1.y * v2.x) || 1
                };
                const mag = Math.sqrt(cross.x ** 2 + cross.y ** 2 + cross.z ** 2) || 1;
                const normal = { x: cross.x / mag, y: cross.y / mag, z: cross.z / mag };

                const isFacing = Math.abs(normal.z) > 0.5;
                hand.palm = { normal, facingCamera: isFacing };

                // ðŸ§¬ Internal Sharding: The Tree Starts Here
                // Node 1: Raw
                hand.cursors.raw.x = lm[8].x; hand.cursors.raw.y = lm[8].y;
                hand.lastSeen = now; hand.coastCount = 0; hand.active = true;

                // Node 2 & 3: Filtered Children of Raw
                hand.cursors.smooth.x = hand.filters.sx.call(hand.cursors.raw.x, now);
                hand.cursors.smooth.y = hand.filters.sy.call(hand.cursors.raw.y, now);
                hand.cursors.snappy.x = hand.filters.nx.call(hand.cursors.raw.x, now);
                hand.cursors.snappy.y = hand.filters.ny.call(hand.cursors.raw.y, now);

                // Store landmarks for skeleton strategy
                hand.landmarks = lm;
            }

            // ðŸš€ Physics Digital Twin (Syncing Anchor)
            if (engine && hand.active && hfoSystem.canvas) {
                const canvas = hfoSystem.canvas;
                const isEngaged = hand.fsm.state === 'PORT_0_POINTER_READY' || hand.fsm.state === 'PORT_7_POINTER_COMMITTED';
                hand.cursors.spring.constraint.stiffness = isEngaged ? hfoState.physics.stiffnessArmed : hfoState.physics.stiffness;

                // Node 4: Spring is driven by Snappy (Node 3)
                const anchorSource = hand.cursors.snappy;
                Matter.Body.setPosition(hand.cursors.spring.anchor, { x: anchorSource.x * canvas.width, y: anchorSource.y * canvas.height });
            }
            return hand.palm?.facingCamera || false;
        };

        /**
         * ðŸ“ PORT 2: SHAPE (Tree Manifold - Step B: Predictive Synthesis)
         */
        const port2ShapePredict = (hand, now) => {
            if (engine && hand.active && hfoSystem.canvas) {
                const canvas = hfoSystem.canvas;
                
                // Node 5: Predictive is driven by Spring (Node 4) + Velocity projection
                const rawVel = hand.cursors.spring.body.velocity;

                // ðŸŒªï¸ V52.0 Resonance Suppression (Non-linear Cubic Deadzone)
                const speed = Math.sqrt(rawVel.x * rawVel.x + rawVel.y * rawVel.y);
                const dz = hfoState.physics.velocityDeadzone || 0.05;
                const ratio = Math.min(1.0, speed / dz);
                const suppression = ratio * ratio * ratio; // Cubic for tighter low-end stabilization

                const vel = {
                    x: hand.filters.vx.call(rawVel.x, now) * suppression,
                    y: hand.filters.vy.call(rawVel.y, now) * suppression
                };

                const lead = {
                    x: vel.x * hfoState.physics.lookAhead,
                    y: vel.y * hfoState.physics.lookAhead
                };

                Matter.Body.setPosition(hand.cursors.predictive.body, {
                    x: (hand.cursors.spring.body.position.x) + lead.x,
                    y: (hand.cursors.spring.body.position.y) + lead.y
                });

                const SafeW = canvas.width || 1280;
                const SafeH = canvas.height || 720;
                hand.cursors.spring.x = hand.cursors.spring.body.position.x / SafeW;
                hand.cursors.spring.y = hand.cursors.spring.body.position.y / SafeH;
                hand.cursors.predictive.x = hand.cursors.predictive.body.position.x / SafeW;
                hand.cursors.predictive.y = hand.cursors.predictive.body.position.y / SafeH;
            }
        };

        // ðŸ—¡ï¸ PORT 3: INJECT (Deliver)
        // Essence: W3C Pointer Injection & Event Synthesis
        // Role: [I]njecting official W3C pointer events into the DOM.
        const port3Inject = window.port3Inject = window.p3InjectPointer = window.p3Inject = (hand) => {
            try {
                if (!hand.active) {
                    if (hand.ghost) hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    if (hand.capturedTarget && hand.capturedTarget.releasePointerCapture) {
                        try { hand.capturedTarget.releasePointerCapture(Number(hand.id) + 10); } catch (e) { }
                        hand.capturedTarget = null;
                    }
                    return;
                }

                if (!hand.ghost) {
                    hand.ghost = document.createElement('div');
                    hand.ghost.className = 'ghost-cursor';
                    document.body.appendChild(hand.ghost);
                }

                const types = { 'pointerdown': 'pointerdown', 'pointermove': 'pointermove', 'pointerup': 'pointerup', 'pointercancel': 'pointercancel' };
                const type = types[hand.fsm.pointerEvent];
                const activeType = type || (hand.fsm.state !== 'IDLE' ? 'pointermove' : null);

                if (!activeType || !hand.active) {
                    hand.ghost.classList.remove('active');
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                    return;
                }

                const cursor = hand.cursors[hfoState.physics.p3Source] || hand.cursors.predictive;
                let normX = cursor.x;
                if (hfoState.physics.p3Mirror) normX = 1 - normX;

                let x = normX * window.innerWidth;
                let y = cursor.y * window.innerHeight;

                // ðŸŽ¯ V40 EXEMPLAR: Robust Target Capture
                const pointerId = Number(hand.id) + 10;
                let target;

                if (hand.capturedTarget) {
                    target = hand.capturedTarget;
                } else {
                    target = document.elementFromPoint(x, y) || document.body;
                }

                // âš¡ Hardened Click Logic: If we are on a DOWN transition, ensure we trigger a real click
                if (activeType === 'pointerdown' && target && !hand.capturedTarget) {
                    // Inject hovering/focusing sequence for sensitive UIs (Excalidraw)
                    const overEvent = new PointerEvent('pointerover', { bubbles: true, cancelable: true, pointerId, x, y, clientX: x, clientY: y });
                    const enterEvent = new PointerEvent('pointerenter', { bubbles: true, cancelable: true, pointerId, x, y, clientX: x, clientY: y });
                    target.dispatchEvent(overEvent);
                    target.dispatchEvent(enterEvent);

                    // Specific fix for Excalidraw buttons: If button is detected, call .click() directly on next tick
                    if (target.tagName === 'BUTTON' || target.closest('button')) {
                        const btn = target.tagName === 'BUTTON' ? target : target.closest('button');
                        requestAnimationFrame(() => {
                            if (btn) btn.click();
                        });
                    }
                }

                let finalX = x;
                let finalY = y;

                // ðŸŽ¯ V44.1: Robust Coordinate Parity & Drill
                if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
                    const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
                    if (remoteEl) {
                        const rect = remoteEl.getBoundingClientRect();

                        // Calculate local coordinates relative to the remote container
                        const localX = x - rect.left;
                        const localY = y - rect.top;

                        if (!hand.capturedTarget) target = remoteEl;

                        if (remoteEl.tagName === 'IFRAME') {
                            try {
                                const innerTarget = remoteEl.contentDocument.elementFromPoint(localX, localY);
                                if (innerTarget && !hand.capturedTarget) {
                                    target = innerTarget;
                                    finalX = localX;
                                    finalY = localY;
                                }
                            } catch (e) {
                                // Fallback to absolute if iframe is cross-origin or blocked
                                finalX = x;
                                finalY = y;
                            }
                        } else {
                            finalX = localX;
                            finalY = localY;
                        }
                    }
                }

                // ðŸŽ¯ V44.1: Local Cursor Management (Shared Substrate Visualization)
                if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
                    const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
                    if (remoteEl) {
                        if (!hand.localCursor) {
                            hand.localCursor = document.createElement('div');
                            hand.localCursor.className = 'local-cursor';
                            document.body.appendChild(hand.localCursor);
                        }
                        const rect = remoteEl.getBoundingClientRect();
                        hand.localCursor.style.display = 'block';
                        hand.localCursor.style.left = `${rect.left + finalX - 5}px`;
                        hand.localCursor.style.top = `${rect.top + finalY - 5}px`;
                        hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
                    }
                } else {
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                }

                if (hfoState.physics.showGlobalCursor) {
                    hand.ghost.classList.add('active');
                    hand.ghost.style.left = `${x - 10}px`;
                    hand.ghost.style.top = `${y - 10}px`;
                    hand.ghost.className = `ghost-cursor active ${hand.fsm.state.toLowerCase().replace(/_/g, '-')}`;
                } else hand.ghost.classList.remove('active');

                // ðŸ§¬ BRIDGE INTERCEPTION: Sequence Hardening
                if (activeType === 'pointerdown') {
                    hand.lastTargetOnDown = target;
                    // Hover sequence
                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId, clientX: finalX, clientY: finalY }));
                    target.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, clientX: finalX, clientY: finalY }));

                    if (hfoState.physics.remoteTargetId === 'excalidraw-iframe') {
                        const btn = target.closest('button, .ToolIcon, label[title]');
                        if (btn) {
                            const label = (btn.getAttribute('aria-label') || btn.title || "").toLowerCase();
                            const tools = ['selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'freedraw', 'text', 'eraser'];
                            const match = tools.find(t => label.includes(t));
                            if (match) document.getElementById('excalidraw-iframe').contentWindow.postMessage({ type: 'SET_TOOL', data: { tool: match } }, '*');
                        }
                    }
                }

                // ðŸŽ¯ CAPTURE LOGIC
                if (activeType === 'pointerdown' && target.setPointerCapture) {
                    try {
                        target.setPointerCapture(pointerId);
                        hand.capturedTarget = target;
                    } catch (e) { console.warn("Pointer capture failed", e); }
                }

                if (hand.lastTarget && hand.lastTarget !== target && !hand.capturedTarget) {
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerout', { bubbles: true, pointerId: pointerId, clientX: x, clientY: y }));
                    hand.lastTarget.dispatchEvent(new PointerEvent('pointerleave', { bubbles: false, pointerId: pointerId, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId: pointerId, clientX: x, clientY: y }));
                    target.dispatchEvent(new PointerEvent('pointerenter', { bubbles: false, pointerId: pointerId, clientX: x, clientY: y }));
                }

                const movementX = hand.lastX !== undefined ? x - hand.lastX : 0;
                const movementY = hand.lastY !== undefined ? y - hand.lastY : 0;
                hand.lastX = x; hand.lastY = y; hand.lastTarget = target;

                const isDown = (hand.fsm.state === 'PORT_7_POINTER_COMMITTED');

                // ðŸ§¬ V44: Intent-Based Primacy (Hot Hand Handoff)
                // Logic: Priority goes to Committed hands, then Ready hands, filtered by activity.
                const handList = Object.values(hfoState.hands).filter(h => h.active);
                const committedHands = handList.filter(h => h.fsm.state === 'PORT_7_POINTER_COMMITTED').sort((a, b) => a.id - b.id);
                const readyHands = handList.filter(h => h.fsm.state === 'PORT_0_POINTER_READY').sort((a, b) => a.id - b.id);

                let isPrimary = false;
                if (committedHands.length > 0) {
                    isPrimary = (Number(hand.id) === Number(committedHands[0].id));
                } else if (readyHands.length > 0) {
                    isPrimary = (Number(hand.id) === Number(readyHands[0].id));
                }

                const ev = new PointerEvent(activeType, {
                    bubbles: true, cancelable: true,
                    pointerType: 'touch', // ðŸ’  Set to touch for better gesture/multi-point harmony
                    view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                    pointerId: pointerId, clientX: finalX, clientY: finalY,
                    movementX: movementX, movementY: movementY,
                    width: 20, height: 20, // Simulate finger contact patch
                    pressure: isDown ? 0.9 : 0.0,
                    buttons: isDown ? 1 : 0,
                    button: (activeType === 'pointerdown' || activeType === 'pointerup') ? 0 : -1,
                    isPrimary: isPrimary
                });
                target.dispatchEvent(ev);

                // ï¿½ï¸ Legacy Polyfill (Option C Standard): 
                // Only dispatch MouseEvents for Hand 0 (Primary) to maintain compatibility with 
                // legacy UI frameworks (Excalidraw buttons, etc.) without polluting 2-hand concurrency.
                // ðŸ›¡ï¸ V43 Hardening: Manual click dispatch
                if (!hfoState.physics.purePointerMode && isPrimary && (activeType === 'pointerdown' || activeType === 'pointerup')) {
                    const mouseType = activeType === 'pointerdown' ? 'mousedown' : 'mouseup';
                    target.dispatchEvent(new MouseEvent(mouseType, { bubbles: true, clientX: finalX, clientY: finalY, button: 0, buttons: isDown ? 1 : 0 }));
                    if (activeType === 'pointerup' && target === hand.lastTargetOnDown) {
                        target.dispatchEvent(new MouseEvent('click', { bubbles: true, clientX: finalX, clientY: finalY, button: 0 }));
                        const btn = target.tagName === 'BUTTON' ? target : target.closest('button');
                        if (btn) btn.click();
                    }
                }

                // ï¿½ðŸŽ¯ RELEASE LOGIC
                if ((activeType === 'pointerup' || activeType === 'pointercancel') && hand.capturedTarget) {
                    try { hand.capturedTarget.releasePointerCapture(pointerId); } catch (e) { }
                    hand.capturedTarget = null;
                }

            } catch (err) {
                if (hfoState.debug) console.error("W3C Injection Error:", err);
            }
        };

        /**
         * ðŸŒªï¸ PORT 4: DISRUPT (Supression)
         * Role: [D]isrupting noise and handle feedback suppression.
         */
        const port4Disrupt = (hand) => { /* Internal suppression logic */ };

        /**
         * ðŸ›¡ï¸ PORT 5: IMMUNIZE (Force Protection)
         * Essence: Defensive Shields
         * Role: [I]mmunizing the system against invalid state transitions and sensor noise.
         * V42.1: Sensor-Aware Coasting Audit.
         */
        const port5Immunize = (hand, nextState, confidence = 1.0) => {
            const prevState = hand.fsm.state;
            const isLowConfidence = confidence < 0.3;

            // ðŸ§¬ Kinetic Coasting Trigger
            if (isLowConfidence && hand.active) {
                if (hfoState.debug) console.warn(`ðŸ›¡ï¸ P5: Low confidence (${confidence.toFixed(2)}). Engaging Kinetic Coast.`);
                return 'COAST';
            }

            const validTransitions = {
                'IDLE': ['IDLE', 'PORT_0_READY_DWELL'],
                'PORT_0_READY_DWELL': ['IDLE', 'PORT_0_READY_DWELL', 'PORT_0_POINTER_READY'],
                'PORT_0_POINTER_READY': ['IDLE', 'PORT_0_POINTER_READY', 'PORT_7_COMMIT_PENDING', 'PORT_7_POINTER_COMMITTED'],
                'PORT_7_COMMIT_PENDING': ['IDLE', 'PORT_0_POINTER_READY', 'PORT_7_COMMIT_PENDING', 'PORT_7_POINTER_COMMITTED'],
                'PORT_7_POINTER_COMMITTED': ['IDLE', 'PORT_7_POINTER_COMMITTED', 'PORT_7_RELEASE_PENDING', 'PORT_0_POINTER_READY'],
                'PORT_7_RELEASE_PENDING': ['IDLE', 'PORT_0_POINTER_READY', 'PORT_7_RELEASE_PENDING', 'PORT_7_POINTER_COMMITTED']
            };

            const allowed = validTransitions[prevState]?.includes(nextState) || false;
            if (!allowed && hfoState.debug) {
                console.warn(`ðŸ›¡ï¸ P5 HardGate BREACH: ${prevState} -> ${nextState} blocked.`);
            }
            return allowed ? 'ALLOW' : 'BLOCK';
        };

        /**
         * ðŸ“¦ PORT 6: ASSIMILATE (Store)
         * Essence: State Persistence & Assimilation
         * Role: [A]ssimilating gesture telemetry into the FSM store.
         */
        const port6Assimilate = (hand, gestureName, score, now, isFacing, confidence = 1.0) => {
            // P5 HardGate Validation with Coasting Support
            const fsmRes = hand.fsm.process(gestureName, now, score, isFacing);
            const auditResult = port5Immunize(hand, fsmRes.state, confidence);

            if (auditResult === 'ALLOW') {
                return fsmRes;
            } else if (auditResult === 'COAST') {
                hand.fsm.lastTimestamp = now;
                hand.isCoasting = true;
                return { state: hand.fsm.state, pointerEvent: 'none' };
            } else {
                hand.fsm.lastTimestamp = now;
                return { state: hand.fsm.state, pointerEvent: 'none' };
            }
        };

        /**
         * ðŸ•¸ï¸ PORT 7: NAVIGATE (Plan)
         * Role: [N]avigating orchestration and BMC2 intent.
         */
        const port7Navigate = (intent) => { /* Strategic planning */ };

        const createCursorSet = (handId, hue) => {
            const h = {
                id: handId, lastSeen: 0, active: false, coastCount: 0, fsm: new GestureFSM(),
                cursors: {
                    raw: { x: 0.5, y: 0.5, color: `hsl(${hue}, 10%, 40%)`, label: `Raw Input` },
                    smooth: { x: 0.5, y: 0.5, color: `hsl(${hue}, 40%, 40%)`, label: `1Euro Smooth` },
                    snappy: { x: 0.5, y: 0.5, color: `hsl(${hue}, 70%, 40%)`, label: `1Euro Snappy` },
                    spring: { x: 0.5, y: 0.5, body: null, anchor: null, constraint: null, color: `hsl(${hue}, 90%, 50%)`, label: `1Euro Spring-Mass-Damper` },
                    predictive: { x: 0.5, y: 0.5, body: null, color: `hsl(${hue}, 100%, 50%)`, label: `1Euro Kinetic Lookahead` }
                },
                filters: {
                    sx: new OneEuroFilter(30, 0.5, 0.001), sy: new OneEuroFilter(30, 0.5, 0.001),
                    nx: new OneEuroFilter(30, 1.0, 0.01), ny: new OneEuroFilter(30, 1.0, 0.01),
                    vx: new OneEuroFilter(30, 0.5, 0.01), vy: new OneEuroFilter(30, 0.5, 0.01) // Velocity Filters for Pred
                },
                gestures: { active: 'None', score: 0, isDown: false, pointerEvent: 'none' },
                lastTarget: null,
                lastTargetOnDown: null
            };
            if (engine) {
                const { Bodies, Composite, Constraint } = Matter;
                h.cursors.spring.anchor = Bodies.circle(0.5, 0.5, 1, { isStatic: true, isSensor: true });
                h.cursors.spring.body = Bodies.circle(0.5, 0.5, 10, { frictionAir: 0.1, label: `H${handId}-SpringB` });
                h.cursors.spring.constraint = Constraint.create({ bodyA: h.cursors.spring.anchor, bodyB: h.cursors.spring.body, stiffness: hfoState.physics.stiffness, damping: hfoState.physics.damping, length: 0 });
                h.cursors.predictive.body = Bodies.circle(0.5, 0.5, 10, { isStatic: true, label: `H${handId}-PredB` });
                Composite.add(engine.world, [h.cursors.spring.anchor, h.cursors.spring.body, h.cursors.spring.constraint, h.cursors.predictive.body]);
            }
            return h;
        };

        let engine, runner, gestureRecognizer;
        const initPhysics = window.initPhysics = () => {
            if (hfoSystem.initialized) return;
            engine = Matter.Engine.create(); engine.gravity.scale = 0;
            // Removed Matter.Runner for sync stepping in the loop
            hfoState.hands[0] = createCursorSet(0, 0); hfoState.hands[1] = createCursorSet(1, 350);
            hfoSystem.initialized = true;
            initTuningMirror();
        };

        const initMediaPipe = async (container) => {
            // Ensure container is ready for absolute children and styled correctly
            container.style.position = 'relative';
            container.style.backgroundColor = '#000';
            container.classList.add('camera-container');

            // UI Controls
            if (!container.querySelector('.camera-controls')) {
                const controls = document.createElement('div');
                controls.className = 'camera-controls';

                const btnStart = document.createElement('button');
                btnStart.className = 'camera-btn start';
                btnStart.innerText = 'Start Video';

                const btnStop = document.createElement('button');
                btnStop.className = 'camera-btn stop';
                btnStop.innerText = 'Stop';
                btnStop.style.display = 'none';

                const btnFlip = document.createElement('button');
                btnFlip.className = 'camera-btn flip';
                btnFlip.innerText = 'Flip';

                const btnGolden = document.createElement('button');
                btnGolden.className = 'camera-btn golden';
                btnGolden.innerText = 'Golden Master: OFF';

                controls.appendChild(btnStart);
                controls.appendChild(btnStop);
                controls.appendChild(btnFlip);
                controls.appendChild(btnGolden);
                container.appendChild(controls);

                const updateButtons = (active) => {
                    btnStart.style.display = active ? 'none' : 'block';
                    btnStop.style.display = active ? 'block' : 'none';
                };

                btnGolden.onclick = () => {
                    const modes = ['STRAIGHT', 'LOW_NOISE', 'HIGH_NOISE'];
                    const currentIdx = modes.indexOf(hfoState.goldenMaster.mode);

                    if (!hfoState.goldenMaster.active) {
                        hfoState.goldenMaster.active = true;
                    } else if (currentIdx === modes.length - 1) {
                        hfoState.goldenMaster.active = false;
                        hfoState.goldenMaster.mode = modes[0];
                    } else {
                        hfoState.goldenMaster.mode = modes[currentIdx + 1];
                    }

                    hfoState.goldenMaster.dropProbability = hfoState.goldenMaster.mode === 'HIGH_NOISE' ? 0.3 : 0;
                    btnGolden.innerText = hfoState.goldenMaster.active ? `Golden: ${hfoState.goldenMaster.mode}` : 'Golden: OFF';
                    btnGolden.classList.toggle('active', hfoState.goldenMaster.active);

                    if (hfoState.goldenMaster.active) {
                        hfoSystem.loopActive = true;
                        if (!hfoSystem.initialized) initPhysics();
                    }
                };

                btnStart.onclick = async () => {
                    try {
                        hfoSystem.stream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 1280, height: 720, facingMode: "user" }
                        });
                        hfoSystem.video.srcObject = hfoSystem.stream;
                        hfoSystem.video.onloadedmetadata = () => {
                            hfoSystem.video.play();
                            hfoSystem.canvas.width = hfoSystem.video.videoWidth;
                            hfoSystem.canvas.height = hfoSystem.video.videoHeight;
                            hfoSystem.loopActive = true;
                            updateButtons(true);
                            if (!hfoSystem.initialized) initPhysics();
                        };
                    } catch (e) {
                        console.error("Camera access failed:", e);
                        alert("Camera access failed. Check permissions.");
                    }
                };

                btnStop.onclick = () => {
                    if (hfoSystem.stream) {
                        hfoSystem.stream.getTracks().forEach(t => t.stop());
                        hfoSystem.stream = null;
                        hfoSystem.video.srcObject = null;
                    }
                    hfoSystem.loopActive = false;
                    updateButtons(false);
                    if (hfoSystem.ctx) hfoSystem.ctx.clearRect(0, 0, hfoSystem.canvas.width, hfoSystem.canvas.height);
                };

                btnFlip.onclick = () => {
                    hfoState.physics.p0Mirror = !hfoState.physics.p0Mirror;
                    hfoState.physics.p3Mirror = hfoState.physics.p0Mirror; // ðŸ›¡ï¸ SYNC: Ensure pointer logic follows visual flip

                    if (hfoState.physics.p0Mirror) {
                        hfoSystem.video.classList.add('mirrored');
                        hfoSystem.canvas.classList.add('mirrored');
                    } else {
                        hfoSystem.video.classList.remove('mirrored');
                        hfoSystem.canvas.classList.remove('mirrored');
                    }
                };
            }

            if (hfoSystem.initializing) {
                // Wait and re-mount if already initializing (don't return empty container)
                setTimeout(() => initMediaPipe(container), 200);
                return;
            }

            hfoSystem.initializing = true;
            try {
                if (!hfoSystem.video) {
                    hfoSystem.video = document.createElement('video');
                    hfoSystem.video.autoplay = true;
                    hfoSystem.video.playsinline = true;
                    hfoSystem.video.className = 'video-feed mirrored';
                }
                if (!hfoSystem.canvas) {
                    hfoSystem.canvas = document.createElement('canvas');
                    hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
                    hfoSystem.canvas.className = 'overlay-canvas mirrored';
                }

                // Force mount to current container (singleton moves)
                // Dedup check: only append if not already child
                if (hfoSystem.video.parentElement !== container) {
                    container.appendChild(hfoSystem.video);
                }
                if (hfoSystem.canvas.parentElement !== container) {
                    container.appendChild(hfoSystem.canvas);
                }

                if (hfoSystem.recognizer) {
                    hfoSystem.initializing = false;
                    return;
                }

                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                    runningMode: "VIDEO", ...hfoState.mpOptions
                });
                hfoSystem.recognizer = gestureRecognizer;

                const render = () => {
                    let lastIter = performance.now();
                    const loop = () => {
                        const now = performance.now();
                        const dt = now - lastIter;
                        lastIter = now;
                        hfoSystem.lastFrame = now;

                        if (hfoState.active && hfoSystem.loopActive) {
                            try {
                                const res = port0Observe(hfoSystem.video, hfoSystem.recognizer, now);

                                // ðŸ•µï¸ TRANSPARENCY CALCULATION
                                let rawQuality = 0;
                                if (res && res.landmarks && res.landmarks.length > 0) {
                                    rawQuality = res.gestures?.[0]?.[0]?.score || 0.8;
                                }

                                // Penalty for low FPS (Target 30fps = 33ms)
                                const fpsPenalty = dt > 50 ? 0.2 : 0;
                                hfoState.transparency = Math.max(0, Math.min(1.0, rawQuality - fpsPenalty));

                                if (res) {
                                    const ctx = hfoSystem.ctx;
                                    const canvas = hfoSystem.canvas;
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    const dw = new DrawingUtils(ctx);

                                    const landmarks = res.landmarks || [];
                                    const landmarkCurls = landmarks.map(lm => getCurls(lm));
                                    const landmarkRatios = landmarks.map(lm => getBoneRatios(lm));

                                    const handIds = Object.keys(hfoState.hands);
                                    const assignedLandmarks = new Set();
                                    const currentAssignments = {};

                                    // PASS 1: Sticky Tracking (Kinetic Snaplock)
                                    handIds.filter(id => hfoState.hands[id].active).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minCost = hfoState.physics.persistence.teleportLimit;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.spring.x) ** 2 + (lm[8].y - h.cursors.spring.y) ** 2);
                                            if (d < minCost) { minCost = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // PASS 2: Discovery
                                    handIds.filter(id => !currentAssignments.hasOwnProperty(id)).forEach(id => {
                                        const h = hfoState.hands[id];
                                        let bestLIdx = -1;
                                        let minD = hfoState.physics.persistence.snapDistance;
                                        landmarks.forEach((lm, lIdx) => {
                                            if (assignedLandmarks.has(lIdx)) return;
                                            const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                            if (d < minD) { minD = d; bestLIdx = lIdx; }
                                        });
                                        if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                                    });

                                    // APPLY - Part 1: Sync Landmarks & Anchors
                                    handIds.forEach(id => {
                                        const h = hfoState.hands[id];
                                        if (currentAssignments.hasOwnProperty(id)) {
                                            const lIdx = currentAssignments[id];
                                            const lm = landmarks[lIdx];
                                            h.curls = landmarkCurls[lIdx];
                                            h.ratios = landmarkRatios[lIdx];
                                            h.isFacing = port2ShapeSync(h, now, lm);
                                            h.isCoasting = false;
                                        } else {
                                            h.palm = { normal: { x: 0, y: 0, z: 0 }, facingCamera: false };
                                            h.coastCount++;
                                            if (h.coastCount > hfoState.physics.persistence.coastFrames) h.active = false;
                                            port2ShapeSync(h, now, null);
                                        }
                                    });

                                    // ðŸ’ª Physics ACT (Matter.js Step)
                                    if (engine) Matter.Engine.update(engine, dt);

                                    // APPLY - Part 2: Predict, Draw, & Inject
                                    handIds.forEach(id => {
                                        const h = hfoState.hands[id];
                                        if (currentAssignments.hasOwnProperty(id)) {
                                            const lIdx = currentAssignments[id];
                                            port2ShapePredict(h, now);

                                            if (res.gestures?.[lIdx]) {
                                                const g = res.gestures[lIdx][0];
                                                const fsmRes = port6Assimilate(h, g.categoryName, g.score, now, h.isFacing, g.score);
                                                h.gestures = { active: g.categoryName, score: g.score, isDown: (h.fsm.state === 'PORT_7_POINTER_COMMITTED'), pointerEvent: fsmRes.pointerEvent };
                                            }
                                        } else {
                                            const fsmRes = port6Assimilate(h, 'LOST', 0, now, false, 0);
                                            h.gestures.isDown = (h.fsm.state === 'PORT_7_POINTER_COMMITTED');
                                            h.gestures.pointerEvent = fsmRes.pointerEvent;
                                            port2ShapePredict(h, now);
                                        }

                                        if (h.active) {
                                            if (h.visuals.showSkeleton && h.landmarks) {
                                                VisualStrategies.SKELETON(ctx, h.landmarks, dw);
                                            }

                                            [h.cursors.raw, h.cursors.smooth, h.cursors.snappy, h.cursors.spring, h.cursors.predictive].forEach(c => {
                                                const isHero = c.label.includes('Pred');
                                                if (!hfoState.debug && !isHero) return;

                                                const state = h.fsm.state;
                                                const dwellRatio = h.fsm.dwellAccumulator / h.fsm.dwellMs;
                                                const strategy = isHero ? h.visuals.hero : h.visuals.support;
                                                const size = isHero ? 14 : 3;

                                                if (VisualStrategies[strategy]) {
                                                    VisualStrategies[strategy](ctx, c, size, state, dwellRatio, c.color);
                                                }

                                                if (hfoState.debug) {
                                                    ctx.globalAlpha = 1.0;
                                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.font = '10px Roboto';
                                                    ctx.fillText(c.label.split(' ')[1], c.x * canvas.width + size + 8, c.y * canvas.height + 3);
                                                }
                                            });

                                            // ðŸ“Š PORT 4: ANALYSIS (Golden Master Results)
                                            if (hfoState.goldenMaster.active && hfoState.debug) {
                                                const tx = 50, ty = 100;
                                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                                ctx.fillRect(tx - 10, ty - 20, 250, 150);
                                                ctx.strokeStyle = '#ff0000';
                                                ctx.strokeRect(tx - 10, ty - 20, 250, 150);

                                                ctx.fillStyle = '#fff';
                                                ctx.font = 'bold 12px Roboto';
                                                ctx.fillText('PORT 4: GOLDEN MASTER ANALYSIS', tx, ty);

                                                const metrics = [
                                                    { l: 'MODE', v: hfoState.goldenMaster.mode },
                                                    { l: 'DB_RMSE', v: hfoSystem.tuningMirror.metrics.rmse.toFixed(5) },
                                                    { l: 'DB_JITTER', v: hfoSystem.tuningMirror.metrics.jitter.toFixed(5) },
                                                    { l: '1EURO_SMOOTH_V', v: (h.cursors.smooth.x - h.cursors.raw.x).toFixed(5) },
                                                    { l: 'STIFFNESS_ERROR', v: (h.cursors.spring.body.position.x - h.cursors.spring.anchor.position.x).toFixed(5) },
                                                    { l: 'PRED_BIAS', v: (h.cursors.predictive.x - h.cursors.spring.x).toFixed(5) },
                                                    { l: 'SENSE_QUALITY', v: hfoState.transparency.toFixed(2) }
                                                ];

                                                if (hfoState.goldenMaster.frameCounter % 60 === 0 && hfoSystem.tuningMirror.active) {
                                                    hfoSystem.tuningMirror.conn.query(`
                                                        SELECT 
                                                            sqrt(avg(pow(raw_x - pred_x, 2) + pow(raw_y - pred_y, 2))) as rmse,
                                                            avg(abs(pred_x - lag(pred_x) over (order by ts))) as jitter
                                                        FROM telemetry 
                                                        WHERE ts > ${now - 2000}
                                                    `).then(res => {
                                                        const row = res.toArray()[0];
                                                        if (row) {
                                                            hfoSystem.tuningMirror.metrics.rmse = row.rmse || 0;
                                                            hfoSystem.tuningMirror.metrics.jitter = row.jitter || 0;
                                                        }
                                                    });
                                                }

                                                metrics.forEach((m, i) => {
                                                    ctx.fillStyle = '#ff5252';
                                                    ctx.fillText(m.l + ':', tx, ty + 25 + i * 20);
                                                    ctx.fillStyle = '#fff';
                                                    ctx.fillText(m.v, tx + 100, ty + 25 + i * 20);
                                                });
                                            }

                                            // ðŸ§¬ Node Telemetry
                                            if (hfoState.debug) {
                                                const tx = h.cursors.raw.x * canvas.width + 15;
                                                const ty = h.cursors.raw.y * canvas.height + 25;
                                                ctx.fillStyle = '#ff0000';
                                                ctx.font = '11px Roboto Mono';
                                                const curlStr = `N1-Index: ${h.curls.index.toFixed(2)}`;
                                                ctx.fillText(curlStr, tx, ty);
                                                ctx.fillText(`COLLECTIVE_ID: ${h.id}`, tx, ty + 14);
                                            }
                                            port3Inject(h);

                                            // ðŸ“¥ Log to Tuning Mirror
                                            if (hfoSystem.tuningMirror.active) {
                                                hfoSystem.tuningMirror.batch.push(`(${now}, ${h.id}, ${h.cursors.raw.x}, ${h.cursors.raw.y}, ${h.cursors.predictive.x}, ${h.cursors.predictive.y}, '${hfoState.goldenMaster.mode}')`);
                                                if (hfoSystem.tuningMirror.batch.length > 30) {
                                                    const batch = hfoSystem.tuningMirror.batch.splice(0, 30);
                                                    hfoSystem.tuningMirror.conn.query(`INSERT INTO telemetry VALUES ${batch.join(',')}`);
                                                }
                                            }
                                        }
                                    });
                                } else {
                                    // ðŸš€ Synthetic Support
                                    const activeHands = Object.values(hfoState.hands).filter(h => h.active);
                                    activeHands.forEach(h => port2ShapeSync(h, now, null));
                                    if (engine) Matter.Engine.update(engine, dt);
                                    activeHands.forEach(h => {
                                        port2ShapePredict(h, now);
                                        port3Inject(h);
                                    });
                                }
                                port1Bridge(hfoState.hands);
                            } catch (loopErr) {
                                console.error("Loop Error Cycle:", loopErr);
                            }
                        }
                        requestAnimationFrame(loop);
                    };
                    loop();
                };

                render();
            } catch (err) {
                console.error("Critical MediaPipe Failure:", err);
            } finally {
                hfoSystem.initializing = false;
            }
        };

        const initPhysicsPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-section'; s.id = `section-h${id}`;
                            s.innerHTML = `<h2 style="font-size: 11px; color: #ff0000; margin: 10px 0 5px 0;">HAND ID: ${id}</h2>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                                    <div class="data-card" style="border-left-color: #666; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Raw</h3><code class="val-raw" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #990000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Smooth</h3><code class="val-smooth" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #cc0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Snappy</h3><code class="val-snappy" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff0000; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Spring</h3><code class="val-spring" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff4d4d; padding: 4px; border-radius: 4px; grid-column: span 2;"><h3 style="font-size:9px;">Pred</h3><code class="val-pred" style="font-size:9px;">...</code></div>
                                </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#section-h${id}`);
                        if (s) {
                            s.querySelector('.val-raw').innerText = `X:${h.cursors.raw.x.toFixed(3)}`;
                            s.querySelector('.val-smooth').innerText = `X:${h.cursors.smooth.x.toFixed(3)}`;
                            s.querySelector('.val-snappy').innerText = `X:${h.cursors.snappy.x.toFixed(3)}`;
                            s.querySelector('.val-spring').innerText = `X:${h.cursors.spring.x.toFixed(3)}`;
                            s.querySelector('.val-pred').innerText = `X:${h.cursors.pred.x.toFixed(3)}, Y:${h.cursors.pred.y.toFixed(3)}`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initTransparencyPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            div.innerHTML = `
                <div class="data-card" style="border-left-color: #ff0000; height: 100%; display: flex; flex-direction: column; justify-content: center;">
                    <h3 style="font-size: 11px; margin-bottom: 10px;">P5 IMMUNIZE: TRANSPARENCY INDEX</h3>
                    <div style="background: #222; height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                        <div id="transparency-bar" style="background: linear-gradient(90deg, #ff0000, #ff8800, #00ff00); height: 100%; width: 100%; transition: width 0.1s;"></div>
                    </div>
                    <div id="transparency-val" style="font-size: 32px; font-weight: bold; margin-top: 10px; color: #ff0000; text-align: center;">1.00</div>
                    <div style="font-size: 9px; color: #666; margin-top: 10px; text-align: center;">
                        <span style="color: #ff0000;">STUB DETECTED:</span> Reward for Honesty. <br>
                        Honest "0.00" > Fake "1.00" (AI Theater)
                    </div>
                </div>
            `;
            const bar = div.querySelector('#transparency-bar');
            const val = div.querySelector('#transparency-val');
            const update = () => {
                const score = window.hfoState.transparency || 0;
                bar.style.width = `${score * 100}%`;
                val.innerText = score.toFixed(2);
                if (score < 0.8) val.style.color = '#ff0000';
                else if (score < 0.9) val.style.color = '#ff8800';
                else val.style.color = '#00ff00';
                requestAnimationFrame(update);
            };
            update();
        };

        const initGesturesPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-gesture-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-gesture-section'; s.id = `gesture-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #cc00ff; padding: 10px; margin-bottom:10px;">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <h3 style="margin:0; font-size:12px;">HAND ${id}</h3>
                                    <span class="val-tag state-tag tag-idle">IDLE</span>
                                </div>
                                <h1 class="val-gesture" style="font-size: 24px; margin: 10px 0;">NONE</h1>
                                <div style="display:flex; gap: 5px; align-items:center;">
                                    <div class="val-event" style="background:#000; padding: 2px 5px; border-radius:3px; color:#00ff88; font-size:10px; font-family:monospace;">none</div>
                                    <div class="val-score" style="color: #666; font-size: 10px;">Conf: 0%</div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#gesture-section-h${id}`);
                        if (s) {
                            const tag = s.querySelector('.val-tag');
                            tag.innerText = h.fsm;
                            tag.className = `val-tag state-tag tag-${h.fsm.toLowerCase().split('_')[0]}`;
                            s.querySelector('.val-gesture').innerText = h.gestures.active;
                            s.querySelector('.val-event').innerText = h.gestures.pointerEvent;
                            s.querySelector('.val-score').innerText = `Conf: ${(h.gestures.score * 100).toFixed(1)}%`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initPalmConePanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting for Palm Data...</div>';
                else {
                    if (div.querySelectorAll('.hand-palm-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-palm-section'; s.id = `palm-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #ffaa00; padding: 10px; margin-bottom:10px;">
                                <h3 style="margin:0; font-size:12px;">PALM ${id}</h3>
                                <div style="display:flex; align-items:center; gap: 20px; margin-top:10px;">
                                    <div class="palm-visual" style="width:60px; height:60px; background:#000; border:2px solid #555; position:relative; border-radius:50%; overflow:hidden;">
                                        <div class="palm-dot" style="width:10px; height:10px; background:#ffaa00; position:absolute; top:50%; left:50%; border-radius:50%; transform:translate(-50%, -50%);"></div>
                                    </div>
                                    <div>
                                        <div class="val-facing" style="font-size:14px; font-weight:bold; color:#ffaa00;">FACING: NO</div>
                                        <code class="val-norm" style="font-size:10px; color:#888;">Z: 0.00</code>
                                    </div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#palm-section-h${id}`);
                        if (s && h.palm) {
                            const visual = s.querySelector('.palm-visual');
                            const dot = s.querySelector('.palm-dot');
                            const facing = s.querySelector('.val-facing');
                            const norm = s.querySelector('.val-norm');

                            facing.innerText = `FACING: ${h.palm.facingCamera ? 'YES' : 'NO'}`;
                            facing.style.color = h.palm.facingCamera ? '#00ff88' : '#ff4444';
                            norm.innerText = `X:${h.palm.normal.x.toFixed(2)} Y:${h.palm.normal.y.toFixed(2)} Z:${h.palm.normal.z.toFixed(2)}`;

                            // Visual hint: move dot based on X/Y normal
                            dot.style.left = `${50 + h.palm.normal.x * 40}%`;
                            dot.style.top = `${50 + h.palm.normal.y * 40}%`;
                            visual.style.borderColor = h.palm.facingCamera ? '#00ff88' : '#555';
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initInteractionTest = (container) => {
            const div = document.createElement('div'); div.className = 'component-container';
            div.innerHTML = `
                <div class="data-card">
                    <h3>HFO Shard Injection Node</h3>
                    <button id="test-btn" style="width:100%; height:56px; background:var(--m3-primary-container); color:white; border:none; border-radius:12px; font-size:14px; font-weight:700; cursor:pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s cubic-bezier(0, 0, 0.2, 1); text-transform:uppercase;">COMMIT GESTURE</button>
                    <div id="click-status" style="margin-top:16px; font-family:'Roboto Mono', monospace; font-size:12px; color:var(--m3-text-secondary);">Hive Status: Idle</div>
                </div>
                <div class="data-card">
                    <h3>HFO Shard Parameter Tuning</h3>
                    <input type="range" id="test-slider" style="width:100%; accent-color: var(--m3-primary);">
                </div>
            `;
            container.appendChild(div);
            const btn = div.querySelector('#test-btn');
            const status = div.querySelector('#click-status');
            btn.addEventListener('pointerdown', () => {
                btn.style.transform = 'scale(0.98) translateY(2px)';
                btn.style.boxShadow = 'none';
                status.innerText = 'Hive Status: SIGNAL_PULSE';
            });
            btn.addEventListener('pointerup', () => {
                btn.style.transform = 'scale(1) translateY(0)';
                btn.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                status.innerText = 'Hive Status: SIGNAL_RESOLVED';
            });
            btn.addEventListener('click', () => {
                status.innerText = 'Hive Status: INTENT_COMMITTED ðŸš€';
                setTimeout(() => { if (status.innerText.includes('PORT_7_POINTER_COMMITTED')) status.innerText = 'Hive Status: Idle'; }, 2000);
            });
        };

        const initPianoGenie = (container) => {
            const div = document.createElement('div');
            div.className = 'component-container';
            div.style.background = '#000';
            div.style.display = 'flex';
            div.style.flexDirection = 'column';
            div.style.alignItems = 'center';
            div.style.justifyContent = 'center';
            div.style.padding = '0px'; 
            div.style.overflow = 'hidden';

            // Official Magenta Palette
            const genieColors = [
                '#EE2B29', '#ff9800', '#ffff00', '#c6ff00',
                '#00e5ff', '#2979ff', '#651fff', '#d500f9'
            ];

            div.innerHTML = `
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center;">
                    <div style="color: var(--m3-primary); font-weight: bold; font-family: 'Roboto Mono'; letter-spacing: 4px; font-size: 18px;">PIANO GENIE</div>
                    <div id="piano-status" style="font-size: 10px; font-family: 'Roboto Mono'; color: #555; margin-top: 8px;">WAITING FOR INITIALIZATION</div>
                </div>
                
                <canvas id="waterfall-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 120px); pointer-events: none;"></canvas>

                <div id="genie-buttons" style="display: flex; gap: 4px; opacity: 0.2; pointer-events: none; width: 100%; height: 120px; position: absolute; bottom: 0; background: #111;">
                    ${[0, 1, 2, 3, 4, 5, 6, 7].map(i => `
                        <button data-id="${i}" class="genie-btn" style="
                            flex-grow: 1;
                            background: #222;
                            border: none;
                            border-top: 4px solid ${genieColors[i]};
                            cursor: pointer;
                            transition: background 0.1s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            position: relative;
                        ">
                            <span style="color: #666; font-weight: bold; font-size: 14px; pointer-events: none;">${i + 1}</span>
                            <div class="active-glow" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: ${genieColors[i]}; opacity: 0; transition: opacity 0.1s;"></div>
                        </button>
                    `).join('')}
                </div>
                
                <button id="start-audio" style="z-index: 20; background: var(--m3-primary); border: none; padding: 16px 32px; color: black; border-radius: 4px; cursor: pointer; font-weight: bold; font-family: 'Roboto Mono'; text-transform: uppercase;">Load Official Model</button>
            `;
            container.appendChild(div);

            const status = div.querySelector('#piano-status');
            const buttons = div.querySelectorAll('[data-id]');
            const btnGroup = div.querySelector('#genie-buttons');
            const btnStart = div.querySelector('#start-audio');
            const canvas = div.querySelector('#waterfall-canvas');
            const ctx = canvas.getContext('2d');

            let genie;
            let player;
            const heldNotes = new Map();
            const temperature = 0.25;
            const LOWEST_MIDI_NOTE = 21;
            
            // ðŸŒŠ Waterfall Physics State
            const activeNotes = []; // { body, color, on }

            const init = async () => {
                try {
                    btnStart.innerText = 'SYNCING WEIGHTS...';
                    btnStart.disabled = true;

                    // Initialize with local assets
                    genie = new mm.PianoGenie('./assets/piano_genie/');
                    await genie.initialize();

                    player = new mm.SoundFontPlayer('./assets/piano_genie/sgm_plus');

                    status.innerText = 'GENIE READY';
                    status.style.color = 'var(--m3-primary)';
                    btnStart.style.display = 'none';
                    btnGroup.style.opacity = '1';
                    btnGroup.style.pointerEvents = 'all';

                    // Start visual loop
                    resizeCanvas();
                    requestAnimationFrame(drawLoop);
                } catch (e) {
                    console.error("Piano Genie Load Failed:", e);
                    status.innerText = 'INITIALIZATION ERROR';
                    status.style.color = '#ff5252';
                    btnStart.innerText = 'RETRY';
                    btnStart.disabled = false;
                }
            };

            const resizeCanvas = () => {
                const rect = div.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height - 120;
            };
            window.addEventListener('resize', resizeCanvas);

            const buttonDown = async (buttonIndex) => {
                if (!genie || !player) return;

                if (mm.Player.tone.context.state !== 'running') {
                    await mm.Player.tone.context.resume();
                }

                const noteIdx = genie.next(buttonIndex, temperature);
                const pitch = LOWEST_MIDI_NOTE + noteIdx;

                player.playNoteDown({ pitch: pitch });
                
                // create visual body
                const btn = div.querySelector(`[data-id="${buttonIndex}"]`);
                const rect = btn.getBoundingClientRect();
                const divRect = div.getBoundingClientRect();
                const x = rect.left - divRect.left;
                const width = rect.width;

                const noteBody = {
                    x: x,
                    y: canvas.height, // falling from bottom up? No, traditional is top down.
                    // But buttons are at the bottom.
                    width: width,
                    height: 0,
                    color: genieColors[buttonIndex],
                    on: true
                };

                activeNotes.push(noteBody);
                heldNotes.set(buttonIndex, { pitch, noteBody });

                btn.querySelector('.active-glow').style.opacity = '0.4';
                btn.style.background = '#333';
            };

            const buttonUp = (buttonIndex) => {
                const data = heldNotes.get(buttonIndex);
                if (data) {
                    player.playNoteUp({ pitch: data.pitch });
                    data.noteBody.on = false;
                    heldNotes.delete(buttonIndex);

                    const btn = div.querySelector(`[data-id="${buttonIndex}"]`);
                    btn.querySelector('.active-glow').style.opacity = '0';
                    btn.style.background = '#222';
                }
            };

            const drawLoop = () => {
                if (!genie) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const dy = 4; // Waterfall speed
                
                for (let i = activeNotes.length - 1; i >= 0; i--) {
                    const note = activeNotes[i];
                    if (note.on) {
                        note.height += dy;
                        // Note Grows UPWARDS from the button
                    } else {
                        note.y -= dy;
                        // Finished note floats UPWARDS
                    }

                    ctx.fillStyle = note.color;
                    ctx.globalAlpha = 0.8;
                    // Draw note (growing from bottom of canvas)
                    ctx.fillRect(note.x, canvas.height - note.y - note.height, note.width, note.height);
                    
                    // Cleanup
                    if (!note.on && (canvas.height - note.y - note.height) < -100) {
                        activeNotes.splice(i, 1);
                    }
                }
                
                requestAnimationFrame(drawLoop);
            };

            buttons.forEach(btn => {
                btn.addEventListener('pointerdown', (e) => {
                    const idx = parseInt(btn.getAttribute('data-id'));
                    buttonDown(idx);
                });
                btn.addEventListener('pointerup', (e) => {
                    const idx = parseInt(btn.getAttribute('data-id'));
                    buttonUp(idx);
                });
                btn.addEventListener('pointerleave', (e) => {
                    const idx = parseInt(btn.getAttribute('data-id'));
                    buttonUp(idx);
                });
            });

            btnStart.onclick = init;
        };

        const initExcalidraw = (container) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-gate';
            wrapper.style.width = '100%';
            wrapper.style.height = '100%';
            wrapper.style.position = 'relative';
            wrapper.style.background = '#000';

            const iframe = document.createElement('iframe');
            iframe.src = './excalidraw_v31_wrapper.html';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.id = 'excalidraw-iframe';
            wrapper.appendChild(iframe);

            container.appendChild(wrapper);
        };

        const initGuide = (container) => {
            const div = document.createElement('div');
            div.className = 'component-container';
            div.innerHTML = `
                <div class="guide-section">
                    <h2 style="font-size: 18px; margin-bottom: 24px; border-bottom: 2px solid var(--m3-primary); padding-bottom: 8px;">Hive Directive</h2>
                    <div class="guide-item">
                        <h3>Collective Primacy (V44)</h3>
                        <p>Individual hands are nodes in the collective. The first node to achieve <strong>COMMITTED</strong> frequency (index finger extension) claims control over the primary cursor stream.</p>
                    </div>
                    <div class="guide-item">
                        <h3>Kinetic Carapace (Nodes)</h3>
                        <p><strong>Raw Input:</strong> The sensory surface of the hive.</p>
                        <p><strong>Spring Core:</strong> The structural core of the intent.</p>
                        <p><strong>Predictive Scout:</strong> Anticipating the hive's next state using kinetic vectors.</p>
                    </div>
                    <div class="guide-item">
                        <h3>Optimization Protocol</h3>
                        <ul>
                            <li><strong>Light:</strong> Ensure high contrast for sensor clarity.</li>
                            <li><strong>State:</strong> Hold palm flat to reset the hive's orientation.</li>
                        </ul>
                    </div>
                    <div class="guide-item" style="border-left-color: #ff9800; border-right: 1px solid rgba(255,152,0,0.2);">
                        <h3 style="color: #ff9800;">PENDING ADAPTATION (STUBS)</h3>
                        <p><strong>Haptic Pheromones:</strong> Sub-threshold haptics not yet evolved.</p>
                    </div>
                </div>
            `;
            container.appendChild(div);
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });

            const phys = gui.addFolder('Hive Dynamics');
            phys.add(hfoState.physics, 'stiffness', 0, 1).name('Node Tension');
            phys.add(hfoState.physics, 'stiffnessArmed', 0, 1).name('Commit Tension');
            phys.add(hfoState.physics, 'damping', 0, 1).name('Viscous Drag');
            phys.add(hfoState.physics, 'lookAhead', 0, 10).name('Scout Range');
            phys.open();

            const p3 = gui.addFolder('Neuro-Interaction');
            p3.add(hfoState.physics, 'p3Source', ['raw', 'smooth', 'snappy', 'spring', 'predictive']).name('Control Node');
            p3.add(hfoState.physics, 'p3Mirror').name('Invert Neural Axis');
            p3.add(hfoState.physics, 'purePointerMode').name('Raw Injection');
            p3.open();

            const mp = gui.addFolder('Sensor Intelligence');
            mp.add(hfoState.mpOptions, 'minHandDetectionConfidence', 0, 1).name('Sense Sensitivity');
            mp.add(hfoState.mpOptions, 'minTrackingConfidence', 0, 1).name('Neural Lock Strength');
            mp.add(hfoState, 'debug').name('Overlay Synapses');
            mp.open();

            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    {
                        type: 'stack',
                        width: 70,
                        content: [
                            {
                                type: 'component',
                                componentType: 'Excalidraw',
                                title: 'OMEGA: EXCALIDRAW'
                            },
                            {
                                type: 'component',
                                componentType: 'PianoGenie',
                                title: 'OMEGA: PIANO GENIE'
                            }
                        ]
                    },
                    {
                        type: 'column',
                        width: 30,
                        content: [
                            {
                                type: 'stack',
                                height: 50,
                                content: [
                                    { type: 'component', componentType: 'Transparency', title: 'P5: IMMUNIZE (FORCE PROTECTION)' },
                                    { type: 'component', componentType: 'PalmCone', title: 'P0: OBSERVE (ISR)' },
                                    { type: 'component', componentType: 'Gestures', title: 'P3: INJECT (KILL-WEB)' },
                                    { type: 'component', componentType: 'Physics', title: 'P2: SHAPE (DIGITAL TWIN)' },
                                    { type: 'component', componentType: 'Settings', title: 'P7: NAVIGATE (BMC2)' },
                                    { type: 'component', componentType: 'Guide', title: 'P7: GUIDE' },
                                    { type: 'component', componentType: 'Interaction', title: 'P3: TEST' }
                                ]
                            },
                            {
                                type: 'component',
                                componentType: 'MediaPipe',
                                title: 'P0: OBSERVE (SENSE)',
                                height: 50
                            }
                        ]
                    }
                ]
            }
        };
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('Transparency', c => initTransparencyPanel(c.element));
        layout.registerComponentFactoryFunction('PianoGenie', c => initPianoGenie(c.element));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.registerComponentFactoryFunction('Physics', c => initPhysicsPanel(c.element));
        layout.registerComponentFactoryFunction('Gestures', c => initGesturesPanel(c.element));
        layout.registerComponentFactoryFunction('PalmCone', c => initPalmConePanel(c.element));
        layout.registerComponentFactoryFunction('Interaction', c => initInteractionTest(c.element));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.registerComponentFactoryFunction('Guide', c => initGuide(c.element));
        layout.loadLayout(config); window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>