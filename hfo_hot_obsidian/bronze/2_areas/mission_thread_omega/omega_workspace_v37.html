<!-- Medallion: Bronze | Mutation: 0% | HIVE: H -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO Omega V36: Symbiotic Canalization</title>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: sans-serif;
        }

        #layout-container {
            width: 100%;
            height: 100%;
        }

        .component-container {
            padding: 10px;
            height: 100%;
            overflow: auto;
            box-sizing: border-box;
            background: #1a1a1a;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            border-radius: 8px;
            background: #000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            pointer-events: none;
        }

        .data-card {
            background: #222;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #00ccff;
            margin-bottom: 15px;
        }

        .data-card h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #888;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            color: #00ff88;
        }

        #gesture-visualizer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .state-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 5px;
        }

        .tag-idle {
            background: #444;
            color: #aaa;
        }

        .tag-arming {
            background: #ffaa00;
            color: #000;
        }

        .tag-armed {
            background: #0088ff;
            color: #fff;
        }

        .tag-committing {
            background: #ffcc00;
            color: #000;
        }

        .tag-committed {
            background: #00ff88;
            color: #000;
        }

        .tag-releasing {
            background: #ff00ff;
            color: #fff;
        }

        .ghost-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s linear, background 0.1s;
            display: none;
        }

        .ghost-cursor.active {
            display: block;
        }

        .ghost-cursor.committed {
            background: rgba(0, 255, 136, 0.6);
            border-color: #00ff88;
            transform: scale(0.8);
        }

        .ghost-cursor.armed {
            border-color: #0088ff;
            background: rgba(0, 136, 255, 0.3);
        }

        .local-cursor {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff0055;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 5px rgba(255, 0, 85, 0.8);
        }

        .local-cursor.committed {
            background: #00ff88;
            transform: scale(1.5);
            box-shadow: 0 0 10px rgba(0, 255, 136, 1);
        }

        .local-cursor.armed {
            background: #0088ff;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/+esm",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "matter-js": "https://cdn.jsdelivr.net/npm/matter-js@0.19.0/+esm",
            "zod": "https://cdn.jsdelivr.net/npm/zod@3.22.4/+esm"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import Matter from 'matter-js';
        import { z } from 'zod';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // üõ°Ô∏è Contracts
        const CursorSchema = z.object({ x: z.number(), y: z.number(), color: z.string(), label: z.string() });
        const HandSchema = z.object({
            id: z.number(), active: z.boolean(), lastSeen: z.number(), fsm: z.string(),
            cursors: z.record(CursorSchema),
            gestures: z.object({ active: z.string(), score: z.number(), isDown: z.boolean(), pointerEvent: z.string() }),
            palm: z.object({ normal: z.object({ x: z.number(), y: z.number(), z: z.number() }), facingCamera: z.boolean() }).optional()
        });
        const CloudEventSchema = z.object({
            specversion: z.literal("1.0"), type: z.string(), source: z.string(), id: z.string(), time: z.string(), data: z.record(HandSchema)
        });

        // ü§ñ V37: Palm-Oriented State Machine (FSM)
        class GestureFSM {
            constructor() {
                this.state = 'IDLE';
                this.progress = 0;
                this.recoveryStartTime = 0;
                this.dwellStartTime = 0;
                this.pointerEvent = 'none';
                this.ARMING_THRESHOLD = 300;
                this.RECOVERY_TIMEOUT = 1000; // V33: Sticky Drag
                this.RELEASE_TIMEOUT = 200;   
                this.CANCEL_DWELL = 50;
                this.lastTimestamp = 0;
            }

            process(gesture, timestamp, score = 1.0, isPalmFacing = false) {
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const dt = this.lastTimestamp ? timestamp - this.lastTimestamp : 0;
                this.lastTimestamp = timestamp;
                this.pointerEvent = 'none';
                const isConfident = score > 0.5;

                switch (this.state) {
                    case 'IDLE':
                        if (isPalmFacing) {
                            this.state = 'ARMING';
                            this.progress = 0;
                        }
                        break;

                    case 'ARMING':
                        if (isPalmFacing) {
                            this.progress += dt;
                        } else {
                            this.state = 'IDLE';
                            break;
                        }
                        if (this.progress >= this.ARMING_THRESHOLD) {
                            this.state = 'ARMED';
                            this.progress = 0;
                        }
                        break;

                    case 'ARMED':
                        this.pointerEvent = 'pointermove';
                        if (!isPalmFacing) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointercancel';
                            break;
                        }
                        // Transition to COMMITTING if we start to point
                        if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'COMMITTING';
                            this.progress = 0;
                        }
                        break;

                    case 'COMMITTING':
                        this.pointerEvent = 'pointermove';
                        if (!isPalmFacing) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointercancel';
                            break;
                        }
                        // Immediately commit if POINTING_UP is stable
                        if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'COMMITTED';
                            this.pointerEvent = 'pointerdown';
                            this.recoveryStartTime = 0;
                        } else if (currentGesture !== 'NONE' && currentGesture !== 'LOST' && isConfident) {
                            // If we see a different gesture entirely, go back to ARMED
                            this.state = 'ARMED';
                        }
                        break;

                    case 'COMMITTED':
                        this.pointerEvent = 'pointermove';
                        if (!isPalmFacing) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointerup';
                            break;
                        }
                        if (currentGesture === 'OPEN_PALM' && isConfident) {
                            this.state = 'RELEASING';
                            this.recoveryStartTime = 0;
                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.recoveryStartTime = 0;
                        } else {
                            // Sticky Drag logic
                            if (!this.recoveryStartTime) this.recoveryStartTime = timestamp;
                            if (timestamp - this.recoveryStartTime > this.RECOVERY_TIMEOUT) {
                                this.state = 'IDLE';
                                this.pointerEvent = 'pointerup';
                                this.recoveryStartTime = 0;
                            }
                        }
                        break;

                    case 'RELEASING':
                        this.pointerEvent = 'pointermove';
                        if (!isPalmFacing) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointerup';
                            break;
                        }
                        if (currentGesture === 'OPEN_PALM' && isConfident) {
                            // Wait for actual gesture release or dwell
                            if (!this.recoveryStartTime) this.recoveryStartTime = timestamp;
                            if (timestamp - this.recoveryStartTime > this.RELEASE_TIMEOUT) {
                                this.state = 'ARMED';
                                this.pointerEvent = 'pointerup';
                                this.recoveryStartTime = 0;
                            }
                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
                            // Re-grip
                            this.state = 'COMMITTED';
                            this.pointerEvent = 'pointerdown';
                            this.recoveryStartTime = 0;
                        } else {
                            // Cancel dwell if unknown gesture
                            if (!this.dwellStartTime) this.dwellStartTime = timestamp;
                            if (timestamp - this.dwellStartTime > this.CANCEL_DWELL) {
                                this.state = 'ARMED';
                                this.pointerEvent = 'pointerup';
                                this.dwellStartTime = 0;
                            }
                        }
                        break;
                }
                return { state: this.state, pointerEvent: this.pointerEvent };
            }
        }

        // üß† Multi-Resolution Filters (Smooth/Snappy Presets)
        class LowPassFilter { constructor(alpha) { this.alpha = alpha; this.s = null; } call(v) { if (this.s === null) this.s = v; else this.s = this.alpha * v + (1 - this.alpha) * this.s; return this.s; } }
        class OneEuroFilter {
            constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
                this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
                this.xFilter = new LowPassFilter(this.alpha(minCutoff)); this.dxFilter = new LowPassFilter(this.alpha(dCutoff)); this.lastTime = null;
            }
            alpha(c) { const te = 1 / this.freq; const tau = 1 / (2 * Math.PI * c); return 1 / (1 + tau / te); }
            call(x, t = null) {
                if (this.lastTime !== null && t !== null) { const dt = (t - this.lastTime) / 1000; if (dt > 0) this.freq = 1 / dt; }
                this.lastTime = t; const prevX = this.xFilter.s; const dx = prevX === null ? 0 : (x - prevX) * this.freq;
                const edx = this.dxFilter.call(dx); const c = this.minCutoff + this.beta * Math.abs(edx);
                this.xFilter.alpha = this.alpha(c); return this.xFilter.call(x);
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: true,
            mpOptions: { numHands: 2, minHandDetectionConfidence: 0.6, minHandPresenceConfidence: 0.6, minTrackingConfidence: 0.6, dwellMs: 1000 },
            physics: {
                stiffness: 0.2, stiffnessArmed: 0.6, damping: 0.1, lookAhead: 1.5,
                springSource: 'snappy', predSource: 'snappy',
                p3Source: 'predictive', p3Mirror: true,
                showGlobalCursor: false,
                remoteMode: true,
                remoteTargetId: 'excalidraw-iframe',
                persistence: { snapDistance: 0.15, coastFrames: 60, repulsionDistance: 0.12, teleportLimit: 0.3 }
            },
            hands: {}, bridge: { lastEvent: null, errorCount: 0, status: 'IDLE' }
        };

        // üõ∞Ô∏è V37 System Singleton Guard
        const hfoSystem = window.hfoSystem = {
            initialized: false,
            video: null,
            canvas: null,
            ctx: null,
            recognizer: null,
            stream: null,
            loopActive: false
        };

        const port1Bridge = (hands) => {
            try {
                const telemetryData = {};
                Object.keys(hands).forEach(id => {
                    const h = hands[id];
                    telemetryData[id] = {
                        id: h.id, active: h.active, lastSeen: h.lastSeen, fsm: h.fsm.state,
                        cursors: {
                            raw: { x: h.cursors.raw.x, y: h.cursors.raw.y, color: h.cursors.raw.color, label: h.cursors.raw.label },
                            smooth: { x: h.cursors.smooth.x, y: h.cursors.smooth.y, color: h.cursors.smooth.color, label: h.cursors.smooth.label },
                            snappy: { x: h.cursors.snappy.x, y: h.cursors.snappy.y, color: h.cursors.snappy.color, label: h.cursors.snappy.label },
                            spring: { x: h.cursors.spring.x, y: h.cursors.spring.y, color: h.cursors.spring.color, label: h.cursors.spring.label },
                            pred: { x: h.cursors.predictive.x, y: h.cursors.predictive.y, color: h.cursors.predictive.color, label: h.cursors.predictive.label }
                        },
                        gestures: { ...h.gestures, pointerEvent: h.fsm.pointerEvent },
                        palm: h.palm ? { normal: { ...h.palm.normal }, facingCamera: h.palm.facingCamera } : undefined
                    };
                });
                const event = { specversion: "1.0", type: "hfo.omega.v25.hand_update", source: "hfo.port.0.sense", id: crypto.randomUUID(), time: new Date().toISOString(), data: telemetryData };
                const validated = CloudEventSchema.parse(event);
                hfoState.bridge.lastEvent = validated; hfoState.bridge.status = 'VALID'; return validated;
            } catch (e) {
                hfoState.bridge.status = 'ERROR'; hfoState.bridge.errorCount++;
                if (hfoState.debug) console.error("P1 Bridge Validation Error:", e);
                return null;
            }
        };

        const p3InjectPointer = window.p3InjectPointer = (hand) => {
            if (!hand.active) {
                if (hand.ghost) hand.ghost.classList.remove('active');
                if (hand.localCursor) hand.localCursor.style.display = 'none';
                return;
            }

            if (!hand.ghost) {
                hand.ghost = document.createElement('div');
                hand.ghost.className = 'ghost-cursor';
                document.body.appendChild(hand.ghost);
            }

            const types = { 'pointerdown': 'pointerdown', 'pointermove': 'pointermove', 'pointerup': 'pointerup', 'pointercancel': 'pointercancel' };
            const type = types[hand.fsm.pointerEvent];
            const activeType = type || (hand.fsm.state !== 'IDLE' ? 'pointermove' : null);

            if (!activeType || !hand.active) {
                hand.ghost.classList.remove('active');
                if (hand.localCursor) hand.localCursor.style.display = 'none';
                return;
            }

            const cursor = hand.cursors[hfoState.physics.p3Source] || hand.cursors.predictive;
            let normX = cursor.x;
            if (hfoState.physics.p3Mirror) normX = 1 - normX;

            let x = normX * window.innerWidth;
            let y = cursor.y * window.innerHeight;

            let target = document.elementFromPoint(x, y) || document.body;
            let finalX = x;
            let finalY = y;

            // üéØ V30: Robust Coordinate Mapping & Drill
            if (hfoState.physics.remoteMode && hfoState.physics.remoteTargetId) {
                const remoteEl = document.getElementById(hfoState.physics.remoteTargetId);
                if (remoteEl) {
                    const rect = remoteEl.getBoundingClientRect();
                    // 1:1 Mapping to Substrate
                    finalX = normX * rect.width;
                    finalY = cursor.y * rect.height;

                    target = remoteEl;

                    // üõ†Ô∏è DRILL: If same-origin iframe, find internal target
                    if (remoteEl.tagName === 'IFRAME') {
                        try {
                            const innerTarget = remoteEl.contentDocument.elementFromPoint(finalX, finalY);
                            if (innerTarget) {
                                target = innerTarget;
                            } else {
                                // Fallback to absolute if drill returns null
                                finalX = rect.left + finalX;
                                finalY = rect.top + finalY;
                            }
                        } catch (e) {
                            if (hfoState.debug) console.warn("Iframe Drill Failed:", e.message);
                            finalX = rect.left + finalX;
                            finalY = rect.top + finalY;
                        }
                    } else {
                        // Not an iframe, map to absolute relative to element
                        finalX = rect.left + finalX;
                        finalY = rect.top + finalY;
                    }

                    // Visual feedback
                    if (!hand.localCursor) {
                        hand.localCursor = document.createElement('div');
                        hand.localCursor.className = 'local-cursor';
                        document.body.appendChild(hand.localCursor);
                    }
                    hand.localCursor.style.display = 'block';
                    hand.localCursor.style.left = `${rect.left + (normX * rect.width) - 5}px`;
                    hand.localCursor.style.top = `${rect.top + (cursor.y * rect.height) - 5}px`;
                    hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase()}`;
                }
            } else {
                // ... Legacy ElementFromPoint Mode ...
                if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                    const rect = target.getBoundingClientRect();
                    finalX = x - rect.left;
                    finalY = y - rect.top;
                    if (target.tagName === 'IFRAME') {
                        try {
                            const inner = target.contentDocument.elementFromPoint(finalX, finalY);
                            if (inner) target = inner;
                            else { finalX = x; finalY = y; }
                        } catch (e) { finalX = x; finalY = y; }
                    }
                } else {
                    finalX = x; finalY = y;
                }

                if (target.tagName === 'IFRAME' || target.classList.contains('canvas-gate')) {
                    if (!hand.localCursor) {
                        hand.localCursor = document.createElement('div');
                        hand.localCursor.className = 'local-cursor';
                        document.body.appendChild(hand.localCursor);
                    }
                    hand.localCursor.style.display = 'block';
                    hand.localCursor.style.left = `${x - 5}px`;
                    hand.localCursor.style.top = `${y - 5}px`;
                    hand.localCursor.className = `local-cursor ${hand.fsm.state.toLowerCase()}`;
                } else {
                    if (hand.localCursor) hand.localCursor.style.display = 'none';
                }
            }

            if (hfoState.physics.showGlobalCursor) {
                hand.ghost.classList.add('active');
                hand.ghost.style.left = `${x - 10}px`;
                hand.ghost.style.top = `${y - 10}px`;
            } else {
                hand.ghost.classList.remove('active');
            }

            hand.ghost.classList.toggle('committed', hand.fsm.state === 'COMMITTED');
            hand.ghost.classList.toggle('armed', hand.fsm.state === 'ARMED' || hand.fsm.state === 'COMMITTING');

            if (hand.lastTarget && hand.lastTarget !== target) {
                hand.lastTarget.dispatchEvent(new PointerEvent('pointerout', { bubbles: true, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                hand.lastTarget.dispatchEvent(new PointerEvent('pointerleave', { bubbles: false, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                target.dispatchEvent(new PointerEvent('pointerover', { bubbles: true, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
                target.dispatchEvent(new PointerEvent('pointerenter', { bubbles: false, pointerId: Number(hand.id) + 10, clientX: x, clientY: y }));
            }

            const movementX = hand.lastX !== undefined ? x - hand.lastX : 0;
            const movementY = hand.lastY !== undefined ? y - hand.lastY : 0;
            hand.lastX = x;
            hand.lastY = y;
            hand.lastTarget = target;

            const isDown = (hand.fsm.state === 'COMMITTED');
            const ev = new PointerEvent(activeType, {
                bubbles: true, cancelable: true, pointerType: 'mouse',
                view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                pointerId: Number(hand.id) + 10,
                clientX: finalX, clientY: finalY,
                screenX: finalX, screenY: finalY,
                pageX: finalX, pageY: finalY,
                movementX: movementX, movementY: movementY,
                width: 10, height: 10,
                pressure: isDown ? 0.9 : 0.0,
                buttons: isDown ? 1 : 0,
                button: (activeType === 'pointerdown' || activeType === 'pointerup') ? 0 : -1,
                isPrimary: true
            });
            target.dispatchEvent(ev);

            // üéØ Synthesis: Mouse events for legacy/React compatibility
            if (activeType === 'pointerdown' || activeType === 'pointerup') {
                const mouseType = activeType === 'pointerdown' ? 'mousedown' : 'mouseup';
                const mouseEv = new MouseEvent(mouseType, {
                    bubbles: true, cancelable: true, view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                    clientX: finalX, clientY: finalY,
                    button: 0, buttons: isDown ? 1 : 0,
                    detail: 1
                });
                target.dispatchEvent(mouseEv);
            }

            // üéØ Synthesis: Discrete Click for UI elements
            if (activeType === 'pointerup' && hand.fsm.state === 'ARMED') {
                const clickEv = new MouseEvent('click', {
                    bubbles: true, cancelable: true, view: (target.ownerDocument ? target.ownerDocument.defaultView : window),
                    clientX: finalX, clientY: finalY,
                    button: 0, buttons: 0,
                    detail: 1
                });
                target.dispatchEvent(clickEv);
                if (hfoState.debug) console.log(`[P3] Synthetic Click on <${target.tagName.toLowerCase()}> at ${finalX.toFixed(0)},${finalY.toFixed(0)}`);
            }

            if (hfoState.debug && type) console.log(`[P3] ${type} on <${target.tagName.toLowerCase()}> @ ${finalX.toFixed(0)},${finalY.toFixed(0)}`);
        };

        const createCursorSet = (handId, hue) => {
            const h = {
                id: handId, lastSeen: 0, active: false, coastCount: 0, fsm: new GestureFSM(),
                cursors: {
                    raw: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 100%)`, label: `H${handId} Raw` },
                    smooth: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 70%)`, label: `H${handId} Smooth` },
                    snappy: { x: 0.5, y: 0.5, color: `hsl(${hue}, 100%, 50%)`, label: `H${handId} Snappy` },
                    spring: { x: 0.5, y: 0.5, body: null, anchor: null, constraint: null, color: `hsl(${hue}, 100%, 40%)`, label: `H${handId} Spring` },
                    predictive: { x: 0.5, y: 0.5, body: null, color: `hsl(${hue}, 100%, 30%)`, label: `H${handId} Pred` }
                },
                filters: { sx: new OneEuroFilter(30, 0.5, 0.001), sy: new OneEuroFilter(30, 0.5, 0.001), nx: new OneEuroFilter(30, 2.0, 0.1), ny: new OneEuroFilter(30, 2.0, 0.1) },
                gestures: { active: 'None', score: 0, isDown: false, pointerEvent: 'none' },
                lastTarget: null
            };
            if (engine) {
                const { Bodies, Composite, Constraint } = Matter;
                h.cursors.spring.anchor = Bodies.circle(0.5, 0.5, 1, { isStatic: true, isSensor: true });
                h.cursors.spring.body = Bodies.circle(0.5, 0.5, 10, { frictionAir: 0.1, label: `H${handId}-SpringB` });
                h.cursors.spring.constraint = Constraint.create({ bodyA: h.cursors.spring.anchor, bodyB: h.cursors.spring.body, stiffness: hfoState.physics.stiffness, damping: hfoState.physics.damping, length: 0 });
                h.cursors.predictive.body = Bodies.circle(0.5, 0.5, 10, { isStatic: true, label: `H${handId}-PredB` });
                Composite.add(engine.world, [h.cursors.spring.anchor, h.cursors.spring.body, h.cursors.spring.constraint, h.cursors.predictive.body]);
            }
            return h;
        };

        let engine, runner, gestureRecognizer;
        const initPhysics = window.initPhysics = () => {
            if (hfoSystem.initialized) return;
            engine = Matter.Engine.create(); engine.gravity.scale = 0;
            runner = Matter.Runner.create(); Matter.Runner.run(runner, engine);
            hfoState.hands[0] = createCursorSet(0, 200); hfoState.hands[1] = createCursorSet(1, 30);
            hfoSystem.initialized = true;
        };

        const initMediaPipe = async (container) => {
            // Re-use or Create Singleton Elements
            if (!hfoSystem.video) {
                hfoSystem.video = document.createElement('video');
                hfoSystem.video.autoplay = true;
                hfoSystem.video.playsinline = true;
                hfoSystem.video.style.opacity = '0.3';
            }
            if (!hfoSystem.canvas) {
                hfoSystem.canvas = document.createElement('canvas');
                hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
            }
            
            // Attach to current container
            container.appendChild(hfoSystem.video);
            container.appendChild(hfoSystem.canvas);

            if (hfoSystem.loopActive) {
                // Resize if needed
                hfoSystem.canvas.width = hfoSystem.video.videoWidth || 1280;
                hfoSystem.canvas.height = hfoSystem.video.videoHeight || 720;
                return;
            }

            const video = hfoSystem.video;
            const canvas = hfoSystem.canvas;
            const ctx = hfoSystem.ctx;
            const dw = new DrawingUtils(ctx);
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO", ...hfoState.mpOptions
            });
            hfoSystem.recognizer = gestureRecognizer;

            const render = () => {
                const loop = () => {
                    const now = performance.now();
                    if (hfoState.active && video.readyState >= 2) {
                        try {
                            const res = gestureRecognizer.recognizeForVideo(video, now);
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const landmarks = res.landmarks || [];
                            const handIds = Object.keys(hfoState.hands);

                            const assignedLandmarks = new Set();
                            const currentAssignments = {};

                            // PASS 1: Sticky Tracking
                            handIds.filter(id => hfoState.hands[id].active).forEach(id => {
                                const h = hfoState.hands[id];
                                let bestLIdx = -1;
                                let minD = hfoState.physics.persistence.teleportLimit;
                                landmarks.forEach((lm, lIdx) => {
                                    if (assignedLandmarks.has(lIdx)) return;
                                    const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                    if (d < minD) { minD = d; bestLIdx = lIdx; }
                                });
                                if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                            });

                            // PASS 2: Discovery
                            handIds.filter(id => !currentAssignments.hasOwnProperty(id)).forEach(id => {
                                const h = hfoState.hands[id];
                                let bestLIdx = -1;
                                let minD = hfoState.physics.persistence.snapDistance;
                                landmarks.forEach((lm, lIdx) => {
                                    if (assignedLandmarks.has(lIdx)) return;
                                    const d = Math.sqrt((lm[8].x - h.cursors.raw.x) ** 2 + (lm[8].y - h.cursors.raw.y) ** 2);
                                    if (d < minD) { minD = d; bestLIdx = lIdx; }
                                });
                                if (bestLIdx !== -1) { assignedLandmarks.add(bestLIdx); currentAssignments[id] = bestLIdx; }
                            });

                            // APPLY
                            handIds.forEach(id => {
                                const h = hfoState.hands[id];
                                if (currentAssignments.hasOwnProperty(id)) {
                                    const lIdx = currentAssignments[id];
                                    const lm = landmarks[lIdx];
                                    
                                    // üéØ V37: Palm Orientation Cone (Safe Calc)
                                    const v1 = { x: lm[5].x - lm[0].x, y: lm[5].y - lm[0].y, z: lm[5].z - lm[0].z };
                                    const v2 = { x: lm[17].x - lm[0].x, y: lm[17].y - lm[0].y, z: lm[17].z - lm[0].z };
                                    const cross = {
                                        x: (v1.y * v2.z - v1.z * v2.y) || 0,
                                        y: (v1.z * v2.x - v1.x * v2.z) || 0,
                                        z: (v1.x * v2.y - v1.y * v2.x) || 0
                                    };
                                    const mag = Math.sqrt(cross.x ** 2 + cross.y ** 2 + cross.z ** 2) || 1;
                                    const normal = { x: cross.x / mag, y: cross.y / mag, z: cross.z / mag };
                                    const isFacing = normal.z < -0.3;
                                    h.palm = { normal, facingCamera: isFacing };

                                    h.cursors.raw.x = lm[8].x; h.cursors.raw.y = lm[8].y; h.lastSeen = now; h.coastCount = 0; h.active = true;
                                    h.cursors.smooth.x = h.filters.sx.call(lm[8].x, now); h.cursors.smooth.y = h.filters.sy.call(lm[8].y, now);
                                    h.cursors.snappy.x = h.filters.nx.call(lm[8].x, now); h.cursors.snappy.y = h.filters.ny.call(lm[8].y, now);

                                    if (res.gestures?.[lIdx]) {
                                        const g = res.gestures[lIdx][0];
                                        const fsmRes = h.fsm.process(g.categoryName, now, g.score, isFacing);
                                        h.gestures = { active: g.categoryName, score: g.score, isDown: (h.fsm.state === 'COMMITTED'), pointerEvent: fsmRes.pointerEvent };
                                    }
                                } else {
                                    h.palm = { normal: { x: 0, y: 0, z: 0 }, facingCamera: false };
                                    h.coastCount++;
                                    const fsmRes = h.fsm.process('LOST', now, 0, false);
                                    h.gestures.isDown = (h.fsm.state === 'COMMITTED');
                                    h.gestures.pointerEvent = fsmRes.pointerEvent;
                                    if (h.coastCount > hfoState.physics.persistence.coastFrames) h.active = false;
                                }

                                if (h.active) {
                                    if (hfoState.debug && currentAssignments.hasOwnProperty(id)) {
                                        dw.drawConnectors(landmarks[currentAssignments[id]], HandLandmarker.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
                                    }
                                    if (engine) {
                                        const isEngaged = h.fsm.state === 'ARMED' || h.fsm.state === 'COMMITTED';
                                        h.cursors.spring.constraint.stiffness = isEngaged ? hfoState.physics.stiffnessArmed : hfoState.physics.stiffness;
                                        Matter.Body.setPosition(h.cursors.spring.anchor, { x: h.cursors[hfoState.physics.springSource].x * canvas.width, y: h.cursors[hfoState.physics.springSource].y * canvas.height });
                                        const lead = { x: (h.cursors.snappy.x - h.cursors.smooth.x) * hfoState.physics.lookAhead, y: (h.cursors.snappy.y - h.cursors.smooth.y) * hfoState.physics.lookAhead };
                                        Matter.Body.setPosition(h.cursors.predictive.body, { x: (h.cursors[hfoState.physics.predSource].x + lead.x) * canvas.width, y: (h.cursors[hfoState.physics.predSource].y + lead.y) * canvas.height });
                                        h.cursors.spring.x = h.cursors.spring.body.position.x / canvas.width; h.cursors.spring.y = h.cursors.spring.body.position.y / canvas.height;
                                        h.cursors.predictive.x = h.cursors.predictive.body.position.x / canvas.width; h.cursors.predictive.y = h.cursors.predictive.body.position.y / canvas.height;
                                    }

                                    [h.cursors.raw, h.cursors.smooth, h.cursors.snappy, h.cursors.spring, h.cursors.predictive].forEach(c => {
                                        ctx.beginPath(); ctx.arc(c.x * canvas.width, c.y * canvas.height, 12, 0, 2 * Math.PI);
                                        ctx.fillStyle = c.color; ctx.globalAlpha = 1.0; ctx.fill();
                                        ctx.strokeStyle = (h.fsm.state === 'COMMITTED') ? '#00ff88' : (h.fsm.state === 'ARMED' ? '#0088ff' : 'transparent');
                                        ctx.lineWidth = 4; ctx.stroke();
                                        ctx.globalAlpha = 1.0; ctx.fillStyle = '#fff'; ctx.font = '10px Courier'; ctx.fillText(c.label, c.x * canvas.width + 15, c.y * canvas.height + 5);
                                    });
                                    p3InjectPointer(h);
                                }
                            });
                            port1Bridge(hfoState.hands);
                        } catch (err) {
                            if (hfoState.debug) console.error("MediaPipe Loop Logic Error:", err);
                        }
                    }
                    requestAnimationFrame(loop);
                };
                hfoSystem.loopActive = true;
                loop();
            };

            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                initPhysics();
                render();
            };
            
            if (!hfoSystem.stream) {
                hfoSystem.stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                video.srcObject = hfoSystem.stream;
            } else if (video.readyState >= 2) {
                render();
            }
        };

        const initPhysicsPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-section'; s.id = `section-h${id}`;
                            s.innerHTML = `<h2 style="font-size: 11px; color: #888; margin: 10px 0 5px 0;">HAND ID: ${id}</h2>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                                    <div class="data-card" style="border-left-color: #ffffff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Raw</h3><code class="val-raw" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #00ccff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Smooth</h3><code class="val-smooth" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ffcc00; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Snappy</h3><code class="val-snappy" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #ff00ff; padding: 4px; border-radius: 4px;"><h3 style="font-size:9px;">Spring</h3><code class="val-spring" style="font-size:9px;">...</code></div>
                                    <div class="data-card" style="border-left-color: #00ff00; padding: 4px; border-radius: 4px; grid-column: span 2;"><h3 style="font-size:9px;">Pred</h3><code class="val-pred" style="font-size:9px;">...</code></div>
                                </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#section-h${id}`);
                        if (s) {
                            s.querySelector('.val-raw').innerText = `X:${h.cursors.raw.x.toFixed(3)}`;
                            s.querySelector('.val-smooth').innerText = `X:${h.cursors.smooth.x.toFixed(3)}`;
                            s.querySelector('.val-snappy').innerText = `X:${h.cursors.snappy.x.toFixed(3)}`;
                            s.querySelector('.val-spring').innerText = `X:${h.cursors.spring.x.toFixed(3)}`;
                            s.querySelector('.val-pred').innerText = `X:${h.cursors.pred.x.toFixed(3)}, Y:${h.cursors.pred.y.toFixed(3)}`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initGesturesPanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting...</div>';
                else {
                    if (div.querySelectorAll('.hand-gesture-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-gesture-section'; s.id = `gesture-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #cc00ff; padding: 10px; margin-bottom:10px;">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <h3 style="margin:0; font-size:12px;">HAND ${id}</h3>
                                    <span class="val-tag state-tag tag-idle">IDLE</span>
                                </div>
                                <h1 class="val-gesture" style="font-size: 24px; margin: 10px 0;">NONE</h1>
                                <div style="display:flex; gap: 5px; align-items:center;">
                                    <div class="val-event" style="background:#000; padding: 2px 5px; border-radius:3px; color:#00ff88; font-size:10px; font-family:monospace;">none</div>
                                    <div class="val-score" style="color: #666; font-size: 10px;">Conf: 0%</div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#gesture-section-h${id}`);
                        if (s) {
                            const tag = s.querySelector('.val-tag');
                            tag.innerText = h.fsm;
                            tag.className = `val-tag state-tag tag-${h.fsm.toLowerCase().split('_')[0]}`;
                            s.querySelector('.val-gesture').innerText = h.gestures.active;
                            s.querySelector('.val-event').innerText = h.gestures.pointerEvent;
                            s.querySelector('.val-score').innerText = `Conf: ${(h.gestures.score * 100).toFixed(1)}%`;
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initPalmConePanel = (container) => {
            const div = document.createElement('div'); div.className = 'component-container'; container.appendChild(div);
            const update = () => {
                const data = hfoState.bridge.lastEvent?.data || {}; const ids = Object.keys(data);
                if (ids.length === 0) div.innerHTML = '<div class="data-card">Waiting for Palm Data...</div>';
                else {
                    if (div.querySelectorAll('.hand-palm-section').length !== ids.length) {
                        div.innerHTML = '';
                        ids.sort().forEach(id => {
                            const s = document.createElement('div'); s.className = 'hand-palm-section'; s.id = `palm-section-h${id}`;
                            s.innerHTML = `<div class="data-card" style="border-left-color: #ffaa00; padding: 10px; margin-bottom:10px;">
                                <h3 style="margin:0; font-size:12px;">PALM ${id}</h3>
                                <div style="display:flex; align-items:center; gap: 20px; margin-top:10px;">
                                    <div class="palm-visual" style="width:60px; height:60px; background:#000; border:2px solid #555; position:relative; border-radius:50%; overflow:hidden;">
                                        <div class="palm-dot" style="width:10px; height:10px; background:#ffaa00; position:absolute; top:50%; left:50%; border-radius:50%; transform:translate(-50%, -50%);"></div>
                                    </div>
                                    <div>
                                        <div class="val-facing" style="font-size:14px; font-weight:bold; color:#ffaa00;">FACING: NO</div>
                                        <code class="val-norm" style="font-size:10px; color:#888;">Z: 0.00</code>
                                    </div>
                                </div>
                           </div>`;
                            div.appendChild(s);
                        });
                    }
                    ids.forEach(id => {
                        const h = data[id]; const s = div.querySelector(`#palm-section-h${id}`);
                        if (s && h.palm) {
                            const visual = s.querySelector('.palm-visual');
                            const dot = s.querySelector('.palm-dot');
                            const facing = s.querySelector('.val-facing');
                            const norm = s.querySelector('.val-norm');

                            facing.innerText = `FACING: ${h.palm.facingCamera ? 'YES' : 'NO'}`;
                            facing.style.color = h.palm.facingCamera ? '#00ff88' : '#ff4444';
                            norm.innerText = `X:${h.palm.normal.x.toFixed(2)} Y:${h.palm.normal.y.toFixed(2)} Z:${h.palm.normal.z.toFixed(2)}`;
                            
                            // Visual hint: move dot based on X/Y normal
                            dot.style.left = `${50 + h.palm.normal.x * 40}%`;
                            dot.style.top = `${50 + h.palm.normal.y * 40}%`;
                            visual.style.borderColor = h.palm.facingCamera ? '#00ff88' : '#555';
                        }
                    });
                }
                requestAnimationFrame(update);
            }; update();
        };

        const initInteractionTest = (container) => {
            const div = document.createElement('div'); div.className = 'component-container';
            div.innerHTML = `
                <div class="data-card" style="border-left-color: #ff0055;">
                    <h3>P3 Injection Target</h3>
                    <button id="test-btn" style="width:100%; height:80px; background:#333; color:#fff; border:2px solid #ff0055; border-radius:8px; font-size:18px; cursor:pointer;">CLICK ME</button>
                    <div id="click-status" style="margin-top:10px; font-family:monospace; font-size:12px; color:#aaa;">Last Action: None</div>
                </div>
                <div class="data-card" style="border-left-color: #00ff88;">
                    <h3>Slider Test</h3>
                    <input type="range" id="test-slider" style="width:100%;">
                </div>
            `;
            container.appendChild(div);
            const btn = div.querySelector('#test-btn');
            const status = div.querySelector('#click-status');
            btn.addEventListener('pointerdown', () => {
                btn.style.background = '#ff0055';
                status.innerText = 'Last Action: pointerdown';
            });
            btn.addEventListener('pointerup', () => {
                btn.style.background = '#333';
                status.innerText = 'Last Action: pointerup';
            });
            btn.addEventListener('click', () => {
                status.innerText = 'Last Action: click! üöÄ';
                setTimeout(() => { if (status.innerText.includes('click')) status.innerText = 'Last Action: waiting...'; }, 2000);
            });
        };

        const initExcalidraw = (container) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-gate';
            wrapper.style.width = '100%';
            wrapper.style.height = '100%';
            wrapper.style.position = 'relative';
            wrapper.style.background = '#fff';

            const iframe = document.createElement('iframe');
            iframe.src = './excalidraw_v30_wrapper.html';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.id = 'excalidraw-iframe';
            wrapper.appendChild(iframe);

            container.appendChild(wrapper);
        };

        const initSettings = (container) => {
            const gui = new GUI({ container, autoPlace: false });
            const phys = gui.addFolder('V25 Dynamics');
            phys.add(hfoState.physics, 'springSource', ['snappy', 'smooth', 'raw']).name('Anchor');
            phys.add(hfoState.physics, 'stiffness', 0, 1).name('Stiffness');
            phys.add(hfoState.physics, 'stiffnessArmed', 0, 1).name('Armed Stiffness');
            phys.add(hfoState.physics, 'lookAhead', 0, 10).name('Pred Time');
            phys.open();

            const p3 = gui.addFolder('P3 Injection');
            p3.add(hfoState.physics, 'p3Source', ['raw', 'smooth', 'snappy', 'spring', 'predictive']).name('Inject Source');
            p3.add(hfoState.physics, 'p3Mirror').name('Mirror X Coordinates');
            p3.open();

            const mp = gui.addFolder('MediaPipe');
            mp.add(hfoState, 'debug').name('Show Connections');
            mp.add(hfoState.physics, 'showGlobalCursor').name('Global Cursor');
            mp.open();
            container.appendChild(gui.domElement);
        };

        const config = {
            root: {
                type: 'row', content: [
                    {
                        type: 'component',
                        componentType: 'Excalidraw',
                        title: 'OMEGA: EXCALIDRAW',
                        width: 70
                    },
                    {
                        type: 'column',
                        width: 30,
                        content: [
                            {
                                type: 'stack',
                                height: 50,
                                content: [
                                    { type: 'component', componentType: 'PalmCone', title: 'P0: ORIENTATION' },
                                    { type: 'component', componentType: 'Gestures', title: 'P3: FSM' },
                                    { type: 'component', componentType: 'Physics', title: 'P2: SHAPE' },
                                    { type: 'component', componentType: 'Settings', title: 'P7: NAVIGATE' },
                                    { type: 'component', componentType: 'Interaction', title: 'P3: TEST' }
                                ]
                            },
                            {
                                type: 'component',
                                componentType: 'MediaPipe',
                                title: 'P0: SENSE',
                                height: 50
                            }
                        ]
                    }
                ]
            }
        };
        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.registerComponentFactoryFunction('Physics', c => initPhysicsPanel(c.element));
        layout.registerComponentFactoryFunction('Gestures', c => initGesturesPanel(c.element));
        layout.registerComponentFactoryFunction('PalmCone', c => initPalmConePanel(c.element));
        layout.registerComponentFactoryFunction('Interaction', c => initInteractionTest(c.element));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('Settings', c => initSettings(c.element));
        layout.loadLayout(config); window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>