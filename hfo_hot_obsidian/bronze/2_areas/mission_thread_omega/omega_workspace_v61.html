<!-- Medallion: Bronze | Mutation: 0% | HIVE: I -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO SHARDS | OMEGA V61.0 | SENTINEL FSM</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <script src="./assets/piano_genie/magenta_music.js"></script>
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css" />
    <style>
        :root {
            /* M3 HFO Shard Palette */
            --m3-bg: #000000;
            --m3-surface: #121212;
            --m3-surface-bright: #1c1c1c;
            --m3-primary: #ff0000;
            --m3-primary-container: #8c0000;
            --m3-on-primary: #ffffff;
            --m3-secondary: #ffb4ab;
            --m3-text: #e6e1e5;
            --m3-text-secondary: #938f99;
            --m3-outline: #49454f;
            --m3-radius: 16px;
            --shard-claw: polygon(0% 0%, 95% 0%, 100% 10%, 100% 100%, 5% 100%, 0% 90%);
        }

        body, html {
            margin: 0; padding: 0; height: 100vh; width: 100vw; overflow: hidden;
            background: var(--m3-bg); color: var(--m3-text); font-family: 'Roboto', sans-serif;
        }

        #layout-container { width: 100%; height: 100%; }

        .component-container {
            padding: 24px; height: 100%; overflow: auto; box-sizing: border-box;
            background-color: var(--m3-bg); position: relative;
        }

        .video-feed {
            width: 100%; height: 100%; object-fit: fill; border-radius: 4px;
            background: #000; filter: grayscale(1) brightness(0.4); opacity: 0.5;
            border: 1px solid var(--m3-outline);
        }

        .video-feed.mirrored, .overlay-canvas.mirrored { transform: scaleX(-1); }

        .overlay-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: fill; pointer-events: none;
        }

        .camera-controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 12px; z-index: 1000; background: var(--m3-surface);
            padding: 8px; border-radius: 20px; border: 1px solid var(--m3-outline);
        }

        .camera-btn {
            padding: 8px 16px; font-size: 11px; font-weight: 500; background: var(--m3-surface-bright);
            color: var(--m3-text); border: none; border-radius: 8px; cursor: pointer; text-transform: uppercase;
        }

        .camera-btn.active { background: #00391d; color: #b7f397; }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./assets/vendor/golden-layout.js",
            "lil-gui": "./assets/vendor/lil-gui.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
            "zod": "./assets/vendor/zod.js"
        }
    }
    </script>
    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer as MPGestureRecognizer, HandLandmarker, FilesetResolver as MPFilesetResolver, DrawingUtils as MPDrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';

        const GestureRecognizer = window.GestureRecognizer || MPGestureRecognizer;
        const FilesetResolver = window.FilesetResolver || MPFilesetResolver;
        const DrawingUtils = window.DrawingUtils || MPDrawingUtils;

        // ðŸ¤– V61: 3-State Sentinel FSM
        class SentinelFSM {
            constructor() {
                this.state = 'IDLE';
                this.bucketFill = 0;
                this.lastTimestamp = 0;
                this.pointerEvent = 'none';
                this.isSticky = false;
            }

            process(gesture, timestamp, score, isPalmFacing) {
                const dt = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 0;
                this.lastTimestamp = timestamp;
                const config = hfoState.leakyBucket;
                const currentGesture = gesture.toUpperCase().replace(/[\s_]/g, '_');
                const isConfident = score > 0.6;

                // Leaky Bucket for Palm Orientation
                if (isPalmFacing) {
                    this.bucketFill = Math.min(this.bucketFill + dt * config.fillRate, config.threshold);
                } else {
                    this.bucketFill = Math.max(this.bucketFill - dt * config.drainRate, 0);
                }
                const dwellRatio = this.bucketFill / config.threshold;

                // FSM Logic
                switch (this.state) {
                    case 'IDLE':
                        this.pointerEvent = 'none';
                        this.isSticky = false;
                        if (this.bucketFill >= config.threshold) {
                            this.state = 'POINTER_READY';
                        }
                        break;

                    case 'POINTER_READY':
                        this.pointerEvent = 'pointermove';
                        if (this.bucketFill <= 0) {
                            this.state = 'IDLE';
                        } else if (currentGesture === 'POINTING_UP' && isConfident) {
                            this.state = 'POINTER_COMMIT';
                            this.pointerEvent = 'pointerdown';
                            this.isSticky = true;
                        }
                        break;

                    case 'POINTER_COMMIT':
                        this.pointerEvent = 'pointermove';
                        // Keep sticky as long as bucket isn't empty OR user explicitly releases
                        // If user turns palm away, bucket drains -> IDLE -> pointerup
                        if (this.bucketFill <= 0) {
                            this.state = 'IDLE';
                            this.pointerEvent = 'pointerup';
                            this.isSticky = false;
                        }
                        break;
                }

                return { state: this.state, pointerEvent: this.pointerEvent, dwellRatio };
            }
        }

        const hfoState = window.hfoState = {
            active: true, debug: true,
            leakyBucket: { fillRate: 1.5, drainRate: 0.8, threshold: 800 },
            physics: { p0Mirror: true },
            visuals: { showSkeleton: true, excalidrawOpacity: 0.6 },
            hands: {}
        };

        const hfoSystem = window.hfoSystem = {
            video: null, canvas: null, ctx: null, stream: null, recognizer: null,
            loopActive: false, overlays: []
        };

        // Palm Orientation Heuristic
        const checkPalmFacing = (landmarks) => {
            if (!landmarks || landmarks.length < 21) return false;
            // Vector cross product to find normal
            // lm[0]=wrist, lm[5]=index_base, lm[17]=pinky_base
            const v1 = { x: landmarks[5].x - landmarks[0].x, y: landmarks[5].y - landmarks[0].y, z: landmarks[5].z - landmarks[0].z };
            const v2 = { x: landmarks[17].x - landmarks[0].x, y: landmarks[17].y - landmarks[0].y, z: landmarks[17].z - landmarks[0].z };
            
            // Cross product: (v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x)
            const normalZ = v1.x * v2.y - v1.y * v2.x;
            // In MediaPipe, Z increases towards the camera? No, Z is depth from wrist.
            // Simplified: if index and pinky bases are correctly oriented relative to wrist, normalZ sign indicates direction.
            // Mirrored video makes this trickier. We check absolute magnitude of Z variation or use normalZ if reliable.
            return normalZ < 0; // Flip based on mirroring/handedness testing.
        };

        const initMediaPipe = async (container) => {
            container.style.position = 'relative';
            const controls = document.createElement('div');
            controls.className = 'camera-controls';
            const btnStart = document.createElement('button');
            btnStart.className = 'camera-btn'; btnStart.innerText = 'Start';
            controls.append(btnStart);
            container.appendChild(controls);

            btnStart.onclick = async () => {
                if (!hfoSystem.stream) {
                    hfoSystem.stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                    hfoSystem.video.srcObject = hfoSystem.stream;
                    hfoSystem.video.play();
                    hfoSystem.loopActive = true;
                    btnStart.innerText = 'Stop'; btnStart.classList.add('active');
                } else {
                    hfoSystem.stream.getTracks().forEach(t => t.stop());
                    hfoSystem.stream = null; hfoSystem.video.srcObject = null;
                    hfoSystem.loopActive = false;
                    btnStart.innerText = 'Start'; btnStart.classList.remove('active');
                }
            };

            hfoSystem.video = document.createElement('video');
            hfoSystem.video.autoplay = true; hfoSystem.video.className = `video-feed ${hfoState.physics.p0Mirror ? 'mirrored' : ''}`;
            hfoSystem.canvas = document.createElement('canvas');
            hfoSystem.ctx = hfoSystem.canvas.getContext('2d');
            hfoSystem.canvas.className = `overlay-canvas ${hfoState.physics.p0Mirror ? 'mirrored' : ''}`;
            container.append(hfoSystem.video, hfoSystem.canvas);

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");
            hfoSystem.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO"
            });

            const render = () => {
                const loop = (now) => {
                    if (hfoSystem.loopActive && hfoSystem.recognizer) {
                        const res = hfoSystem.recognizer.recognizeForVideo(hfoSystem.video, now);
                        hfoSystem.ctx.clearRect(0, 0, hfoSystem.canvas.width, hfoSystem.canvas.height);
                        if (res && res.landmarks) {
                            const ctx = hfoSystem.ctx;
                            const drawing = new DrawingUtils(ctx);
                            res.landmarks.forEach((lm, i) => {
                                if (!hfoState.hands[i]) hfoState.hands[i] = { fsm: new SentinelFSM() };
                                const hand = hfoState.hands[i];
                                const isFacing = checkPalmFacing(lm);
                                const gesture = res.gestures?.[i]?.[0] || { categoryName: 'None', score: 0 };
                                const fsm = hand.fsm.process(gesture.categoryName, now, gesture.score, isFacing);

                                const x = lm[8].x * hfoSystem.canvas.width;
                                const y = lm[8].y * hfoSystem.canvas.height;

                                if (hfoState.visuals.showSkeleton) {
                                    drawing.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { color: "rgba(255,0,0,0.2)", lineWidth: 2 });
                                }

                                // State Visualization
                                ctx.beginPath();
                                ctx.arc(x, y, fsm.state === 'POINTER_COMMIT' ? 15 : 8, 0, Math.PI * 2);
                                ctx.fillStyle = fsm.state === 'POINTER_COMMIT' ? '#ff0000' : (fsm.state === 'POINTER_READY' ? '#ffff00' : '#ffffff');
                                ctx.fill();

                                if (hfoState.debug) {
                                    ctx.fillStyle = '#fff';
                                    ctx.font = '12px Roboto Mono';
                                    ctx.fillText(`${fsm.state} | Bucket: ${fsm.dwellRatio.toFixed(2)} | Palm: ${isFacing}`, x + 20, y);
                                }
                            });
                        }
                    }
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            };
            render();
        };

        const initExcalidraw = (container) => {
            const iframe = document.createElement('iframe');
            iframe.src = 'https://excalidraw.com?embed=1&theme=dark';
            iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
            iframe.style.opacity = hfoState.visuals.excalidrawOpacity;
            container.appendChild(iframe);
        };

        const layout = new GoldenLayout(document.getElementById('layout-container'));
        layout.registerComponentFactoryFunction('Excalidraw', c => initExcalidraw(c.element));
        layout.registerComponentFactoryFunction('MediaPipe', c => initMediaPipe(c.element));
        layout.loadLayout({
            root: { type: 'row', content: [
                { type: 'component', componentType: 'Excalidraw', title: 'HERO', width: 70 },
                { type: 'component', componentType: 'MediaPipe', title: 'VIDEO', width: 30 }
            ]}
        });
        window.addEventListener('resize', () => layout.updateSize());
    </script>
</body>

</html>
