<!-- Medallion: Bronze | Mutation: 0% | HIVE: H -->
<!-- OMEGA GEN 4 V30.0 TACTICAL TUTORIAL (Phoenix Rebirth) -->
<!-- Mission: Interactive Sequential FSM Guidance -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFO OMEGA GEN 4 | V30.0 Tutorial</title>

    <!-- CSS Dependencies -->
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet" href="./lib/css/goldenlayout-dark-theme.css" />

    <!-- Babylon.js Dependencies -->
    <script src="./lib/js/babylon.js"></script>
    <script src="./lib/js/babylon.loaders.min.js"></script>

    <!-- OpenFeature SDK -->
    <script src="./lib/js/web-sdk.min.js"></script>

    <style>
        :root {
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-outline: #938F99;
            --hfo-red: #FF4136;
            --hfo-black: #000000;
            --m3-radius: 12px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: var(--hfo-black);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', system-ui, sans-serif;
        }

        #layout-container {
            width: 100%;
            height: calc(100% - 28px);
        }

        #status-bar {
            height: 28px;
            background: var(--md-sys-color-surface);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 10px;
            border-top: 1px solid var(--md-sys-color-outline);
            text-transform: uppercase;
            z-index: 1000;
        }

        .component-container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            background: var(--hfo-black);
        }

        /* ðŸ“œ SECURED SCROLLING PANEL */
        .scrollable-panel {
            overflow-y: auto !important;
            height: 100% !important;
            padding: 12px;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--hfo-black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-surface-variant);
            border-radius: 10px;
            border: 2px solid var(--hfo-black);
        }

        .hero-view-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #video-feed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.1);
        }

        #overlay-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            /* Above Pixi Juice (10) */
        }

        .hfo-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 12px 32px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .hfo-btn:active {
            transform: scale(0.95);
        }

        /* ï¿½ BABYLON/PIXI OVERLAY CONTAINERS */
        .visual-substrate {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ï¿½ðŸ’Ž M3 INTEGRATION */
        .m3-card {
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--m3-radius);
            padding: 16px;
            margin-bottom: 12px;
            color: var(--md-sys-color-on-surface);
            border: 1px solid var(--md-sys-color-outline);
        }

        .m3-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--md-sys-color-primary);
            margin-bottom: 4px;
        }

        .m3-progress-container {
            height: 4px;
            background: var(--hfo-black);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .m3-progress-bar {
            height: 100%;
            background: var(--md-sys-color-primary);
            transition: width 0.1s linear;
        }

        .m3-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }

        .lil-gui {
            --background-color: transparent;
            --widget-color: var(--md-sys-color-surface-variant);
            --focus-color: var(--md-sys-color-primary);
            --title-background-color: var(--md-sys-color-primary-container);
            --title-text-color: var(--md-sys-color-on-primary-container);
            width: 100% !important;
        }

        /* ðŸ“– TUTORIAL OVERLAY [V30] */
        .tutorial-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--md-sys-color-primary);
            border-radius: var(--m3-radius);
            padding: 16px;
            z-index: 100;
            pointer-events: none;
            display: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .tutorial-step-active {
            animation: tutorial-pulse 2s infinite;
        }

        @keyframes tutorial-pulse {
            0% {
                border-color: var(--md-sys-color-primary);
            }

            50% {
                border-color: #fff;
            }

            100% {
                border-color: var(--md-sys-color-primary);
            }
        }

        .tutorial-step {
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
        }

        .tutorial-highlight {
            color: var(--md-sys-color-primary);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>

<body>
    <div id="layout-container"></div>
    <div id="status-bar">
        <span>[HFO OMEGA V24.6 - TELEMETRY TESTING]</span>
        <span id="p5-status" style="margin-left: 16px; color: #00FF41;">P5: ENFORCED</span>
        <span style="margin-left: auto;" id="state-indicator">P1: CONTRACTS ACTIVE | FSM: IDLE</span>
    </div>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "golden-layout": "./lib/js/golden-layout.esm.js",
            "lil-gui": "./lib/js/lil-gui.esm.js",
            "@mediapipe/tasks-vision": "./lib/js/vision_bundle.js",
            "zod": "./lib/js/zod.esm.js",
            "planck": "./lib/js/planck.esm.js"
        }
    }
    </script>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import GUI from 'lil-gui';
        import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
        import { z } from 'zod';
        import planck from 'planck';

        // --- ðŸš© OPENFEATURE CONFIGURATION (V24.2 Evolution) ---
        const urlParams = new URLSearchParams(window.location.search);

        const featureConfig = {
            'phoenix-core': true,
            'engine-babylon': true,
            'engine-pixi': false,
            'engine-canvas': false,
            'physics-planck': true,
            'ui-golden-layout': true,
            'ui-excalidraw': true,
            'ui-lil-gui': true,
            'p3-injector': true,
            'data-fabric': true
        };

        const HFOFeatureProvider = {
            metadata: { name: 'HFODefaultProvider' },
            resolveBooleanEvaluation(flagKey, defaultValue) {
                // Priority: URL Param > Config Map > Default
                let val = featureConfig[flagKey] ?? defaultValue;
                if (urlParams.has(`flag-${flagKey}`)) {
                    val = urlParams.get(`flag-${flagKey}`) === 'true';
                }
                return { value: val };
            }
        };

        // ðŸ›¡ï¸ [HFO] Initialize OpenFeature (Local UMD Bridge)
        const OF_ROOT = window.OpenFeature || {};
        const api = OF_ROOT.OpenFeature || OF_ROOT.default || OF_ROOT;

        if (typeof api.setProvider === 'function') {
            api.setProvider(HFOFeatureProvider);
            console.log("ðŸš€ [HFO] OpenFeature Hardened (Offline Ready)");
        } else {
            console.warn("âš ï¸ [HFO] OpenFeature API not found in expected UMD location.");
        }

        const featureClient = typeof api.getClient === 'function' ? api.getClient() : {
            getBooleanValue: (key, def) => {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has(`flag-${key}`)) return urlParams.get(`flag-${key}`) === 'true';
                return featureConfig[key] ?? def;
            }
        };

        const isFlagEnabled = (key) => featureClient.getBooleanValue(key, false);

        // --- MEDALLION LIFECYCLE: Resource Zero-Trust [V24.5] ---
        class LifecycleManager {
            constructor() {
                this.disposables = new Set();
                this.engines = new Map(); // Track singleton engines
            }
            register(id, obj) {
                if (obj && typeof obj.dispose === 'function') {
                    this.disposables.add(obj);
                    if (id) this.engines.set(id, obj);
                }
                return obj;
            }
            unregister(obj) {
                this.disposables.delete(obj);
            }
            dispose(id) {
                if (id) {
                    const obj = this.engines.get(id);
                    if (obj) {
                        try { obj.dispose(); } catch (e) { console.error(`[LIFECYCLE] Error disposing ${id}:`, e); }
                        this.disposables.delete(obj);
                        this.engines.delete(id);
                        console.log(`[LIFECYCLE] Disposed engine: ${id}`);
                    }
                }
            }
            disposeAll() {
                this.disposables.forEach(obj => {
                    try { obj.dispose(); } catch (e) { }
                });
                this.disposables.clear();
                this.engines.clear();
                console.log("[LIFECYCLE] All resources purged.");
            }
        }
        window.hfoLifecycle = new LifecycleManager();

        // --- TELEMETRY: Deterministic Replay Substrate [V24.5] ---
        class TelemetryRecorder {
            constructor() {
                this.buffer = [];
                this.isRecording = false;
                this.maxEntries = 10000;
            }
            start() {
                this.buffer = [];
                this.isRecording = true;
                console.log("âºï¸ [TELEMETRY] Recording started.");
            }
            stop() {
                this.isRecording = false;
                console.log("â¹ï¸ [TELEMETRY] Recording stopped. Entries:", this.buffer.length);
            }
            record(phase, data) {
                if (!this.isRecording || window.hfoPlayer.isPlaying) return;
                this.buffer.push({
                    timestamp: performance.now(),
                    phase: phase,
                    data: JSON.parse(JSON.stringify(data)) // Deep clone
                });
                if (this.buffer.length > this.maxEntries) this.buffer.shift();
            }
            exportJSONL() {
                const content = this.buffer.map(e => JSON.stringify(e)).join('\n');
                const blob = new Blob([content], { type: 'application/x-jsonlines' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hfo_telemetry_${new Date().toISOString()}.jsonl`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        window.hfoTelemetry = new TelemetryRecorder();

        // --- TELEMETRY PLAYER: Golden Master Replay [V24.6] ---
        class TelemetryPlayer {
            constructor() {
                this.sequence = [];
                this.index = 0;
                this.isPlaying = false;
                this.loop = false;
            }
            async load(file) {
                const text = await file.text();
                this.sequence = text.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
                this.index = 0;
                console.log("ðŸŽžï¸ [TELEMETRY] Sequence loaded. Entries:", this.sequence.length);
            }
            start() {
                if (this.sequence.length === 0) return console.warn("P6: No sequence loaded.");
                this.index = 0;
                this.isPlaying = true;
                systemState.parameters.p0Active = true; // Force loop
                console.log("â–¶ï¸ [TELEMETRY] Playback started.");
            }
            stop() {
                this.isPlaying = false;
                console.log("â¹ï¸ [TELEMETRY] Playback stopped.");
            }
            pause() {
                this.isPlaying = false;
                console.log("â¸ï¸ [TELEMETRY] Playback paused.");
            }
            getNextFrame() {
                if (!this.isPlaying || this.sequence.length === 0) return null;
                const frame = this.sequence[this.index];
                this.index++;
                if (this.index >= this.sequence.length) {
                    if (this.loop) this.index = 0;
                    else this.stop();
                }
                return frame;
            }
        }
        window.hfoPlayer = new TelemetryPlayer();

        // --- P1: FUSE CONTRACTS (The Bridger) ---
        const ConfigSchema = z.object({
            ui: z.object({
                showTutorial: z.boolean().default(true)
            }).optional(),
            camera: z.object({
                resolution: z.enum(['640x480', '1280x720', '1920x1080']),
                fpsTarget: z.number().min(1).max(120),
                mirror: z.boolean()
            }),
            landmarks: z.object({
                minConfidence: z.number().min(0).max(1),
                minTrackingConfidence: z.number().min(0).max(1),
                minPresenceConfidence: z.number().min(0).max(1),
                numHands: z.number().min(1).max(4),
                showSkeleton: z.boolean()
            }),
            gestures: z.object({
                minGestureConfidence: z.number().min(0).max(1),
                preferredHand: z.enum(['Any', 'Left', 'Right'])
            }),
            palm: z.object({
                enterThreshold: z.number().min(0).max(1),
                exitThreshold: z.number().min(0).max(1)
            }),
            fsm: z.object({
                hysteresisHigh: z.number().min(0).max(100),
                hysteresisLow: z.number().min(0).max(100),
                chargeTimeMs: z.number().min(1),
                releaseTimeMs: z.number().min(1),
                coastDrainTimeMs: z.number().min(1), // Added for V16
                tensionMs: z.number().min(0),
                commitExitDelayMs: z.number().min(0)
            }),
            coasting: z.object({
                timeoutMs: z.number().min(0),
                confidenceThreshold: z.number().min(0).max(1)
            }),
            physics: z.object({
                mode: z.enum(['STATIC_ROD', 'PLANCK_SPRING']),
                useDirectProjection: z.boolean(), // V20.6: User Requested Feature Flag
                directProjectionOffset: z.number().min(0), // V20.6: Tuning for LI/Direct stability
                cursorTheme: z.enum(['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']), // V20.4: HFO Trigram Bagua
                oneEuroMinCutoff: z.number().min(0),
                oneEuroBeta: z.number().min(0),
                oneEuroRodMinCutoff: z.number().min(0),
                planckStiffness: z.number().min(0),
                planckDamping: z.number().min(0),
                fireScale: z.number().min(0.1).default(1.0),
                fireIntensity: z.number().min(0.1).default(1.0),
                palmRodMultiplier: z.number().min(0.5).max(10), // V18: Palm-width based scaling
                showLaserBeam: z.boolean(),
                predictiveLookahead: z.number().min(0)
            }),
            anatomy: z.object({
                palmWidthCm: z.number().min(3).max(15),
                rodExtensionMultiplier: z.number().min(0.1).max(10)
            }),
            visuals: z.object({
                engine: z.literal('BABYLON'),
                variant: z.string()
            }).optional(),
            canvasCursors: z.object({
                radiusBase: z.number().default(40).optional(),
                gageHeight: z.number().default(80).optional(),
                readinessGaugeHeight: z.number().default(80).optional(),
                gageOffset: z.number().default(20).optional()
            }).optional()
        });

        // ðŸ—ï¸ PORT 1: FUSION CONTRACTS
        const FusionSchema = z.object({
            screenX: z.number(),
            screenY: z.number(),
            normX: z.number(),
            normY: z.number(),
            uiNormX: z.number().optional(), // V28.5: UPE Parity Hardening
            uiNormY: z.number().optional(), // V28.5: UPE Parity Hardening
            normZ: z.number(), // V24.21: Depth Parity
            rawX: z.number(), // V18: Required for laser origin
            rawY: z.number(), // V18: Required for laser origin
            fsmState: z.enum(['IDLE', 'READY', 'COMMIT', 'COAST']),
            gesture: z.string(),
            confidence: z.number(),
            isPalmFacing: z.boolean(),
            normalZ: z.number(),
            palmConeAngle: z.number(), // V20.3: Anatomical Stability Factor
            palmNormal: z.object({
                x: z.number(),
                y: z.number(),
                z: z.number()
            }),
            readinessScore: z.number(),
            skeletonAlpha: z.number().default(1.0), // V24.22: Fading on tracking loss
            handIndex: z.number(),
            pointerId: z.number(), // V24.4: Stable ABI ID
            curls: z.object({
                index: z.number(),
                middle: z.number(),
                ring: z.number(),
                pinky: z.number()
            }),
            landmarks: z.array(z.object({ x: z.number(), y: z.number(), z: z.number() })).optional(), // V24.17: Skeletal Fabric
            timestamp: z.number().optional()
        });

        const LandmarkSchema = z.object({ x: z.number(), y: z.number(), z: z.number() });

        const DataFabricSchema = z.object({
            cursors: z.array(FusionSchema),
            systemTime: z.number(),
            frameId: z.number()
        });

        const CoordinateSchema = FusionSchema;

        // --- PRODUCTION STATE ---
        const systemState = {
            parameters: {
                ui: { showTutorial: true },
                camera: { resolution: '1280x720', fpsTarget: 30, mirror: true },
                landmarks: {
                    minConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    minPresenceConfidence: 0.5,
                    numHands: 2,
                    showSkeleton: true,
                    skeletonFadeTimeMs: 400, // V26: Time to fade out
                    skeletonInactivityTimeoutMs: 1500 // V26: Time before pruning stale skeleton
                },
                gestures: { minGestureConfidence: 0.7, preferredHand: 'Any' },
                palm: { enterThreshold: 0.80, exitThreshold: 0.64 },
                fsm: {
                    hysteresisHigh: 80,
                    hysteresisLow: 64,
                    chargeTimeMs: 266,
                    releaseTimeMs: 200,
                    coastDrainTimeMs: 1200, // Slower drain for Inertia [V16]
                    tensionMs: 100,
                    commitExitDelayMs: 250
                },
                coasting: { timeoutMs: 150, confidenceThreshold: 0.4 },
                physics: {
                    mode: 'PLANCK_SPRING',
                    useDirectProjection: true, // V20.6 Feature Flag (Default ON)
                    directProjectionOffset: 0.04, // V20.6 Custom Offset for Direct projection
                    cursorTheme: 'LI', // V20.5 stable evolution
                    oneEuroMinCutoff: 0.85,
                    oneEuroBeta: 0.02,
                    oneEuroRodMinCutoff: 0.8,
                    planckStiffness: 4.5,
                    planckDamping: 1.2,
                    palmRodMultiplier: 0.64,
                    showLaserBeam: true,
                    showTrailMesh: false, // V24.17: Off by default
                    showHFOClaw: false, // V24.18: Off by default
                    predictiveLookahead: 0.5,
                    fireScale: 2.0, // V24.11 Default
                    fireIntensity: 2.0 // V24.11 Default
                },
                anatomy: {
                    palmWidthCm: 8,
                    rodExtensionMultiplier: 0.125
                },
                excalidraw: {
                    opacity: 0.8,
                    enabled: true,
                    activeTool: 'freedraw',
                    zoomFactor: 1.15 // V28: Digital zoom to eliminate gutters (1/0.85 approx)
                },
                visuals: {
                    engine: 'BABYLON',
                    variant: 'PHOENIX_CORE'
                },
                ports: {
                    p0_recognizer: 'MEDIAPIPE_HANDS',
                    p1_fusion: 'UNIVERSAL_PROJECTION_V28',
                    p2_fsm: 'SOVEREIGN_4_STATE',
                    p3_injector: 'HYDRA_ADAPTER_PULSE',
                },
                canvasCursors: {
                    radiusBase: 40,
                    gageHeight: 80,
                    readinessGaugeHeight: 80,
                    gageOffset: 20
                },
                p0Active: false,
                devMode: false
            },
            fsm: {
                currentState: 'IDLE',
                lastState: 'IDLE',
                lastCommitTime: 0,
                commitExitStartTime: 0,
                primaryHandIndex: null,
                nematocystTargetLock: null,
                lastTarget: null,
                activePointers: {} // V24.4: Tracks down status per pointerId
            },
            p0: { recognizer: null, video: null, canvas: null, ctx: null, videoBounds: null },
            p1: {
                cursors: [],
                readinessScores: [0, 0, 0, 0], // Per-hand leaky buckets
                fsmStates: ['IDLE', 'IDLE', 'IDLE', 'IDLE'], // Per-hand FSM states [V15]
                palmFacingStates: [false, false, false, false], // Hysteresis state
                lastPalmFacingTimes: [0, 0, 0, 0], // Tension/Coyote timers
                lastData: [null, null, null, null], // Per-hand coasting data
                lastTrackingTimes: [0, 0, 0, 0], // V26: Tracking heartbeats
                lastMovementTimes: [0, 0, 0, 0], // V26: Inactivity detection
                lastLandmarks: [null, null, null, null], // V26: Ghost landmarks for fading
                coastStartTimes: [0, 0, 0, 0], // Per-hand coast timers
                filters: [null, null, null, null], // OneEuroFilters
                rodFilters: [null, null, null, null], // V19.2: Stabilize rod length
                anchorFilters: [null, null, null, null], // V19.2: Stabilize anchor point
                directionFilters: [null, null, null, null], // V19.2: Stabilize rod direction
                physicsState: [null, null, null, null], // Mass-Spring state

                // ðŸŽ¯ V28.0 UNIVERSAL PROJECTION ENGINE (UPE)
                // Centralized parity logic for all coordinate substrates
                // V28.0 FIX: Internal drawing (Fire/Skeleton) MUST use buffer space.
                // Interaction (PointerEvents) MUST use viewport space.
                toBufferX: (nx) => nx * (systemState.p0.canvas?.width || 1280),
                toBufferY: (ny) => ny * (systemState.p0.canvas?.height || 720),
                toViewportX: (nx) => {
                    const b = systemState.ui.viewBounds || { width: 1280, offsetX: 0 };
                    const r = systemState.p0.video?.parentElement?.getBoundingClientRect() || { left: 0 };
                    return r.left + b.offsetX + (nx * b.width);
                },
                toViewportY: (ny) => {
                    const b = systemState.ui.viewBounds || { height: 720, offsetY: 0 };
                    const r = systemState.p0.video?.parentElement?.getBoundingClientRect() || { top: 0 };
                    return r.top + b.offsetY + (ny * b.height);
                }
            },
            ui: {
                gestures: null,
                palm: null,
                palmCtx: null,
                fsm: null,
                fsmCtx: null,
                juiceLayers: [],
                viewBounds: { width: 0, height: 0, offsetX: 0, offsetY: 0 }
            },
            dataFabric: { cursors: [], systemTime: 0, frameId: 0 }
        };

        // --- P4: VISUAL JUICE (BabylonJS Substrate) ---
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // thumb
            [0, 5], [5, 6], [6, 7], [7, 8], // index
            [0, 9], [9, 10], [10, 11], [11, 12], // middle
            [0, 13], [13, 14], [14, 15], [15, 16], // ring
            [0, 17], [17, 18], [18, 19], [19, 20], // pinky
            [5, 9], [9, 13], [13, 17] // palm
        ];

        class BabylonJuiceSubstrate {
            constructor(container) {
                // V24.4: Hard Enforcement of Single-Engine Invariant
                window.hfoLifecycle.dispose('BABYLON_ENGINE');

                this.canvas = document.createElement('canvas');
                this.canvas.id = 'babylon-canvas';
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '0';
                this.canvas.style.top = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.zIndex = '9';
                this.canvas.style.display = 'none'; // Hidden by default
                container.appendChild(this.canvas);

                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                this.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -10), this.scene);
                this.camera.setTarget(BABYLON.Vector3.Zero());

                this.light = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 0, -5), this.scene);
                this.light.intensity = 0.8;
                this.light.diffuse = new BABYLON.Color3(1, 0.4, 0.1);

                this.emitterRoots = [];
                this.particleSystems = [];
                this.trails = []; // V24.16: Hybrid Geometric Core
                this.skeletons = []; // V24.17: Skeletal Data Fabric
                this.lastPositions = [];
                this.perfMultiplier = 1.0; // V24.14: Adaptive Performance Scaling

                this.engine.runRenderLoop(() => {
                    if (this.canvas && this.canvas.style.display !== 'none') {
                        this.scene.render();

                        // V24.15: 30FPS Mobile Optimization Target
                        const fps = this.engine.getFps();
                        if (fps > 0) {
                            const target = 30; // 30Hz Baseline for Midrange Mobile
                            const factor = fps / target;
                            this.perfMultiplier = this.perfMultiplier * 0.95 + factor * 0.05;
                            this.perfMultiplier = Math.max(0.2, Math.min(this.perfMultiplier, 1.5));
                        }
                    }
                });

                window.hfoLifecycle.register('BABYLON_ENGINE', this);
            }

            dispose() {
                if (this.engine) {
                    // Loop through all hand-specific resources
                    this.emitterRoots.forEach((root, i) => {
                        this.particleSystems[i]?.forEach(s => s.dispose());
                        this.trails[i]?.dispose();
                        this.skeletons[i]?.root.dispose();
                        root?.dispose();
                    });

                    this.engine.dispose();
                    this.engine = null;
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                console.log("[BABYLON] Engine and all associated trails/emitters disposed via Lifecycle hook.");
            }

            update(cursors) {
                const width = this.engine.getRenderWidth();
                const height = this.engine.getRenderHeight();

                const activeIndices = new Set();

                cursors.forEach((c) => {
                    const i = c.handIndex;
                    activeIndices.add(i);

                    if (!this.emitterRoots[i]) this.createEffect(i);
                    const root = this.emitterRoots[i];
                    const systems = this.particleSystems[i];
                    const trail = this.trails[i];
                    const skeleton = this.skeletons[i];

                    const isActive = (c.fsmState !== 'IDLE');
                    const isCoast = (c.fsmState === 'COAST');
                    const showSkeleton = systemState.parameters.landmarks.showSkeleton;
                    const hasLandmarks = !!(c.landmarks && c.landmarks.length > 0);

                    // V24.18: Sovereign Skeleton Visibility (IDLE, READY, COMMIT)
                    // V24.22: Fading logic for Tracking Loss / COAST
                    if (skeleton) {
                        const shouldShowSkeleton = showSkeleton && hasLandmarks;
                        skeleton.root.setEnabled(shouldShowSkeleton);

                        if (shouldShowSkeleton) {
                            const fadeAlpha = c.skeletonAlpha !== undefined ? c.skeletonAlpha : 1.0;
                            // Apply fading to children
                            skeleton.root.getChildMeshes().forEach(m => {
                                m.visibility = fadeAlpha;
                            });

                            // Update 21 landmark spheres
                            c.landmarks.forEach((lm, lIndex) => {
                                // V24.18 Perspective Alignment: 
                                // projectToWorld correctly handles the perspective shift for depth.
                                // V28.5 HARDENED: Use landmarks directly (already mirrored/scaled in Fabric)
                                const targetZ = lm.z * 1.5;
                                const lmPos = this.projectToWorld(lm.x, lm.y, width, height, targetZ);
                                skeleton.spheres[lIndex].position.copyFrom(lmPos);
                            });

                            // Update Index Claw (Link from Tip 8 to pointer root)
                            const showClaw = systemState.parameters.physics.showHFOClaw || false;
                            skeleton.claw.setEnabled(showClaw && isActive); // Only show claw if in an active pointing state

                            if (showClaw && isActive) {
                                const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height);
                                const tipPos = skeleton.spheres[8].position;
                                const clawPoints = [tipPos, targetPos];
                                skeleton.claw = BABYLON.MeshBuilder.CreateLines("claw" + i, { points: clawPoints, instance: skeleton.claw }, this.scene);

                                // Set Claw Color based on state
                                const isCommit = (c.fsmState === 'COMMIT');
                                skeleton.claw.color = isCommit ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0.4, 0);
                            }

                            // Update wire skeleton bones
                            HAND_CONNECTIONS.forEach((conn, bIndex) => {
                                const p1 = skeleton.spheres[conn[0]].position;
                                const p2 = skeleton.spheres[conn[1]].position;
                                const bonePoints = [p1, p2];
                                skeleton.bones[bIndex] = BABYLON.MeshBuilder.CreateLines("bone" + i + "_" + bIndex, { points: bonePoints, instance: skeleton.bones[bIndex] }, this.scene);
                            });
                        }
                    }

                    if (isActive) {
                        systems.forEach(s => { if (!s.isStarted()) s.start(); });

                        // V24.17: Toggleable TrailMesh (Off by default)
                        if (trail) {
                            trail.isVisible = systemState.parameters.physics.showTrailMesh || false;
                        }

                        // Pixel to World Projection for the pointer root
                        // V28.5: Use unified uiNorm coordinates to bypass Zod Scythe and parity drift
                        const targetPos = this.projectToWorld(c.uiNormX || c.normX, c.uiNormY || c.normY, width, height, (c.normZ || 0) * 1.5);

                        let motionVector = BABYLON.Vector3.Zero();
                        if (this.lastPositions[i]) {
                            motionVector = targetPos.subtract(this.lastPositions[i]);
                        }
                        this.lastPositions[i] = targetPos.clone();
                        root.position.copyFrom(targetPos);

                        // V24.10: Plasma Needle Scion (Fire Lab V3 Aesthetics)
                        const scale = systemState.parameters.physics.fireScale || 1.0;
                        const intensity = systemState.parameters.physics.fireIntensity || 1.0;

                        if (c.fsmState === 'COMMIT') {
                            if (trail) {
                                trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1);
                                trail.material.alpha = 0.3;
                            }
                            systems.forEach(s => {
                                s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                this.tuneFireSystem(s, motionVector, scale, intensity, true);
                            });
                        } else {
                            // READY, COAST, etc.
                            const isCyan = (c.fsmState === 'COAST'); // Coast maintains visual of last state (often COMMIT)
                            if (isCyan) {
                                // COAST keeps Cyan if it was COMMIT-ing
                                if (trail) { trail.material.emissiveColor = new BABYLON.Color3(0, 0.7, 1); }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(0.0, 0.8, 1.0, 0.4);
                                    s.color2 = new BABYLON.Color4(0, 0.4, 1, 0.2);
                                });
                            } else {
                                if (trail) {
                                    trail.material.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
                                    trail.material.alpha = 0.2;
                                }
                                systems.forEach(s => {
                                    s.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 0.5);
                                    s.color2 = new BABYLON.Color4(1, 0.2, 0, 0.2);
                                    this.tuneFireSystem(s, motionVector, scale, intensity, false);
                                });
                            }
                        }
                    } else {
                        systems.forEach(s => s.stop());
                        if (trail) trail.isVisible = false;
                        this.lastPositions[i] = null;
                    }
                });

                // V24.16: Production Hardening (Prune Lost Emitters)
                // Hide or Dispose emitters for hands not present in cursors
                this.emitterRoots.forEach((root, i) => {
                    if (!activeIndices.has(i)) {
                        this.particleSystems[i]?.forEach(s => s.stop());
                        if (this.trails[i]) this.trails[i].isVisible = false;
                        if (this.skeletons[i]) this.skeletons[i].root.setEnabled(false); // V26: Close UX leakage

                        // If tracking is lost entirely (no bucket level), dispose of resources
                        const readiness = systemState.p1.readinessScores[i] || 0;
                        if (readiness <= 0 && this.emitterRoots[i]) {
                            console.log(`[BABYLON] Pruning stale emitter for Hand ${i}`);
                            this.particleSystems[i]?.forEach(s => s.dispose());
                            this.trails[i]?.dispose();
                            this.skeletons[i]?.root.dispose();
                            this.emitterRoots[i]?.dispose();

                            delete this.particleSystems[i];
                            delete this.trails[i];
                            delete this.skeletons[i];
                            delete this.emitterRoots[i];
                            this.lastPositions[i] = null;
                        }
                    }
                });
            }

            projectToWorld(nx, ny, width, height, targetZ = 0) {
                const vectorNear = new BABYLON.Vector3(nx * width, ny * height, 0);
                const worldCoordNear = BABYLON.Vector3.Unproject(
                    vectorNear, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const vectorFar = new BABYLON.Vector3(nx * width, ny * height, 1);
                const worldCoordFar = BABYLON.Vector3.Unproject(
                    vectorFar, width, height, BABYLON.Matrix.Identity(),
                    this.scene.getViewMatrix(), this.scene.getProjectionMatrix()
                );
                const direction = worldCoordFar.subtract(worldCoordNear).normalize();
                if (Math.abs(direction.z) > 0.0001) {
                    const distance = (targetZ - worldCoordNear.z) / direction.z;
                    return worldCoordNear.add(direction.scale(distance));
                }
                return worldCoordNear;
            }

            tuneFireSystem(s, motionVector, scale, intensity, isHigh) {
                const speed = motionVector.length();
                const densityMultiplier = 1.0 + Math.min(speed * (isHigh ? 20 : 10), isHigh ? 2.5 : 2.0);
                const baseRate = (isHigh ? 600 : 250) * scale;
                s.emitRate = baseRate * densityMultiplier * this.perfMultiplier;

                const jitter = (isHigh ? 0.03 * (1.0 + speed) : 0.06);
                s.minEmitBox = motionVector.scale(isHigh ? -1.0 : -0.8).add(new BABYLON.Vector3(-jitter, isHigh ? -0.02 : -jitter, -jitter));
                s.maxEmitBox = new BABYLON.Vector3(jitter, isHigh ? 0.02 : jitter, jitter);

                s.minSize = (isHigh ? 0.06 : 0.1) * scale;
                s.maxSize = (isHigh ? 0.24 : 0.3) * scale;
                s.minLifeTime = isHigh ? 0.25 : 0.4;
                s.maxLifeTime = isHigh ? 0.5 : 0.8;
                s.gravity = new BABYLON.Vector3(0, (isHigh ? 4 : 2) * intensity, 0);
            }

            createSkeleton(index) {
                const root = new BABYLON.TransformNode("skeleton" + index, this.scene);
                const spheres = [];
                const bones = [];

                const mat = new BABYLON.StandardMaterial("skeletonMat" + index, this.scene);
                mat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Bone White
                mat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                mat.alpha = 0.12; // V24.18: Transparent Bone
                mat.disableLighting = true;

                for (let i = 0; i < 21; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere("tm_" + index + "_" + i, { diameter: 0.12 }, this.scene);
                    sphere.material = mat;
                    sphere.parent = root;
                    spheres.push(sphere);
                }

                // Initial claw line
                const claw = BABYLON.MeshBuilder.CreateLines("claw" + index, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                claw.color = new BABYLON.Color3(0.9, 0.9, 1.0); // Bright Bone Claw
                claw.parent = root;
                claw.alpha = 0.2;

                // Wire skeleton bones
                HAND_CONNECTIONS.forEach((_, bIndex) => {
                    const bone = BABYLON.MeshBuilder.CreateLines("bone" + index + "_" + bIndex, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true }, this.scene);
                    bone.color = new BABYLON.Color3(0.8, 0.8, 0.8);
                    bone.alpha = 0.08; // Delicate Bone Structure
                    bone.parent = root;
                    bones.push(bone);
                });

                return { root, spheres, bones, claw };
            }

            createEffect(index) {
                const root = BABYLON.MeshBuilder.CreateSphere("emitter" + index, { diameter: 0.05 }, this.scene);
                root.isVisible = false;
                this.emitterRoots[index] = root;

                // Initialize Skeleton
                this.skeletons[index] = this.createSkeleton(index);

                // V24.16: Hybrid Geometric Core (Exemplar TrailMesh)
                // Diameter 0.08, Length 30, Auto-shrink enabled.
                const trail = new BABYLON.TrailMesh("trail" + index, root, this.scene, 0.08, 30, true);
                const trailMat = new BABYLON.StandardMaterial("trailMat" + index, this.scene);
                trailMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1);
                trailMat.alpha = 0.4;
                trailMat.disableLighting = true;
                trail.material = trailMat;
                trail.isVisible = false;
                this.trails[index] = trail;

                const defaultTexture = "./lib/models/flare.png";

                // PHOENIX CORE EFFECT
                const fire = new BABYLON.ParticleSystem("fire", 2000, this.scene);
                fire.particleTexture = new BABYLON.Texture(defaultTexture, this.scene);
                fire.emitter = root;
                fire.minEmitBox = new BABYLON.Vector3(-0.05, 0, -0.05);
                fire.maxEmitBox = new BABYLON.Vector3(0.05, 0, 0.05);
                fire.color1 = new BABYLON.Color4(1.0, 0.6, 0.1, 1.0);
                fire.color2 = new BABYLON.Color4(1, 0.2, 0, 0.5);
                fire.colorDead = new BABYLON.Color4(0, 0, 0, 0);
                fire.minLifeTime = 0.1; fire.maxLifeTime = 0.3;
                fire.emitRate = 400;
                fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                fire.gravity = new BABYLON.Vector3(0, 2, 0);
                this.particleSystems[index] = [fire];
            }

            resize() { this.engine.resize(); }
        }

        window.hfoState = systemState;

        // --- P2: AGNOSTIC PHYSICS MANIFOLD ---
        /**
         * IPhysicsAdapter: Interface for vendor-agnostic physics steering.
         * Decouples the FSM and Pointer logic from specific engines (Planck, Matter, Rapier).
         */
        class IPhysicsAdapter {
            update(targetX, targetY, dt) { throw new Error("Not implemented"); }
            setParams(params) { throw new Error("Not implemented"); }
            reset(x, y) { throw new Error("Not implemented"); }
            setBallistic(enabled) { throw new Error("Not implemented"); }
            getTelemetry() { return {}; }
        }

        /**
         * PlanckPhysicsAdapter: High-fidelity deterministic Box2D (Planck.js) implementation.
         * Uses MKS scaling (1 meter = 100 pixels) for numerical stability.
         */
        class PlanckPhysicsAdapter extends IPhysicsAdapter {
            constructor(stiffness = 5.0, damping = 0.7) {
                super();
                this.SCALE = 100.0; // 100px = 1m
                this.world = planck.World({ gravity: planck.Vec2(0, 0) });
                this.stiffness = stiffness;
                this.damping = damping;
                this.isBallistic = false;

                // Cursor Body (Dynamic)
                this.cursor = this.world.createBody({
                    type: 'dynamic',
                    position: planck.Vec2(0, 0),
                    linearDamping: 2.0, // Reduced for smoother glide
                    angularDamping: 5.0
                });
                this.cursor.createFixture(planck.Circle(0.1), { density: 1.0, friction: 0.3 });

                // Target Body (Kinematic)
                this.target = this.world.createBody({ type: 'kinematic', position: planck.Vec2(0, 0) });

                // Constant Distance Joint (Rod) or Spring (DistanceJoint with frequency)
                this.joint = this.world.createJoint(planck.DistanceJoint({
                    bodyA: this.target,
                    bodyB: this.cursor,
                    anchorA: planck.Vec2(0, 0),
                    anchorB: planck.Vec2(0, 0),
                    frequencyHz: stiffness, // Stiffness as frequency
                    dampingRatio: damping,    // Damping
                    length: 0
                }));

                this.lastPos = { x: 0, y: 0 };
            }

            setBallistic(enabled) {
                this.isBallistic = enabled;
                if (enabled) {
                    this.joint.setFrequency(0); // Effectively detach
                } else {
                    this.joint.setFrequency(this.stiffness);
                }
            }

            update(targetX, targetY, dt) {
                if (!this.isBallistic) {
                    const tx = targetX / this.SCALE;
                    const ty = targetY / this.SCALE;
                    this.target.setPosition(planck.Vec2(tx, ty));
                }

                // Step world
                this.world.step(Math.min(dt / 1000, 0.033));

                const pos = this.cursor.getPosition();
                this.lastPos = { x: pos.x * this.SCALE, y: pos.y * this.SCALE };
                return this.lastPos;
            }

            setParams(params) {
                this.stiffness = params.stiffness || 5.0;
                this.damping = params.dampingRatio || 0.7;
                if (!this.isBallistic) {
                    this.joint.setFrequency(this.stiffness);
                }
                this.joint.setDampingRatio(this.damping);
            }

            reset(x, y) {
                const px = x / this.SCALE;
                const py = y / this.SCALE;
                this.cursor.setPosition(planck.Vec2(px, py));
                this.target.setPosition(planck.Vec2(px, py));
                this.cursor.setLinearVelocity(planck.Vec2(0, 0));
            }

            getTelemetry() {
                const vel = this.cursor.getLinearVelocity();
                return {
                    velocity: { x: vel.x * this.SCALE, y: vel.y * this.SCALE },
                    speed: vel.length() * this.SCALE,
                    position: { ...this.lastPos }
                };
            }
        }

        // --- COORDINATE SUBSTRATE: 1EURO ---
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.0) {
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.xPrev = null;
                this.dxPrev = 0;
            }

            filter(x, rate = 30) {
                if (this.xPrev === null) {
                    this.xPrev = x;
                    return x;
                }
                const dx = (x - this.xPrev) * rate;
                const edx = this.alpha(rate, 1.0); // Simple smoothing for derivative
                const dxHat = edx * dx + (1 - edx) * this.dxPrev;
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(rate, cutoff);
                const xHat = a * x + (1 - a) * this.xPrev;
                this.xPrev = xHat;
                this.dxPrev = dxHat;
                return xHat;
            }

            alpha(rate, cutoff) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                const te = 1.0 / rate;
                return 1.0 / (1.0 + tau / te);
            }
        }

        class MassSpringDampener {
            constructor(stiffness = 0.15, damping = 0.05) {
                this.pos = null;
                this.vel = { x: 0, y: 0 };
                this.stiffness = stiffness;
                this.damping = damping;
            }

            update(targetX, targetY) {
                if (this.pos === null) {
                    this.pos = { x: targetX, y: targetY };
                    return this.pos;
                }
                const forceX = (targetX - this.pos.x) * this.stiffness;
                const forceY = (targetY - this.pos.y) * this.stiffness;

                this.vel.x = this.vel.x * (1 - this.damping) + forceX;
                this.vel.y = this.vel.y * (1 - this.damping) + forceY;

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                return this.pos;
            }
        }

        // --- P1 BRIDGER: CONTRACT ENFORCEMENT ---
        class P1Bridger {
            static calculateCurl(landmarks, indices) {
                let totalAngle = 0;
                for (let i = 0; i < indices.length - 2; i++) {
                    const a = landmarks[indices[i]];
                    const b = landmarks[indices[i + 1]];
                    const c = landmarks[indices[i + 2]];
                    const v1 = { x: a.x - b.x, y: a.y - b.y, z: (a.z - b.z) * 0.1 };
                    const v2 = { x: c.x - b.x, y: c.y - b.y, z: (c.z - b.z) * 0.1 };
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z) || 1e-6;
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) || 1e-6;
                    const dot = (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / (mag1 * mag2);
                    totalAngle += Math.acos(Math.max(-1, Math.min(1, dot)));
                }
                return Math.min(1.0, totalAngle / Math.PI);
            }

            static validateConfig(config) {
                try {
                    return ConfigSchema.parse(config);
                } catch (e) {
                    console.error("ðŸš¨ P1_CONFIG_CONTRACT_BREACH:", e.errors);
                    return null;
                }
            }

            static fuse(results, dt) {
                const cursors = [];
                const now = performance.now();
                const { numHands } = systemState.parameters.landmarks;

                for (let i = 0; i < numHands; i++) {
                    const landmarks = results.landmarks?.[i];
                    const bestGesture = results.gestures?.[i]?.[0];
                    let cursorData = null;

                    // V26: Tracking Heartbeat
                    if (landmarks) systemState.p1.lastTrackingTimes[i] = now;
                    const tTracking = now - (systemState.p1.lastTrackingTimes[i] || 0);
                    const isTrackingLost = !landmarks;

                    if (landmarks) {
                        try {
                            const validatedLandmarks = landmarks.map(l => LandmarkSchema.parse(l));
                            const { width, height } = systemState.p0.videoBounds || { width: 0, height: 0 };
                            const lm = validatedLandmarks;

                            // V26: Inactivity Detection (Skeleton Dormancy)
                            const lastLms = systemState.p1.lastData[i]?.landmarks;
                            if (lastLms && lastLms[8]) {
                                const dx = lm[8].x - lastLms[8].x;
                                const dy = lm[8].y - lastLms[8].y;
                                if (Math.sqrt(dx * dx + dy * dy) > 0.005) systemState.p1.lastMovementTimes[i] = now;
                            } else {
                                systemState.p1.lastMovementTimes[i] = now;
                            }
                            const tMovement = now - (systemState.p1.lastMovementTimes[i] || now);
                            const dormancyAlpha = tMovement < 3000 ? 1.0 : Math.max(0, 1.0 - (tMovement - 3000) / 1000);

                            // V20.3: ANATOMICAL STABILITY (Hardened Rod)
                            const p5 = lm[5];
                            const p17 = lm[17];
                            const p0_palm = lm[0];

                            // Observed 3D Palm Span (Index MCP to Pinky MCP) - Absolute Measure
                            const observedPalmSpan = Math.sqrt(
                                (p5.x - p17.x) ** 2 +
                                (p5.y - p17.y) ** 2 +
                                (p5.z - p17.z) ** 2
                            ) || 1e-6;

                            // V20.3: Calculate Palm Orientation / normalZ Early for stabilization
                            const v1_palm = { x: p5.x - p0_palm.x, y: p5.y - p0_palm.y, z: p5.z - p0_palm.z };
                            const v2_palm = { x: p17.x - p0_palm.x, y: p17.y - p0_palm.y, z: p17.z - p0_palm.z };
                            const cross_palm = {
                                x: (v1_palm.y * v2_palm.z - v1_palm.z * v2_palm.y) || 0,
                                y: (v1_palm.z * v2_palm.x - v1_palm.x * v2_palm.z) || 0,
                                z: (v1_palm.x * v2_palm.y - v1_palm.y * v2_palm.x) || 1
                            };
                            const mag_palm = Math.sqrt(cross_palm.x ** 2 + cross_palm.y ** 2 + cross_palm.z ** 2) || 1;
                            const nz = Math.abs(cross_palm.z / mag_palm);
                            const normalZ = nz;
                            const palmConeAngle = Math.acos(Math.min(1.0, normalZ));

                            // V20.3: Harden Rod length with Palm Cone Angle damping to stop longitudinal bouncing
                            if (!systemState.p1.rodFilters[i]) {
                                systemState.p1.rodFilters[i] = new OneEuroFilter(systemState.parameters.physics.oneEuroRodMinCutoff, systemState.parameters.physics.oneEuroBeta);
                            }
                            // Adaptive cutoff: smoother if tilting away (noisy Z)
                            systemState.p1.rodFilters[i].minCutoff = normalZ > 0.7 ?
                                systemState.parameters.physics.oneEuroRodMinCutoff :
                                systemState.parameters.physics.oneEuroRodMinCutoff * 0.5;

                            let baseRodLength;
                            const theme = systemState.parameters.physics.cursorTheme;
                            if (theme === 'LI') {
                                // V20.6: User Tunable Fixed Standoff for Fire (Li) stability
                                baseRodLength = systemState.parameters.physics.directProjectionOffset;
                            } else {
                                baseRodLength = observedPalmSpan * systemState.parameters.anatomy.rodExtensionMultiplier;
                            }
                            const rodLength = systemState.p1.rodFilters[i].filter(baseRodLength);

                            // V19.1: Anchor at Index Tip (8), Project further based on Palm Span
                            const mcp = lm[5];
                            const tipRaw = lm[8];
                            const dx_dir = tipRaw.x - mcp.x;
                            const dy_dir = tipRaw.y - mcp.y;
                            const dz_dir = tipRaw.z - mcp.z;
                            const mag_dir = Math.sqrt(dx_dir ** 2 + dy_dir ** 2 + dz_dir ** 2) || 1e-6;

                            // Projected point starts at Tip (8) and extends rodLength
                            const projectedPoint = {
                                x: tipRaw.x + (dx_dir / mag_dir) * rodLength,
                                y: tipRaw.y + (dy_dir / mag_dir) * rodLength,
                                z: tipRaw.z + (dz_dir / mag_dir) * rodLength
                            };

                            // V19.4: MIRROR AWARENESS (Global Port 1 Flip)
                            const isMirror = systemState.parameters.camera.mirror;

                            // V24.17 Fix: Mirror individual landmarks for shared data fabric parity
                            const mirroredLandmarks = lm.map(l => ({
                                x: isMirror ? (1.0 - l.x) : l.x,
                                y: l.y,
                                z: l.z
                            }));

                            const finalProjX = isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x;
                            const finalTipX = isMirror ? (1.0 - tipRaw.x) : tipRaw.x;

                            // V28: OVERSCAN PROJECTION (UPE Enforced - ALL DRAWING IS BUFFER-RELATIVE)
                            const screenX = systemState.p1.toBufferX(finalProjX);
                            const screenY = systemState.p1.toBufferY(projectedPoint.y);

                            // V18: Standardized cursor raw origin for laser beam/firebase
                            const rawX = systemState.p1.toBufferX(finalTipX);
                            const rawY = systemState.p1.toBufferY(tipRaw.y);

                            // V24.17 Fix: Also mirror the raw anchor point and projected point in 3D
                            const mirroredProjected3D = {
                                x: isMirror ? (1.0 - projectedPoint.x) : projectedPoint.x,
                                y: projectedPoint.y,
                                z: projectedPoint.z
                            };

                            // V19.2: Apply Smoothing to Anchor Point (Tip) to stop jitter
                            if (!systemState.p1.anchorFilters[i]) {
                                systemState.p1.anchorFilters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const anchorX = systemState.p1.anchorFilters[i].x.filter(systemState.p1.toBufferX(finalTipX));
                            const anchorY = systemState.p1.anchorFilters[i].y.filter(systemState.p1.toBufferY(tipRaw.y));

                            // Palm Orientation (Calculated bridger_nx, bridger_ny for telemetry/mirroring)
                            let bridger_nx = cross_palm.x / mag_palm;
                            let bridger_ny = cross_palm.y / mag_palm;

                            // V19.5: Mirror the normal X-component to match mirrored coordinate space
                            if (isMirror) {
                                bridger_nx = -bridger_nx;
                            }

                            // Palm Facing Hysteresis (80 Enter, 64 Exit)
                            let isPalmFacing = systemState.p1.palmFacingStates[i];
                            if (!isPalmFacing) {
                                if (normalZ > systemState.parameters.palm.enterThreshold) isPalmFacing = true;
                            } else {
                                if (normalZ < systemState.parameters.palm.exitThreshold) isPalmFacing = false;
                            }
                            systemState.p1.palmFacingStates[i] = isPalmFacing;

                            const category = bestGesture?.categoryName || 'None';
                            const confidence = bestGesture?.score || 0;

                            // Apply 1EuroFilter (Always applied for landmark jitter)
                            if (!systemState.p1.filters[i]) {
                                systemState.p1.filters[i] = {
                                    x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                    y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                };
                            }
                            const smoothedX = systemState.p1.filters[i].x.filter(screenX);
                            const smoothedY = systemState.p1.filters[i].y.filter(screenY);

                            // V24.3: TRIPLE FLOW FSM
                            const fsmState = systemState.p1.fsmStates[i];
                            const isPointing = (category === 'Pointing_Up' && confidence > systemState.parameters.gestures.minGestureConfidence);
                            const hasConfidence = (confidence > systemState.parameters.coasting.confidenceThreshold);

                            if (isPalmFacing) systemState.p1.lastPalmFacingTimes[i] = now;
                            const isCharging = isPalmFacing || (now - systemState.p1.lastPalmFacingTimes[i] < systemState.parameters.fsm.tensionMs);
                            const isCoasting = (fsmState === 'COAST');

                            if (isCharging) {
                                const fillAmount = (100 / systemState.parameters.fsm.chargeTimeMs) * dt;
                                systemState.p1.readinessScores[i] = Math.min(100, systemState.p1.readinessScores[i] + fillAmount);
                            } else {
                                const drainTime = isCoasting ? systemState.parameters.fsm.coastDrainTimeMs : systemState.parameters.fsm.releaseTimeMs;
                                const drainAmount = (100 / drainTime) * dt;
                                systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainAmount);
                            }

                            let fsmStateNew = fsmState;
                            const readiness = systemState.p1.readinessScores[i];
                            const primary = systemState.fsm.primaryHandIndex;
                            const isSeatAvailable = (primary === null || primary === i);

                            if (fsmState === 'IDLE') {
                                if (readiness >= systemState.parameters.fsm.hysteresisHigh) fsmStateNew = 'READY';
                            } else if (fsmState === 'READY') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) fsmStateNew = 'IDLE';
                                else if (!hasConfidence) fsmStateNew = 'COAST';
                                else if (isPointing && isPalmFacing && isSeatAvailable) {
                                    fsmStateNew = 'COMMIT';
                                    systemState.fsm.primaryHandIndex = i;
                                }
                            } else if (fsmState === 'COMMIT') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (!hasConfidence) fsmStateNew = 'COAST';
                            } else if (fsmState === 'COAST') {
                                if (readiness <= systemState.parameters.fsm.hysteresisLow) {
                                    fsmStateNew = 'IDLE';
                                    if (primary === i) systemState.fsm.primaryHandIndex = null;
                                } else if (hasConfidence && isPalmFacing) {
                                    fsmStateNew = isPointing ? 'COMMIT' : 'READY';
                                }
                            }
                            systemState.p1.fsmStates[i] = fsmStateNew;

                            let finalX, finalY;
                            const forceDirect = systemState.parameters.physics.useDirectProjection;

                            if (systemState.parameters.physics.mode === 'STATIC_ROD' || forceDirect) {
                                finalX = smoothedX;
                                finalY = smoothedY;
                            } else {
                                // PLANCK_SPRING Mode
                                if (isFlagEnabled('physics-planck') && !(systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter)) {
                                    systemState.p1.physicsState[i] = new PlanckPhysicsAdapter(
                                        systemState.parameters.physics.planckStiffness,
                                        systemState.parameters.physics.planckDamping
                                    );
                                    systemState.p1.physicsState[i].reset(smoothedX, smoothedY);
                                }

                                let physicsPos = { x: smoothedX, y: smoothedY };
                                if (systemState.p1.physicsState[i] instanceof PlanckPhysicsAdapter) {
                                    systemState.p1.physicsState[i].setBallistic(fsmStateNew === 'COAST');
                                    systemState.p1.physicsState[i].setParams({
                                        stiffness: systemState.parameters.physics.planckStiffness,
                                        dampingRatio: systemState.parameters.physics.planckDamping
                                    });
                                    physicsPos = systemState.p1.physicsState[i].update(smoothedX, smoothedY, dt);
                                }

                                // V19.2: CLAW RIGID PROJECTION
                                const dx = smoothedX - anchorX;
                                const dy = smoothedY - anchorY;
                                const mag = Math.sqrt(dx * dx + dy * dy) || 1e-6;
                                let ux = dx / mag;
                                let uy = dy / mag;

                                if (!systemState.p1.directionFilters[i]) {
                                    systemState.p1.directionFilters[i] = {
                                        x: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta),
                                        y: new OneEuroFilter(systemState.parameters.physics.oneEuroMinCutoff, systemState.parameters.physics.oneEuroBeta)
                                    };
                                }
                                ux = systemState.p1.directionFilters[i].x.filter(ux);
                                uy = systemState.p1.directionFilters[i].y.filter(uy);
                                const mag_filtered = Math.sqrt(ux * ux + uy * uy) || 1e-6;
                                ux /= mag_filtered; uy /= mag_filtered;

                                const vx = physicsPos.x - anchorX;
                                const vy = physicsPos.y - anchorY;
                                const d_proj = vx * ux + vy * uy;

                                finalX = anchorX + ux * d_proj;
                                finalY = anchorY + uy * d_proj;
                            }

                            const curls = {
                                index: this.calculateCurl(lm, [5, 6, 7, 8]),
                                middle: this.calculateCurl(lm, [9, 10, 11, 12]),
                                ring: this.calculateCurl(lm, [13, 14, 15, 16]),
                                pinky: this.calculateCurl(lm, [17, 18, 19, 20])
                            };

                            const rawCursorData = {
                                screenX: finalX, screenY: finalY,
                                normX: finalX / width, normY: finalY / height,
                                uiNormX: finalX / width, // V28.5: Hardened 1:1 Parity
                                uiNormY: finalY / height, // V28.5: Hardened 1:1 Parity
                                normZ: projectedPoint.z,
                                fsmState: fsmStateNew, gesture: category,
                                confidence, isPalmFacing, readinessScore: readiness,
                                skeletonAlpha: dormancyAlpha, // V26: Fades on stillness
                                handIndex: i, pointerId: 10 + i, // V24.4: Stable Hand ID
                                curls,
                                landmarks: mirroredLandmarks, // Fixed: Mirrored landmarks
                                rawX: anchorX, rawY: anchorY,
                                normalZ: normalZ,
                                palmConeAngle: palmConeAngle,
                                palmNormal: { x: bridger_nx, y: bridger_ny, z: nz },
                                timestamp: now
                            };

                            cursorData = FusionSchema.parse(rawCursorData);
                            systemState.p1.lastData[i] = cursorData;
                        } catch (e) {
                            console.error("ðŸš¨ P1_FUSE_CONTRACT_BREACH:", e);
                        }
                    } else {
                        // Coasting Logic for missing landmarks (V24.3: Ballistic Inertia)
                        const last = systemState.p1.lastData[i];
                        const fsmState = systemState.p1.fsmStates[i];
                        const fadeTime = systemState.parameters.landmarks.skeletonFadeTimeMs || 400;

                        if (last && fsmState !== 'IDLE') {
                            const isCoasting = (fsmState === 'COAST' || fsmState === 'COMMIT');
                            const drainTime = isCoasting ? systemState.parameters.fsm.coastDrainTimeMs : systemState.parameters.fsm.releaseTimeMs;
                            const drainAmount = (100 / drainTime) * dt;
                            systemState.p1.readinessScores[i] = Math.max(0, systemState.p1.readinessScores[i] - drainAmount);

                            const readiness = systemState.p1.readinessScores[i];
                            const tTrackingLost = now - (systemState.p1.lastTrackingTimes[i] || now);

                            if (readiness > systemState.parameters.fsm.hysteresisLow) {
                                // Update Physics in Ballistic mode to get inertial position
                                let coastPos = { x: last.screenX, y: last.screenY };
                                const adapter = systemState.p1.physicsState[i];
                                if (adapter instanceof PlanckPhysicsAdapter) {
                                    adapter.setBallistic(true);
                                    coastPos = adapter.update(last.screenX, last.screenY, dt);
                                }

                                cursorData = FusionSchema.parse({
                                    ...last,
                                    screenX: coastPos.x,
                                    screenY: coastPos.y,
                                    uiNormX: coastPos.x / (systemState.p0.videoBounds?.width || 1280), // V28.5 Recalculate UI Norms
                                    uiNormY: coastPos.y / (systemState.p0.videoBounds?.height || 720), // V28.5 Recalculate UI Norms
                                    fsmState: 'COAST',
                                    readinessScore: readiness,
                                    skeletonAlpha: Math.max(0, 1.0 - (tTrackingLost / fadeTime)), // V26: Dedicated tracking loss fade
                                    handIndex: i,
                                    landmarks: last.landmarks || [], // V24.22: Keep landmarks for fading
                                    timestamp: now
                                });
                                systemState.p1.fsmStates[i] = 'COAST';
                            } else {
                                // Terminal Drain reached
                                systemState.p1.lastData[i] = null;
                                systemState.p1.fsmStates[i] = 'IDLE';
                                if (systemState.fsm.primaryHandIndex === i) systemState.fsm.primaryHandIndex = null;
                            }
                        }
                    }

                    if (cursorData) {
                        const validated = FusionSchema.parse({ ...cursorData, timestamp: now });
                        cursors.push(validated);
                    }
                }

                // V24.7: MULTI-READY / SINGLE-COMMIT (HOT SEAT V2)
                // Return ALL active cursors for visual feedback.
                const primary = systemState.fsm.primaryHandIndex;
                const primaryHand = cursors.find(c => c.handIndex === primary);

                if (primaryHand) {
                    systemState.fsm.currentState = primaryHand.fsmState;
                } else if (cursors.length > 0) {
                    const states = cursors.map(c => c.fsmState);
                    if (states.includes('COMMIT')) systemState.fsm.currentState = 'COMMIT';
                    else if (states.includes('COAST')) systemState.fsm.currentState = 'COAST';
                    else if (states.includes('READY')) systemState.fsm.currentState = 'READY';
                    else systemState.fsm.currentState = 'IDLE';
                } else {
                    systemState.fsm.currentState = 'IDLE';
                }

                // ðŸŒ UPDATE DATA FABRIC
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });

                return cursors;
            }
        }

        // Expose to window for hardened testing [V24.3]
        window.systemState = systemState;
        window.PlanckPhysicsAdapter = PlanckPhysicsAdapter;
        window.P1Bridger = P1Bridger;
        window.drawResults = drawResults;

        // --- P0: SENSE ---
        async function initP0() {
            logMission("P0: Initializing V7 Laser Cluster...");
            const vision = await FilesetResolver.forVisionTasks("./lib/wasm");
            systemState.p0.recognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "./lib/models/gesture_recognizer.task",
                    delegate: 'GPU'
                },
                runningMode: "VIDEO",
                numHands: systemState.parameters.landmarks.numHands
            });
            logMission("âœ… P0: Sensing Cluster Online");
        }

        /**
         * ðŸ“– V30 TACTICAL TUTORIAL SYSTEM
         * Enforces User flow: IDLE -> READY (Palm) -> COMMIT (Gesture) -> IDLE
         */
        class TutorialSystem {
            constructor() {
                this.isCompleted = false;
                this.completionTimer = null;
                this.steps = [
                    {
                        id: 'IDLE',
                        test: (cursors) => cursors.length === 0 || cursors.every(c => c.fsmState === 'IDLE' && c.readinessScore < 1),
                        header: 'Step 1: Initiation ðŸ–ï¸',
                        body: 'Welcome Commander. Show your <span class="tutorial-highlight">Palm</span> to the camera to begin charging.'
                    },
                    {
                        id: 'READY_INGRESS',
                        test: (cursors) => cursors.some(c => c.isPalmFacing && c.fsmState === 'IDLE' && c.readinessScore > 5),
                        header: 'Step 2: Charging ðŸ–ï¸',
                        body: 'Hold steady. Your palm is facing the camera. Charging: <span class="tutorial-highlight">%RE%%</span>'
                    },
                    {
                        id: 'READY_DRAIN',
                        test: (cursors) => cursors.some(c => !c.isPalmFacing && c.fsmState === 'IDLE' && c.readinessScore > 5),
                        header: 'Signal Warning âš ï¸',
                        body: 'Palm away detected! The charge is <span class="tutorial-highlight">Draining</span>. Face the camera to maintain readiness.'
                    },
                    {
                        id: 'READY_ACTIVE',
                        test: (cursors) => cursors.some(c => c.fsmState === 'READY'),
                        header: 'Step 3: READY (Amber) â˜ï¸',
                        body: 'Phoenix Core ignited! Notice the <span class="tutorial-highlight">Amber Flame</span>. Perform a <span class="tutorial-highlight">Pointing Up</span> gesture to lock.'
                    },
                    {
                        id: 'COMMIT_ACTIVE',
                        test: (cursors) => cursors.some(c => c.fsmState === 'COMMIT'),
                        header: 'Step 4: COMMITTED (Cyan) ðŸŽ¯',
                        body: 'CONTROL LOCKED. The core is <span class="tutorial-highlight">Cyan</span>. Interact now. Turn your palm away to reset.'
                    }
                ];
                this.currentStepIdx = -1;
                this.isVisible = false;
            }

            reset() {
                this.isCompleted = false;
                this.currentStepIdx = -1;
                if (this.completionTimer) {
                    clearTimeout(this.completionTimer);
                    this.completionTimer = null;
                }
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.opacity = '1';
                    systemState.ui.tutorial.style.display = 'block';
                }
                this.isVisible = true;
                logMission("Tutorial Reset.");
            }

            show() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'block';
                    this.isVisible = true;
                }
            }

            hide() {
                if (systemState.ui.tutorial) {
                    systemState.ui.tutorial.style.display = 'none';
                    this.isVisible = false;
                }
            }

            update(cursors) {
                // Kiosk Logic: Disable if completed or toggled off
                if (this.isCompleted || !systemState.parameters.ui.showTutorial) {
                    if (this.isVisible) this.hide();
                    return;
                }

                if (!this.isVisible) this.show();

                // Find highest readiness for %RE% replacement
                const maxRE = cursors.length > 0 ? Math.max(...cursors.map(c => (c.readinessScore || 0))) : 0;

                // Find the first matching step from the end (highest priority)
                const newIdx = this.steps.slice().reverse().findIndex(s => s.test(cursors));
                const actualIdx = newIdx === -1 ? -1 : this.steps.length - 1 - newIdx;

                if (actualIdx !== -1) {
                    const step = this.steps[actualIdx];
                    const bodyText = step.body.replace('%RE%', maxRE.toFixed(0));

                    // Once-only logic: If COMMIT is reached, start the completion exit timer
                    if (step.id === 'COMMIT_ACTIVE' && !this.isCompleted && !this.completionTimer) {
                        this.completionTimer = setTimeout(() => {
                            this.isCompleted = true;
                            // Add a final fade effect or just hide
                            systemState.ui.tutorial.style.opacity = '0';
                            setTimeout(() => {
                                this.hide();
                                logMission("Tactical Onboarding Completed. (Kiosk Mode Active)");
                            }, 1000);
                        }, 4000); // Give them 4 seconds to enjoy the COMMIT state
                    }

                    if (actualIdx !== this.currentStepIdx) {
                        this.currentStepIdx = actualIdx;
                        systemState.ui.tutHeader.innerText = step.header;

                        // Trigger haptic-like visual pulse
                        systemState.ui.tutorial.classList.remove('tutorial-step-active');
                        void systemState.ui.tutorial.offsetWidth; // trigger reflow
                        systemState.ui.tutorial.classList.add('tutorial-step-active');
                    }
                    systemState.ui.tutBody.innerHTML = bodyText;
                }
            }
        }
        window.hfoTutorial = new TutorialSystem();

        let lastFrameTime = performance.now();
        function predictLoop() {
            if (!systemState.parameters.p0Active) return;
            const now = performance.now();
            const dt = now - lastFrameTime;
            lastFrameTime = now;

            // V24.6: Telemetry Replay Logic (Golden Master)
            if (window.hfoPlayer.isPlaying) {
                const frame = window.hfoPlayer.getNextFrame();
                if (frame && frame.phase === 'P1_FUSE') {
                    systemState.dataFabric = DataFabricSchema.parse(frame.data);
                    systemState.p1.cursors = systemState.dataFabric.cursors;
                    // Skip remaining sensing/fusion
                    requestAnimationFrame(predictLoop);
                    return;
                }
            }

            // ðŸ’‰ P4: INJECTION HOOK (For E2E/Stress Testing)
            let results;
            if (window.hfoMockResults) {
                results = window.hfoMockResults;
            } else {
                results = systemState.p0.recognizer.recognizeForVideo(systemState.p0.video, now);
            }

            // P1 BRIDGE: Fusing sensing to coordinates under contract
            const cursors = P1Bridger.fuse(results, dt);

            // V19.4: VALIDATED SHARED DATA FABRIC ENFORCEMENT
            try {
                systemState.dataFabric = DataFabricSchema.parse({
                    cursors: cursors,
                    systemTime: now,
                    frameId: (systemState.dataFabric.frameId || 0) + 1
                });
                // Maintain legacy pointer for back-compat with existing FSM logic
                systemState.p1.cursors = systemState.dataFabric.cursors;

                // V24.5 Telemetry Recording
                window.hfoTelemetry.record('P1_FUSE', systemState.dataFabric);
            } catch (e) {
                console.error("PORT 1 CONTRACT BREACH:", e);
                // Fail-safe to last known good or empty
            }

            // ðŸ“Š P5: State Transparency (For E2E Testing)
            window.hfoState = {
                hands: systemState.dataFabric.cursors,
                parameters: systemState.parameters,
                fsm: systemState.fsm,
                lineage: 'SHARED_DATA_FABRIC_V19.5'
            };

            // V19.5: Unified Draw Call (Only skeleton receives raw results for ISR overlay)
            // V24.10: Substrate Gating (Prevent visual muddiness when Babylon is active)
            if (isFlagEnabled('engine-canvas')) {
                drawResults(results, systemState.dataFabric);
            }

            if (isFlagEnabled('ui-lil-gui')) {
                updateVisualPanels(results);
            }

            if (isFlagEnabled('p3-injector')) {
                w3cPointerNematocystInjector(); // V20.1: Rebranded Hydra Port
            }

            // ðŸ“– V30 Tutorial Update
            window.hfoTutorial.update(systemState.dataFabric.cursors);

            // BABYLON ENGINE (Standardized V28+)
            systemState.ui.juiceLayers.forEach(layer => {
                if (layer instanceof BabylonJuiceSubstrate) {
                    layer.canvas.style.display = 'block';
                    layer.update(systemState.dataFabric.cursors);
                }
            });

            requestAnimationFrame(predictLoop);
        }

        /**
         * ï¿½ W3C POINTER INJECTOR (Hybrid Strategy Adapter - V27)
         * Implements industry-standard event chains for UI Interaction.
         */
        function w3cPointerNematocystInjector() {
            const cursors = systemState.dataFabric.cursors;
            const video = systemState.p0.video;
            if (!video) return;

            const videoWidth = video.videoWidth || parseInt(systemState.parameters.camera.resolution.split('x')[0]) || 1280;
            const videoHeight = video.videoHeight || parseInt(systemState.parameters.camera.resolution.split('x')[1]) || 720;
            const rect = video.getBoundingClientRect();
            const rectWidth = rect.width || videoWidth;
            const rectHeight = rect.height || videoHeight;
            const rectLeft = rect.left || 0;
            const rectTop = rect.top || 0;

            const currentIds = new Set();

            cursors.forEach(cursor => {
                const pid = cursor.pointerId;

                // V24.7: Hot Seat V2 Interaction Gating
                // Ensures only ONE hand can interact with the system at a time.
                // READY hands provide multiple visual fireballs, but only the primary hand injects events.
                const isPrimary = (systemState.fsm.primaryHandIndex === cursor.handIndex);
                let pState = systemState.fsm.activePointers[pid];

                // If not primary, only allow processing if it was previously active (to cleanup)
                if (!isPrimary && (!pState || !pState.wasDown)) return;

                currentIds.add(pid);

                // V28.0: UNIVERSAL PROJECTION ENGINE (UPE) ENFORCEMENT
                // V28.5 HARDENED: Use pre-calculated uiNorms for cross-substrate parity
                const viewX = systemState.p1.toViewportX(cursor.uiNormX || cursor.normX);
                const viewY = systemState.p1.toViewportY(cursor.uiNormY || cursor.normY);

                const isDown = (cursor.fsmState === 'COMMIT' || cursor.fsmState === 'COAST');
                const pressure = isDown ? (cursor.fsmState === 'COMMIT' ? 1.0 : 0.5) : 0.0;

                if (!pState) {
                    systemState.fsm.activePointers[pid] = { lastTarget: null, lock: null, wasDown: false };
                    pState = systemState.fsm.activePointers[pid];
                }

                let target = pState.lock;
                let finalX = viewX;
                let finalY = viewY;

                if (!target) {
                    let probe = document.elementFromPoint(viewX, viewY) || document.body;
                    if (probe && probe.tagName === 'IFRAME') {
                        try {
                            const iframeRect = probe.getBoundingClientRect();
                            const subX = viewX - iframeRect.left;
                            const subY = viewY - iframeRect.top;
                            const inner = probe.contentDocument.elementFromPoint(subX, subY);
                            if (inner) {
                                probe = inner;
                                finalX = subX;
                                finalY = subY;
                            }
                        } catch (e) { }
                    }
                    target = probe;
                } else {
                    if (target.ownerDocument !== document) {
                        const iframe = Array.from(document.querySelectorAll('iframe')).find(f => f.contentDocument === target.ownerDocument);
                        if (iframe) {
                            const r = iframe.getBoundingClientRect();
                            finalX = viewX - r.left;
                            finalY = viewY - r.top;
                        }
                    }
                }

                const eventInit = {
                    bubbles: true, cancelable: true, pointerId: pid, pointerType: 'mouse',
                    clientX: finalX, clientY: finalY, screenX: viewX, screenY: viewY,
                    pressure: pressure, buttons: isDown ? 1 : 0, button: isDown ? 0 : -1,
                    width: 1, height: 1, isPrimary: pid === 10
                };

                if (target !== pState.lastTarget) {
                    if (pState.lastTarget) {
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerout', eventInit));
                        dispatchToHydraHydrant(pState.lastTarget, new PointerEvent('pointerleave', eventInit));
                    }
                    if (target) {
                        dispatchToHydraHydrant(target, new PointerEvent('pointerover', eventInit));
                        dispatchToHydraHydrant(target, new PointerEvent('pointerenter', eventInit));
                    }
                    pState.lastTarget = target;
                }

                if (isDown && !pState.wasDown) {
                    pState.lock = target;
                    if (target.setPointerCapture) try { target.setPointerCapture(pid); } catch (e) { }
                    dispatchToHydraHydrant(target, new PointerEvent('pointerdown', eventInit), true);
                }

                dispatchToHydraHydrant(target, new PointerEvent('pointermove', eventInit));

                if (!isDown && pState.wasDown) {
                    dispatchToHydraHydrant(target, new PointerEvent('pointerup', { ...eventInit, pressure: 0.0, buttons: 0, button: 0 }));
                    if (target.releasePointerCapture) try { target.releasePointerCapture(pid); } catch (e) { }
                    pState.lock = null;
                }

                pState.wasDown = isDown;
            });

            // V24.4: Real pointercancel path for lost tracking
            Object.keys(systemState.fsm.activePointers).forEach(pidStr => {
                const pid = parseInt(pidStr);
                if (!currentIds.has(pid)) {
                    const pState = systemState.fsm.activePointers[pid];
                    if (pState.wasDown && pState.lock) {
                        dispatchToHydraHydrant(pState.lock, new PointerEvent('pointercancel', {
                            pointerId: pid, bubbles: true, pointerType: 'mouse'
                        }));
                        if (pState.lock.releasePointerCapture) try { pState.lock.releasePointerCapture(pid); } catch (e) { }
                        if (systemState.parameters.devMode) console.log(`[P3] Handled pointer-loss cancel for id: ${pid}`);
                    }
                    delete systemState.fsm.activePointers[pid];
                }
            });
        }

        /**
         * ðŸ”± HYDRA HYDRANT: Payload Delivery Mechanism (Formalized V20.8 Pulse Strategy)
         * Optimized for React/Excalidraw and universal target discovery.
         * @param {Boolean} isPulse - If true, triggers immediate click sequence.
         */
        function dispatchToHydraHydrant(t, e, isPulse = false) {
            if (!t) return;

            // V28: Target Normalization (Find nearest interactive ancestor if child hit)
            const findControl = (el) => {
                let curr = el;
                // Traverse up to 5 levels or until a known interactive tag/role is found
                for (let i = 0; i < 5 && curr && curr !== document.body; i++) {
                    const tag = curr.tagName ? curr.tagName.toLowerCase() : '';
                    const role = curr.getAttribute ? curr.getAttribute('role') : null;
                    if (tag === 'button' || tag === 'a' || tag === 'input' || tag === 'select' ||
                        role === 'button' || role === 'link' || role === 'checkbox' ||
                        curr.classList?.contains('ToolIcon') || curr.onclick) {
                        return curr;
                    }
                    curr = curr.parentElement;
                }
                return el;
            };

            const control = findControl(t);
            t.dispatchEvent(e);

            // Legacy Mouse Simulation & V20.8 Pulse Sequence
            if (e.type === 'pointerdown' || e.type === 'pointerup') {
                const mouseType = e.type === 'pointerdown' ? 'mousedown' : 'mouseup';
                const mouseEv = new MouseEvent(mouseType, {
                    bubbles: true,
                    cancelable: true,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    buttons: e.buttons,
                    button: 0,
                    view: t.ownerDocument.defaultView || window
                });
                t.dispatchEvent(mouseEv);

                // Focus Priming on Down
                if (e.type === 'pointerdown') {
                    if (control.focus) control.focus();
                }

                // V20.8 "Pulse Trigger": Force click on DOWN if pulse is active
                if (isPulse && e.type === 'pointerdown') {
                    // 10ms settle buffer for React to finalize hover/focus state
                    setTimeout(() => {
                        if (control.click) {
                            control.click();
                        } else {
                            const clickEv = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                clientX: e.clientX,
                                clientY: e.clientY,
                                view: t.ownerDocument.defaultView || window
                            });
                            control.dispatchEvent(clickEv);
                        }
                        if (systemState.parameters.devMode) console.log(`[P3] PULSE CLICK triggered on ${control.tagName}`);
                    }, 10);
                }

                // Legacy Release Click (Fallback/Safety)
                if (e.type === 'pointerup' && !isPulse) {
                    setTimeout(() => {
                        if (control.click) control.click();
                    }, 10);
                }
            }
        }

        // --- SPARKLINE HELPER ---
        function drawSparkline(ctx, x, y, w, h, data, color, markers = []) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            const step = w / 64;
            data.forEach((val, i) => {
                const px = x + i * step;
                const py = y + h - (val * h);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Draw Markers
            markers.forEach(m => {
                const my = y + h - (m.val * h);
                ctx.strokeStyle = m.color;
                ctx.setLineDash([2, 1]);
                ctx.beginPath(); ctx.moveTo(x, my); ctx.lineTo(x + w, my); ctx.stroke();
                ctx.setLineDash([]);
            });
        }

        // --- ðŸŒ  ELEMENTAL JUICE HELPERS ---
        function drawFireball(ctx, x, y, size, intensity, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 236, 61, 0.9)', 'rgba(255, 77, 79, 0.8)', 'rgba(255, 30, 0, 0)'],
                'READY': ['rgba(255, 255, 255, 0.8)', 'rgba(255, 251, 143, 0.7)', 'rgba(255, 169, 64, 0.6)', 'rgba(255, 169, 64, 0)'],
                'COAST': ['rgba(255, 255, 255, 0.4)', 'rgba(145, 213, 255, 0.3)', 'rgba(9, 109, 217, 0.2)', 'rgba(9, 109, 217, 0)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Outer Gloom/Heat Distortion
            const bloomSize = size * (4 + Math.sin(time / 150) * 0.5);
            const bloomGrad = ctx.createRadialGradient(x, y, 0, x, y, bloomSize);
            bloomGrad.addColorStop(0, c[2]);
            bloomGrad.addColorStop(0.4, c[3]);
            ctx.fillStyle = bloomGrad;
            ctx.beginPath(); ctx.arc(x, y, bloomSize, 0, Math.PI * 2); ctx.fill();

            // Core Plasma
            const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
            coreGrad.addColorStop(0, c[0]);
            coreGrad.addColorStop(0.3, c[1]);
            coreGrad.addColorStop(0.7, c[2]);
            coreGrad.addColorStop(1, c[3]);

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Pulsing spikes/tendrils
            if (state === 'COMMIT') {
                ctx.strokeStyle = c[1];
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (time / 200) + (i * Math.PI / 4);
                    const length = size * (2.5 + Math.sin(time / 50 + i) * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // --- ðŸŒŠ WATER ELEMENT CURSOR (V20.4) ---
        function drawWaterCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(0, 191, 255, 0.8)', 'rgba(0, 123, 255, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(173, 216, 230, 0.5)', 'rgba(0, 191, 255, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(224, 247, 250, 0.2)', 'rgba(178, 235, 242, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Fluid Laser / Beam Path
            if (systemState.parameters.physics.showLaserBeam) {
                const dist = Math.sqrt((x - rawX) ** 2 + (y - rawY) ** 2);
                const steps = 10;
                ctx.lineWidth = state === 'COMMIT' ? 8 : 4;
                ctx.strokeStyle = c[1];
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);

                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    // Sine wave distortion for water feel
                    const wave = Math.sin(time / 200 + ratio * 10) * 5 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();

                // Inner white fluid core
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                for (let i = 1; i <= steps; i++) {
                    const ratio = i / steps;
                    const px = rawX + (x - rawX) * ratio;
                    const py = rawY + (y - rawY) * ratio;
                    const wave = Math.sin(time / 200 + ratio * 10) * 2 * ratio;
                    const ux = -(y - rawY) / (dist || 1);
                    const uy = (x - rawX) / (dist || 1);
                    ctx.lineTo(px + ux * wave, py + uy * wave);
                }
                ctx.stroke();
            }

            // 2. Ripple Effect at Tip
            const rippleSize = (state === 'COMMIT' ? 20 : 12) + Math.sin(time / 300) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, rippleSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.5, c[1]);
            grad.addColorStop(1, 'rgba(0, 123, 255, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, rippleSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Bubbles/Droplets if committed
            if (state === 'COMMIT') {
                for (let i = 0; i < 3; i++) {
                    const bTime = (time + i * 1000) % 2000;
                    const bScale = bTime / 2000;
                    const bx = x + Math.cos(i * 2 + time / 500) * 20 * bScale;
                    const by = y - 30 * bScale; // Rise up
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - bScale) + ')';
                    ctx.beginPath(); ctx.arc(bx, by, 2 * (1 - bScale), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        // --- ðŸ”¥ FIRE ELEMENT CURSOR (V20.4) ---
        function drawFireCursor(ctx, rawX, rawY, x, y, state) {
            const time = Date.now();
            const colors = {
                'COMMIT': ['rgba(255, 255, 255, 1.0)', 'rgba(255, 69, 0, 0.8)', 'rgba(255, 140, 0, 0.6)'],
                'READY': ['rgba(255, 255, 255, 0.6)', 'rgba(255, 195, 0, 0.5)', 'rgba(255, 69, 0, 0.3)'],
                'COAST': ['rgba(255, 255, 255, 0.2)', 'rgba(255, 140, 0, 0.2)', 'rgba(128, 0, 0, 0.1)']
            };
            const c = colors[state] || colors['READY'];

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // 1. Heat Distortion Beam
            if (systemState.parameters.physics.showLaserBeam) {
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = c[1];
                ctx.lineWidth = state === 'COMMIT' ? 12 : 6;
                ctx.lineCap = 'round';
                ctx.globalAlpha = 0.6;
                ctx.stroke();

                // Subtler Flicker Core (V20.5: Reduced magnitude to stop "perceived" oscillation)
                ctx.beginPath();
                ctx.moveTo(rawX, rawY);
                ctx.lineTo(x + (Math.random() - 0.5) * 3, y + (Math.random() - 0.5) * 3);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.2;
                ctx.stroke();
            }

            // 2. Rising Fireball at Tip (V20.5: Slower pulse)
            const fireSize = (state === 'COMMIT' ? 25 : 15) + Math.sin(time / 250) * 3;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, fireSize);
            grad.addColorStop(0, c[0]);
            grad.addColorStop(0.4, c[1]);
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, fireSize, 0, Math.PI * 2);
            ctx.fill();

            // 3. Emitted Sparks
            if (state === 'COMMIT' || state === 'READY') {
                for (let i = 0; i < (state === 'COMMIT' ? 5 : 2); i++) {
                    const sparkTime = (time + i * 500) % 1000;
                    const sRatio = sparkTime / 1000;
                    const angle = (i * Math.PI * 2 / 5) + time / 1000;
                    const sx = x + Math.cos(angle) * 30 * sRatio;
                    // Rise up in screen space
                    const sy = y + Math.sin(angle) * 10 * sRatio - 60 * sRatio;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = 1 - sRatio;
                    ctx.beginPath(); ctx.arc(sx, sy, 2 * (1 - sRatio), 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawElementalJuice(ctx, landmarks, readinessScore, canvasWidth, canvasHeight) {
            if (readinessScore <= 5) return;
            const intensity = readinessScore / 100;
            const time = Date.now();

            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Scale points based on intensity (0=wrist, 20=tips)
            const targetPoints = [0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 16, 17, 20];
            const activeCount = Math.floor(targetPoints.length * intensity);

            for (let i = 0; i < activeCount; i++) {
                const lm = landmarks[targetPoints[i]];
                const x = lm.x * canvasWidth;
                const y = lm.y * canvasHeight;

                const size = (15 + Math.sin(time / 100 + i) * 5) * intensity;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
                grad.addColorStop(0, `rgba(255, ${100 + Math.random() * 50}, 50, ${0.6 * intensity})`);
                grad.addColorStop(1, 'rgba(255, 50, 0, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();

                // Upward Ash/Sparks
                if (Math.random() > 0.7) {
                    const sx = x + (Math.random() - 0.5) * 20;
                    const sy = y - (time % 1000 / 1000) * 40 * intensity;
                    ctx.fillStyle = '#FFD700';
                    ctx.globalAlpha = Math.random() * intensity;
                    ctx.beginPath(); ctx.arc(sx, sy, 1.5, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }

        function updateVisualPanels(results) {
            // Update Gestures Panel
            if (systemState.ui.gestures) {
                let html = '<div class="scrollable-panel">';
                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((cursor, i) => {
                        const hIdx = cursor.handIndex;
                        const gesture = cursor.gesture;
                        const score = cursor.confidence;
                        // Handedness still comes from raw results for now
                        const handedness = results.handedness?.[hIdx]?.[0]?.categoryName || 'Unknown';

                        const isCoasting = cursor.fsmState === 'COAST';
                        const stateColor = cursor.fsmState === 'COMMIT' ? 'var(--hfo-red)' : (isCoasting ? '#FFA500' : 'var(--md-sys-color-primary)');

                        // Deep Debug Data
                        const phys = systemState.p1.physicsState[hIdx];
                        const telemetry = phys && phys.getTelemetry ? phys.getTelemetry() : { speed: 0 };
                        const speed = telemetry.speed.toFixed(2);

                        const isPrimary = systemState.fsm.primaryHandIndex === hIdx;
                        const labelPrefix = isPrimary ? 'ðŸŽ–ï¸ [PRIMARY] ' : '';

                        html += `
                            <div class="m3-card" style="border-left: 4px solid ${stateColor}">
                                <div class="m3-label">${labelPrefix}Hand ${hIdx} | ${handedness}</div>
                                <div class="m3-stat">
                                    <span>Gesture | Confidence</span>
                                    <span style="font-weight:bold">${gesture} | ${(score * 100).toFixed(0)}%</span>
                                </div>
                                <div class="m3-stat" style="margin-top:8px">
                                    <span>Planck Speed (px/s)</span>
                                    <span style="color:var(--hfo-gold)">${speed}</span>
                                </div>
                                <div class="m3-stat">
                                    <span>Readiness Score</span>
                                    <span>${(cursor.readinessScore || 0).toFixed(1)}%</span>
                                </div>
                                <div class="m3-progress-container">
                                    <div class="m3-progress-bar" style="width: ${cursor.readinessScore || 0}%; background: ${stateColor}"></div>
                                </div>
                                <div class="m3-stat">
                                    <span>Rod Sync (Projected)</span>
                                    <span style="font-family:monospace">${cursor.screenX.toFixed(0)}/${cursor.screenY.toFixed(0)}</span>
                                </div>
                                <div class="m3-stat" style="margin-top:4px; font-size:10px; opacity:0.7">
                                    <span>FSM State</span>
                                    <span>${cursor.fsmState || 'IDLE'}</span>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    html += '<div style="color:var(--md-sys-color-outline); text-align:center; margin-top:40px;">No hands detected</div>';
                }
                html += '</div>';
                systemState.ui.gestures.innerHTML = html;
            }

            // Update Palm Panel
            if (systemState.ui.palmCtx) {
                const ctx = systemState.ui.palmCtx;
                const canvas = systemState.ui.palm;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (systemState.dataFabric.cursors.length > 0) {
                    systemState.dataFabric.cursors.forEach((c, i) => {
                        const x = (i === 0 ? canvas.width * 0.25 : canvas.width * 0.75);
                        const y = canvas.height * 0.5;
                        const radius = 40;

                        // ðŸŸ¢ Palm Orientation Sphere (Enhanced V14)
                        const enterT = systemState.parameters.palm.enterThreshold;
                        const exitT = systemState.parameters.palm.exitThreshold;

                        // Background Sphere
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = c.isPalmFacing ? 'rgba(0, 255, 65, 0.05)' : 'rgba(255, 65, 54, 0.05)';
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Hysteresis Rings (Target Zones)
                        ctx.setLineDash([2, 4]);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath(); ctx.arc(x, y, radius * enterT, 0, Math.PI * 2); ctx.stroke(); // Enter Ring
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.beginPath(); ctx.arc(x, y, radius * exitT, 0, Math.PI * 2); ctx.stroke();  // Exit Ring
                        ctx.setLineDash([]);

                        // Face Dot & Normal (Fabric Driven)
                        const nx = c.palmNormal.x;
                        const ny = c.palmNormal.y;
                        const nz = c.normalZ;

                        if (true) { // Fabric always has normal data if cursor exists
                            // ðŸ“Š UPDATE SPARKLINE BUFFERS
                            if (!systemState.ui.history) systemState.ui.history = [];
                            if (!systemState.ui.history[i]) systemState.ui.history[i] = { zNorm: [], readiness: [] };

                            systemState.ui.history[i].zNorm.push(nz);
                            systemState.ui.history[i].readiness.push(c.readinessScore / 100);
                            if (systemState.ui.history[i].zNorm.length > 88) { // Pareto-length history
                                systemState.ui.history[i].zNorm.shift();
                                systemState.ui.history[i].readiness.shift();
                            }

                            // Dynamic Color based on facing status
                            const stateColor = c.isPalmFacing ? '#00FF41' : '#FF4136';

                            // Depth Progress Ring (Fidelity Visualization)
                            ctx.beginPath();
                            ctx.arc(x, y, radius * nz, 0, Math.PI * 2);
                            ctx.strokeStyle = stateColor;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;

                            // Draw Normal Vector Shadow/Pointer
                            const dotX = x + nx * radius;
                            const dotY = y + ny * radius;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(dotX, dotY);
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.stroke();

                            // Facing Dot (Orientation Feedback)
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 6, 0, Math.PI * 2);
                            ctx.fillStyle = stateColor;
                            ctx.shadowBlur = c.isPalmFacing ? 15 : 0;
                            ctx.shadowColor = stateColor;
                            ctx.fill();
                            ctx.shadowBlur = 0;

                            // Crosshair if inside "Goldilocks" area (approx)
                            if (nz > 0.88) {
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 1;
                                ctx.beginPath(); ctx.moveTo(dotX - 10, dotY); ctx.lineTo(dotX + 10, dotY); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(dotX, dotY - 10); ctx.lineTo(dotX, dotY + 10); ctx.stroke();
                            }

                            // ðŸ“Š Z-NORM Hysteresis Gauge
                            const gageW = 8, gageH = 80;
                            const gageX = x + radius + 15, gageY = y - gageH / 2;

                            // Track
                            ctx.fillStyle = '#111';
                            ctx.fillRect(gageX, gageY, gageW, gageH);

                            // ðŸ“Š SPARKLINE: Z-NORM HISTORY
                            const zHistory = systemState.ui.history[i].zNorm;
                            drawSparkline(ctx, gageX - 5, gageY, gageW + 10, gageH, zHistory, '#00FF4144');

                            // Thresholds (0.80 & 0.64) & Goldilocks (0.88)
                            const enterY = gageY + gageH * (1 - systemState.parameters.palm.enterThreshold);
                            const exitY = gageY + gageH * (1 - systemState.parameters.palm.exitThreshold);
                            const goldY = gageY + gageH * (1 - 0.88); // 88% Pareto Target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(gageX - 5, enterY); ctx.lineTo(gageX + gageW + 5, enterY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(gageX - 5, exitY); ctx.lineTo(gageX + gageW + 5, exitY); ctx.stroke();

                            // 88% Goldilocks Marker
                            ctx.strokeStyle = '#FFD700'; // Gold
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(gageX - 8, goldY); ctx.lineTo(gageX + gageW + 8, goldY); ctx.stroke();
                            ctx.setLineDash([]);

                            // Fill
                            const normFill = gageH * Math.max(0, Math.min(1, nz));
                            ctx.fillStyle = c.isPalmFacing ? '#00FF41' : '#444';
                            ctx.fillRect(gageX, gageY + gageH - normFill, gageW, normFill);

                            // âš–ï¸ Readiness Hysteresis Visualizer
                            const rgW = 12, rgH = 80;
                            const rgX = x - radius - 27, rgY = y - rgH / 2;
                            const readinessScore = systemState.p1.readinessScores[i] || 0;

                            ctx.fillStyle = '#111';
                            ctx.fillRect(rgX, rgY, rgW, rgH);

                            // ðŸ“Š SPARKLINE: READINESS HISTORY
                            const bHistory = systemState.ui.history[i].readiness;
                            drawSparkline(ctx, rgX - 5, rgY, rgW + 10, rgH, bHistory, '#D0BCFF44');

                            const highY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisHigh / 100);
                            const lowY = rgY + rgH * (1 - systemState.parameters.fsm.hysteresisLow / 100);
                            const targetY = rgY + rgH * (1 - 0.88); // 88% HIVE target

                            ctx.strokeStyle = '#555';
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath(); ctx.moveTo(rgX - 2, highY); ctx.lineTo(rgX + rgW + 2, highY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(rgX - 2, lowY); ctx.lineTo(rgX + rgW + 2, lowY); ctx.stroke();

                            // 88% Target Marker
                            ctx.strokeStyle = '#D0BCFF';
                            ctx.setLineDash([1, 1]);
                            ctx.beginPath(); ctx.moveTo(rgX - 5, targetY); ctx.lineTo(rgX + rgW + 5, targetY); ctx.stroke();
                            ctx.setLineDash([]);

                            const fillH = rgH * (readinessScore / 100);
                            ctx.fillStyle = c.fsmState === 'READY' ? '#FFD700' : (c.fsmState === 'COMMIT' ? '#FF4136' : '#D0BCFF');
                            ctx.fillRect(rgX, rgY + rgH - fillH, rgW, fillH);

                            // Textual readout
                            ctx.fillStyle = '#AAA';
                            ctx.font = '9px Roboto';
                            ctx.textAlign = 'center';
                            ctx.fillText(`80/64 Z`, gageX + gageW / 2, gageY - 5);
                            ctx.fillText(`88% HFO`, rgX + rgW / 2, rgY - 5);
                            ctx.fillText(`Z: ${nz.toFixed(2)}`, gageX + gageW / 2, gageY + gageH + 12);
                            ctx.fillText(`READINESS: ${readinessScore.toFixed(0)}%`, rgX + rgW / 2, rgY + rgH + 12);
                            ctx.fillText(`FSM: ${c.fsmState}`, x, y + radius + 35);
                        }
                    });
                }
            }

            // --- V18: TACTICAL VIEW (P3 GHOST CURSOR) ---
            if (systemState.ui.tacticalCtx) {
                const ctx = systemState.ui.tacticalCtx;
                const canvas = systemState.ui.tactical;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Grid lines for tactical feel
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const gx = (i / 10) * canvas.width;
                    const gy = (i / 10) * canvas.height;
                    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
                }

                if (systemState.p1.cursors.length > 0) {
                    systemState.p1.cursors.forEach((c) => {
                        const tx = (c.screenX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ty = (c.screenY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        // Origin Pointer (Raw Sensing)
                        const rx = (c.rawX / (systemState.p0.videoBounds?.width || 1)) * canvas.width;
                        const ry = (c.rawY / (systemState.p0.videoBounds?.height || 1)) * canvas.height;

                        ctx.beginPath();
                        ctx.moveTo(rx, ry);
                        ctx.lineTo(tx, ty);
                        ctx.strokeStyle = '#555';
                        ctx.setLineDash([1, 1]);
                        ctx.stroke();

                        // Ghost Cursor (Tactical UI)
                        ctx.beginPath();
                        ctx.arc(tx, ty, 6, 0, Math.PI * 2);
                        ctx.strokeStyle = c.fsmState === 'COMMIT' ? '#FF4136' : '#FFD700';
                        ctx.setLineDash([]);
                        ctx.stroke();

                        // Pressure Indicator
                        if (c.fsmState === 'COMMIT') {
                            ctx.beginPath();
                            ctx.arc(tx, ty, 10 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 65, 54, 0.2)';
                            ctx.fill();
                        }

                        // Identifier
                        ctx.fillStyle = '#888';
                        ctx.font = '9px monospace';
                        ctx.fillText(`H${c.handIndex}:${c.fsmState}`, tx + 10, ty - 10);
                    });
                }
            }

            // Update FSM Visualization Panel
            if (systemState.ui.fsmCtx) {
                const ctx = systemState.ui.fsmCtx;
                const canvas = systemState.ui.fsm;
                if (canvas.width === 0) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const nodes = [
                    { id: 'IDLE', x: 0.15, y: 0.5 },
                    { id: 'READY', x: 0.4, y: 0.5 },
                    { id: 'COMMIT', x: 0.65, y: 0.5 },
                    { id: 'COAST', x: 0.9, y: 0.5 }
                ];

                const nodeWidth = 70, nodeHeight = 35;
                const current = systemState.fsm.currentState;

                // Draw Transitions
                ctx.strokeStyle = '#333';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                // IDLE -> READY
                ctx.moveTo(canvas.width * 0.15 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.4 - nodeWidth / 2, canvas.height * 0.5);
                // READY -> COMMIT
                ctx.moveTo(canvas.width * 0.4 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.65 - nodeWidth / 2, canvas.height * 0.5);
                // COMMIT -> COAST
                ctx.moveTo(canvas.width * 0.65 + nodeWidth / 2, canvas.height * 0.5);
                ctx.lineTo(canvas.width * 0.9 - nodeWidth / 2, canvas.height * 0.5);
                // Transitions back and to IDLE omitted for clarity in simple viz
                ctx.stroke();
                ctx.setLineDash([]);

                nodes.forEach(node => {
                    const nx = canvas.width * node.x;
                    const ny = canvas.height * node.y;
                    const isActive = node.id === current;

                    // Glow for active node
                    if (isActive) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF')));
                    }

                    ctx.fillStyle = isActive ? '#000' : '#111';
                    ctx.strokeStyle = isActive ? (node.id === 'COMMIT' ? '#FF4136' : (node.id === 'READY' ? '#FFD700' : (node.id === 'COAST' ? '#FFA500' : '#D0BCFF'))) : '#444';
                    ctx.beginPath();
                    ctx.roundRect(nx - nodeWidth / 2, ny - nodeHeight / 2, nodeWidth, nodeHeight, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = isActive ? '#FFF' : '#888';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.id, nx, ny + 5);

                    // Draw Readiness Gauge for active state
                    if (isActive && node.id !== 'IDLE') {
                        const pIdx = systemState.fsm.primaryHandIndex !== null ? systemState.fsm.primaryHandIndex : 0;
                        const charge = systemState.p1.readinessScores[pIdx] || 0;
                        const high = systemState.parameters.fsm.hysteresisHigh;
                        const low = systemState.parameters.fsm.hysteresisLow;

                        ctx.fillStyle = '#222';
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth, 6);

                        // Fill
                        ctx.fillStyle = (node.id === 'COAST' ? '#FFA500' : '#FFD700');
                        ctx.fillRect(nx - nodeWidth / 2, ny + 22, nodeWidth * (charge / 100), 6);

                        // HFO Threshold Markers (80/64)
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * (high / 100), ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * (high / 100), ny + 30);
                        ctx.stroke();

                        ctx.strokeStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(nx - nodeWidth / 2 + nodeWidth * (low / 100), ny + 20);
                        ctx.lineTo(nx - nodeWidth / 2 + nodeWidth * (low / 100), ny + 30);
                        ctx.stroke();
                    }
                });
            }
        }

        function updateFSM(state) {
            if (systemState.fsm.currentState !== state) {
                systemState.fsm.currentState = state;
                const status = document.getElementById('state-indicator');
                status.innerText = `P1: CONTRACTS ACTIVE | FSM: ${state}`;
            }
        }

        function drawResults(rawResults, fabric) {
            const { ctx, canvas } = systemState.p0;
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cursors = fabric.cursors;
            const isMirror = systemState.parameters.camera.mirror;

            // --- V19.6: INTEGRATED TACTICAL GRID ---
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const gx = (i / 10) * canvas.width;
                const gy = (i / 10) * canvas.height;
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }
            ctx.restore();

            // --- P0 ISR SKELETON (Restricted Bypass) ---
            // V24.18: Consolidated skeleton drawing to Port 1 Fabric loop below for state-awareness.

            // --- PORT 1 FABRIC VISUALS (Enforced) ---
            cursors.forEach((c, i) => {
                const { screenX, screenY, fsmState, rawX, rawY, landmarks } = c;

                // V24.19 Parity Fix: landmarks are already mirrored/processed by P1Bridger.
                // Do NOT re-mirror them here.
                if ((fsmState === 'IDLE' || fsmState === 'READY' || fsmState === 'COMMIT') && landmarks && landmarks.length > 0 && systemState.parameters.landmarks.showSkeleton) {
                    const utils = new DrawingUtils(ctx);

                    // V28.0: UPE-AWARE SKELETON
                    // We must project landmarks into buffer space using UPE to maintain parity
                    const bufferLandmarks = landmarks.map(l => ({
                        x: systemState.p1.toBufferX(l.x) / canvas.width,
                        y: systemState.p1.toBufferY(l.y) / canvas.height,
                        z: l.z
                    }));

                    utils.drawConnectors(bufferLandmarks, GestureRecognizer.HAND_CONNECTIONS, { color: 'rgba(255, 255, 255, 0.15)', lineWidth: 1.2 });
                    utils.drawLandmarks(bufferLandmarks, { color: 'rgba(255, 255, 255, 0.2)', radius: 1 });
                }

                // V28.5: DIAGNOSTIC CROSSHAIRS (Red Truth Calibration)
                if (isFlagEnabled('dev-mode') && fsmState !== 'IDLE') {
                    ctx.save();
                    ctx.strokeStyle = (fsmState === 'COMMIT') ? '#00ffff' : '#ff9900';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 20, screenY); ctx.lineTo(screenX + 20, screenY);
                    ctx.moveTo(screenX, screenY - 20); ctx.lineTo(screenX, screenY + 20);
                    ctx.stroke();
                    ctx.restore();
                }

                if (fsmState === 'IDLE') return;

                const theme = systemState.parameters.physics.cursorTheme;

                if (theme === 'LI') {
                    drawFireCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'DUI') {
                    drawWaterCursor(ctx, rawX, rawY, screenX, screenY, fsmState);
                } else if (theme === 'QIAN') {
                    // Legacy Rigid Rod Logic (Metal/Heaven)
                    const color = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                    if (systemState.parameters.physics.showLaserBeam) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = fsmState === 'COMMIT' ? 10 : 6;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = fsmState === 'COMMIT' ? 0.9 : 0.6;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(rawX, rawY); ctx.lineTo(screenX, screenY);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = fsmState === 'COMMIT' ? 3 : 2;
                        ctx.globalAlpha = 0.4;
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 8 : 5, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Placeholder for other 5 elements (ZHEN, XUN, KAN, GEN, KUN)
                    const themeColors = {
                        'ZHEN': '#9400D3', 'XUN': '#00FF00', 'KAN': '#00008B',
                        'GEN': '#8B4513', 'KUN': '#A52A2A'
                    };
                    const color = themeColors[theme] || '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, fsmState === 'COMMIT' ? 10 : 6, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }

                // --- V19.6: INTEGRATED GHOST CURSOR (Tactical Layer) ---
                const ghostColor = fsmState === 'COMMIT' ? '#FF4136' : (fsmState === 'READY' ? '#FFD700' : '#0074D9');
                ctx.save();
                ctx.beginPath();
                ctx.arc(screenX, screenY, 12, 0, Math.PI * 2);
                ctx.strokeStyle = ghostColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.restore();

                // Focal Crosshair (Goldilocks Zone)
                if (fsmState === 'COMMIT') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 10, screenY); ctx.lineTo(screenX + 10, screenY);
                    ctx.moveTo(screenX, screenY - 10); ctx.lineTo(screenX, screenY + 10);
                    ctx.stroke();
                }
            });
        }

        // --- P7: NAVIGATOR (Settings Shell) ---
        class P7Navigator {
            static init(container) {
                const div = document.createElement('div');
                div.className = 'scrollable-panel';
                container.appendChild(div);

                const gui = new GUI({ container: div, title: 'ðŸ›°ï¸ NAVIGATOR CONFIG', autoPlace: false });
                const fTelem = gui.addFolder('P6: Telemetry & Replay [V24.6]');
                fTelem.add(window.hfoTelemetry, 'isRecording').name('RECORDING ACTIVE').listen();
                fTelem.add({ start: () => window.hfoTelemetry.start() }, 'start').name('Start Recording');
                fTelem.add({ stop: () => window.hfoTelemetry.stop() }, 'stop').name('Stop Recording');
                fTelem.add({ export: () => window.hfoTelemetry.exportJSONL() }, 'export').name('Export .jsonl');

                // Replay Controls (Golden Master)
                fTelem.add(window.hfoPlayer, 'isPlaying').name('REPLAY ACTIVE').listen();
                fTelem.add(window.hfoPlayer, 'loop').name('Loop Replay');
                fTelem.add({
                    load: () => {
                        const inp = document.createElement('input');
                        inp.type = 'file';
                        inp.accept = '.jsonl';
                        inp.onchange = (e) => {
                            const file = e.target.files[0];
                            if (file) window.hfoPlayer.load(file);
                        };
                        inp.click();
                    }
                }, 'load').name('Load JSONL Replay');
                fTelem.add({ start: () => window.hfoPlayer.start() }, 'start').name('â–¶ Start Replay');
                fTelem.add({ stop: () => window.hfoPlayer.stop() }, 'stop').name('â¹ Stop Replay');
                fTelem.add({ pause: () => window.hfoPlayer.pause() }, 'pause').name('â¸ Pause Replay');

                // ðŸ’  HEXAGONAL PORTS (MOSA ALIGNMENT)
                const fPorts = gui.addFolder('ðŸ’  JADC2 MOSAIC PORTS');
                fPorts.add(systemState.parameters.ports, 'p0_recognizer', ['MEDIAPIPE_HANDS', 'TENSORFLOW_JS', 'OPENCV_STUB']).name('P0: Sensing Shard').onChange(val => {
                    logMission(`P0 Shard Swapped: ${val}`);
                    // Future: Reinstate P0 Lifecycle reset
                });
                fPorts.add(systemState.parameters.ports, 'p1_fusion', ['UNIVERSAL_PROJECTION_V28', 'LEGACY_PIXI_MAP']).name('P1: Fusion Bridge').onChange(val => {
                    logMission(`P1 Bridge Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p2_fsm', ['SOVEREIGN_4_STATE', 'LEGACY_3_STATE', 'BFT_CONSENSUS']).name('P2: FSM Controller').onChange(val => {
                    logMission(`P2 Controller Swapped: ${val}`);
                });
                fPorts.add(systemState.parameters.ports, 'p3_injector', ['HYDRA_ADAPTER_PULSE', 'DIRECT_DOM_CLICK']).name('P3: Effect Injector').onChange(val => {
                    logMission(`P3 Injector Swapped: ${val}`);
                });

                fPorts.add(systemState.parameters.visuals, 'engine', ['BABYLON', 'PIXI', 'CANVAS']).name('P4: Visual Substrate').onChange(val => {
                    logMission(`Port 4: Visual Engine Swapping to ${val}...`);

                    // ðŸ”„ HYPER-SLIVER ENGINE SWAP
                    if (val === 'BABYLON') {
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'block';
                        }
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    } else if (val === 'CANVAS') {
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'block';
                        if (systemState.ui.juiceLayers[0] instanceof BabylonJuiceSubstrate) {
                            systemState.ui.juiceLayers[0].canvas.style.display = 'none';
                        }
                    } else if (val === 'PIXI') {
                        logMission("âš ï¸ PIXI Engine selected. Note: Library removed in V28.1 for performance. Stub mode active.", "#FFA500");
                        if (systemState.p0.canvas) systemState.p0.canvas.style.display = 'none';
                    }
                });

                const fVisuals = gui.addFolder('ðŸš€ P4: Visual Engines');
                fVisuals.add(systemState.parameters.visuals, 'variant').disable().name('Active: PHOENIX_CORE (BabylonJS)');
                fVisuals.add(systemState.parameters.physics, 'showTrailMesh').name('Show Trail Ribbon (Legacy)');
                fVisuals.add(systemState.parameters.physics, 'showHFOClaw').name('Show HFO Pointer Claw');

                const fCam = gui.addFolder('P0: Camera Range');
                fCam.add(systemState.parameters.camera, 'resolution', ['640x480', '1280x720', '1920x1080']).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'fpsTarget', 15, 60, 1).onChange(syncConfig);
                fCam.add(systemState.parameters.camera, 'mirror').onChange(syncConfig);

                const fLand = gui.addFolder('P0: Neural Shards');
                fLand.add(systemState.parameters.landmarks, 'minConfidence', 0.1, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'numHands', 1, 4, 1).onChange(syncConfig);
                fLand.add(systemState.parameters.landmarks, 'showSkeleton');
                fLand.add(systemState.parameters.landmarks, 'skeletonFadeTimeMs', 100, 2000, 10).name('Skeleton Fade (ms)');
                fLand.add(systemState.parameters.landmarks, 'skeletonInactivityTimeoutMs', 500, 5000, 10).name('Dormancy Timeout (ms)');

                const fGest = gui.addFolder('P1: Gesture Confidence');
                fGest.add(systemState.parameters.gestures, 'minGestureConfidence', 0, 1).name('Confidence Threshold');
                fGest.add(systemState.parameters.gestures, 'preferredHand', ['Any', 'Left', 'Right']);

                const fPalm = gui.addFolder('P1: Palm Cone Orientation');
                fPalm.add(systemState.parameters.palm, 'enterThreshold', 0, 1).name('Enter Threshold (80)');
                fPalm.add(systemState.parameters.palm, 'exitThreshold', 0, 1).name('Exit Threshold (64)');

                const fFSM = gui.addFolder('P2: Sharding & Hysteresis (Dev)');
                fFSM.add(systemState.parameters.fsm, 'hysteresisHigh', 0, 100).name('Ready Threshold');
                fFSM.add(systemState.parameters.fsm, 'hysteresisLow', 0, 100).name('Idle Threshold');
                fFSM.add(systemState.parameters.fsm, 'chargeTimeMs', 10, 1000).name('Charge Time (ms)');
                fFSM.add(systemState.parameters.fsm, 'releaseTimeMs', 10, 1000).name('Release Time (ms)');
                fFSM.add(systemState.parameters.fsm, 'coastDrainTimeMs', 10, 3000).name('Coast Drain (ms)'); // V16
                fFSM.add(systemState.parameters.fsm, 'tensionMs', 0, 500).name('Tension/Coyote (ms)');
                fFSM.add(systemState.parameters.fsm, 'commitExitDelayMs', 0, 1000).name('Sticky Exit (ms)');

                const fCoast = gui.addFolder('P4: Coasting Control');
                fCoast.add(systemState.parameters.coasting, 'timeoutMs', 0, 1000).name('Coast Timeout (ms)');
                fCoast.add(systemState.parameters.coasting, 'confidenceThreshold', 0, 1).name('Min Signal Confidence');

                const fPhys = gui.addFolder('P2: Coordinate Substrate');
                fPhys.add(systemState.parameters.physics, 'mode', ['STATIC_ROD', 'PLANCK_SPRING']).name('Physics Mode').onChange(syncConfig);
                fPhys.add(systemState.parameters.physics, 'useDirectProjection').name('Direct Projection Flag'); // V20.6
                fPhys.add(systemState.parameters.physics, 'directProjectionOffset', 0, 0.5, 0.01).name('Direct Offset (LI)'); // V20.6
                fPhys.add(systemState.parameters.physics, 'cursorTheme', ['QIAN', 'DUI', 'LI', 'ZHEN', 'XUN', 'KAN', 'GEN', 'KUN']).name('HFO Element (Trigram)'); // V20.4
                fPhys.add(systemState.parameters.physics, 'oneEuroMinCutoff', 0.1, 5).name('Smoothing MinCutoff');
                fPhys.add(systemState.parameters.physics, 'oneEuroBeta', 0, 0.5).name('Smoothing Beta');
                fPhys.add(systemState.parameters.physics, 'planckStiffness', 0.1, 20).name('Planck Stiffness (Hz)');
                fPhys.add(systemState.parameters.physics, 'planckDamping', 0.0, 1.0).name('Planck Damping Ratio');
                fPhys.add(systemState.parameters.physics, 'palmRodMultiplier', 0.5, 10.0).step(0.1).name('Rod Length Factor');
                fPhys.add(systemState.parameters.physics, 'showLaserBeam').name('Show Beam Path');
                fPhys.add(systemState.parameters.physics, 'predictiveLookahead', 0, 5).name('Lookahead Factor');

                // V20: EXCALIDRAW OVERLAY CONTROL
                const fExcal = gui.addFolder('P3: Excalidraw Overlay');
                fExcal.add(systemState.parameters.excalidraw, 'enabled').name('Enabled').onChange(val => {
                    if (systemState.ui.excalidrawOverlay) {
                        systemState.ui.excalidrawOverlay.style.display = val ? 'block' : 'none';
                    }
                });
                fExcal.add(systemState.parameters.excalidraw, 'opacity', 0, 1).name('Transparency').onChange(val => {
                    if (systemState.ui.excalidrawOverlay) {
                        systemState.ui.excalidrawOverlay.style.opacity = val;
                    }
                });
                fExcal.add(systemState.parameters.excalidraw, 'zoomFactor', 1.0, 2.0, 0.01).name('Overscan Zoom').onChange(resizeCanvas);

                const fTools = gui.addFolder('P3: Excalidraw Tools');
                fTools.add(systemState.parameters.excalidraw, 'activeTool', [
                    'selection', 'rectangle', 'diamond', 'ellipse', 'arrow', 'line', 'freedraw', 'text', 'eraser'
                ]).name('Active Tool').onChange(val => {
                    if (systemState.ui.excalidrawIframe) {
                        systemState.ui.excalidrawIframe.contentWindow.postMessage({
                            type: 'SET_TOOL',
                            data: { tool: val }
                        }, '*');
                    }
                });

                const fAnat = gui.addFolder('P1: Anatomical Constraints');
                fAnat.add(systemState.parameters.anatomy, 'palmWidthCm', 4, 12, 0.1).name('Palm Width (cm)').onChange(syncConfig);
                fAnat.add(systemState.parameters.anatomy, 'rodExtensionMultiplier', 0.1, 5, 0.1).name('Rod Extension Factor').onChange(syncConfig);

                const fSystem = gui.addFolder('ðŸ›°ï¸ P7: SYSTEM & ONBOARDING');
                fSystem.add(systemState.parameters.ui, 'showTutorial').name('ONBOARDING ACTIVE').listen();
                fSystem.add({ reset: () => { window.hfoTutorial.reset(); } }, 'reset').name('Reset Tutorial');

                const fDebug = gui.addFolder('P5: Deep Visual Debugging');
                fDebug.add(systemState.parameters, 'devMode').name('Enable Full Telemetry').onChange(syncConfig);
                fDebug.add(systemState.parameters.landmarks, 'showSkeleton').name('Draw Skeleton');

                function syncConfig() {
                    const valid = P1Bridger.validateConfig(systemState.parameters);
                    if (valid) {
                        if (systemState.p0.recognizer) {
                            systemState.p0.recognizer.setOptions({
                                numHands: valid.landmarks.numHands,
                                minHandDetectionConfidence: valid.landmarks.minConfidence
                            });
                        }
                        logMission("P7: Configuration Synchronized & Validated");
                    } else {
                        logMission("âš ï¸ P1: Configuration Breach Detected", '#FF4136');
                    }
                }
            }
        }

        function resizeCanvas() {
            const { video, canvas } = systemState.p0;
            if (!video || !canvas) return;

            // V28: Fallback resolution for headless/mock testing
            const [w_param, h_param] = systemState.parameters.camera.resolution.split('x').map(Number);
            const vw = video.videoWidth || w_param || 1280;
            const vh = video.videoHeight || h_param || 720;

            systemState.p0.videoBounds = { width: vw, height: vh };

            const parent = video.parentElement;
            if (!parent) return;
            const pRect = parent.getBoundingClientRect();

            // Handle 0 dimensions in headless
            const parentWidth = pRect.width || vw;
            const parentHeight = pRect.height || vh;

            const vRatio = vw / vh;

            let drawW_base = parentWidth, drawH_base = parentWidth / vRatio;
            if (drawH_base > parentHeight) { drawH_base = parentHeight; drawW_base = drawH_base * vRatio; }

            // V28: OVERSCAN PATTERN
            const zoom = systemState.parameters.excalidraw.zoomFactor || 1.15;
            const drawW = drawW_base * zoom;
            const drawH = drawH_base * zoom;

            // V24.19: Substrate Parity Alignment
            // Center zoomed substrates (offsetX/Y will be negative if zoom > 1.0)
            const offsetX = (parentWidth - drawW) / 2;
            const offsetY = (parentHeight - drawH) / 2;

            // V28.5: Hardened Video Alignment (Fix for Visual Drift)
            video.style.objectFit = 'fill';
            video.style.width = `${drawW}px`;
            video.style.height = `${drawH}px`;
            video.style.left = `${offsetX}px`;
            video.style.top = `${offsetY}px`;
            video.style.position = 'absolute';
            // V28.5: Standard Mirroring Logic
            const isMirror = systemState.parameters.camera.mirror;
            video.style.transform = isMirror ? 'scaleX(-1)' : 'none';

            // Set buffer size to match video source (High-fidelity sensing baseline)
            canvas.width = vw;
            canvas.height = vh;

            // V24.20: Store view bounds for coordinate transformation parity
            systemState.ui.viewBounds = {
                width: drawW,
                height: drawH,
                offsetX: offsetX,
                offsetY: offsetY
            };

            // Sync all canvas elements (Overlay, Babylon)
            // V24.20: Including Excalidraw UI in the parity box
            const substrates = [
                canvas,
                ...systemState.ui.juiceLayers.map(l => l.canvas),
                systemState.ui.excalidrawOverlay
            ];

            substrates.forEach(el => {
                if (el) {
                    el.style.position = 'absolute';
                    el.style.left = `${offsetX}px`;
                    el.style.top = `${offsetY}px`;
                    el.style.width = `${drawW}px`;
                    el.style.height = `${drawH}px`;
                }
            });

            // V28.5: Calibration Markers (UPE Parity Verification)
            let calWrap = document.getElementById('upe-calibration-overlay');
            if (isFlagEnabled('dev-mode')) {
                if (!calWrap) {
                    calWrap = document.createElement('div');
                    calWrap.id = 'upe-calibration-overlay';
                    calWrap.style.position = 'absolute';
                    calWrap.style.pointerEvents = 'none';
                    calWrap.style.zIndex = '1000';
                    parent.appendChild(calWrap);
                }
                calWrap.style.left = `${offsetX}px`;
                calWrap.style.top = `${offsetY}px`;
                calWrap.style.width = `${drawW}px`;
                calWrap.style.height = `${drawH}px`;
                calWrap.innerHTML = `
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; top:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); left:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; width:10px; height:10px; background:rgba(255,0,0,0.5); right:0; bottom:0; border-radius:50%; border:1px solid white;"></div>
                    <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:red; font-size:10px; font-weight:bold;">UPE PARITY BOX</div>
                `;
            } else if (calWrap) {
                calWrap.remove();
            }

            // Trigger engine resizes to match the new CSS bounds
            systemState.ui.juiceLayers.forEach(l => {
                if (l.resize) l.resize(drawW, drawH);
            });
        }

        function logMission(msg, color = '#00ff41') {
            const logs = document.getElementById('mission-logs');
            if (!logs) return;
            const entry = document.createElement('div');
            entry.style.color = color;
            entry.innerText = `[${new Date().toLocaleTimeString('en-GB')}] ${msg}`;
            logs.prepend(entry);
        }

        // --- LAYOUT ENGINE ---
        const container = document.getElementById('layout-container');
        const layout = new GoldenLayout(container);

        layout.registerComponentFactoryFunction('hero', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.innerHTML = `
                <div class="hero-view-container">
                    <video id="video-feed" autoplay playsinline></video>
                    
                    <!-- EXCALIDRAW OVERLAY LAYER [V20.1: Dark Mode Hardening] -->
                    ${isFlagEnabled('ui-excalidraw') ? `
                    <div id="excalidraw-hero-overlay" style="position:absolute; width:100%; height:100%; z-index:4; opacity: 0.8; display:none;">
                        <iframe 
                            id="excalidraw-iframe"
                            src="excalidraw_v20_wrapper.html" 
                            style="width:100%; height:100%; border:none; filter: contrast(1.1) brightness(0.9); background: transparent;"
                            allow="clipboard-read; clipboard-write; display-capture">
                        </iframe>
                    </div>
                    ` : ''}

                    <div id="babylon-juice-overlay" style="position:absolute; width:100%; height:100%; pointer-events:none; z-index:9;"></div>
                    <canvas id="overlay-canvas" style="z-index:11;"></canvas>
                    
                    <!-- ðŸ“– V30 TACTICAL TUTORIAL -->
                    <div id="hfo-tutorial" class="tutorial-overlay">
                        <div class="m3-label" id="tut-header">Tactical Instruction</div>
                        <div class="tutorial-step" id="tut-body">
                            Initializing Mission Profile...
                        </div>
                    </div>

                    <button id="btn-ignite" class="hfo-btn" style="position:absolute; bottom:30px; z-index:20;">IGNITE OMEGA</button>
                </div>
            `;
            container.getElement().appendChild(wrap);
            systemState.p0.video = wrap.querySelector('#video-feed');
            systemState.p0.canvas = wrap.querySelector('#overlay-canvas');
            systemState.p0.ctx = systemState.p0.canvas.getContext('2d');

            // Reference for tutorial
            systemState.ui.tutorial = wrap.querySelector('#hfo-tutorial');
            systemState.ui.tutHeader = wrap.querySelector('#tut-header');
            systemState.ui.tutBody = wrap.querySelector('#tut-body');

            // Reference for opacity control
            systemState.ui.excalidrawOverlay = wrap.querySelector('#excalidraw-hero-overlay');
            systemState.ui.excalidrawIframe = wrap.querySelector('#excalidraw-iframe');

            // V23: Initialize Hybrid Substrates (Gated by V24.1 OpenFeature)
            const babylonWrap = wrap.querySelector('#babylon-juice-overlay');
            let babylonJuice = null;

            if (isFlagEnabled('engine-babylon') && babylonWrap) {
                babylonJuice = new BabylonJuiceSubstrate(babylonWrap);
            }

            systemState.ui.juiceLayers = [babylonJuice].filter(l => l !== null);

            wrap.querySelector('#btn-ignite').onclick = async (e) => {
                e.target.style.display = 'none';

                // V24.1: Ensure only enabled engines are displayed
                if (babylonJuice) babylonJuice.canvas.style.display = 'block';

                // ðŸŽ¨ V26.1: Show Excalidraw overlay on Ignite if enabled
                if (systemState.ui.excalidrawOverlay && systemState.parameters.excalidraw.enabled) {
                    systemState.ui.excalidrawOverlay.style.display = 'block';
                }

                // ðŸ“– V30: Start Tutorial
                window.hfoTutorial.show();

                await initP0();
                const [w, h] = systemState.parameters.camera.resolution.split('x');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: parseInt(w), height: parseInt(h) } });
                    systemState.p0.video.srcObject = stream;
                    systemState.p0.video.onloadeddata = () => {
                        systemState.parameters.p0Active = true;
                        resizeCanvas(); predictLoop();
                    };
                } catch (err) {
                    console.warn("P0 Camera Error:", err);
                    // Playwright Fallback: Ensure the loop starts for mock-based testing
                    systemState.parameters.p0Active = true;
                    resizeCanvas();
                    predictLoop();
                }
            };

            // Responsiveness: Hub Listener
            container.on('resize', () => {
                resizeCanvas();
                const rect = wrap.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (babylonJuice) babylonJuice.resize();
                }
            });

            // V24.5: Component Teardown Integration
            container.on('destroy', () => {
                console.log("[LIFECYCLE] Destroying Hero Component...");
                if (babylonJuice) window.hfoLifecycle.unregister(babylonJuice);
                systemState.p0.video = null;
                systemState.p0.canvas = null;
                systemState.ui.juiceLayers = [];
            });
        });

        layout.registerComponentFactoryFunction('navigator', (container) => {
            P7Navigator.init(container.getElement());
        });

        layout.registerComponentFactoryFunction('logs', (container) => {
            const div = document.createElement('div');
            div.id = 'mission-logs';
            div.className = 'scrollable-panel';
            div.style.background = '#000'; div.style.fontSize = '10px'; div.style.fontFamily = 'monospace';
            container.getElement().appendChild(div);
            logMission("SYSTEM_LOGS: READY");
        });

        layout.registerComponentFactoryFunction('excalidraw', (container) => {
            if (!isFlagEnabled('ui-excalidraw')) {
                container.getElement().innerHTML = '<div style="color:red; padding:20px;">EXCALIDRAW_DISABLED</div>';
                return;
            }
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.background = '#000';
            wrap.innerHTML = `
                <iframe 
                    src="./excalidraw_v20_wrapper.html" 
                    style="width:100%; height:100%; border:none; opacity: 0.8; filter: contrast(1.2) brightness(0.8);">
                </iframe>
                <div style="position:absolute; top:10px; right:10px; color:#555; font-size:9px; pointer-events:none;">OBSIDIAN MIRROR V8.0</div>
            `;
            container.getElement().appendChild(wrap);
        });

        layout.registerComponentFactoryFunction('gestures', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container scrollable-panel';
            container.getElement().appendChild(wrap);
            systemState.ui.gestures = wrap;
        });

        layout.registerComponentFactoryFunction('tactical', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.innerHTML = `
                <canvas id="tactical-canvas"></canvas>
            `;
            container.getElement().appendChild(wrap);
            const canvas = wrap.querySelector('#tactical-canvas');
            systemState.ui.tactical = canvas;
            systemState.ui.tacticalCtx = canvas.getContext('2d');

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);

            // V24.5: Tactical Teardown
            container.on('destroy', () => {
            });
        });

        layout.registerComponentFactoryFunction('fsm-viz', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.justifyContent = 'center';
            wrap.style.background = '#050505';
            const canvas = document.createElement('canvas');
            canvas.id = 'fsm-visualizer';
            wrap.appendChild(canvas);
            container.getElement().appendChild(wrap);
            systemState.ui.fsm = canvas;
            systemState.ui.fsmCtx = canvas.getContext('2d');

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);
        });

        layout.registerComponentFactoryFunction('palm', (container) => {
            const wrap = document.createElement('div');
            wrap.className = 'component-container';
            wrap.style.display = 'flex';
            wrap.style.alignItems = 'center';
            wrap.style.justifyContent = 'center';
            wrap.style.background = '#050a05';
            const canvas = document.createElement('canvas');
            canvas.id = 'palm-orientation-visualizer';
            wrap.appendChild(canvas);
            container.getElement().appendChild(wrap);

            systemState.ui.palm = canvas;
            systemState.ui.palmCtx = canvas.getContext('2d');

            const handleResize = () => {
                const rect = wrap.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            };
            container.on('resize', handleResize);
            setTimeout(handleResize, 200);
        });

        layout.loadLayout({
            root: {
                type: 'row', content: [
                    {
                        type: 'stack', width: 60, content: [
                            { type: 'component', componentType: 'hero', title: 'Tactical Workspace' }
                        ]
                    },
                    {
                        type: 'column', width: 40, content: [
                            {
                                type: 'row', height: 40, content: [
                                    { type: 'component', componentType: 'gestures', title: 'P1: Gestures' },
                                    { type: 'component', componentType: 'palm', title: 'P1: Palm Orientation' },
                                    { type: 'component', componentType: 'tactical', title: 'P3: Integrated Tactical' }
                                ]
                            },
                            { type: 'component', componentType: 'fsm-viz', title: 'Tactical FSM Visualization', height: 15 },
                            { type: 'component', componentType: 'navigator', title: 'Port 7: Navigator', height: 20 },
                            { type: 'component', componentType: 'logs', title: 'System Telemetry', height: 5 }
                        ]
                    }
                ]
            }
        });

        window.addEventListener('resize', () => {
            layout.updateSize();
            resizeCanvas();
        });

        // Lifecycle Hardening: Guaranteed resource disposal [V24.4]
        window.addEventListener('beforeunload', () => {
            console.log("ðŸŒ€ [HFO LIFECYCLE]: Initiating global disposal sequence...");
            window.hfoLifecycle.disposeAll();
        });

        // ðŸŒ‰ HFO BRIDGE: Sync initial state with Excalidraw on Ready
        window.addEventListener('message', (event) => {
            const { type } = event.data;
            if (type === 'EXCALIDRAW_READY') {
                console.log("ðŸŽ¨ [P3] Excalidraw Ready. Syncing initial tool:", systemState.parameters.excalidraw.activeTool);
                if (systemState.ui.excalidrawIframe) {
                    systemState.ui.excalidrawIframe.contentWindow.postMessage({
                        type: 'SET_TOOL',
                        data: { tool: systemState.parameters.excalidraw.activeTool }
                    }, '*');
                }
            }
        });
    </script>
</body>

</html>